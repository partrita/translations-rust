msgid ""
msgstr ""
"Project-Id-Version: Command Line Applications in Rust\n"
"POT-Creation-Date: 2025-10-15T16:18:32+09:00\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"PO-Revision-Date: 2025-10-15T16:18:32+09:00\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"

#: src/SUMMARY.md:1
msgid "Summary"
msgstr ""

#: src/SUMMARY.md:3
msgid "Getting started"
msgstr ""

#: src/SUMMARY.md:5
msgid "A command line app in 15 minutes"
msgstr ""

#: src/SUMMARY.md:6 src/tutorial/setup.md:1
msgid "Project setup"
msgstr ""

#: src/SUMMARY.md:7
msgid "Parsing command line arguments"
msgstr ""

#: src/SUMMARY.md:8
msgid "First implementation"
msgstr ""

#: src/SUMMARY.md:9 src/tutorial/errors.md:1
msgid "Nicer error reporting"
msgstr ""

#: src/SUMMARY.md:10
msgid "Output for humans and machines"
msgstr ""

#: src/SUMMARY.md:11 src/tutorial/testing.md:1
msgid "Testing"
msgstr ""

#: src/SUMMARY.md:12 src/tutorial/packaging.md:1
msgid "Packaging and distributing a Rust tool"
msgstr ""

#: src/SUMMARY.md:13 src/in-depth/index.md:1
msgid "In-depth topics"
msgstr ""

#: src/SUMMARY.md:14 src/in-depth/signals.md:1
msgid "Signal handling"
msgstr ""

#: src/SUMMARY.md:15 src/in-depth/config-files.md:1
msgid "Using config files"
msgstr ""

#: src/SUMMARY.md:16 src/in-depth/exit-code.md:1
msgid "Exit codes"
msgstr ""

#: src/SUMMARY.md:17 src/in-depth/human-communication.md:1
msgid "Communicating with humans"
msgstr ""

#: src/SUMMARY.md:18 src/in-depth/machine-communication.md:1
msgid "Communicating with machines"
msgstr ""

#: src/SUMMARY.md:19 src/in-depth/docs.md:1
msgid "Rendering documentation for your CLI apps"
msgstr ""

#: src/SUMMARY.md:20 src/resources/index.md:1
msgid "Resources"
msgstr ""

#: src/index.md:1
msgid "Command line apps in Rust"
msgstr ""

#: src/index.md:3
msgid ""
"Rust is a statically compiled, fast language with great tooling and a "
"rapidly growing ecosystem. That makes it a great fit for writing command "
"line applications: They should be small, portable, and quick to run. Command "
"line applications are also a great way to get started with learning Rust; or "
"to introduce Rust to your team!"
msgstr ""

#: src/index.md:9
msgid ""
"Writing a program with a simple command line interface (CLI) is a great "
"exercise for a beginner who is new to the language and wants to get a feel "
"for it. There are many aspects to this topic, though, that often only reveal "
"themselves later on."
msgstr ""

#: src/index.md:15
msgid ""
"This book is structured like this: We start with a quick tutorial, after "
"which you'll end up with a working CLI tool. You'll be exposed to a few of "
"the core concepts of Rust as well as the main aspects of CLI applications. "
"What follows are chapters that go into more detail on some of these aspects."
msgstr ""

#: src/index.md:23
msgid ""
"One last thing before we dive right into CLI applications: If you find an "
"error in this book or want to help us write more content for it, you can "
"find its source [in the CLI book repository](https://github.com/rust-cli/"
"book). We'd love to hear your feedback! Thank you!"
msgstr ""

#: src/tutorial/index.md:1
msgid "Learning Rust by Writing a Command Line App in 15 Minutes"
msgstr ""

#: src/tutorial/index.md:3
msgid ""
"This tutorial will guide you through writing a CLI (command line interface) "
"application in [Rust](https://rust-lang.org/). It will take you roughly "
"fifteen minutes to get to a point where you have a running program (around "
"chapter 1.3). After that, we'll continue to tweak our program until we reach "
"a point where we can ship our little tool."
msgstr ""

#: src/tutorial/index.md:14
msgid ""
"You’ll learn all the essentials about how to get going, and where to find "
"more information. Feel free to skip parts you don't need to know right now "
"or jump in at any point."
msgstr ""

#: src/tutorial/index.md:21
msgid ""
"**Prerequisites:** This tutorial does not replace a general introduction to "
"programming, and expects you to be familiar with a few common concepts. You "
"should be comfortable with using a command line/terminal. If you already "
"know a few other languages, this can be a good first contact with Rust."
msgstr ""

#: src/tutorial/index.md:28
msgid ""
"**Getting help:** If you at any point feel overwhelmed or confused with the "
"features used, have a look at the extensive official documentation that "
"comes with Rust, first and foremost the book, The Rust Programming Language. "
"It comes with most Rust installations (`rustup doc`), and is available "
"online on [doc.rust-lang.org](https://doc.rust-lang.org)."
msgstr ""

#: src/tutorial/index.md:39
msgid ""
"You are also very welcome to ask questions – the Rust community is known to "
"be friendly and helpful. Have a look at the [community page](https://"
"www.rust-lang.org/community) to see a list of places where people discuss "
"Rust."
msgstr ""

#: src/tutorial/index.md:48
msgid ""
"What kind of project do you want to write? How about we start with something "
"simple: Let’s write a small `grep` clone. That is a tool that we can give a "
"string and a path and it’ll print only the lines that contain the given "
"string. Let’s call it `grrs` (pronounced “grass”)."
msgstr ""

#: src/tutorial/index.md:55
msgid "In the end, we want to be able to run our tool like this:"
msgstr ""

#: src/tutorial/index.md:71
msgid ""
"**Note:** This book is written for [Rust 2018](https://doc.rust-lang.org/"
"edition-guide/index.html). The code examples can also be used on Rust 2015, "
"but you might need to tweak them a bit; add `extern crate foo;` invocations, "
"for example."
msgstr ""

#: src/tutorial/index.md:77
msgid ""
"Make sure you run Rust 1.31.0 (or later) and that you have `edition = "
"\"2018\"` set in the `[package]` section of your `Cargo.toml` file."
msgstr ""

#: src/tutorial/setup.md:3
msgid ""
"If you haven’t already, [install Rust](https://www.rust-lang.org/tools/"
"install) on your computer (it should only take a few minutes). After that, "
"open a terminal and navigate to the directory you want to put your "
"application code into."
msgstr ""

#: src/tutorial/setup.md:11
msgid ""
"Start by running `cargo new grrs` in the directory you store your "
"programming projects in. If you look at the newly created `grrs` directory, "
"you’ll find a typical setup for a Rust project:"
msgstr ""

#: src/tutorial/setup.md:17
msgid ""
"A `Cargo.toml` file that contains metadata for our project, incl. a list of "
"dependencies/external libraries we use."
msgstr ""

#: src/tutorial/setup.md:19
msgid "A `src/main.rs` file that is the entry point for our (main) binary."
msgstr ""

#: src/tutorial/setup.md:21
msgid ""
"If you can execute `cargo run` in the `grrs` directory and get a \"Hello "
"World\", you’re all set up."
msgstr ""

#: src/tutorial/setup.md:24
msgid "What it might look like"
msgstr ""

#: src/tutorial/cli-args.md:1
msgid "Parsing command-line arguments"
msgstr ""

#: src/tutorial/cli-args.md:3
msgid "A typical invocation of our CLI tool will look like this:"
msgstr ""

#: src/tutorial/cli-args.md:9
msgid ""
"We expect our program to look at `test.txt` and print out the lines that "
"contain `foobar`. But how do we get these two values?"
msgstr ""

#: src/tutorial/cli-args.md:13
msgid ""
"The text after the name of the program is often called the \"command-line "
"arguments\", or \"command-line flags\" (especially when they look like `--"
"this`). Internally, the operating system usually represents them as a list "
"of strings – roughly speaking, they get separated by spaces."
msgstr ""

#: src/tutorial/cli-args.md:21
msgid ""
"There are many ways to think about these arguments, and how to parse them "
"into something more easy to work with. You will also need to tell the users "
"of your program which arguments they need to give and in which format they "
"are expected."
msgstr ""

#: src/tutorial/cli-args.md:28
msgid "Getting the arguments"
msgstr ""

#: src/tutorial/cli-args.md:30
msgid ""
"The standard library contains the function [`std::env::args()`](https://"
"doc.rust-lang.org/1.39.0/std/env/fn.args.html) that gives you an [iterator]"
"(https://doc.rust-lang.org/1.39.0/std/iter/index.html) of the given "
"arguments. The first entry (at index `0`) will be the name your program was "
"called as (e.g. `grrs`), the ones that follow are what the user wrote "
"afterwards."
msgstr ""

#: src/tutorial/cli-args.md:38
msgid ""
"Getting the raw arguments this way is quite easy (in file `src/main.rs`):"
msgstr ""

#: src/tutorial/cli-args.md:42 src/tutorial/cli-args.md:111
msgid "\"no pattern given\""
msgstr ""

#: src/tutorial/cli-args.md:43 src/tutorial/cli-args.md:112
msgid "\"no path given\""
msgstr ""

#: src/tutorial/cli-args.md:45 src/tutorial/cli-args.md:119
#: src/tutorial/cli-args.md:181 src/tutorial/cli-args.md:225
msgid "\"pattern: {:?}, path: {:?}\""
msgstr ""

#: src/tutorial/cli-args.md:49
msgid ""
"We can run it using `cargo run`, passing arguments by writing them after `--"
"`:"
msgstr ""

#: src/tutorial/cli-args.md:52 src/tutorial/cli-args.md:247
msgid ""
"```console\n"
"$ cargo run -- some-pattern some-file\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.11s\n"
"     Running `target/debug/grrs some-pattern some-file`\n"
"pattern: \"some-pattern\", path: \"some-file\"\n"
"```"
msgstr ""

#: src/tutorial/cli-args.md:59
msgid "CLI arguments as data type"
msgstr ""

#: src/tutorial/cli-args.md:61
msgid ""
"Instead of thinking about them as a bunch of text, it often pays off to "
"think of CLI arguments as a custom data type that represents the inputs to "
"your program."
msgstr ""

#: src/tutorial/cli-args.md:65
msgid ""
"Look at `grrs foobar test.txt`: There are two arguments, first the `pattern` "
"(the string to look for), and then the `path` (the file to look in)."
msgstr ""

#: src/tutorial/cli-args.md:70
msgid ""
"What more can we say about them? Well, for a start, both are required. We "
"haven't talked about any default values, so we expect our users to always "
"provide two values. Furthermore, we can say a bit about their types: The "
"pattern is expected to be a string, while the second argument is expected to "
"be a path to a file."
msgstr ""

#: src/tutorial/cli-args.md:78
msgid ""
"In Rust, it is common to structure programs around the data they handle, so "
"this way of looking at CLI arguments fits very well. Let's start with this "
"(in file `src/main.rs`, before `fn main() {`):"
msgstr ""

#: src/tutorial/cli-args.md:89
msgid ""
"This defines a new structure (a [`struct`](https://doc.rust-lang.org/1.39.0/"
"book/ch05-00-structs.html)) that has two fields to store data in: `pattern`, "
"and `path`."
msgstr ""

#: src/tutorial/cli-args.md:96
msgid ""
"**Note:** [`PathBuf`](https://doc.rust-lang.org/1.39.0/std/path/"
"struct.PathBuf.html) is like a [`String`](https://doc.rust-lang.org/1.39.0/"
"std/string/struct.String.html) but for file system paths that work cross-"
"platform."
msgstr ""

#: src/tutorial/cli-args.md:104
msgid ""
"Now, we still need to get the actual arguments our program got into this "
"form. One option would be to manually parse the list of strings we get from "
"the operating system and build the structure ourselves. It would look "
"something like this:"
msgstr ""

#: src/tutorial/cli-args.md:123
msgid ""
"This works, but it's not very convenient. How would you deal with the "
"requirement to support `--pattern=\"foo\"` or `--pattern \"foo\"`? How would "
"you implement `--help`?"
msgstr ""

#: src/tutorial/cli-args.md:128
msgid "Parsing CLI arguments with Clap"
msgstr ""

#: src/tutorial/cli-args.md:130
msgid ""
"A much nicer way is to use one of the many available libraries. The most "
"popular library for parsing command-line arguments is called [`clap`]"
"(https://docs.rs/clap/). It has all the functionality you'd expect, "
"including support for sub-commands, [shell completions](https://docs.rs/"
"clap_complete/), and great help messages."
msgstr ""

#: src/tutorial/cli-args.md:139
msgid ""
"Let's first import `clap` by adding `clap = { version = \"4.0\", features = "
"[\"derive\"] }` to the `[dependencies]` section of our `Cargo.toml` file."
msgstr ""

#: src/tutorial/cli-args.md:143
msgid ""
"Now, we can write `use clap::Parser;` in our code, and add "
"`#[derive(Parser)]` right above our `struct Cli`. Let's also write some "
"documentation comments along the way."
msgstr ""

#: src/tutorial/cli-args.md:147
msgid "It’ll look like this (in file `src/main.rs`, before `fn main() {`):"
msgstr ""

#: src/tutorial/cli-args.md:151 src/tutorial/cli-args.md:212
#: src/tutorial/impl-draft.md:54 src/tutorial/errors.md:261
#: src/in-depth/machine-communication.md:175
msgid ""
"/// Search for a pattern in a file and display the lines that contain it.\n"
msgstr ""

#: src/tutorial/cli-args.md:155 src/tutorial/cli-args.md:216
#: src/tutorial/impl-draft.md:58 src/tutorial/errors.md:265
msgid "/// The pattern to look for\n"
msgstr ""

#: src/tutorial/cli-args.md:157 src/tutorial/cli-args.md:218
#: src/tutorial/impl-draft.md:60 src/tutorial/errors.md:267
#: src/in-depth/machine-communication.md:267
msgid "/// The path to the file to read\n"
msgstr ""

#: src/tutorial/cli-args.md:164
msgid ""
"**Note:** There are a lot of custom attributes you can add to fields. For "
"example, to say you want to use this field for the argument after `-o` or `--"
"output`, you'd add `#[arg(short = 'o', long = \"output\")]`. For more "
"information, see the [clap documentation](https://docs.rs/clap/)."
msgstr ""

#: src/tutorial/cli-args.md:174
msgid ""
"Right below the `Cli` struct our template contains its `main` function. When "
"the program starts, it will call this function:"
msgstr ""

#: src/tutorial/cli-args.md:185
msgid "This will try to parse the arguments into our `Cli` struct."
msgstr ""

#: src/tutorial/cli-args.md:187
msgid ""
"But what if that fails? That's the beauty of this approach: Clap knows which "
"fields to expect, and what their expected format is. It can automatically "
"generate a nice `--help` message, as well as give some great errors to "
"suggest you pass `--output` when you wrote `--putput`."
msgstr ""

#: src/tutorial/cli-args.md:197
msgid ""
"**Note:** The `parse` method is meant to be used in your `main` function. "
"When it fails, it will print out an error or help message and immediately "
"exit the program. Don't use it in other places!"
msgstr ""

#: src/tutorial/cli-args.md:206 src/tutorial/impl-draft.md:48
#: src/tutorial/errors.md:254
msgid "Wrapping up"
msgstr ""

#: src/tutorial/cli-args.md:208 src/tutorial/impl-draft.md:50
#: src/tutorial/errors.md:256
msgid "Your code should now look like:"
msgstr ""

#: src/tutorial/cli-args.md:229
msgid "Running it without any arguments:"
msgstr ""

#: src/tutorial/cli-args.md:245
msgid "Running it passing arguments:"
msgstr ""

#: src/tutorial/cli-args.md:254
msgid ""
"The output demonstrates that our program successfully parsed the arguments "
"into the `Cli` struct."
msgstr ""

#: src/tutorial/impl-draft.md:1
msgid "First implementation of _grrs_"
msgstr ""

#: src/tutorial/impl-draft.md:3
msgid ""
"After the last chapter on command line arguments, we have our input data, "
"and we can start to write our actual tool. Our `main` function only contains "
"this line right now:"
msgstr ""

#: src/tutorial/impl-draft.md:12
msgid ""
"(We drop the `println` statement that we merely put there temporarily to "
"demonstrate that our program works as expected.)"
msgstr ""

#: src/tutorial/impl-draft.md:15
msgid "Let’s start by opening the file we got."
msgstr ""

#: src/tutorial/impl-draft.md:18 src/tutorial/impl-draft.md:66
#: src/tutorial/testing.md:461
msgid "\"could not read file\""
msgstr ""

#: src/tutorial/impl-draft.md:23
msgid ""
"**Note:** See that [`.expect`](https://doc.rust-lang.org/1.39.0/std/result/"
"enum.Result.html#method.expect) method here? This is a shortcut function "
"that will make the program exit immediately when the value (in this case the "
"input file) could not be read. It's not very pretty, and in the next chapter "
"on [Nicer error reporting](./errors.html) we will look at how to improve "
"this."
msgstr ""

#: src/tutorial/impl-draft.md:37
msgid ""
"Now, let’s iterate over the lines and print each one that contains our "
"pattern:"
msgstr ""

#: src/tutorial/impl-draft.md:43 src/tutorial/impl-draft.md:70
#: src/tutorial/errors.md:279 src/tutorial/testing.md:117
#: src/tutorial/testing.md:130 src/tutorial/testing.md:219
#: src/in-depth/machine-communication.md:188
msgid "\"{}\""
msgstr ""

#: src/tutorial/impl-draft.md:76
msgid "Give it a try: `cargo run -- main src/main.rs` should work now!"
msgstr ""

#: src/tutorial/impl-draft.md:80
msgid ""
"**Exercise for the reader:** This is not the best implementation: It will "
"read the whole file into memory – however large the file may be. Find a way "
"to optimize it! (One idea might be to use a [`BufReader`](https://doc.rust-"
"lang.org/1.39.0/std/io/struct.BufReader.html) instead of `read_to_string()`.)"
msgstr ""

#: src/tutorial/errors.md:3
msgid ""
"We all can do nothing but accept the fact that errors will occur. And in "
"contrast to many other languages, it's very hard not to notice and deal with "
"this reality when using Rust: As it doesn't have exceptions, all possible "
"error states are often encoded in the return types of functions."
msgstr ""

#: src/tutorial/errors.md:10
msgid "Results"
msgstr ""

#: src/tutorial/errors.md:12
msgid ""
"A function like [`read_to_string`](https://doc.rust-lang.org/1.39.0/std/fs/"
"fn.read_to_string.html) doesn't return a string. Instead, it returns a "
"[`Result`](https://doc.rust-lang.org/1.39.0/std/result/index.html) that "
"contains either a `String` or an error of some type (in this case "
"[`std::io::Error`](https://doc.rust-lang.org/1.39.0/std/io/"
"type.Result.html))."
msgstr ""

#: src/tutorial/errors.md:23
msgid ""
"How do you know which it is? Since `Result` is an `enum`, you can use "
"`match` to check which variant it is:"
msgstr ""

#: src/tutorial/errors.md:28 src/tutorial/errors.md:53
#: src/tutorial/errors.md:73 src/tutorial/errors.md:83
#: src/tutorial/errors.md:101 src/tutorial/errors.md:143
#: src/tutorial/errors.md:196 src/tutorial/errors.md:237
msgid "\"test.txt\""
msgstr ""

#: src/tutorial/errors.md:30
msgid "\"File content: {}\""
msgstr ""

#: src/tutorial/errors.md:31
msgid "\"Oh noes: {}\""
msgstr ""

#: src/tutorial/errors.md:37
msgid ""
"**Note:** Not sure what enums are or how they work in Rust? [Check this "
"chapter of the Rust book](https://doc.rust-lang.org/1.39.0/book/ch06-00-"
"enums.html) to get up to speed."
msgstr ""

#: src/tutorial/errors.md:44
msgid "Unwrapping"
msgstr ""

#: src/tutorial/errors.md:46
msgid ""
"Now, we were able to access the content of the file, but we can't really do "
"anything with it after the `match` block. For this, we'll need to somehow "
"deal with the error case. The challenge is that all arms of a `match` block "
"need to return something of the same type. But there's a neat trick to get "
"around that:"
msgstr ""

#: src/tutorial/errors.md:56
msgid "\"Can't deal with {}, just exit here\""
msgstr ""

#: src/tutorial/errors.md:58 src/tutorial/errors.md:106
#: src/tutorial/errors.md:144 src/tutorial/errors.md:199
#: src/tutorial/errors.md:240
msgid "\"file content: {}\""
msgstr ""

#: src/tutorial/errors.md:61
msgid ""
"We can use the String in `content` after the match block. If `result` were "
"an error, the String wouldn't exist. But since the program would exit before "
"it ever reached a point where we use `content`, it's fine."
msgstr ""

#: src/tutorial/errors.md:66
msgid ""
"This may seem drastic, but it's very convenient. If your program needs to "
"read that file and can't do anything if the file doesn't exist, exiting is a "
"valid strategy. There's even a shortcut method on `Result`s, called `unwrap`:"
msgstr ""

#: src/tutorial/errors.md:76
msgid "No need to panic"
msgstr ""

#: src/tutorial/errors.md:78
msgid ""
"Of course, aborting the program is not the only way to deal with errors. "
"Instead of the `panic!`, we can also easily write `return`:"
msgstr ""

#: src/tutorial/errors.md:92
msgid ""
"This, however changes the return type our function needs. Indeed, there was "
"something hidden in our examples all this time: The function signature this "
"code lives in. And in this last example with `return`, it becomes important. "
"Here's the _full_ example:"
msgstr ""

#: src/tutorial/errors.md:111
msgid ""
"Our return type is a `Result`! This is why we can write `return Err(error);` "
"in the second match arm. See how there is an `Ok(())` at the bottom? It's "
"the default return value of the function and means \"Result is okay, and has "
"no content\"."
msgstr ""

#: src/tutorial/errors.md:119
msgid ""
"**Note:** Why is this not written as `return Ok(());`? It easily could be – "
"this is totally valid as well. The last expression of any block in Rust is "
"its return value, and it is customary to omit needless `return`s."
msgstr ""

#: src/tutorial/errors.md:127
msgid "Question Mark"
msgstr ""

#: src/tutorial/errors.md:129
msgid ""
"Just like calling `.unwrap()` is a shortcut for the `match` with `panic!` in "
"the error arm, we have another shortcut for the `match` that `return`s in "
"the error arm: `?`."
msgstr ""

#: src/tutorial/errors.md:134
msgid ""
"That's right, a question mark. You can append this operator to a value of "
"type `Result`, and Rust will internally expand this to something very "
"similar to the `match` we just wrote."
msgstr ""

#: src/tutorial/errors.md:139
msgid "Give it a try:"
msgstr ""

#: src/tutorial/errors.md:149
msgid "Very concise!"
msgstr ""

#: src/tutorial/errors.md:153
msgid ""
"**Note:** There are a few more things happening here that are not required "
"to understand to work with this. For example, the error type in our `main` "
"function is `Box<dyn std::error::Error>`. But we've seen above that "
"`read_to_string` returns a [`std::io::Error`](https://doc.rust-lang.org/"
"1.39.0/std/io/type.Result.html). This works because `?` expands to code "
"that  _converts_ error types."
msgstr ""

#: src/tutorial/errors.md:161
msgid ""
"`Box<dyn std::error::Error>` is also an interesting type. It's a `Box` that "
"can contain _any_ type that implements the standard [`Error`](https://"
"doc.rust-lang.org/1.39.0/std/error/trait.Error.html) trait. This means that "
"basically all errors can be put into this box, so we can use `?` on all of "
"the usual functions that return `Result`s."
msgstr ""

#: src/tutorial/errors.md:171
msgid "Providing Context"
msgstr ""

#: src/tutorial/errors.md:173
msgid ""
"The errors you get when using `?` in your `main` function are okay, but they "
"are not great. For example: When you run "
"`std::fs::read_to_string(\"test.txt\")?` but the file `test.txt` doesn't "
"exist, you get this output:"
msgstr ""

#: src/tutorial/errors.md:180
msgid ""
"```text\n"
"Error: Os { code: 2, kind: NotFound, message: \"No such file or "
"directory\" }\n"
"```"
msgstr ""

#: src/tutorial/errors.md:184
msgid ""
"In cases where your code doesn't literally contain the file name, it would "
"be very hard to tell which file was `NotFound`. There are multiple ways to "
"deal with this."
msgstr ""

#: src/tutorial/errors.md:188
msgid ""
"For example, we can create our own error type, and then use that to build a "
"custom error message:"
msgstr ""

#: src/tutorial/errors.md:198
msgid "\"Error reading `{}`: {}\""
msgstr ""

#: src/tutorial/errors.md:204
msgid "Now, running this we'll get our custom error message:"
msgstr ""

#: src/tutorial/errors.md:207
msgid ""
"```text\n"
"Error: CustomError(\"Error reading `test.txt`: No such file or directory (os "
"error 2)\")\n"
"```"
msgstr ""

#: src/tutorial/errors.md:211
msgid ""
"Not very pretty, but we can easily adapt the debug output for our type later "
"on."
msgstr ""

#: src/tutorial/errors.md:214
msgid ""
"This pattern is in fact very common. It has one problem, though: We don't "
"store the original error, only its string representation. The often used "
"[`anyhow`](https://docs.rs/anyhow) library has a neat solution for that: "
"similar to our `CustomError` type, its [`Context`](https://docs.rs/anyhow/"
"1.0/anyhow/trait.Context.html) trait can be used to add a description. "
"Additionally, it also keeps the original error, so we get a \"chain\" of "
"error messages pointing out the root cause."
msgstr ""

#: src/tutorial/errors.md:227
msgid ""
"Let's first import the `anyhow` crate by adding `anyhow = \"1.0\"` to the "
"`[dependencies]` section of our `Cargo.toml` file."
msgstr ""

#: src/tutorial/errors.md:231
msgid "The full example will then look like this:"
msgstr ""

#: src/tutorial/errors.md:239 src/tutorial/errors.md:275
#: src/tutorial/testing.md:259
msgid "\"could not read file `{}`\""
msgstr ""

#: src/tutorial/errors.md:245
msgid "This will print an error:"
msgstr ""

#: src/tutorial/output.md:1
msgid "Output"
msgstr ""

#: src/tutorial/output.md:3
msgid "Printing \"Hello World\""
msgstr ""

#: src/tutorial/output.md:6
msgid "\"Hello World\""
msgstr ""

#: src/tutorial/output.md:9
msgid "Well, that was easy. Great, onto the next topic."
msgstr ""

#: src/tutorial/output.md:12
msgid "Using `println!`"
msgstr ""

#: src/tutorial/output.md:14
msgid ""
"You can pretty much print all the things you like with the `println!` macro. "
"This macro has some pretty amazing capabilities, but also a special syntax. "
"It expects you to write a string literal as the first parameter, that "
"contains placeholders that will be filled in by the values of the parameters "
"that follow as further arguments."
msgstr ""

#: src/tutorial/output.md:22
msgid "For example:"
msgstr ""

#: src/tutorial/output.md:26
msgid "\"My lucky number is {}.\""
msgstr ""

#: src/tutorial/output.md:29 src/tutorial/output.md:50
msgid "will print"
msgstr ""

#: src/tutorial/output.md:35
msgid ""
"The curly braces (`{}`) in the string above is one of these placeholders. "
"This is the default placeholder type that tries to print the given value in "
"a human readable way. For numbers and strings this works very well, but not "
"all types can do that. This is why there is also a \"debug representation\", "
"that you can get by filling the braces of the placeholder like this: `{:?}`."
msgstr ""

#: src/tutorial/output.md:43
msgid "For example,"
msgstr ""

#: src/tutorial/output.md:47
msgid "\"The list is: {:?}\""
msgstr ""

#: src/tutorial/output.md:56
msgid ""
"If you want your own data types to be printable for debugging and logging, "
"you can in most cases add a `#[derive(Debug)]` above their definition."
msgstr ""

#: src/tutorial/output.md:61
msgid ""
"**Note:** \"User-friendly\" printing is done using the [`Display`](https://"
"doc.rust-lang.org/1.39.0/std/fmt/trait.Display.html) trait, debug output "
"(human-readable but targeted at developers) uses the [`Debug`](https://"
"doc.rust-lang.org/1.39.0/std/fmt/trait.Debug.html) trait. You can find more "
"information about the syntax you can use in `println!` in the [documentation "
"for the `std::fmt` module](https://doc.rust-lang.org/1.39.0/std/fmt/"
"index.html)."
msgstr ""

#: src/tutorial/output.md:73
msgid "Printing errors"
msgstr ""

#: src/tutorial/output.md:75
msgid ""
"Printing errors should be done via `stderr` to make it easier for users and "
"other tools to pipe their outputs to files or more tools."
msgstr ""

#: src/tutorial/output.md:83
msgid ""
"**Note:** On most operating systems, a program can write to two output "
"streams, `stdout` and `stderr`. `stdout` is for the program's actual output, "
"while `stderr` allows errors and other messages to be kept separate from "
"`stdout`. That way, output can be stored to a file or piped to another "
"program while errors are shown to the user."
msgstr ""

#: src/tutorial/output.md:94
msgid ""
"In Rust this is achieved with `println!` and `eprintln!`, the former "
"printing to `stdout` and the latter to `stderr`."
msgstr ""

#: src/tutorial/output.md:100
msgid "\"This is information\""
msgstr ""

#: src/tutorial/output.md:101
msgid "\"This is an error! :(\""
msgstr ""

#: src/tutorial/output.md:106
msgid ""
"**Beware**: Printing [escape codes](https://en.wikipedia.org/wiki/"
"ANSI_escape_code) can be dangerous, putting the user's terminal into a weird "
"state. Always be careful when manually printing them!"
msgstr ""

#: src/tutorial/output.md:112
msgid ""
"Ideally you should be using a crate like `ansi_term` when dealing with raw "
"escape codes to make your (and your user's) life easier."
msgstr ""

#: src/tutorial/output.md:118
msgid "A note on printing performance"
msgstr ""

#: src/tutorial/output.md:120
msgid ""
"Printing to the terminal is surprisingly slow! If you call things like "
"`println!` in a loop, it can easily become a bottleneck in an otherwise fast "
"program. To speed this up, there are two things you can do."
msgstr ""

#: src/tutorial/output.md:126
msgid ""
"First, you might want to reduce the number of writes that actually \"flush\" "
"to the terminal. `println!` tells the system to flush to the terminal "
"_every_ time, because it is common to print each new line. If you don't need "
"that, you can wrap your `stdout` handle in a [`BufWriter`](https://doc.rust-"
"lang.org/1.39.0/std/io/struct.BufWriter.html) which by default buffers up to "
"8 kB. (You can still call `.flush()` on this `BufWriter` when you want to "
"print immediately.)"
msgstr ""

#: src/tutorial/output.md:140 src/tutorial/output.md:153
msgid "// get the global stdout entity\n"
msgstr ""

#: src/tutorial/output.md:141
msgid "// optional: wrap that handle in a buffer\n"
msgstr ""

#: src/tutorial/output.md:142 src/tutorial/output.md:155
msgid "\"foo: {}\""
msgstr ""

#: src/tutorial/output.md:142 src/tutorial/output.md:155
msgid "// add `?` if you care about errors here\n"
msgstr ""

#: src/tutorial/output.md:145
msgid ""
"Second, it helps to acquire a lock on `stdout` (or `stderr`) and use "
"`writeln!` to print to it directly. This prevents the system from locking "
"and unlocking `stdout` over and over again."
msgstr ""

#: src/tutorial/output.md:154
msgid "// acquire a lock on it\n"
msgstr ""

#: src/tutorial/output.md:158
msgid "You can also combine the two approaches."
msgstr ""

#: src/tutorial/output.md:162
msgid "Showing a progress bar"
msgstr ""

#: src/tutorial/output.md:164
msgid ""
"Some CLI applications run less than a second, others take minutes or hours. "
"If you are writing one of the latter types of programs, you might want to "
"show the user that something is happening. For this, you should try to print "
"useful status updates, ideally in a form that can be easily consumed."
msgstr ""

#: src/tutorial/output.md:171
msgid ""
"Using the [indicatif](https://crates.io/crates/indicatif) crate, you can add "
"progress bars and little spinners to your program. Here's a quick example:"
msgstr ""

#: src/tutorial/output.md:181
msgid "\"[+] finished #{}\""
msgstr ""

#: src/tutorial/output.md:184
msgid "\"done\""
msgstr ""

#: src/tutorial/output.md:188
msgid ""
"See the [documentation](https://docs.rs/indicatif) and [examples](https://"
"github.com/console-rs/indicatif/tree/main/examples) for more information."
msgstr ""

#: src/tutorial/output.md:196
msgid "Logging"
msgstr ""

#: src/tutorial/output.md:198
msgid ""
"To make it easier to understand what is happening in our program, we might "
"want to add some log statements. This is usually easy while writing your "
"application. But it will become super helpful when running this program "
"again in half a year. In some regard, logging is the same as using `println!"
"`, except that you can specify the importance of a message. The levels you "
"can usually use are _error_, _warn_, _info_, _debug_, and _trace_ (_error_ "
"has the highest priority, _trace_ the lowest)."
msgstr ""

#: src/tutorial/output.md:208
msgid ""
"To add simple logging to your application, you'll need two things: The [log]"
"(https://crates.io/crates/log) crate (this contains macros named after the "
"log level) and an _adapter_ that actually writes the log output somewhere "
"useful. Having the ability to use log adapters is very flexible: You can, "
"for example, use them to write logs not only to the terminal but also to "
"[syslog](https://en.wikipedia.org/wiki/Syslog), or to a central log server."
msgstr ""

#: src/tutorial/output.md:218
msgid ""
"Since we are right now only concerned with writing a CLI application, an "
"easy adapter to use is [env_logger](https://crates.io/crates/env_logger). "
"It's called \"env\" logger because you can use an environment variable to "
"specify which parts of your application you want to log (and at which level "
"you want to log them). It will prefix your log messages with a timestamp and "
"the module where the log messages come from. Since libraries can also use "
"`log`, you easily configure their log output, too."
msgstr ""

#: src/tutorial/output.md:232
msgid "Here's a quick example:"
msgstr ""

#: src/tutorial/output.md:239
msgid "\"starting up\""
msgstr ""

#: src/tutorial/output.md:240
msgid "\"oops, nothing implemented!\""
msgstr ""

#: src/tutorial/output.md:244
msgid ""
"Assuming you have this file as `src/bin/output-log.rs`, on Linux and macOS, "
"you can run it like this:"
msgstr ""

#: src/tutorial/output.md:254
msgid "In Windows PowerShell, you can run it like this:"
msgstr ""

#: src/tutorial/output.md:255
msgid ""
"```console\n"
"$ $env:RUST_LOG=\"info\"\n"
"$ cargo run --bin output-log\n"
"    Finished dev [unoptimized + debuginfo] target(s) in 0.17s\n"
"     Running `target/debug/output-log.exe`\n"
"[2018-11-30T20:25:52Z INFO  output_log] starting up\n"
"[2018-11-30T20:25:52Z WARN  output_log] oops, nothing implemented!\n"
"```"
msgstr ""

#: src/tutorial/output.md:264
msgid "In Windows CMD, you can run it like this:"
msgstr ""

#: src/tutorial/output.md:274
msgid ""
"`RUST_LOG` is the name of the environment variable you can use to set your "
"log settings. `env_logger` also contains a builder so you can "
"programmatically adjust these settings, and, for example, also show _info_ "
"level messages by default."
msgstr ""

#: src/tutorial/output.md:280
msgid ""
"There are a lot of alternative logging adapters out there, and also "
"alternatives or extensions to `log`. If you know your application will have "
"a lot to log, make sure to review them, and make your users' life easier."
msgstr ""

#: src/tutorial/output.md:288
msgid ""
"**Tip:** Experience has shown that even mildly useful CLI programs can end "
"up being used for years to come. (Especially if they were meant as a "
"temporary solution.) If your application doesn't work and someone (e.g., "
"you, in the future) needs to figure out why, being able to pass `--verbose` "
"to get additional log output can make the difference between minutes and "
"hours of debugging. The [clap-verbosity-flag](https://crates.io/crates/clap-"
"verbosity-flag) crate contains a quick way to add a `--verbose` to a project "
"using `clap`."
msgstr ""

#: src/tutorial/testing.md:3
msgid ""
"Over decades of software development, people have discovered one truth: "
"Untested software rarely works. (Many people would go as far as saying: "
"\"Most tested software doesn't work either.\" But we are all optimists here, "
"right?) So, to ensure that your program does what you expect it to do, it is "
"wise to test it."
msgstr ""

#: src/tutorial/testing.md:12
msgid ""
"One easy way to do that is to write a `README` file that describes what your "
"program should do. And when you feel ready to make a new release, go through "
"the `README` and ensure that the behavior is still as expected. You can make "
"this a more rigorous exercise by also writing down how your program should "
"react to erroneous inputs."
msgstr ""

#: src/tutorial/testing.md:21
msgid ""
"Here's another fancy idea: Write that `README` before you write the code."
msgstr ""

#: src/tutorial/testing.md:26
msgid ""
"**Note:** Have a look at [test-driven development](https://en.wikipedia.org/"
"wiki/Test-driven_development) (TDD) if you haven't heard of it."
msgstr ""

#: src/tutorial/testing.md:36
msgid "Automated testing"
msgstr ""

#: src/tutorial/testing.md:38
msgid ""
"Now, this is all fine and dandy, but doing all of this manually? That can "
"take a lot of time. At the same time, many people have come to enjoy telling "
"computers to do things for them. Let's talk about how to automate these "
"tests."
msgstr ""

#: src/tutorial/testing.md:45
msgid ""
"Rust has a built-in test framework, so let's start by writing a first test:"
msgstr ""

#: src/tutorial/testing.md:59
msgid ""
"You can put this snippet of code in pretty much any source file in your "
"package and `cargo test` will find and run it. The key here is the `#[test]` "
"attribute. It allows the build system to discover such functions and run "
"them as tests, verifying that they don't panic."
msgstr ""

#: src/tutorial/testing.md:69
msgid "**Exercise for the reader:** Make this test work."
msgstr ""

#: src/tutorial/testing.md:72
msgid "You should end up with output like the following:"
msgstr ""

#: src/tutorial/testing.md:83
msgid ""
"Now that we've seen _how_ we can write tests, we still need to figure out "
"_what_ to test. As you've seen it's fairly easy to write assertions for "
"functions. But a CLI application is often more than one function! Worse, it "
"often deals with user input, reads files, and writes output."
msgstr ""

#: src/tutorial/testing.md:92
msgid "Making your code testable"
msgstr ""

#: src/tutorial/testing.md:94
msgid ""
"There are two complementary approaches to testing functionality: Testing the "
"small units that you build your complete application from, these are called "
"\"unit tests\". There is also testing the final application \"from the "
"outside\" called \"black box tests\" or \"integration tests\". Let's begin "
"with the first one."
msgstr ""

#: src/tutorial/testing.md:101
msgid ""
"To figure out what we should test, let's see what our program features are. "
"Mainly, `grrs` is supposed to print out the lines that match a given "
"pattern. So, let's write unit tests for _exactly this_: We want to ensure "
"that our most important piece of logic works, and we want to do it in a way "
"that is not dependent on any of the setup code we have around it (that deals "
"with CLI arguments, for example)."
msgstr ""

#: src/tutorial/testing.md:110
msgid ""
"Going back to our [first implementation](impl-draft.md) of `grrs`, we added "
"this block of code to the `main` function:"
msgstr ""

#: src/tutorial/testing.md:114
msgid "// ...\n"
msgstr ""

#: src/tutorial/testing.md:122
msgid ""
"Sadly, this is not very easy to test. First of all, it's in the main "
"function, so we can't easily call it. This is easily fixed by moving this "
"piece of code into a function:"
msgstr ""

#: src/tutorial/testing.md:136
msgid "Now we can call this function in our test, and see what its output is:"
msgstr ""

#: src/tutorial/testing.md:142 src/tutorial/testing.md:243
msgid "\"lorem ipsum\\ndolor sit amet\""
msgstr ""

#: src/tutorial/testing.md:142 src/tutorial/testing.md:243
msgid "\"lorem\""
msgstr ""

#: src/tutorial/testing.md:143
msgid "// uhhhh\n"
msgstr ""

#: src/tutorial/testing.md:146
msgid ""
"Or… can we? Right now, `find_matches` prints directly to `stdout`, i.e., the "
"terminal. We can't easily capture this in a test! This is a problem that "
"often comes up when writing tests after the implementation: We have written "
"a function that is firmly integrated in the context it is used in."
msgstr ""

#: src/tutorial/testing.md:156
msgid ""
"**Note:** This is totally fine when writing small CLI applications. There's "
"no need to make everything testable! It is important to think about which "
"parts of your code you might want to write unit tests for, however. While "
"we'll see that it's easy to change this function to be testable, this is not "
"always the case."
msgstr ""

#: src/tutorial/testing.md:166
msgid ""
"Alright, how can we make this testable? We'll need to capture the output "
"somehow. Rust's standard library has some neat abstractions for dealing with "
"I/O (input/output) and we'll make use of one called [`std::io::Write`]"
"(https://doc.rust-lang.org/1.39.0/std/io/trait.Write.html). This is a [trait]"
"(https://doc.rust-lang.org/book/ch10-02-traits.html) that abstracts over "
"things we can write to, which includes strings but also `stdout`."
msgstr ""

#: src/tutorial/testing.md:177
msgid ""
"If this is the first time you've heard \"trait\" in the context of Rust, you "
"are in for a treat. Traits are one of the most powerful features of Rust. "
"You can think of them like interfaces in Java, or type classes in Haskell "
"(whatever you are more familiar with). They allow you to abstract over "
"behavior that can be shared by different types. Code that uses traits can "
"express ideas in very generic and flexible ways. This means it can also get "
"difficult to read, though. Don't let that intimidate you: Even people who "
"have used Rust for years don't always get what generic code does "
"immediately. In that case, it helps to think of concrete uses. For example, "
"in our case, the behavior that we abstract over is \"write to it\". Examples "
"for the types that implement (\"impl\") it include: The terminal's standard "
"output, files, a buffer in memory, or TCP network connections. (Scroll down "
"in the [documentation for `std::io::Write`](https://doc.rust-lang.org/1.39.0/"
"std/io/trait.Write.html) to see a list of \"Implementors\".)"
msgstr ""

#: src/tutorial/testing.md:206
msgid ""
"With that knowledge, let's change our function to accept a third parameter. "
"It should be of any type that implements `Write`. This way, we can then "
"supply a simple string in our tests and make assertions on it. Here is how "
"we can write this version of `find_matches`:"
msgstr ""

#: src/tutorial/testing.md:225
msgid ""
"The new parameter is `mut writer`, i.e., a mutable thing we call \"writer\". "
"Its type is `impl std::io::Write`, which you can read as \"a placeholder for "
"any type that implements the `Write` trait\". Also note how we replaced the "
"`println!(…)` we used earlier with `writeln!(writer, …)`. `println!` works "
"the same as `writeln!` but always uses standard output."
msgstr ""

#: src/tutorial/testing.md:237
msgid "Now we can test for the output:"
msgstr ""

#: src/tutorial/testing.md:244
msgid "b\"lorem ipsum\\n\""
msgstr ""

#: src/tutorial/testing.md:248
msgid ""
"To now use this in our application code, we have to change the call to "
"`find_matches` in `main` by adding [`&mut std::io::stdout()`](https://"
"doc.rust-lang.org/1.39.0/std/io/fn.stdout.html) as the third parameter. "
"Here's an example of a main function that builds on what we've seen in the "
"previous chapters and uses our extracted `find_matches` function:"
msgstr ""

#: src/tutorial/testing.md:271
msgid ""
"**Note:** Since `stdout` expects bytes (not strings), we use "
"`std::io::Write` instead of `std::fmt::Write`. As a result, we give an empty "
"vector as \"writer\" in our tests (its type will be inferred to `Vec<u8>`), "
"in the `assert_eq!` we use a `b\"foo\"`. (The `b` prefix makes this a _byte "
"string literal_ so its type is going to be `&[u8]` instead of `&str`)."
msgstr ""

#: src/tutorial/testing.md:285
msgid ""
"**Note:** We could also make this function return a `String`, but that would "
"change its behavior. Instead of writing to the terminal directly, it would "
"then collect everything into a string, and dump all the results in one go at "
"the end."
msgstr ""

#: src/tutorial/testing.md:296
msgid ""
"**Exercise for the reader:** [`writeln!`](https://doc.rust-lang.org/1.39.0/"
"std/macro.writeln.html) returns an [`io::Result`](https://doc.rust-lang.org/"
"1.39.0/std/io/type.Result.html) because writing can fail, for example when "
"the buffer is full and cannot be expanded. Add error handling to "
"`find_matches`."
msgstr ""

#: src/tutorial/testing.md:307
msgid "We've just seen how to make this piece of code easily testable. We have"
msgstr ""

#: src/tutorial/testing.md:310
msgid "identified one of the core pieces of our application,"
msgstr ""

#: src/tutorial/testing.md:311
msgid "put it into its own function,"
msgstr ""

#: src/tutorial/testing.md:312
msgid "and made it more flexible."
msgstr ""

#: src/tutorial/testing.md:314
msgid ""
"Even though the goal was to make it testable, the result we ended up with is "
"actually a very idiomatic and reusable piece of Rust code. That's awesome!"
msgstr ""

#: src/tutorial/testing.md:319
msgid "Splitting your code into library and binary targets"
msgstr ""

#: src/tutorial/testing.md:321
msgid ""
"We can do one more thing here. So far we've put everything we wrote into the "
"`src/main.rs` file. This means our current project produces a single binary. "
"But we can also make our code available as a library, like this:"
msgstr ""

#: src/tutorial/testing.md:326
msgid "Put the `find_matches` function into a new `src/lib.rs`."
msgstr ""

#: src/tutorial/testing.md:327
msgid ""
"Add a `pub` in front of the `fn` (so it's `pub fn find_matches`) to make it "
"something that users of our library can access."
msgstr ""

#: src/tutorial/testing.md:329
msgid "Remove `find_matches` from `src/main.rs`."
msgstr ""

#: src/tutorial/testing.md:330
msgid ""
"In the `fn main`, prepend the call to `find_matches` with `grrs::`, so it's "
"now `grrs::find_matches(…)`. This means it uses the function from the "
"library we just wrote!"
msgstr ""

#: src/tutorial/testing.md:334
msgid ""
"The way Rust deals with projects is quite flexible and it's a good idea to "
"think about what to put into the library part of your crate early on. You "
"can for example think about writing a library for your application-specific "
"logic first and then use it in your CLI just like any other library. Or, if "
"your project has multiple binaries, you can put the common functionality "
"into the library part of that crate."
msgstr ""

#: src/tutorial/testing.md:345
msgid ""
"**Note:** Speaking of putting everything into a `src/main.rs`: If we "
"continue to do that, it'll become difficult to read. The [module system]"
"(https://doc.rust-lang.org/1.39.0/book/ch07-00-managing-growing-projects-"
"with-packages-crates-and-modules.html) can help you structure and organize "
"your code."
msgstr ""

#: src/tutorial/testing.md:356
msgid "Testing CLI applications by running them"
msgstr ""

#: src/tutorial/testing.md:358
msgid ""
"Thus far, we've gone out of our way to test the _business logic_ of our "
"application, which turned out to be the `find_matches` function. This is "
"very valuable and is a great first step towards a well-tested code base. "
"(Usually, these kinds of tests are called \"unit tests\".)"
msgstr ""

#: src/tutorial/testing.md:366
msgid ""
"There is a lot of code we aren't testing, though: Everything that we wrote "
"to deal with the outside world! Imagine you wrote the main function, but "
"accidentally left in a hard-coded string instead of using the argument of "
"the user-supplied path. We should write tests for that, too! (This level of "
"testing is often called \"integration testing\", or \"system testing\".)"
msgstr ""

#: src/tutorial/testing.md:375
msgid ""
"At its core, we are still writing functions and annotating them with "
"`#[test]`. It's just a matter of what we do inside these functions. For "
"example, we'll want to use the main binary of our project, and run it like a "
"regular program. We will also put these tests into a new file in a new "
"directory: `tests/cli.rs`."
msgstr ""

#: src/tutorial/testing.md:386
msgid ""
"**Note:** By convention, `cargo` will look for integration tests in the "
"`tests/` directory. Similarly, it will look for benchmarks in `benches/`, "
"and examples in `examples/`. These conventions also extend to your main "
"source code: libraries have a `src/lib.rs` file, the main binary is `src/"
"main.rs`, or, if there are multiple binaries, cargo expects them to be in "
"`src/bin/<name>.rs`. Following these conventions will make your code base "
"more discoverable by people used to reading Rust code."
msgstr ""

#: src/tutorial/testing.md:402
msgid ""
"To recall, `grrs` is a small tool that searches for a string in a file. We "
"have previously tested that we can find a match. Let's think about what "
"other functionality we can test."
msgstr ""

#: src/tutorial/testing.md:407
msgid "Here is what I came up with."
msgstr ""

#: src/tutorial/testing.md:409
msgid "What happens when the file doesn't exist?"
msgstr ""

#: src/tutorial/testing.md:410
msgid "What is the output when there is no match?"
msgstr ""

#: src/tutorial/testing.md:411
msgid ""
"Does our program exit with an error when we forget one (or both) arguments?"
msgstr ""

#: src/tutorial/testing.md:413
msgid ""
"These are all valid test cases. Additionally, we should also include one "
"test case for the \"happy path\", i.e., we found at least one match and we "
"print it."
msgstr ""

#: src/tutorial/testing.md:420
msgid ""
"To make these kinds of tests easier, we're going to use the [`assert_cmd`]"
"(https://docs.rs/assert_cmd) crate. It has a bunch of neat helpers that "
"allow us to run our main binary and see how it behaves. Further, we'll also "
"add the [`predicates`](https://docs.rs/predicates) crate which helps us "
"write assertions that `assert_cmd` can test against (and that have great "
"error messages). We'll add those dependencies not to the main list, but to a "
"\"dev dependencies\" section in our `Cargo.toml`. They are only required "
"when developing the crate, not when using it."
msgstr ""

#: src/tutorial/testing.md:435
msgid ""
"```toml\n"
"[dev-dependencies]\n"
"assert_cmd = \"2.0.14\"\n"
"predicates = \"3.1.0\"\n"
"```"
msgstr ""

#: src/tutorial/testing.md:444
msgid ""
"This sounds like a lot of setup. Nevertheless – let's dive right in and "
"create our `tests/cli.rs` file:"
msgstr ""

#: src/tutorial/testing.md:450
msgid "// Add methods on commands\n"
msgstr ""

#: src/tutorial/testing.md:451
msgid "// Used for writing assertions\n"
msgstr ""

#: src/tutorial/testing.md:452
msgid "// Run programs\n"
msgstr ""

#: src/tutorial/testing.md:456 src/tutorial/testing.md:521
msgid "\"grrs\""
msgstr ""

#: src/tutorial/testing.md:458
msgid "\"foobar\""
msgstr ""

#: src/tutorial/testing.md:458
msgid "\"test/file/doesnt/exist\""
msgstr ""

#: src/tutorial/testing.md:467
msgid ""
"You can run this test with `cargo test`, just like the tests we wrote above. "
"It might take a little longer the first time, as "
"`Command::cargo_bin(\"grrs\")` needs to compile your main binary."
msgstr ""

#: src/tutorial/testing.md:473
msgid "Generating test files"
msgstr ""

#: src/tutorial/testing.md:475
msgid ""
"The test we've just seen only checks that our program writes an error "
"message when the input file doesn't exist. That's an important test to have, "
"but maybe not the most important one: Let's now test that we will actually "
"print the matches we found in a file!"
msgstr ""

#: src/tutorial/testing.md:481
msgid ""
"We'll need to have a file whose content we know, so that we can know what "
"our program _should_ return and check this expectation in our code. One idea "
"might be to add a file to the project with custom content and use that in "
"our tests. Another would be to create temporary files in our tests. For this "
"tutorial, we'll have a look at the latter approach. Mainly, because it is "
"more flexible and will also work in other cases; for example, when you are "
"testing programs that change the files."
msgstr ""

#: src/tutorial/testing.md:492
msgid ""
"To create these temporary files, we'll be using the [`assert_fs`](https://"
"docs.rs/assert_fs) crate. Let's add it to the `dev-dependencies` in our "
"`Cargo.toml`:"
msgstr ""

#: src/tutorial/testing.md:496
msgid ""
"```toml\n"
"assert_fs = \"1.1.1\"\n"
"```"
msgstr ""

#: src/tutorial/testing.md:502
msgid ""
"Here is a new test case (that you can write below the other one) that first "
"creates a temp file (a \"named\" one so we can get its path), fills it with "
"some text, and then runs our program to see if we get the correct output. "
"When the `file` goes out of scope (at the end of the function), the actual "
"temporary file will automatically get deleted."
msgstr ""

#: src/tutorial/testing.md:518
msgid "\"sample.txt\""
msgstr ""

#: src/tutorial/testing.md:519
msgid "\"A test\\nActual content\\nMore content\\nAnother test\""
msgstr ""

#: src/tutorial/testing.md:522
msgid "\"test\""
msgstr ""

#: src/tutorial/testing.md:525
msgid "\"A test\\nAnother test\""
msgstr ""

#: src/tutorial/testing.md:533
msgid ""
"**Exercise for the reader:** Add integration tests for passing an empty "
"string as pattern. Adjust the program as needed."
msgstr ""

#: src/tutorial/testing.md:539
msgid "What to test?"
msgstr ""

#: src/tutorial/testing.md:541
msgid ""
"While it can certainly be fun to write integration tests, it will also take "
"some time to write them, as well as to update them when your application's "
"behavior changes. To make sure you use your time wisely, you should ask "
"yourself what you should test."
msgstr ""

#: src/tutorial/testing.md:547
msgid ""
"In general it's a good idea to write integration tests for all types of "
"behavior that a user can observe. That means that you don't need to cover "
"all edge cases: It usually suffices to have examples for the different types "
"and rely on unit tests to cover the edge cases."
msgstr ""

#: src/tutorial/testing.md:553
msgid ""
"It is also a good idea not to focus your tests on things you can't actively "
"control. It would be a bad idea to test the exact layout of `--help` as it "
"is generated for you. Instead, you might just want to check that certain "
"elements are present."
msgstr ""

#: src/tutorial/testing.md:558
msgid ""
"Depending on the nature of your program, you can also try to add more "
"testing techniques. For example, if you have extracted parts of your program "
"and find yourself writing a lot of example cases as unit tests while trying "
"to come up with all the edge cases, you should look into [`proptest`]"
"(https://docs.rs/proptest). If you have a program which consumes arbitrary "
"files and parses them, try to write a [fuzzer](https://rust-fuzz.github.io/"
"book/introduction.html) to find bugs in edge cases."
msgstr ""

#: src/tutorial/testing.md:573
msgid ""
"**Note:** You can find the full, runnable source code used in this chapter "
"[in this book's repository](https://github.com/rust-cli/book/tree/master/src/"
"tutorial/testing)."
msgstr ""

#: src/tutorial/packaging.md:3
msgid ""
"If you feel confident that your program is ready for other people to use, it "
"is time to package and release it!"
msgstr ""

#: src/tutorial/packaging.md:6
msgid ""
"There are a few approaches, and we'll look at three of them from \"quickest "
"to set up\" to \"most convenient for users\"."
msgstr ""

#: src/tutorial/packaging.md:10
msgid "Quickest: `cargo publish`"
msgstr ""

#: src/tutorial/packaging.md:12
msgid ""
"The easiest way to publish your app is with cargo. Do you remember how we "
"added external dependencies to our project? Cargo downloaded them from its "
"default \"crate registry\", [crates.io](https://crates.io/). With `cargo "
"publish`, you too can publish crates to [crates.io](https://crates.io/). And "
"this works for all crates, including those with binary targets."
msgstr ""

#: src/tutorial/packaging.md:20
msgid ""
"Publishing a crate to [crates.io](https://crates.io/) is pretty "
"straightforward: If you haven't already, create an account on [crates.io]"
"(https://crates.io/). Currently, this is done via authorizing you on GitHub, "
"so you'll need to have a GitHub account (and be logged in there). Next, you "
"log in using cargo on your local machine. For that, go to your [crates.io "
"account page](https://crates.io/me), create a new token, and then run `cargo "
"login <your-new-token>`. You only need to do this once per computer. You can "
"learn more about this in cargo's [publishing guide](https://doc.rust-"
"lang.org/1.39.0/cargo/reference/publishing.html)."
msgstr ""

#: src/tutorial/packaging.md:34
msgid ""
"Now that cargo as well as crates.io know you, you are ready to publish "
"crates. Before you hastily go ahead and publish a new crate (version), it's "
"a good idea to open your `Cargo.toml` once more and make sure you added the "
"necessary metadata. You can find all the possible fields you can set in the "
"documentation for [cargo's manifest format](https://doc.rust-lang.org/1.39.0/"
"cargo/reference/manifest.html). Here's a quick overview of some common "
"entries:"
msgstr ""

#: src/tutorial/packaging.md:43
msgid ""
"```toml\n"
"[package]\n"
"name = \"grrs\"\n"
"version = \"0.1.0\"\n"
"authors = [\"Your Name <your@email.com>\"]\n"
"license = \"MIT OR Apache-2.0\"\n"
"description = \"A tool to search files\"\n"
"readme = \"README.md\"\n"
"homepage = \"https://github.com/you/grrs\"\n"
"repository = \"https://github.com/you/grrs\"\n"
"keywords = [\"cli\", \"search\", \"demo\"]\n"
"categories = [\"command-line-utilities\"]\n"
"```"
msgstr ""

#: src/tutorial/packaging.md:59
msgid ""
"**Note:** This example includes the mandatory license field with a common "
"choice for Rust projects: The same license that is also used for the "
"compiler itself. It also refers to a `README.md` file. It should include a "
"quick description of what your project is about, and will be included not "
"only on the crates.io page of your crate, but also what GitHub shows by "
"default on repository pages."
msgstr ""

#: src/tutorial/packaging.md:75
msgid "How to install a binary from crates.io"
msgstr ""

#: src/tutorial/packaging.md:77
msgid ""
"We've seen how to publish a crate to crates.io, and you might be wondering "
"how to install it. In contrast to libraries, which cargo will download and "
"compile for you when you run `cargo build` (or a similar command), you'll "
"need to tell it to explicitly install binaries."
msgstr ""

#: src/tutorial/packaging.md:84
msgid ""
"This is done using `cargo install <crate-name>`. It will by default download "
"the crate, compile all the binary targets it contains (in \"release\" mode, "
"so it might take a while) and copy them into the `~/.cargo/bin/` directory. "
"(Make sure that your shell knows to look there for binaries!)"
msgstr ""

#: src/tutorial/packaging.md:92
msgid ""
"It's also possible to install crates from git repositories, only install "
"specific binaries of a crate, and specify an alternative directory to "
"install them to. Have a look at `cargo install --help` for details."
msgstr ""

#: src/tutorial/packaging.md:98 src/tutorial/packaging.md:244
msgid "When to use it"
msgstr ""

#: src/tutorial/packaging.md:100
msgid ""
"`cargo install` is a simple way to install a binary crate. It's very "
"convenient for Rust developers to use, but has some significant downsides: "
"Since it will always compile your source from scratch, users of your tool "
"will need to have Rust, cargo, and all other system dependencies your "
"project requires to be installed on their machine. Compiling large Rust "
"codebases can also take some time."
msgstr ""

#: src/tutorial/packaging.md:109
msgid ""
"It's best to use this for distributing tools that are targeted at other Rust "
"developers. For example: A lot of cargo subcommands like `cargo-tree` or "
"`cargo-outdated` can be installed with it."
msgstr ""

#: src/tutorial/packaging.md:116
msgid "Distributing binaries"
msgstr ""

#: src/tutorial/packaging.md:118
msgid ""
"Rust is a language that compiles to native code and by default statically "
"links all dependencies. When you run `cargo build` on your project that "
"contains a binary called `grrs`, you'll end up with a binary file called "
"`grrs`. Try it out: Using `cargo build`, it'll be `target/debug/grrs`, and "
"when you run `cargo build --release`, it'll be `target/release/grrs`. Unless "
"you use crates that explicitly need external libraries to be installed on "
"the target system (like using the system's version of OpenSSL), this binary "
"will only depend on common system libraries. That means, you take that one "
"file, send it to people running the same operating system as you, and "
"they'll be able to run it."
msgstr ""

#: src/tutorial/packaging.md:135
msgid ""
"This is already very powerful! It works around two of the downsides we just "
"saw for `cargo install`: There is no need to have Rust installed on the "
"user's machine, and instead of it taking a minute to compile, they can "
"instantly run the binary."
msgstr ""

#: src/tutorial/packaging.md:141
msgid ""
"So, as we've seen, `cargo build` _already_ builds binaries for us. The only "
"issue is, those are not guaranteed to work on all platforms. If you run "
"`cargo build` on your Windows machine, you won't get a binary that works on "
"a Mac by default. Is there a way to generate these binaries for all the "
"interesting platforms automatically?"
msgstr ""

#: src/tutorial/packaging.md:151
msgid "Building binary releases on CI"
msgstr ""

#: src/tutorial/packaging.md:153
msgid ""
"If your tool is open sourced and hosted on GitHub, it's quite easy to set up "
"a free CI (continuous integration) service like [Travis CI](https://travis-"
"ci.com/). (There are other services that also work on other platforms, but "
"Travis is very popular.) This basically runs setup commands in a virtual "
"machine each time you push changes to your repository. What those commands "
"are, and the types of machines they run on, is configurable. For example: A "
"good idea is to run `cargo test` on a machine with Rust and some common "
"build tools installed. If this fails, you know there are issues in the most "
"recent changes."
msgstr ""

#: src/tutorial/packaging.md:172
msgid ""
"We can also use this to build binaries and upload them to GitHub! Indeed, if "
"we run `cargo build --release` and upload the binary somewhere, we should be "
"all set, right? Not quite. We still need to make sure the binaries we build "
"are compatible with as many systems as possible. For example, on Linux we "
"can compile not for the current system, but instead for the `x86_64-unknown-"
"linux-musl` target, to not depend on default system libraries. On macOS, we "
"can set `MACOSX_DEPLOYMENT_TARGET` to `10.7` to only depend on system "
"features present in versions 10.7 and older."
msgstr ""

#: src/tutorial/packaging.md:188
msgid ""
"You can see one example of building binaries using this approach [here]"
"(https://github.com/rustwasm/wasm-pack/blob/"
"51e6351c28fbd40745719e6d4a7bf26dadd30c85/.travis.yml#L74-L91) for Linux and "
"macOS and [here](https://github.com/rustwasm/wasm-pack/blob/"
"51e6351c28fbd40745719e6d4a7bf26dadd30c85/.appveyor.yml) for Windows (using "
"AppVeyor)."
msgstr ""

#: src/tutorial/packaging.md:195
msgid ""
"Another way is to use pre-built (Docker) images that contain all the tools "
"we need to build binaries. This allows us to easily target more exotic "
"platforms, too. The [trust](https://github.com/japaric/trust) project "
"contains scripts that you can include in your project as well as "
"instructions on how to set this up. It also includes support for Windows "
"using AppVeyor."
msgstr ""

#: src/tutorial/packaging.md:204
msgid ""
"If you'd rather set this up locally and generate the release files on your "
"own machine, still have a look at trust. It uses [cross](https://github.com/"
"rust-embedded/cross) internally, which works similar to cargo but forwards "
"commands to a cargo process inside a Docker container. The definitions of "
"the images are also available in [cross' repository](https://github.com/rust-"
"embedded/cross)."
msgstr ""

#: src/tutorial/packaging.md:216
msgid "How to install these binaries"
msgstr ""

#: src/tutorial/packaging.md:218
msgid ""
"You point your users to your release page that might look something [like "
"this one](https://github.com/rustwasm/wasm-pack/releases/tag/v0.5.1), and "
"they can download the artifacts we've just created. The release artifacts "
"we've just generated are nothing special: At the end, they are just archive "
"files that contain our binaries! This means that users of your tool can "
"download them with their browser, extract them (often happens "
"automatically), and copy the binaries to a place they like."
msgstr ""

#: src/tutorial/packaging.md:230
msgid ""
"This does require some experience with manually \"installing\" programs, so "
"you want to add a section to your README file on how to install this program."
msgstr ""

#: src/tutorial/packaging.md:236
msgid ""
"**Note:** If you used [trust](https://github.com/japaric/trust) to build "
"your binaries and added them to GitHub releases, you can also tell people to "
"run `curl -LSfs https://japaric.github.io/trust/install.sh | sh -s -- --git "
"your-name/repo-name` if you think that makes it easier."
msgstr ""

#: src/tutorial/packaging.md:246
msgid ""
"Having binary releases is a good idea in general, there's hardly any "
"downside to it. It does not solve the problem of users having to manually "
"install and update your tools, but they can quickly get the latest releases "
"version without the need to install Rust."
msgstr ""

#: src/tutorial/packaging.md:254
msgid "What to package in addition to your binaries"
msgstr ""

#: src/tutorial/packaging.md:256
msgid ""
"Right now, when a user downloads our release builds, they will get a "
"`.tar.gz` file that only contains binary files. So, in our example project, "
"they will just get a single `grrs` file they can run. But there are some "
"more files we already have in our repository that they might want to have. "
"The README file that tells them how to use this tool, and the license "
"file(s), for example. Since we already have them, they are easy to add."
msgstr ""

#: src/tutorial/packaging.md:270
msgid ""
"There are some more interesting files that make sense especially for command-"
"line tools, though: How about we also ship a man page in addition to that "
"README file, and config files that add completions of the possible flags to "
"your shell? You can write these by hand, but _clap_, the argument parsing "
"library we use (which clap builds upon) has a way to generate all these "
"files for us. See [this in-depth chapter](../in-depth/docs.html) for more "
"details."
msgstr ""

#: src/tutorial/packaging.md:286
msgid "Getting your app into package repositories"
msgstr ""

#: src/tutorial/packaging.md:288
msgid ""
"Both approaches we've seen so far are not how you typically install software "
"on your machine. Especially command-line tools you install using global "
"package managers on most operating systems. The advantages for users are "
"quite obvious: There is no need to think about how to install your program, "
"if it can be installed the same way as they install the other tools. These "
"package managers also allow users to update their programs when a new "
"version is available."
msgstr ""

#: src/tutorial/packaging.md:299
msgid ""
"Sadly, supporting different systems means you'll have to look at how these "
"different systems work. For some, it might be as easy as adding a file to "
"your repository (e.g. adding a Formula file like [this](https://github.com/"
"BurntSushi/ripgrep/blob/31adff6f3c4bfefc9e77df40871f2989443e6827/pkg/brew/"
"ripgrep-bin.rb) for macOS's `brew`), but for others you'll often need to "
"send in patches yourself and add your tool to their repositories. There are "
"helpful tools like [cargo-bundle](https://crates.io/crates/cargo-bundle), "
"[cargo-deb](https://crates.io/crates/cargo-deb), and [cargo-aur](https://"
"crates.io/crates/cargo-aur), but describing how they work and how to "
"correctly package your tool for those different systems is beyond the scope "
"of this chapter."
msgstr ""

#: src/tutorial/packaging.md:316
msgid ""
"Instead, let's have a look at a tool that is written in Rust and that is "
"available in many different package managers."
msgstr ""

#: src/tutorial/packaging.md:320
msgid "An example: ripgrep"
msgstr ""

#: src/tutorial/packaging.md:322
msgid ""
"[ripgrep](https://github.com/BurntSushi/ripgrep) is an alternative to `grep`/"
"`ack`/`ag` and is written in Rust. It's quite successful and is packaged for "
"many operating systems: Just look at [the \"Installation\" section](https://"
"github.com/BurntSushi/ripgrep/tree/"
"31adff6f3c4bfefc9e77df40871f2989443e6827#installation) of its README!"
msgstr ""

#: src/tutorial/packaging.md:326
msgid ""
"Note that it lists a few different options how you can install it: It starts "
"with a link to the GitHub releases which contain the binaries so you can "
"download them directly; then it lists how to install it using a bunch of "
"different package managers; finally, you can also install it using `cargo "
"install`."
msgstr ""

#: src/tutorial/packaging.md:332
msgid ""
"This seems like a very good idea: Don't pick and choose one of the "
"approaches presented here, but start with `cargo install`, add binary "
"releases, and finally start distributing your tool using system package "
"managers."
msgstr ""

#: src/in-depth/index.md:3
msgid ""
"A small collection of chapters covering some more details that you might "
"care about when writing your command line application."
msgstr ""

#: src/in-depth/signals.md:3
msgid ""
"Processes like command line applications need to react to signals sent by "
"the operating system. The most common example is probably <kbd>Ctrl</"
"kbd>+<kbd>C</kbd>, the signal that typically tells a process to terminate. "
"To handle signals in Rust programs you need to consider how you can receive "
"these signals as well as how you can react to them."
msgstr ""

#: src/in-depth/signals.md:14
msgid ""
"**Note:** If your applications does not need to gracefully shutdown, the "
"default handling is fine (i.e. exit immediately and let the OS cleanup "
"resources like open file handles). In that case: No need to do what this "
"chapter tells you!"
msgstr ""

#: src/in-depth/signals.md:22
msgid ""
"However, for applications that need to clean up after themselves, this "
"chapter is very relevant! For example, if your application needs to properly "
"close network connections (saying \"good bye\" to the processes at the other "
"end), remove temporary files, or reset system settings, read on."
msgstr ""

#: src/in-depth/signals.md:35
msgid "Differences between operating systems"
msgstr ""

#: src/in-depth/signals.md:37
msgid ""
"On Unix systems (like Linux, macOS, and FreeBSD) a process can receive "
"[signals](https://manpages.ubuntu.com/manpages/bionic/en/man7/"
"signal.7.html). It can either react to them in a default (OS-provided) way, "
"catch the signal and handle them in a program-defined way, or ignore the "
"signal entirely."
msgstr ""

#: src/in-depth/signals.md:47
msgid ""
"Windows does not have signals. You can use [Console Handlers](https://"
"docs.microsoft.com/en-us/windows/console/console-control-handlers) to define "
"callbacks that get executed when an event occurs. There is also [structured "
"exception handling](https://docs.microsoft.com/en-us/windows/desktop/debug/"
"structured-exception-handling) which handles all the various types of system "
"exceptions such as division by zero, invalid access exceptions, stack "
"overflow, and so on"
msgstr ""

#: src/in-depth/signals.md:56
msgid "First off: Handling Ctrl+C"
msgstr ""

#: src/in-depth/signals.md:58
msgid ""
"The [ctrlc](https://crates.io/crates/ctrlc) crate does just what the name "
"suggests: It allows you to react to the user pressing <kbd>Ctrl</"
"kbd>+<kbd>C</kbd>, in a cross-platform way. The main way to use the crate is "
"this:"
msgstr ""

#: src/in-depth/signals.md:70
msgid "\"received Ctrl+C!\""
msgstr ""

#: src/in-depth/signals.md:72
msgid "\"Error setting Ctrl-C handler\""
msgstr ""

#: src/in-depth/signals.md:74 src/in-depth/signals.md:119
msgid ""
"// Following code does the actual work, and can be interrupted by pressing\n"
"    // Ctrl-C. As an example: Let's wait a few seconds.\n"
msgstr ""

#: src/in-depth/signals.md:80
msgid ""
"This is, of course, not that helpful: It only prints a message but otherwise "
"doesn't stop the program."
msgstr ""

#: src/in-depth/signals.md:83
msgid ""
"In a real-world program, it's a good idea to instead set a variable in the "
"signal handler that you then check in various places in your program. For "
"example, you can set an `Arc<AtomicBool>` (a boolean shareable between "
"threads) in your signal handler, and in hot loops, or when waiting for a "
"thread, you periodically check its value and break when it becomes true."
msgstr ""

#: src/in-depth/signals.md:95
msgid "Handling other types of signals"
msgstr ""

#: src/in-depth/signals.md:97
msgid ""
"The [ctrlc](https://crates.io/crates/ctrlc) crate only handles <kbd>Ctrl</"
"kbd>+<kbd>C</kbd>, or, what on Unix systems would be called `SIGINT` (the "
"\"interrupt\" signal). To react to more Unix signals, you should have a look "
"at [signal-hook](https://crates.io/crates/signal-hook). Its design is "
"described in [this blog post](https://vorner.github.io/2018/06/28/signal-"
"hook.html), and it is currently the library with the widest community "
"support."
msgstr ""

#: src/in-depth/signals.md:104
msgid "Here's a simple example:"
msgstr ""

#: src/in-depth/signals.md:115
msgid "\"Received signal {:?}\""
msgstr ""

#: src/in-depth/signals.md:129
msgid "Using channels"
msgstr ""

#: src/in-depth/signals.md:131
msgid ""
"Instead of setting a variable and having other parts of the program check "
"it, you can use channels: You create a channel into which the signal handler "
"emits a value whenever the signal is received. In your application code you "
"use this and other channels as synchronization points between threads. Using "
"[crossbeam-channel](https://crates.io/crates/crossbeam-channel) it would "
"look something like this:"
msgstr ""

#: src/in-depth/signals.md:164
msgid "\"working!\""
msgstr ""

#: src/in-depth/signals.md:168
msgid "\"Goodbye!\""
msgstr ""

#: src/in-depth/signals.md:178
msgid "Using futures and streams"
msgstr ""

#: src/in-depth/signals.md:180
msgid ""
"If you are using [tokio](https://tokio.rs/), you are most likely already "
"writing your application with asynchronous patterns and an event-driven "
"design. Instead of using crossbeam's channels directly, you can enable "
"signal-hook's `tokio-support` feature. This allows you to call "
"[`.into_async()`](https://docs.rs/signal-hook/0.1.6/signal_hook/iterator/"
"struct.Signals.html#method.into_async) on signal-hook's `Signals` types to "
"get a new type that implements `futures::Stream`."
msgstr ""

#: src/in-depth/signals.md:193
msgid ""
"What to do when you receive another Ctrl+C while you're handling the first "
"Ctrl+C"
msgstr ""

#: src/in-depth/signals.md:195
msgid ""
"Most users will press <kbd>Ctrl</kbd>+<kbd>C</kbd>, and then give your "
"program a few seconds to exit, or tell them what's going on. If that doesn't "
"happen, they will press <kbd>Ctrl</kbd>+<kbd>C</kbd> again. The typical "
"behavior is to have the application quit immediately."
msgstr ""

#: src/in-depth/config-files.md:3
msgid ""
"Dealing with configurations can be annoying especially if you support "
"multiple operating systems which all have their own places for short- and "
"long-term files."
msgstr ""

#: src/in-depth/config-files.md:8
msgid ""
"There are multiple solutions to this, some being more low-level than others."
msgstr ""

#: src/in-depth/config-files.md:11
msgid ""
"The easiest crate to use for this is [`confy`](https://docs.rs/confy/0.3.1/"
"confy/). It asks you for the name of your application and requires you to "
"specify the config layout via a `struct` (that is `Serialize`, "
"`Deserialize`) and it will figure out the rest!"
msgstr ""

#: src/in-depth/config-files.md:26
msgid "\"my_app\""
msgstr ""

#: src/in-depth/config-files.md:27
msgid "\"{:#?}\""
msgstr ""

#: src/in-depth/config-files.md:32
msgid ""
"This is incredibly easy to use for which you of course surrender "
"configurability. But if a simple config is all you want, this crate might be "
"for you!"
msgstr ""

#: src/in-depth/config-files.md:39
msgid "Configuration environments"
msgstr ""

#: src/in-depth/config-files.md:43
msgid "**TODO**"
msgstr ""

#: src/in-depth/config-files.md:45
msgid "Evaluate crates that exist"
msgstr ""

#: src/in-depth/config-files.md:46
msgid "Cli-args + multiple configs + env variables"
msgstr ""

#: src/in-depth/config-files.md:47
msgid ""
"Can [`configure`](https://docs.rs/configure/0.1.1/configure/) do all this? "
"Is there a nice wrapper around it?"
msgstr ""

#: src/in-depth/exit-code.md:3
msgid ""
"A program doesn't always succeed. And when an error occurs, you should make "
"sure to emit the necessary information correctly. In addition to [telling "
"the user about errors](human-communication.html), on most systems, when a "
"process exits, it also emits an exit code (an integer between 0 and 255 is "
"compatible with most platforms). You should try to emit the correct code for "
"your program's state. For example, in the ideal case when your program "
"succeeds, it should exit with `0`."
msgstr ""

#: src/in-depth/exit-code.md:18
msgid ""
"When an error occurs, it gets a bit more complicated, though. In the wild, "
"many tools exit with `1` when a common failure occurs. Currently, Rust sets "
"an exit code of `101` when the process panicked. Beyond that, people have "
"done many things in their programs."
msgstr ""

#: src/in-depth/exit-code.md:24
msgid ""
"So, what to do? The BSD ecosystem has collected a common definition for "
"their exit codes (you can find them [here](https://www.freebsd.org/cgi/"
"man.cgi?query=sysexits&apropos=0&sektion=0&manpath=FreeBSD+11.2-"
"stable&arch=default&format=html)). The Rust library [`exitcode`](https://"
"crates.io/crates/exitcode) provides these same codes, ready to be used in "
"your application. Please see its API documentation for the possible values "
"to use."
msgstr ""

#: src/in-depth/exit-code.md:31
msgid ""
"After you add the `exitcode` dependency to your `Cargo.toml`, you can use it "
"like this:"
msgstr ""

#: src/in-depth/exit-code.md:36
msgid "// ...actual work...\n"
msgstr ""

#: src/in-depth/exit-code.md:39
msgid "\"Done!\""
msgstr ""

#: src/in-depth/exit-code.md:43 src/in-depth/exit-code.md:47
msgid "\"Error: {}\""
msgstr ""

#: src/in-depth/human-communication.md:3
msgid ""
"Make sure to read [the chapter on CLI output](../tutorial/output.html) in "
"the tutorial first. It covers how to write output to the terminal, while "
"this chapter will talk about _what_ to output."
msgstr ""

#: src/in-depth/human-communication.md:10
msgid "When everything is fine"
msgstr ""

#: src/in-depth/human-communication.md:12
msgid ""
"It is useful to report on the application's progress even when everything is "
"fine. Try to be informative and concise in these messages. Don't use overly "
"technical terms in the logs. Remember: the application is not crashing so "
"there's no reason for users to look up errors."
msgstr ""

#: src/in-depth/human-communication.md:20
msgid ""
"Most importantly, be consistent in the style of communication. Use the same "
"prefixes and sentence structure to make the logs easily skimmable."
msgstr ""

#: src/in-depth/human-communication.md:25
msgid ""
"Try to let your application output tell a story about what it's doing and "
"how it impacts the user. This can involve showing a timeline of steps "
"involved or even a progress bar and indicator for long-running actions. The "
"user should at no point get the feeling that the application is doing "
"something mysterious that they cannot follow."
msgstr ""

#: src/in-depth/human-communication.md:34
msgid "When it's hard to tell what's going on"
msgstr ""

#: src/in-depth/human-communication.md:36
msgid ""
"When communicating non-nominal state it's important to be consistent. A "
"heavily logging application that doesn't follow strict logging levels "
"provides the same amount, or even less information than a non-logging "
"application."
msgstr ""

#: src/in-depth/human-communication.md:41
msgid ""
"Because of this, it's important to define the severity of events and "
"messages that are related to it; then use consistent log levels for them. "
"This way users can select the amount of logging themselves via `--verbose` "
"flags or environment variables (like `RUST_LOG`)."
msgstr ""

#: src/in-depth/human-communication.md:49
msgid ""
"The commonly used `log` crate [defines](https://docs.rs/log/0.4.4/log/"
"enum.Level.html) the following levels (ordered by increasing severity):"
msgstr ""

#: src/in-depth/human-communication.md:53
msgid "trace"
msgstr ""

#: src/in-depth/human-communication.md:54
msgid "debug"
msgstr ""

#: src/in-depth/human-communication.md:55
msgid "info"
msgstr ""

#: src/in-depth/human-communication.md:56
msgid "warning"
msgstr ""

#: src/in-depth/human-communication.md:57
msgid "error"
msgstr ""

#: src/in-depth/human-communication.md:59
msgid ""
"It's a good idea to think of _info_ as the default log level. Use it for, "
"well, informative output. (Some applications that lean towards a more quiet "
"output style might only show warnings and errors by default.)"
msgstr ""

#: src/in-depth/human-communication.md:64
msgid ""
"Additionally, it's always a good idea to use similar prefixes and sentence "
"structure across log messages, making it easy to use a tool like `grep` to "
"filter for them. A message should provide enough context by itself to be "
"useful in a filtered log while not being _too_ verbose at the same time."
msgstr ""

#: src/in-depth/human-communication.md:74
msgid "Example log statements"
msgstr ""

#: src/in-depth/human-communication.md:85
msgid ""
"The following log output is taken from [wasm-pack](https://crates.io/crates/"
"wasm-pack):"
msgstr ""

#: src/in-depth/human-communication.md:103
msgid "When panicking"
msgstr ""

#: src/in-depth/human-communication.md:105
msgid ""
"One aspect often forgotten is that your program also outputs something when "
"it crashes. In Rust, \"crashes\" are most often \"panics\" (i.e., "
"\"controlled crashing\" in contrast to \"the operating system killed the "
"process\"). By default, when a panic occurs, a \"panic handler\" will print "
"some information to the console."
msgstr ""

#: src/in-depth/human-communication.md:114
msgid ""
"For example, if you create a new binary project with `cargo new --bin foo` "
"and replace the content of `fn main` with `panic!(\"Hello World\")`, you get "
"this when you run your program:"
msgstr ""

#: src/in-depth/human-communication.md:125
msgid ""
"This is useful information to you, the developer. (Surprise: the program "
"crashed because of line 2 in your `main.rs` file). But for a user who "
"doesn't even have access to the source code, this is not very valuable. In "
"fact, it most likely is just confusing. That's why it's a good idea to add a "
"custom panic handler, that provides a bit more end-user focused output."
msgstr ""

#: src/in-depth/human-communication.md:133
msgid ""
"One library that does just that is called [human-panic](https://crates.io/"
"crates/human-panic). To add it to your CLI project, you import it and call "
"the `setup_panic!()` macro at the beginning of your `main` function:"
msgstr ""

#: src/in-depth/human-communication.md:145
#: src/in-depth/machine-communication.md:191
#: src/in-depth/machine-communication.md:195
msgid "\"Hello world\""
msgstr ""

#: src/in-depth/human-communication.md:149
msgid ""
"This will now show a very friendly message, and tells the user what they can "
"do:"
msgstr ""

#: src/in-depth/human-communication.md:152
msgid ""
"```console\n"
"Well, this is embarrassing.\n"
"\n"
"foo had a problem and crashed. To help us diagnose the problem you can send "
"us a crash report.\n"
"\n"
"We have generated a report file at \"/var/folders/n3/"
"dkk459k908lcmkzwcmq0tcv00000gn/T/report-738e1bec-5585-47a4-8158-"
"f1f7227f0168.toml\". Submit an issue or email with the subject of \"foo "
"Crash Report\" and include the report as an attachment.\n"
"\n"
"- Authors: Your Name <your.name@example.com>\n"
"\n"
"We take privacy seriously, and do not perform any automated error "
"collection. In order to improve the software, we rely on people to submit "
"reports.\n"
"\n"
"Thank you kindly!\n"
"```"
msgstr ""

#: src/in-depth/machine-communication.md:3
msgid ""
"The power of command-line tools really comes to shine when you are able to "
"combine them. This is not a new idea: In fact, this is a sentence from the "
"[Unix philosophy](https://en.wikipedia.org/wiki/Unix_philosophy):"
msgstr ""

#: src/in-depth/machine-communication.md:8
msgid ""
"Expect the output of every program to become the input to another, as yet "
"unknown, program."
msgstr ""

#: src/in-depth/machine-communication.md:12
msgid ""
"If our programs fulfill this expectation, our users will be happy. To make "
"sure this works well, we should provide not just pretty output for humans, "
"but also a version tailored to what other programs need. Let's see how we "
"can do this."
msgstr ""

#: src/in-depth/machine-communication.md:21
msgid ""
"**Note:** Make sure to read [the chapter on CLI output](../tutorial/"
"output.html) in the tutorial first. It covers how to write output to the "
"terminal."
msgstr ""

#: src/in-depth/machine-communication.md:30
msgid "Who's reading this?"
msgstr ""

#: src/in-depth/machine-communication.md:32
msgid ""
"The first question to ask is: Is our output for a human in front of a "
"colorful terminal, or for another program? To answer this, we can use the "
"[IsTerminal](https://doc.rust-lang.org/stable/std/io/trait.IsTerminal.html) "
"trait:"
msgstr ""

#: src/in-depth/machine-communication.md:44
msgid "\"I'm a terminal\""
msgstr ""

#: src/in-depth/machine-communication.md:46
msgid "\"I'm not\""
msgstr ""

#: src/in-depth/machine-communication.md:50
msgid ""
"Depending on who will read our output, we can then add extra information. "
"Humans tend to like colors, for example, if you run `ls` in a random Rust "
"project, you might see something like this:"
msgstr ""

#: src/in-depth/machine-communication.md:65
msgid ""
"Because this style is made for humans, in most configurations it'll even "
"print some of the names (like `src`) in color to show that they are "
"directories. If you instead pipe this to a file, or a program like `cat`, "
"`ls` will adapt its output. Instead of using columns that fit my terminal "
"window it will print every entry on its own line. It will also not emit any "
"colors."
msgstr ""

#: src/in-depth/machine-communication.md:92
msgid "Easy output formats for machines"
msgstr ""

#: src/in-depth/machine-communication.md:94
msgid ""
"Historically, the only type of output command-line tools produced were "
"strings. This is usually fine for people in front of terminals, who are able "
"to read text and reason about its meaning. Other programs usually don't have "
"that ability, though: The only way for them to understand the output of a "
"tool like `ls` is if the author of the program included a parser that "
"happens to work for whatever `ls` outputs."
msgstr ""

#: src/in-depth/machine-communication.md:105
msgid ""
"This often means that output was limited to what is easy to parse. Formats "
"like TSV (tab-separated values), where each record is on its own line, and "
"each line contains tab-separated content, are very popular. These simple "
"formats based on lines of text allow tools like `grep` to be used on the "
"output of tools like `ls`. `| grep Cargo` doesn't care if your lines are "
"from `ls` or file, it will just filter line by line."
msgstr ""

#: src/in-depth/machine-communication.md:117
msgid ""
"The downside of this is that you can't use an easy `grep` invocation to "
"filter all the directories that `ls` gave you. For that, each directory item "
"would need to carry additional data."
msgstr ""

#: src/in-depth/machine-communication.md:121
msgid "JSON output for machines"
msgstr ""

#: src/in-depth/machine-communication.md:123
msgid ""
"Tab-separated values is a simple way to output structured data but it "
"requires the other program to know which fields to expect (and in which "
"order) and it's difficult to output messages of different types. For "
"example, let's say our program wanted to message the consumer that it is "
"currently waiting for a download, and afterwards output a message describing "
"the data it got. Those are very different kinds of messages and trying to "
"unify them in a TSV output would require us to invent a way to differentiate "
"them. Same when we wanted to print a message that contains two lists of "
"items of varying lengths."
msgstr ""

#: src/in-depth/machine-communication.md:138
msgid ""
"Still, it's a good idea to choose a format that is easily parsable in most "
"programming languages/environments. Thus, over the last years a lot of "
"applications gained the ability to output their data in [JSON](https://"
"www.json.org/). It's simple enough that parsers exist in practically every "
"language yet powerful enough to be useful in a lot of cases. While its a "
"text format that can be read by humans, a lot of people have also worked on "
"implementations that are very fast at parsing JSON data and serializing data "
"to JSON."
msgstr ""

#: src/in-depth/machine-communication.md:152
msgid ""
"In the description above, we've talked about \"messages\" being written by "
"our program. This is a good way of thinking about the output: Your program "
"doesn't necessarily only output one blob of data but may in fact emit a lot "
"of different information while it is running. One easy way to support this "
"approach when outputting JSON is to write one JSON document per message and "
"to put each JSON document on new line (sometimes called [Line-delimited JSON]"
"(https://en.wikipedia.org/wiki/JSON_streaming#Line-delimited_JSON)). This "
"can make implementations as simple as using a regular `println!`."
msgstr ""

#: src/in-depth/machine-communication.md:166
msgid ""
"Here's a simple example, using the `json!` macro from [serde_json](https://"
"crates.io/crates/serde_json) to quickly write valid JSON in your Rust source "
"code:"
msgstr ""

#: src/in-depth/machine-communication.md:179
msgid "/// Output JSON instead of human readable messages\n"
msgstr ""

#: src/in-depth/machine-communication.md:190
msgid "\"type\""
msgstr ""

#: src/in-depth/machine-communication.md:190
msgid "\"message\""
msgstr ""

#: src/in-depth/machine-communication.md:191
msgid "\"content\""
msgstr ""

#: src/in-depth/machine-communication.md:200
msgid "And here is the output:"
msgstr ""

#: src/in-depth/machine-communication.md:202
msgid ""
"```console\n"
"$ cargo run -q\n"
"Hello world\n"
"$ cargo run -q -- --json\n"
"{\"content\":\"Hello world\",\"type\":\"message\"}\n"
"```"
msgstr ""

#: src/in-depth/machine-communication.md:209
msgid ""
"(Running `cargo` with `-q` suppresses its usual output. The arguments after "
"`--` are passed to our program.)"
msgstr ""

#: src/in-depth/machine-communication.md:212
msgid "Practical example: ripgrep"
msgstr ""

#: src/in-depth/machine-communication.md:214
msgid ""
"_[ripgrep](https://github.com/BurntSushi/ripgrep)_ is a replacement for "
"_grep_ or _ag_, written in Rust. By default it will produce output like this:"
msgstr ""

#: src/in-depth/machine-communication.md:228
msgid "But given `--json` it will print:"
msgstr ""

#: src/in-depth/machine-communication.md:230
msgid ""
"```console\n"
"$ rg default --json\n"
"{\"type\":\"begin\",\"data\":{\"path\":{\"text\":\"src/lib.rs\"}}}\n"
"{\"type\":\"match\",\"data\":{\"path\":{\"text\":\"src/lib.rs\"},\"lines\":"
"{\"text\":\"    Output::default()\\n\"},"
"\"line_number\":37,\"absolute_offset\":761,\"submatches\":[{\"match\":"
"{\"text\":\"default\"},\"start\":12,\"end\":19}]}}\n"
"{\"type\":\"end\",\"data\":{\"path\":{\"text\":\"src/lib.rs\"},"
"\"binary_offset\":null,\"stats\":{\"elapsed\":"
"{\"secs\":0,\"nanos\":137622,\"human\":\"0.000138s\"},"
"\"searches\":1,\"searches_with_match\":1,\"bytes_searched\":6064,\"bytes_printed\":256,\"matched_lines\":1,\"matches\":1}}}\n"
"{\"type\":\"begin\",\"data\":{\"path\":{\"text\":\"src/components/"
"span.rs\"}}}\n"
"{\"type\":\"match\",\"data\":{\"path\":{\"text\":\"src/components/span.rs\"},"
"\"lines\":{\"text\":\"    Span::default()\\n\"},"
"\"line_number\":6,\"absolute_offset\":117,\"submatches\":[{\"match\":"
"{\"text\":\"default\"},\"start\":10,\"end\":17}]}}\n"
"{\"type\":\"end\",\"data\":{\"path\":{\"text\":\"src/components/span.rs\"},"
"\"binary_offset\":null,\"stats\":{\"elapsed\":"
"{\"secs\":0,\"nanos\":22025,\"human\":\"0.000022s\"},"
"\"searches\":1,\"searches_with_match\":1,\"bytes_searched\":5221,\"bytes_printed\":277,\"matched_lines\":1,\"matches\":1}}}\n"
"{\"data\":{\"elapsed_total\":{\"human\":\"0.006995s\","
"\"nanos\":6994920,\"secs\":0},\"stats\":"
"{\"bytes_printed\":533,\"bytes_searched\":11285,\"elapsed\":{\"human\":"
"\"0.000160s\",\"nanos\":159647,\"secs\":0},"
"\"matched_lines\":2,\"matches\":2,\"searches\":2,\"searches_with_match\":2}},"
"\"type\":\"summary\"}\n"
"```"
msgstr ""

#: src/in-depth/machine-communication.md:241
msgid ""
"As you can see, each JSON document is an object (map) containing a `type` "
"field. This would allow us to write a simple frontend for `rg` that reads "
"these documents as they come in and show the matches (as well the files they "
"are in) even while _ripgrep_ is still searching."
msgstr ""

#: src/in-depth/machine-communication.md:250
msgid ""
"**Note:** This is how Visual Studio Code uses _ripgrep_ for its code search."
msgstr ""

#: src/in-depth/machine-communication.md:255
msgid "How to deal with input piped into us"
msgstr ""

#: src/in-depth/machine-communication.md:257
msgid "Let's say we have a program that reads the number of words in a file:"
msgstr ""

#: src/in-depth/machine-communication.md:262
msgid "/// Count the number of lines in a file\n"
msgstr ""

#: src/in-depth/machine-communication.md:277
#: src/in-depth/machine-communication.md:343
msgid "' '"
msgstr ""

#: src/in-depth/machine-communication.md:280
msgid "\"Words in {}: {}\""
msgstr ""

#: src/in-depth/machine-communication.md:284
msgid ""
"It takes the path to a file, reads it line by line, and counts the number of "
"words separated by a space."
msgstr ""

#: src/in-depth/machine-communication.md:287
msgid "When you run it, it outputs the total words in the file:"
msgstr ""

#: src/in-depth/machine-communication.md:294
msgid ""
"But what if we wanted to count the number of words piped into the program? "
"Rust programs can read data passed in via stdin with the [Stdin struct]"
"(https://doc.rust-lang.org/std/io/struct.Stdin.html) which you can obtain "
"via [the stdin function](https://doc.rust-lang.org/std/io/fn.stdin.html) "
"from the standard library. Similar to reading the lines of a file, it can "
"read the lines from stdin."
msgstr ""

#: src/in-depth/machine-communication.md:301
msgid "Here's a program that counts the words of what's piped in via stdin"
msgstr ""

#: src/in-depth/machine-communication.md:310
msgid "/// Count the number of lines in a file or stdin\n"
msgstr ""

#: src/in-depth/machine-communication.md:315
msgid ""
"/// The path to the file to read, use - to read from stdin (must not be a "
"tty)\n"
msgstr ""

#: src/in-depth/machine-communication.md:325
msgid "\"-\""
msgstr ""

#: src/in-depth/machine-communication.md:331
msgid "\"<stdin>\""
msgstr ""

#: src/in-depth/machine-communication.md:337
msgid "\"Words from {}: {}\""
msgstr ""

#: src/in-depth/machine-communication.md:349
msgid ""
"If you run that program with text piped in, with `-` representing the intent "
"to read from `stdin`, it'll output the word count:"
msgstr ""

#: src/in-depth/machine-communication.md:352
msgid ""
"```console\n"
"$ echo \"hi there friend\" | cargo run -- -\n"
"Words from stdin: 3\n"
"```"
msgstr ""

#: src/in-depth/machine-communication.md:357
msgid ""
"It requires that stdin is not interactive because we're expecting input "
"that's piped through to the program, not text that's typed in at runtime. If "
"stdin is a tty, it outputs the help docs so that it's clear why it doesn't "
"work."
msgstr ""

#: src/in-depth/docs.md:3
msgid ""
"Documentation for CLIs usually consists of a `--help` section in the command "
"and a manual (`man`) page."
msgstr ""

#: src/in-depth/docs.md:7
msgid ""
"Both can be automatically generated when using [`clap`](https://crates.io/"
"crates/clap), via [`clap_mangen`](https://crates.io/crates/clap_mangen) "
"crate."
msgstr ""

#: src/in-depth/docs.md:14
msgid "/// file to load\n"
msgstr ""

#: src/in-depth/docs.md:16
msgid "/// how many lines to print\n"
msgstr ""

#: src/in-depth/docs.md:22
msgid ""
"Secondly, you need to use a `build.rs` to generate the manual file at "
"compile time from the definition of your app in code."
msgstr ""

#: src/in-depth/docs.md:27
msgid ""
"There are a few things to keep in mind (such as how you want to package your "
"binary) but for now we simply put the `man` file next to our `src` folder."
msgstr ""

#: src/in-depth/docs.md:36
msgid "\"src/cli.rs\""
msgstr ""

#: src/in-depth/docs.md:40
msgid "\"OUT_DIR\""
msgstr ""

#: src/in-depth/docs.md:47
msgid "\"head.1\""
msgstr ""

#: src/in-depth/docs.md:53
msgid ""
"When you now compile your application there will be a `head.1` file in your "
"project directory."
msgstr ""

#: src/in-depth/docs.md:57
msgid ""
"If you open that in `man` you'll be able to admire your free documentation."
msgstr ""

#: src/resources/index.md:3
msgid "Collaboration / help"
msgstr ""

#: src/resources/index.md:4
msgid ""
"[cli-and-tui Discord Channel](https://discord.com/channels/"
"273534239310479360/943315667430563862)"
msgstr ""

#: src/resources/index.md:6
msgid "Crates referenced in this book"
msgstr ""

#: src/resources/index.md:8
msgid ""
"[anyhow](https://crates.io/crates/anyhow) - provides `anyhow::Error` for "
"easy error handling"
msgstr ""

#: src/resources/index.md:9
msgid ""
"[assert_cmd](https://crates.io/crates/assert_cmd) - simplifies integration "
"testing of CLIs"
msgstr ""

#: src/resources/index.md:10
msgid ""
"[assert_fs](https://crates.io/crates/assert_fs) - Setup input files and test "
"output files"
msgstr ""

#: src/resources/index.md:11
msgid ""
"[clap-verbosity-flag](https://crates.io/crates/clap-verbosity-flag) - adds a "
"`--verbose` flag to clap CLIs"
msgstr ""

#: src/resources/index.md:12
msgid "[clap](https://crates.io/crates/clap) - command line argument parser"
msgstr ""

#: src/resources/index.md:13
msgid ""
"[confy](https://crates.io/crates/confy) - boilerplate-free configuration "
"management"
msgstr ""

#: src/resources/index.md:14
msgid ""
"[crossbeam-channel](https://crates.io/crates/crossbeam-channel) - provides "
"multi-producer multi-consumer channels for message passing"
msgstr ""

#: src/resources/index.md:15
msgid "[ctrlc](https://crates.io/crates/ctrlc) - easy ctrl-c handler"
msgstr ""

#: src/resources/index.md:16
msgid ""
"[env_logger](https://crates.io/crates/env_logger) - implements a logger "
"configurable via environment variables"
msgstr ""

#: src/resources/index.md:17
msgid ""
"[exitcode](https://crates.io/crates/exitcode) - system exit code constants"
msgstr ""

#: src/resources/index.md:18
msgid ""
"[human-panic](https://crates.io/crates/human-panic) - panic message handler"
msgstr ""

#: src/resources/index.md:19
msgid ""
"[indicatif](https://crates.io/crates/indicatif) - progress bars and spinners"
msgstr ""

#: src/resources/index.md:20
msgid ""
"[log](https://crates.io/crates/log) - provides logging abstracted over "
"implementation"
msgstr ""

#: src/resources/index.md:21
msgid ""
"[predicates](https://crates.io/crates/predicates) - implements boolean-"
"valued predicate functions"
msgstr ""

#: src/resources/index.md:22
msgid ""
"[proptest](https://crates.io/crates/proptest) - property testing framework"
msgstr ""

#: src/resources/index.md:23
msgid ""
"[serde_json](https://crates.io/crates/serde_json) - serialize/deserialize to "
"JSON"
msgstr ""

#: src/resources/index.md:24
msgid ""
"[signal-hook](https://crates.io/crates/signal-hook) - handles UNIX signals"
msgstr ""

#: src/resources/index.md:25
msgid "[tokio](https://crates.io/crates/tokio) - asynchronous runtime"
msgstr ""

#: src/resources/index.md:26
msgid ""
"[wasm-pack](https://crates.io/crates/wasm-pack) - tool for building "
"WebAssembly"
msgstr ""

#: src/resources/index.md:28
msgid "Other crates"
msgstr ""

#: src/resources/index.md:30
msgid ""
"Due to the constantly-changing landscape of Rust crates, a good place to "
"find crates is the [lib.rs](https://lib.rs) crate index, including:"
msgstr ""

#: src/resources/index.md:32
msgid "[Command-line interface](https://lib.rs/command-line-interface)"
msgstr ""

#: src/resources/index.md:33
msgid "[Configuration](https://lib.rs/config)"
msgstr ""

#: src/resources/index.md:34
msgid "[Database interfaces](https://lib.rs/database)"
msgstr ""

#: src/resources/index.md:35
msgid "[Encoding](https://lib.rs/encoding)"
msgstr ""

#: src/resources/index.md:36
msgid "[Filesystem](https://lib.rs/filesystem)"
msgstr ""

#: src/resources/index.md:37
msgid "[HTTP Client](https://lib.rs/web-programming/http-client)"
msgstr ""

#: src/resources/index.md:38
msgid "[Operating systems](https://lib.rs/os)"
msgstr ""

#: src/resources/index.md:40
msgid "Other resources:"
msgstr ""

#: src/resources/index.md:41
msgid "[Rust Cookbook](https://rust-lang-nursery.github.io/rust-cookbook/)"
msgstr ""

#: src/resources/index.md:42
msgid "[rosetta-rs](https://github.com/rosetta-rs)"
msgstr ""
