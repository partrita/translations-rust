msgid ""
msgstr ""
"Project-Id-Version: The Embedded Rust Book\n"
"POT-Creation-Date: 2025-10-15T16:19:26+09:00\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"PO-Revision-Date: 2025-10-15T16:19:26+09:00\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"

#: src/SUMMARY.md:1 src/intro/no-std.md:36
msgid "Summary"
msgstr "요약"

#: src/SUMMARY.md:12 src/intro/index.md:1
msgid "Introduction"
msgstr "소개"

#: src/SUMMARY.md:13 src/SUMMARY.md:23 src/start/hardware.md:1
msgid "Hardware"
msgstr "하드웨어"

#: src/SUMMARY.md:14
msgid "`no_std`"
msgstr "`no_std`"

#: src/SUMMARY.md:15 src/intro/tooling.md:1
msgid "Tooling"
msgstr "도구"

#: src/SUMMARY.md:16
msgid "Installation"
msgstr "설치"

#: src/SUMMARY.md:17 src/intro/install/linux.md:1
msgid "Linux"
msgstr "리눅스"

#: src/SUMMARY.md:18
msgid "MacOS"
msgstr "맥OS"

#: src/SUMMARY.md:19 src/intro/install/windows.md:1
msgid "Windows"
msgstr "윈도우"

#: src/SUMMARY.md:20 src/intro/install/verify.md:1
msgid "Verify Installation"
msgstr "설치 확인"

#: src/SUMMARY.md:21
msgid "Getting started"
msgstr "시작하기"

#: src/SUMMARY.md:22 src/intro/install/windows.md:35 src/start/qemu.md:1
msgid "QEMU"
msgstr "QEMU"

#: src/SUMMARY.md:24
msgid "Memory-mapped Registers"
msgstr "메모리 매핑 레지스터"

#: src/SUMMARY.md:25 src/start/semihosting.md:1
msgid "Semihosting"
msgstr "세미호스팅"

#: src/SUMMARY.md:26 src/start/panicking.md:1
msgid "Panicking"
msgstr "패닉"

#: src/SUMMARY.md:27 src/start/exceptions.md:1
msgid "Exceptions"
msgstr "예외"

#: src/SUMMARY.md:28 src/intro/index.md:50 src/intro/index.md:64
#: src/start/interrupts.md:1
msgid "Interrupts"
msgstr "인터럽트"

#: src/SUMMARY.md:29 src/start/io.md:1
msgid "IO"
msgstr "입출력"

#: src/SUMMARY.md:30 src/peripherals/index.md:1
msgid "Peripherals"
msgstr "주변장치"

#: src/SUMMARY.md:31
msgid "A first attempt in Rust"
msgstr "Rust로 첫 번째 시도"

#: src/SUMMARY.md:32 src/peripherals/borrowck.md:13
msgid "The Borrow Checker"
msgstr "빌림 검사기"

#: src/SUMMARY.md:33 src/peripherals/singletons.md:1
msgid "Singletons"
msgstr "싱글톤"

#: src/SUMMARY.md:34 src/static-guarantees/index.md:1
msgid "Static Guarantees"
msgstr "정적 보장"

#: src/SUMMARY.md:35 src/static-guarantees/typestate-programming.md:1
msgid "Typestate Programming"
msgstr "타입 상태 프로그래밍"

#: src/SUMMARY.md:36 src/static-guarantees/state-machines.md:1
msgid "Peripherals as State Machines"
msgstr "상태 머신으로서의 주변장치"

#: src/SUMMARY.md:37 src/static-guarantees/design-contracts.md:1
msgid "Design Contracts"
msgstr "설계 계약"

#: src/SUMMARY.md:38 src/static-guarantees/zero-cost-abstractions.md:1
msgid "Zero Cost Abstractions"
msgstr "제로 비용 추상화"

#: src/SUMMARY.md:39 src/portability/index.md:1
msgid "Portability"
msgstr "이식성"

#: src/SUMMARY.md:40 src/concurrency/index.md:1
msgid "Concurrency"
msgstr "동시성"

#: src/SUMMARY.md:41 src/collections/index.md:1
msgid "Collections"
msgstr "컬렉션"

#: src/SUMMARY.md:42 src/design-patterns/index.md:1
msgid "Design Patterns"
msgstr "디자인 패턴"

#: src/SUMMARY.md:43
msgid "HALs"
msgstr "HAL"

#: src/SUMMARY.md:44
msgid "Checklist"
msgstr "체크리스트"

#: src/SUMMARY.md:45 src/design-patterns/hal/naming.md:1
msgid "Naming"
msgstr "명명"

#: src/SUMMARY.md:46 src/SUMMARY.md:51
#: src/design-patterns/hal/interoperability.md:1
#: src/interoperability/index.md:1
msgid "Interoperability"
msgstr "상호 운용성"

#: src/SUMMARY.md:47 src/design-patterns/hal/predictability.md:1
msgid "Predictability"
msgstr "예측 가능성"

#: src/SUMMARY.md:48
msgid "GPIO"
msgstr "GPIO"

#: src/SUMMARY.md:49 src/c-tips/index.md:1
msgid "Tips for embedded C developers"
msgstr "임베디드 C 개발자를 위한 팁"

#: src/SUMMARY.md:52 src/interoperability/c-with-rust.md:1
msgid "A little C with your Rust"
msgstr "Rust와 함께하는 약간의 C"

#: src/SUMMARY.md:53 src/interoperability/rust-with-c.md:1
msgid "A little Rust with your C"
msgstr "C와 함께하는 약간의 Rust"

#: src/SUMMARY.md:54 src/unsorted/index.md:1
msgid "Unsorted topics"
msgstr "미분류 주제"

#: src/SUMMARY.md:55
msgid "Optimizations: The speed size tradeoff"
msgstr "최적화: 속도와 크기의 트레이드오프"

#: src/SUMMARY.md:56
msgid "Performing Math Functionality"
msgstr "수학 기능 수행"

#: src/SUMMARY.md:60 src/appendix/glossary.md:1
msgid "Appendix A: Glossary"
msgstr "부록 A: 용어집"

#: src/intro/index.md:3
msgid ""
"Welcome to The Embedded Rust Book: An introductory book about using the Rust "
"Programming Language on \"Bare Metal\" embedded systems, such as "
"Microcontrollers."
msgstr ""
"임베디드 Rust 북에 오신 것을 환영합니다: 마이크로컨트롤러와 같은 \"베어 메탈\" "
"임베디드 시스템에서 Rust 프로그래밍 언어를 사용하는 방법에 대한 입문서입니다."
"임베디드 Rust 북에 오신 것을 환영합니다: 마이크로컨트롤러와 같은 \"베어 메탈\" "
"임베디드 시스템에서 Rust 프로그래밍 언어를 사용하는 방법에 대한 입문서입니다."
"임베디드 Rust 북에 오신 것을 환영합니다: 마이크로컨트롤러와 같은 \"베어 메탈\" "
"임베디드 시스템에서 Rust 프로그래밍 언어를 사용하는 방법에 대한 입문서입니다."

#: src/intro/index.md:6
msgid "Who Embedded Rust is For"
msgstr "임베디드 Rust는 누구를 위한 것인가"

#: src/intro/index.md:7
msgid ""
"Embedded Rust is for everyone who wants to do embedded programming while "
"taking advantage of the higher-level concepts and safety guarantees the Rust "
"language provides. (See also [Who Rust Is For](https://doc.rust-lang.org/"
"book/ch00-00-introduction.html))"
msgstr ""
"임베디드 Rust는 Rust 언어가 제공하는 고수준 개념과 안전성 보장을 활용하면서 "
"임베디드 프로그래밍을 하고자 하는 모든 사람을 위한 것입니다. ([Rust는 누구를 위한 것인가]"
"(https://doc.rust-lang.org/book/ch00-00-introduction.html)도 참조하세요)"
"임베디드 Rust는 Rust 언어가 제공하는 고수준 개념과 안전성 보장을 활용하면서 "
"임베디드 프로그래밍을 하고자 하는 모든 사람을 위한 것입니다. ([Rust는 누구를 위한 것인가]"
"(https://doc.rust-lang.org/book/ch00-00-introduction.html)도 참조하세요)"
"임베디드 Rust는 Rust 언어가 제공하는 고수준 개념과 안전성 보장을 활용하면서 "
"임베디드 프로그래밍을 하고자 하는 모든 사람을 위한 것입니다. ([Rust는 누구를 위한 것인가]"
"(https://doc.rust-lang.org/book/ch00-00-introduction.html)도 참조하세요)"

#: src/intro/index.md:10
msgid "Scope"
msgstr "범위"

#: src/intro/index.md:12
msgid "The goals of this book are:"
msgstr "이 책의 목표는 다음과 같습니다:"

#: src/intro/index.md:14
msgid ""
"Get developers up to speed with embedded Rust development. i.e. How to set "
"up a development environment."
msgstr ""
"개발자들이 임베디드 Rust 개발에 빠르게 적응할 수 있도록 돕습니다. 즉, 개발 환경을 "
"설정하는 방법을 알려줍니다."

#: src/intro/index.md:17
msgid ""
"Share _current_ best practices about using Rust for embedded development. "
"i.e. How to best use Rust language features to write more correct embedded "
"software."
msgstr ""
"임베디드 개발에서 Rust를 사용하는 _현재의_ 모범 사례를 공유합니다. 즉, Rust 언어 "
"기능을 최대한 활용하여 더 정확한 임베디드 소프트웨어를 작성하는 방법을 알려줍니다."

#: src/intro/index.md:21
msgid ""
"Serve as a cookbook in some cases. e.g. How do I mix C and Rust in a single "
"project?"
msgstr ""
"경우에 따라서는 요리책 역할을 합니다. 예를 들어, 하나의 프로젝트에서 C와 Rust를 "
"어떻게 혼합할 수 있을까요?"

#: src/intro/index.md:24
msgid ""
"This book tries to be as general as possible but to make things easier for "
"both the readers and the writers it uses the ARM Cortex-M architecture in "
"all its examples. However, the book doesn't assume that the reader is "
"familiar with this particular architecture and explains details particular "
"to this architecture where required."
msgstr ""
"이 책은 가능한 한 일반적이려고 하지만 독자와 저자 모두에게 편의를 위해 모든 예제에서 "
"ARM Cortex-M 아키텍처를 사용합니다. 하지만 이 책은 독자가 이 특정 아키텍처에 "
"익숙하다고 가정하지 않으며, 필요한 경우 이 아키텍처에 특정한 세부사항을 설명합니다."

#: src/intro/index.md:30
msgid "Who This Book is For"
msgstr "이 책은 누구를 위한 것인가"

#: src/intro/index.md:31
msgid ""
"This book caters towards people with either some embedded background or some "
"Rust background, however we believe everybody curious about embedded Rust "
"programming can get something out of this book. For those without any prior "
"knowledge we suggest you read the \"Assumptions and Prerequisites\" section "
"and catch up on missing knowledge to get more out of the book and improve "
"your reading experience. You can check out the \"Other Resources\" section "
"to find resources on topics you might want to catch up on."
msgstr ""
"이 책은 임베디드 배경이나 Rust 배경을 가진 사람들을 대상으로 하지만, 임베디드 Rust "
"프로그래밍에 관심이 있는 모든 사람이 이 책에서 무언가를 얻을 수 있다고 믿습니다. "
"사전 지식이 없는 분들은 \"가정 및 전제 조건\" 섹션을 읽고 부족한 지식을 보충하여 "
"책을 더 잘 활용하고 읽기 경험을 향상시키기를 권합니다. \"기타 자료\" 섹션에서 "
"보충하고 싶은 주제에 대한 자료를 찾을 수 있습니다."

#: src/intro/index.md:37
msgid "Assumptions and Prerequisites"
msgstr "가정 및 전제 조건"

#: src/intro/index.md:39
msgid ""
"You are comfortable using the Rust Programming Language, and have written, "
"run, and debugged Rust applications on a desktop environment. You should "
"also be familiar with the idioms of the [2018 edition](https://doc.rust-"
"lang.org/edition-guide/) as this book targets Rust 2018."
msgstr ""
"Rust 프로그래밍 언어를 편안하게 사용할 수 있고, 데스크톱 환경에서 Rust 애플리케이션을 "
"작성, 실행, 디버깅해본 경험이 있어야 합니다. 또한 이 책은 Rust 2018을 대상으로 하므로 "
"[2018 에디션](https://doc.rust-lang.org/edition-guide/)의 관용구에도 익숙해야 합니다."

#: src/intro/index.md:46
msgid ""
"You are comfortable developing and debugging embedded systems in another "
"language such as C, C++, or Ada, and are familiar with concepts such as:"
msgstr ""
"C, C++, Ada와 같은 다른 언어로 임베디드 시스템을 개발하고 디버깅하는 데 익숙하며, "
"다음과 같은 개념들에 친숙해야 합니다:"

#: src/intro/index.md:48
msgid "Cross Compilation"
msgstr "크로스 컴파일"

#: src/intro/index.md:49 src/peripherals/index.md:32
msgid "Memory Mapped Peripherals"
msgstr "메모리 매핑 주변장치"

#: src/intro/index.md:51
msgid "Common interfaces such as I2C, SPI, Serial, etc."
msgstr "I2C, SPI, 시리얼 등과 같은 일반적인 인터페이스"

#: src/intro/index.md:53 src/c-tips/index.md:410
msgid "Other Resources"
msgstr "기타 자료"

#: src/intro/index.md:54
msgid ""
"If you are unfamiliar with anything mentioned above or if you want more "
"information about a specific topic mentioned in this book you might find "
"some of these resources helpful."
msgstr ""
"위에서 언급한 내용 중 익숙하지 않은 것이 있거나 이 책에서 언급된 특정 주제에 대한 "
"더 많은 정보를 원한다면 다음 자료들이 도움이 될 것입니다."

#: src/intro/index.md:56
msgid "Topic"
msgstr "주제"

#: src/intro/index.md:56
msgid "Resource"
msgstr "자료"

#: src/intro/index.md:56 src/peripherals/a-first-attempt.md:9
msgid "Description"
msgstr "설명"

#: src/intro/index.md:58
msgid "Rust"
msgstr "Rust"

#: src/intro/index.md:58
msgid "[Rust Book](https://doc.rust-lang.org/book/)"
msgstr "[Rust 책](https://doc.rust-lang.org/book/)"

#: src/intro/index.md:58
msgid ""
"If you are not yet comfortable with Rust, we highly suggest reading this "
"book."
msgstr ""
"아직 Rust에 익숙하지 않다면, 이 책을 읽어보시기를 강력히 권합니다."

#: src/intro/index.md:59 src/intro/index.md:60 src/intro/index.md:61
#: src/intro/index.md:62 src/intro/index.md:63
msgid "Rust, Embedded"
msgstr "Rust, 임베디드"

#: src/intro/index.md:59
msgid "[Discovery Book](https://docs.rust-embedded.org/discovery/)"
msgstr "[Discovery 책](https://docs.rust-embedded.org/discovery/)"

#: src/intro/index.md:59
msgid ""
"If you have never done any embedded programming, this book might be a better "
"start"
msgstr ""
"임베디드 프로그래밍을 한 번도 해본 적이 없다면, 이 책이 더 나은 시작점이 될 수 있습니다"

#: src/intro/index.md:60
msgid "[Embedded Rust Bookshelf](https://docs.rust-embedded.org)"
msgstr "[임베디드 Rust 서재](https://docs.rust-embedded.org)"

#: src/intro/index.md:60
msgid ""
"Here you can find several other resources provided by Rust's Embedded "
"Working Group."
msgstr ""
"여기서 Rust 임베디드 워킹 그룹에서 제공하는 여러 다른 자료들을 찾을 수 있습니다."

#: src/intro/index.md:61
msgid "[Embedonomicon](https://docs.rust-embedded.org/embedonomicon/)"
msgstr "[Embedonomicon](https://docs.rust-embedded.org/embedonomicon/)"

#: src/intro/index.md:61
msgid "The nitty gritty details when doing embedded programming in Rust."
msgstr "Rust로 임베디드 프로그래밍을 할 때의 세부적인 내용들."

#: src/intro/index.md:62
msgid "[embedded FAQ](https://docs.rust-embedded.org/faq.html)"
msgstr "[임베디드 FAQ](https://docs.rust-embedded.org/faq.html)"

#: src/intro/index.md:62
msgid "Frequently asked questions about Rust in an embedded context."
msgstr "임베디드 환경에서 Rust에 대한 자주 묻는 질문들."

#: src/intro/index.md:63
msgid ""
"[Comprehensive Rust 🦀: Bare Metal](https://google.github.io/comprehensive-"
"rust/bare-metal.html)"
msgstr ""
"[포괄적인 Rust 🦀: 베어 메탈](https://google.github.io/comprehensive-"
"rust/bare-metal.html)"

#: src/intro/index.md:63
msgid "Teaching material for a 1-day class on bare-metal Rust development"
msgstr "베어 메탈 Rust 개발에 대한 1일 수업용 교육 자료"

#: src/intro/index.md:64
msgid "[Interrupt](https://en.wikipedia.org/wiki/Interrupt)"
msgstr "[인터럽트](https://en.wikipedia.org/wiki/Interrupt)"

#: src/intro/index.md:64 src/intro/index.md:65 src/intro/index.md:66
msgid "\\-"
msgstr "\\-"

#: src/intro/index.md:65
msgid "Memory-mapped IO/Peripherals"
msgstr "메모리 매핑 입출력/주변장치"

#: src/intro/index.md:65
msgid "[Memory-mapped I/O](https://en.wikipedia.org/wiki/Memory-mapped_I/O)"
msgstr "[메모리 매핑 입출력](https://en.wikipedia.org/wiki/Memory-mapped_I/O)"

#: src/intro/index.md:66
msgid "SPI, UART, RS232, USB, I2C, TTL"
msgstr "SPI, UART, RS232, USB, I2C, TTL"

#: src/intro/index.md:66
msgid ""
"[Stack Exchange about SPI, UART, and other interfaces](https://"
"electronics.stackexchange.com/questions/37814/usart-uart-rs232-usb-spi-i2c-"
"ttl-etc-what-are-all-of-these-and-how-do-th)"
msgstr ""
"[SPI, UART 및 기타 인터페이스에 대한 Stack Exchange](https://"
"electronics.stackexchange.com/questions/37814/usart-uart-rs232-usb-spi-i2c-"
"ttl-etc-what-are-all-of-these-and-how-do-th)"

#: src/intro/index.md:68
msgid "Translations"
msgstr "번역"

#: src/intro/index.md:70
msgid ""
"This book has been translated by generous volunteers. If you would like your "
"translation listed here, please open a PR to add it."
msgstr ""
"이 책은 관대한 자원봉사자들에 의해 번역되었습니다. 여러분의 번역을 여기에 "
"나열하고 싶다면 PR을 열어 추가해 주세요."

#: src/intro/index.md:73
msgid ""
"[Japanese](https://tomoyuki-nakabayashi.github.io/book/) ([repository]"
"(https://github.com/tomoyuki-nakabayashi/book))"
msgstr ""
"[일본어](https://tomoyuki-nakabayashi.github.io/book/) ([저장소]"
"(https://github.com/tomoyuki-nakabayashi/book))"

#: src/intro/index.md:76
msgid ""
"[Chinese](https://xxchang.github.io/book/) ([repository](https://github.com/"
"XxChang/book))"
msgstr ""
"[중국어](https://xxchang.github.io/book/) ([저장소](https://github.com/"
"XxChang/book))"

#: src/intro/index.md:79
msgid "How to Use This Book"
msgstr "이 책을 사용하는 방법"

#: src/intro/index.md:81
msgid ""
"This book generally assumes that you’re reading it front-to-back. Later "
"chapters build on concepts in earlier chapters, and earlier chapters may not "
"dig into details on a topic, revisiting the topic in a later chapter."
msgstr ""
"이 책은 일반적으로 처음부터 끝까지 순서대로 읽는다고 가정합니다. 후반 "
"장들은 이전 장의 개념을 기반으로 하며, 이전 장에서는 주제에 대한 세부사항을 "
"깊이 다루지 않고 후반 장에서 다시 다룰 수 있습니다."

#: src/intro/index.md:85
msgid ""
"This book will be using the [STM32F3DISCOVERY](http://www.st.com/en/"
"evaluation-tools/stm32f3discovery.html) development board from "
"STMicroelectronics for the majority of the examples contained within. This "
"board is based on the ARM Cortex-M architecture, and while basic "
"functionality is the same across most CPUs based on this architecture, "
"peripherals and other implementation details of Microcontrollers are "
"different between different vendors, and often even different between "
"Microcontroller families from the same vendor."
msgstr ""
"이 책은 포함된 대부분의 예제에서 STMicroelectronics의 "
"[STM32F3DISCOVERY](http://www.st.com/en/"
"evaluation-tools/stm32f3discovery.html) 개발 보드를 사용할 것입니다. "
"이 보드는 ARM Cortex-M 아키텍처를 기반으로 하며, 이 아키텍처를 기반으로 한 "
"대부분의 CPU에서 기본 기능은 동일하지만, 마이크로컨트롤러의 주변장치와 기타 "
"구현 세부사항은 벤더마다 다르고, 종종 같은 벤더의 마이크로컨트롤러 패밀리 간에도 다릅니다."

#: src/intro/index.md:93
msgid ""
"For this reason, we suggest purchasing the [STM32F3DISCOVERY](http://"
"www.st.com/en/evaluation-tools/stm32f3discovery.html) development board for "
"the purpose of following the examples in this book."
msgstr ""
"이러한 이유로, 이 책의 예제를 따라하기 위해 "
"[STM32F3DISCOVERY](http://www.st.com/en/evaluation-tools/stm32f3discovery.html) "
"개발 보드를 구입하시기를 권합니다."

#: src/intro/index.md:98
msgid "Contributing to This Book"
msgstr "이 책에 기여하기"

#: src/intro/index.md:100
msgid ""
"The work on this book is coordinated in [this repository](https://github.com/"
"rust-embedded/book) and is mainly developed by the [resources team](https://"
"github.com/rust-embedded/wg#the-resources-team)."
msgstr ""
"이 책의 작업은 [이 저장소](https://github.com/"
"rust-embedded/book)에서 조정되며 주로 [리소스 팀](https://"
"github.com/rust-embedded/wg#the-resources-team)에서 개발됩니다."

#: src/intro/index.md:106
msgid ""
"If you have trouble following the instructions in this book or find that "
"some section of the book is not clear enough or hard to follow then that's a "
"bug and it should be reported in [the issue tracker](https://github.com/rust-"
"embedded/book/issues/) of this book."
msgstr ""
"이 책의 지침을 따르는 데 문제가 있거나 책의 일부 섹션이 충분히 명확하지 않거나 "
"따라하기 어렵다면 그것은 버그이며 이 책의 [이슈 트래커](https://github.com/rust-"
"embedded/book/issues/)에 보고해야 합니다."

#: src/intro/index.md:112
msgid "Pull requests fixing typos and adding new content are very welcome!"
msgstr "오타를 수정하고 새로운 내용을 추가하는 풀 리퀘스트는 매우 환영합니다!"

#: src/intro/index.md:114
msgid "Re-using this material"
msgstr "이 자료 재사용하기"

#: src/intro/index.md:116
msgid "This book is distributed under the following licenses:"
msgstr "이 책은 다음 라이선스 하에 배포됩니다:"

#: src/intro/index.md:118
msgid ""
"The code samples and free-standing Cargo projects contained within this book "
"are licensed under the terms of both the [MIT License](https://"
"opensource.org/licenses/MIT) and the [Apache License v2.0](http://"
"www.apache.org/licenses/LICENSE-2.0)."
msgstr ""
"이 책에 포함된 코드 샘플과 독립적인 Cargo 프로젝트는 [MIT 라이선스](https://"
"opensource.org/licenses/MIT)와 [Apache License v2.0](http://"
"www.apache.org/licenses/LICENSE-2.0) 조건 하에 라이선스됩니다."

#: src/intro/index.md:119
msgid ""
"The written prose, pictures and diagrams contained within this book are "
"licensed under the terms of the Creative Commons [CC-BY-SA v4.0](https://"
"creativecommons.org/licenses/by-sa/4.0/legalcode) license."
msgstr ""
"이 책에 포함된 글, 그림, 다이어그램은 크리에이티브 커먼즈 [CC-BY-SA v4.0](https://"
"creativecommons.org/licenses/by-sa/4.0/legalcode) 라이선스의 조건 하에 라이선스됩니다."

#: src/intro/index.md:125
msgid "TL;DR: If you want to use our text or images in your work, you need to:"
msgstr "요약: 작업에서 우리의 텍스트나 이미지를 사용하려면 다음이 필요합니다:"

#: src/intro/index.md:127
msgid ""
"Give the appropriate credit (i.e. mention this book on your slide, and "
"provide a link to the relevant page)"
msgstr ""
"적절한 크레딧을 제공하세요 (즉, 슬라이드에 이 책을 언급하고 관련 페이지에 대한 "
"링크를 제공하세요)"

#: src/intro/index.md:128
msgid ""
"Provide a link to the [CC-BY-SA v4.0](https://creativecommons.org/licenses/"
"by-sa/4.0/legalcode) licence"
msgstr ""
"[CC-BY-SA v4.0](https://creativecommons.org/licenses/"
"by-sa/4.0/legalcode) 라이선스에 대한 링크를 제공하세요"

#: src/intro/index.md:129
msgid ""
"Indicate if you have changed the material in any way, and make any changes "
"to our material available under the same licence"
msgstr ""
"자료를 어떤 방식으로든 변경했는지 표시하고, 우리 자료에 대한 모든 변경사항을 "
"동일한 라이선스 하에 제공하세요"

#: src/intro/index.md:131
msgid "Also, please do let us know if you find this book useful!"
msgstr "또한 이 책이 유용하다고 생각하시면 알려주세요!"

#: src/intro/hardware.md:1
msgid "Meet Your Hardware"
msgstr "하드웨어 소개"

#: src/intro/hardware.md:3
msgid "Let's get familiar with the hardware we'll be working with."
msgstr "우리가 작업할 하드웨어에 익숙해져 봅시다."

#: src/intro/hardware.md:5
msgid "STM32F3DISCOVERY (the \"F3\")"
msgstr "STM32F3DISCOVERY (\"F3\")"

#: src/intro/hardware.md:11
msgid "What does this board contain?"
msgstr "이 보드에는 무엇이 포함되어 있나요?"

#: src/intro/hardware.md:13
msgid ""
"A [STM32F303VCT6](https://www.st.com/en/microcontrollers/stm32f303vc.html) "
"microcontroller. This microcontroller has"
msgstr ""
"[STM32F303VCT6](https://www.st.com/en/microcontrollers/stm32f303vc.html) "
"마이크로컨트롤러. 이 마이크로컨트롤러는 다음을 가지고 있습니다"

#: src/intro/hardware.md:14
msgid ""
"A single-core ARM Cortex-M4F processor with hardware support for single-"
"precision floating point operations and a maximum clock frequency of 72 MHz."
msgstr ""
"단정밀도 부동소수점 연산을 위한 하드웨어 지원과 최대 72MHz의 클록 주파수를 가진 "
"단일 코어 ARM Cortex-M4F 프로세서."

#: src/intro/hardware.md:17
msgid "256 KiB of \"Flash\" memory. (1 KiB = 10**24** bytes)"
msgstr "256 KiB의 \"플래시\" 메모리. (1 KiB = 10**24** 바이트)"

#: src/intro/hardware.md:19
msgid "48 KiB of RAM."
msgstr "48 KiB의 RAM."

#: src/intro/hardware.md:21
msgid "A variety of integrated peripherals such as timers, I2C, SPI and USART."
msgstr "타이머, I2C, SPI, USART와 같은 다양한 통합 주변장치."

#: src/intro/hardware.md:23
msgid ""
"General purpose Input Output (GPIO) and other types of pins accessible "
"through the two rows of headers along side the board."
msgstr ""
"보드 양쪽의 두 줄의 헤더를 통해 접근할 수 있는 범용 입출력(GPIO) 및 기타 유형의 핀."

#: src/intro/hardware.md:25
msgid "A USB interface accessible through the USB port labeled \"USB USER\"."
msgstr "\"USB USER\"라고 표시된 USB 포트를 통해 접근할 수 있는 USB 인터페이스."

#: src/intro/hardware.md:27
msgid ""
"An [accelerometer](https://en.wikipedia.org/wiki/Accelerometer) as part of "
"the [LSM303DLHC](https://www.st.com/en/mems-and-sensors/lsm303dlhc.html) "
"chip."
msgstr ""
"[LSM303DLHC](https://www.st.com/en/mems-and-sensors/lsm303dlhc.html) "
"칩의 일부인 [가속도계](https://en.wikipedia.org/wiki/Accelerometer)."

#: src/intro/hardware.md:29
msgid ""
"A [magnetometer](https://en.wikipedia.org/wiki/Magnetometer) as part of the "
"[LSM303DLHC](https://www.st.com/en/mems-and-sensors/lsm303dlhc.html) chip."
msgstr ""
"[LSM303DLHC](https://www.st.com/en/mems-and-sensors/lsm303dlhc.html) "
"칩의 일부인 [자력계](https://en.wikipedia.org/wiki/Magnetometer)."

#: src/intro/hardware.md:31
msgid ""
"A [gyroscope](https://en.wikipedia.org/wiki/Gyroscope) as part of the "
"[L3GD20](https://www.pololu.com/file/0J563/L3GD20.pdf) chip."
msgstr ""
"[L3GD20](https://www.pololu.com/file/0J563/L3GD20.pdf) "
"칩의 일부인 [자이로스코프](https://en.wikipedia.org/wiki/Gyroscope)."

#: src/intro/hardware.md:33
msgid "8 user LEDs arranged in the shape of a compass."
msgstr "나침반 모양으로 배열된 8개의 사용자 LED."

#: src/intro/hardware.md:35
msgid ""
"A second microcontroller: a [STM32F103](https://www.st.com/en/"
"microcontrollers/stm32f103cb.html). This microcontroller is actually part of "
"an on-board programmer / debugger and is connected to the USB port named "
"\"USB ST-LINK\"."
msgstr ""
"두 번째 마이크로컨트롤러: [STM32F103](https://www.st.com/en/"
"microcontrollers/stm32f103cb.html). 이 마이크로컨트롤러는 실제로 "
"온보드 프로그래머/디버거의 일부이며 \"USB ST-LINK\"라는 이름의 USB 포트에 연결되어 있습니다."

#: src/intro/hardware.md:37
msgid ""
"For a more detailed list of features and further specifications of the board "
"take a look at the [STMicroelectronics](https://www.st.com/en/evaluation-"
"tools/stm32f3discovery.html) website."
msgstr ""
"보드의 더 자세한 기능 목록과 추가 사양은 "
"[STMicroelectronics](https://www.st.com/en/evaluation-"
"tools/stm32f3discovery.html) 웹사이트를 참조하세요."

#: src/intro/hardware.md:39
msgid ""
"A word of caution: be careful if you want to apply external signals to the "
"board. The microcontroller STM32F303VCT6 pins take a nominal voltage of 3.3 "
"volts. For further information consult the [6.2 Absolute maximum ratings "
"section in the manual](https://www.st.com/resource/en/datasheet/"
"stm32f303vc.pdf)"
msgstr ""
"주의사항: 보드에 외부 신호를 적용하려는 경우 주의하세요. "
"마이크로컨트롤러 STM32F303VCT6 핀은 3.3볼트의 정격 전압을 사용합니다. "
"자세한 정보는 [매뉴얼의 6.2 절대 최대 정격 섹션](https://www.st.com/resource/en/datasheet/"
"stm32f303vc.pdf)을 참조하세요"

#: src/intro/no-std.md:1
msgid "A `no_std` Rust Environment"
msgstr "`no_std` Rust 환경"

#: src/intro/no-std.md:3
msgid ""
"The term Embedded Programming is used for a wide range of different classes "
"of programming. Ranging from programming 8-Bit MCUs (like the [ST72325xx]"
"(https://www.st.com/resource/en/datasheet/st72325j6.pdf)) with just a few KB "
"of RAM and ROM, up to systems like the Raspberry Pi ([Model B 3+](https://"
"en.wikipedia.org/wiki/Raspberry_Pi#Specifications)) which has a 32/64-bit 4-"
"core Cortex-A53 @ 1.4 GHz and 1GB of RAM. Different restrictions/limitations "
"will apply when writing code depending on what kind of target and use case "
"you have."
msgstr ""
"임베디드 프로그래밍이라는 용어는 다양한 종류의 프로그래밍 클래스에 사용됩니다. "
"몇 KB의 RAM과 ROM만을 가진 8비트 MCU([ST72325xx]"
"(https://www.st.com/resource/en/datasheet/st72325j6.pdf)와 같은) 프로그래밍부터 "
"32/64비트 4코어 Cortex-A53 @ 1.4 GHz와 1GB RAM을 가진 라즈베리 파이([Model B 3+]"
"(https://en.wikipedia.org/wiki/Raspberry_Pi#Specifications))와 같은 시스템까지 다양합니다. "
"어떤 종류의 대상과 사용 사례를 가지고 있는지에 따라 코드를 작성할 때 다른 제한사항/한계가 적용됩니다."

#: src/intro/no-std.md:10
msgid "There are two general Embedded Programming classifications:"
msgstr "임베디드 프로그래밍에는 두 가지 일반적인 분류가 있습니다:"

#: src/intro/no-std.md:12
msgid "Hosted Environments"
msgstr "호스트 환경"

#: src/intro/no-std.md:13
msgid ""
"These kinds of environments are close to a normal PC environment. What this "
"means is that you are provided with a System Interface [E.G. POSIX](https://"
"en.wikipedia.org/wiki/POSIX) that provides you with primitives to interact "
"with various systems, such as file systems, networking, memory management, "
"threads, etc. Standard libraries in turn usually depend on these primitives "
"to implement their functionality. You may also have some sort of sysroot and "
"restrictions on RAM/ROM-usage, and perhaps some special HW or I/Os. Overall "
"it feels like coding on a special-purpose PC environment."
msgstr ""
"이런 종류의 환경은 일반적인 PC 환경과 유사합니다. 이는 파일 시스템, 네트워킹, "
"메모리 관리, 스레드 등과 같은 다양한 시스템과 상호작용할 수 있는 기본 요소를 제공하는 "
"시스템 인터페이스 [예: POSIX](https://en.wikipedia.org/wiki/POSIX)가 제공된다는 의미입니다. "
"표준 라이브러리는 일반적으로 이러한 기본 요소에 의존하여 기능을 구현합니다. "
"또한 어떤 종류의 sysroot와 RAM/ROM 사용량 제한, 그리고 아마도 일부 특수 HW나 I/O가 있을 수 있습니다. "
"전반적으로 특수 목적 PC 환경에서 코딩하는 것처럼 느껴집니다."

#: src/intro/no-std.md:20
msgid "Bare Metal Environments"
msgstr "베어 메탈 환경"

#: src/intro/no-std.md:21
msgid ""
"In a bare metal environment no code has been loaded before your program. "
"Without the software provided by an OS we can not load the standard library. "
"Instead the program, along with the crates it uses, can only use the "
"hardware (bare metal) to run. To prevent rust from loading the standard "
"library use `no_std`. The platform-agnostic parts of the standard library "
"are available through [libcore](https://doc.rust-lang.org/core/). libcore "
"also excludes things which are not always desirable in an embedded "
"environment. One of these things is a memory allocator for dynamic memory "
"allocation. If you require this or any other functionalities there are often "
"crates which provide these."
msgstr ""
"베어 메탈 환경에서는 프로그램 이전에 로드된 코드가 없습니다. "
"OS에서 제공하는 소프트웨어 없이는 표준 라이브러리를 로드할 수 없습니다. "
"대신 프로그램은 사용하는 크레이트와 함께 하드웨어(베어 메탈)만을 사용하여 실행할 수 있습니다. "
"Rust가 표준 라이브러리를 로드하는 것을 방지하려면 `no_std`를 사용하세요. "
"표준 라이브러리의 플랫폼 독립적인 부분은 [libcore](https://doc.rust-lang.org/core/)를 통해 사용할 수 있습니다. "
"libcore는 또한 임베디드 환경에서 항상 바람직하지 않은 것들을 제외합니다. "
"이러한 것들 중 하나는 동적 메모리 할당을 위한 메모리 할당자입니다. "
"이것이나 다른 기능이 필요한 경우 이를 제공하는 크레이트가 종종 있습니다."

#: src/intro/no-std.md:30
msgid "The libstd Runtime"
msgstr "libstd 런타임"

#: src/intro/no-std.md:31
msgid ""
"As mentioned before using [libstd](https://doc.rust-lang.org/std/) requires "
"some sort of system integration, but this is not only because [libstd]"
"(https://doc.rust-lang.org/std/) is just providing a common way of accessing "
"OS abstractions, it also provides a runtime. This runtime, among other "
"things, takes care of setting up stack overflow protection, processing "
"command line arguments, and spawning the main thread before a program's main "
"function is invoked. This runtime also won't be available in a `no_std` "
"environment."
msgstr ""
"앞서 언급했듯이 [libstd](https://doc.rust-lang.org/std/)를 사용하려면 "
"어떤 종류의 시스템 통합이 필요하지만, 이는 [libstd](https://doc.rust-lang.org/std/)가 "
"단순히 OS 추상화에 접근하는 일반적인 방법을 제공하기 때문만이 아니라 런타임도 제공하기 때문입니다. "
"이 런타임은 무엇보다도 스택 오버플로 보호 설정, 명령줄 인수 처리, "
"프로그램의 main 함수가 호출되기 전에 메인 스레드 생성을 담당합니다. "
"이 런타임은 `no_std` 환경에서도 사용할 수 없습니다."

#: src/intro/no-std.md:37
msgid ""
"`#![no_std]` is a crate-level attribute that indicates that the crate will "
"link to the core-crate instead of the std-crate. The [libcore](https://"
"doc.rust-lang.org/core/) crate in turn is a platform-agnostic subset of the "
"std crate which makes no assumptions about the system the program will run "
"on. As such, it provides APIs for language primitives like floats, strings "
"and slices, as well as APIs that expose processor features like atomic "
"operations and SIMD instructions. However it lacks APIs for anything that "
"involves platform integration. Because of these properties no\\_std and "
"[libcore](https://doc.rust-lang.org/core/) code can be used for any kind of "
"bootstrapping (stage 0) code like bootloaders, firmware or kernels."
msgstr "`#![no_std]`는 크레이트가 std-크레이트 대신 core-크레이트에 링크될 것임을 나타내는 크레이트 수준 속성입니다. [libcore](https://doc.rust-lang.org/core/) 크레이트는 프로그램이 실행될 시스템에 대해 어떠한 가정도 하지 않는 std 크레이트의 플랫폼 독립적인 하위 집합입니다. 따라서 부동 소수점, 문자열 및 슬라이스와 같은 언어 기본 요소에 대한 API와 원자적 연산 및 SIMD 명령어와 같은 프로세서 기능을 노출하는 API를 제공합니다. 그러나 플랫폼 통합과 관련된 모든 것에 대한 API는 부족합니다. 이러한 속성 때문에 no_std 및 [libcore](https://doc.rust-lang.org/core/) 코드는 부트로더, 펌웨어 또는 커널과 같은 모든 종류의 부트스트래핑(단계 0) 코드에 사용될 수 있습니다."


#: src/intro/no-std.md:45 src/intro/tooling.md:58
msgid "Overview"
msgstr "개요"

#: src/intro/no-std.md:47
msgid "feature"
msgstr "기능"

#: src/intro/no-std.md:47
msgid "no\\_std"
msgstr "no_std"

#: src/intro/no-std.md:47
msgid "std"
msgstr "std"

#: src/intro/no-std.md:49
msgid "heap (dynamic memory)"
msgstr "힙 (동적 메모리)"

#: src/intro/no-std.md:49
msgid "\\*"
msgstr "\\*"

#: src/intro/no-std.md:49 src/intro/no-std.md:50 src/intro/no-std.md:51
#: src/intro/no-std.md:52 src/intro/no-std.md:53 src/intro/no-std.md:54
#: src/intro/no-std.md:55
msgid "✓"
msgstr ""

#: src/intro/no-std.md:50
msgid "collections (Vec, BTreeMap, etc)"
msgstr "컬렉션 (Vec, BTreeMap 등)"

#: src/intro/no-std.md:50
msgid "\\**"
msgstr "\\**"

#: src/intro/no-std.md:51
msgid "stack overflow protection"
msgstr "스택 오버플로 보호"

#: src/intro/no-std.md:51 src/intro/no-std.md:52 src/intro/no-std.md:53
#: src/intro/no-std.md:55
msgid "✘"
msgstr "✘"

#: src/intro/no-std.md:52
msgid "runs init code before main"
msgstr "main 이전에 초기화 코드 실행"

#: src/intro/no-std.md:53
msgid "libstd available"
msgstr "libstd 사용 가능"

#: src/intro/no-std.md:54
msgid "libcore available"
msgstr "libcore 사용 가능"

#: src/intro/no-std.md:55
msgid "writing firmware, kernel, or bootloader code"
msgstr "펌웨어, 커널 또는 부트로더 코드 작성"

#: src/intro/no-std.md:57
msgid ""
"\\* Only if you use the `alloc` crate and use a suitable allocator like "
"[alloc-cortex-m](https://github.com/rust-embedded/alloc-cortex-m)."
msgstr "* `alloc` 크레이트를 사용하고 [alloc-cortex-m](https://github.com/rust-embedded/alloc-cortex-m)과 같은 적절한 할당자를 사용하는 경우에만 해당됩니다."

#: src/intro/no-std.md:59
msgid ""
"\\*\\* Only if you use the `collections` crate and configure a global "
"default allocator."
msgstr "** `collections` 크레이트를 사용하고 전역 기본 할당자를 구성하는 경우에만 해당됩니다."

#: src/intro/no-std.md:61
msgid ""
"\\*\\* HashMap and HashSet are not available due to a lack of a secure "
"random number generator."
msgstr "** 안전한 난수 생성기가 부족하여 HashMap 및 HashSet을 사용할 수 없습니다."

#: src/intro/no-std.md:65
msgid "See Also"
msgstr "참조"

#: src/intro/no-std.md:66
msgid ""
"[RFC-1184](https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-"
"no_std.md)"
msgstr "[RFC-1184](https://github.com/rust-lang/rfcs/blob/master/text/1184-stabilize-no_std.md)"

#: src/intro/tooling.md:3
msgid ""
"Dealing with microcontrollers involves using several different tools as "
"we'll be dealing with an architecture different than your laptop's and we'll "
"have to run and debug programs on a _remote_ device."
msgstr "마이크로컨트롤러를 다루는 것은 여러 가지 다른 도구를 사용하는 것을 포함합니다. 이는 노트북과는 다른 아키텍처를 다루고 _원격_ 장치에서 프로그램을 실행하고 디버깅해야 하기 때문입니다."

#: src/intro/tooling.md:7
msgid ""
"We'll use all the tools listed below. Any recent version should work when a "
"minimum version is not specified, but we have listed the versions we have "
"tested."
msgstr "아래 나열된 모든 도구를 사용할 것입니다. 최소 버전이 지정되지 않은 경우 최신 버전은 모두 작동해야 하지만, 저희가 테스트한 버전을 나열했습니다."

#: src/intro/tooling.md:11
msgid ""
"Rust 1.31, 1.31-beta, or a newer toolchain PLUS ARM Cortex-M compilation "
"support."
msgstr "Rust 1.31, 1.31-beta 또는 더 새로운 툴체인 + ARM Cortex-M 컴파일 지원."

#: src/intro/tooling.md:13
msgid ""
"[`cargo-binutils`](https://github.com/rust-embedded/cargo-binutils) ~0.1.4"
msgstr "[`cargo-binutils`](https://github.com/rust-embedded/cargo-binutils) ~0.1.4"

#: src/intro/tooling.md:14
msgid "[`qemu-system-arm`](https://www.qemu.org/). Tested versions: 3.0.0"
msgstr "[`qemu-system-arm`](https://www.qemu.org/). 테스트 버전: 3.0.0"

#: src/intro/tooling.md:15
msgid "OpenOCD >=0.8. Tested versions: v0.9.0 and v0.10.0"
msgstr "OpenOCD >=0.8. 테스트 버전: v0.9.0 및 v0.10.0"

#: src/intro/tooling.md:16
msgid ""
"GDB with ARM support. Version 7.12 or newer highly recommended. Tested "
"versions: 7.10, 7.11, 7.12 and 8.1"
msgstr "ARM 지원 GDB. 버전 7.12 이상을 강력히 권장합니다. 테스트 버전: 7.10, 7.11, 7.12 및 8.1"

#: src/intro/tooling.md:18
msgid ""
"[`cargo-generate`](https://github.com/ashleygwilliams/cargo-generate) or "
"`git`. These tools are optional but will make it easier to follow along with "
"the book."
msgstr "[`cargo-generate`](https://github.com/ashleygwilliams/cargo-generate) 또는 `git`. 이 도구들은 선택 사항이지만 책을 따라하기 쉽게 해줄 것입니다."

#: src/intro/tooling.md:21
msgid ""
"The text below explains why we are using these tools. Installation "
"instructions can be found on the next page."
msgstr "아래 텍스트는 이러한 도구를 사용하는 이유를 설명합니다. 설치 지침은 다음 페이지에서 찾을 수 있습니다."

#: src/intro/tooling.md:24
msgid "`cargo-generate` OR `git`"
msgstr "`cargo-generate` 또는 `git`"

#: src/intro/tooling.md:26
msgid ""
"Bare metal programs are non-standard (`no_std`) Rust programs that require "
"some adjustments to the linking process in order to get the memory layout of "
"the program right. This requires some additional files (like linker scripts) "
"and settings (like linker flags). We have packaged those for you in a "
"template such that you only need to fill in the missing information (such as "
"the project name and the characteristics of your target hardware)."
msgstr "베어 메탈 프로그램은 프로그램의 메모리 레이아웃을 올바르게 얻기 위해 링크 프로세스에 일부 조정이 필요한 비표준(`no_std`) Rust 프로그램입니다. 이를 위해서는 일부 추가 파일(링커 스크립트 등) 및 설정(링커 플래그 등)이 필요합니다. 저희는 이러한 것들을 템플릿으로 패키징하여 프로젝트 이름 및 대상 하드웨어의 특성과 같은 누락된 정보만 채우면 됩니다."

#: src/intro/tooling.md:33
msgid ""
"Our template is compatible with `cargo-generate`: a Cargo subcommand for "
"creating new Cargo projects from templates. You can also download the "
"template using `git`, `curl`, `wget`, or your web browser."
msgstr "저희 템플릿은 템플릿에서 새 Cargo 프로젝트를 생성하기 위한 Cargo 하위 명령인 `cargo-generate`와 호환됩니다. `git`, `curl`, `wget` 또는 웹 브라우저를 사용하여 템플릿을 다운로드할 수도 있습니다."

#: src/intro/tooling.md:37 src/intro/install.md:59
msgid "`cargo-binutils`"
msgstr "`cargo-binutils`"

#: src/intro/tooling.md:39
msgid ""
"`cargo-binutils` is a collection of Cargo subcommands that make it easy to "
"use the LLVM tools that are shipped with the Rust toolchain. These tools "
"include the LLVM versions of `objdump`, `nm` and `size` and are used for "
"inspecting binaries."
msgstr "`cargo-binutils`는 Rust 툴체인과 함께 제공되는 LLVM 도구를 쉽게 사용할 수 있도록 하는 Cargo 하위 명령 모음입니다. 이 도구에는 `objdump`, `nm`, `size`의 LLVM 버전이 포함되어 있으며 바이너리를 검사하는 데 사용됩니다."

#: src/intro/tooling.md:44
msgid ""
"The advantage of using these tools over GNU binutils is that (a) installing "
"the LLVM tools is the same one-command installation (`rustup component add "
"llvm-tools`) regardless of your OS and (b) tools like `objdump` support all "
"the architectures that `rustc` supports -- from ARM to x86_64 -- because "
"they both share the same LLVM backend."
msgstr "GNU binutils 대신 이 도구를 사용하는 장점은 (a) LLVM 도구 설치가 OS에 관계없이 동일한 단일 명령 설치(`rustup component add llvm-tools`)이며 (b) `objdump`와 같은 도구는 ARM에서 x86_64까지 `rustc`가 지원하는 모든 아키텍처를 지원한다는 것입니다. 이는 둘 다 동일한 LLVM 백엔드를 공유하기 때문입니다."

#: src/intro/tooling.md:50
msgid "`qemu-system-arm`"
msgstr "`qemu-system-arm`"

#: src/intro/tooling.md:52
msgid ""
"QEMU is an emulator. In this case we use the variant that can fully emulate "
"ARM systems. We use QEMU to run embedded programs on the host. Thanks to "
"this you can follow some parts of this book even if you don't have any "
"hardware with you!"
msgstr "QEMU는 에뮬레이터입니다. 이 경우 ARM 시스템을 완전히 에뮬레이션할 수 있는 변형을 사용합니다. QEMU를 사용하여 호스트에서 임베디드 프로그램을 실행합니다. 덕분에 하드웨어가 없어도 이 책의 일부를 따라할 수 있습니다!"

#: src/intro/tooling.md:56
msgid "Tooling for Embedded Rust Debugging"
msgstr "임베디드 Rust 디버깅을 위한 도구"

#: src/intro/tooling.md:60
msgid ""
"Debugging embedded systems in Rust requires specialized tools including "
"software to manage the debugging process, debuggers to inspect and control "
"program execution, and hardware probes to facilitate interaction between the "
"host and the embedded device. This document outlines essential software "
"tools like Probe-rs and OpenOCD, which simplify and support the debugging "
"process, alongside prominent debuggers such as GDB and the Probe-rs Visual "
"Studio Code extension. Additionally, it covers key hardware probes such as "
"Rusty-probe, ST-Link, J-Link, and MCU-Link, which are integral for effective "
"debugging and programming of embedded devices."
msgstr "Rust에서 임베디드 시스템을 디버깅하려면 디버깅 프로세스를 관리하는 소프트웨어, 프로그램 실행을 검사하고 제어하는 디버거, 호스트와 임베디드 장치 간의 상호 작용을 용이하게 하는 하드웨어 프로브를 포함한 전문 도구가 필요합니다. 이 문서는 디버깅 프로세스를 단순화하고 지원하는 Probe-rs 및 OpenOCD와 같은 필수 소프트웨어 도구와 GDB 및 Probe-rs Visual Studio Code 확장과 같은 주요 디버거를 설명합니다. 또한 Rusty-probe, ST-Link, J-Link 및 MCU-Link와 같은 주요 하드웨어 프로브를 다루며, 이는 임베디드 장치의 효과적인 디버깅 및 프로그래밍에 필수적입니다."

#: src/intro/tooling.md:62
msgid "Software that drives debugging tools"
msgstr "디버깅 도구를 구동하는 소프트웨어"

#: src/intro/tooling.md:64
msgid "Probe-rs"
msgstr "Probe-rs"

#: src/intro/tooling.md:66
msgid ""
"Probe-rs is a modern, Rust-focused software designed to work with debuggers "
"in embedded systems. Unlike OpenOCD, Probe-rs is built with simplicity in "
"mind and aims to reduce the configuration burden often found in other "
"debugging solutions. It supports various probes and targets, providing a "
"high-level interface for interacting with embedded hardware. Probe-rs "
"integrates directly with Rust tooling, and integrates with Visual Studio "
"Code through its extension, allowing developers to streamline their "
"debugging workflow."
msgstr "Probe-rs는 임베디드 시스템의 디버거와 함께 작동하도록 설계된 현대적인 Rust 중심 소프트웨어입니다. OpenOCD와 달리 Probe-rs는 단순성을 염두에 두고 구축되었으며 다른 디버깅 솔루션에서 흔히 볼 수 있는 구성 부담을 줄이는 것을 목표로 합니다. 다양한 프로브와 타겟을 지원하며 임베디드 하드웨어와 상호 작용하기 위한 고수준 인터페이스를 제공합니다. Probe-rs는 Rust 툴링과 직접 통합되며 확장을 통해 Visual Studio Code와 통합되어 개발자가 디버깅 워크플로를 간소화할 수 있습니다."

#: src/intro/tooling.md:69
msgid "OpenOCD (Open On-Chip Debugger)"
msgstr "OpenOCD (오픈 온칩 디버거)"

#: src/intro/tooling.md:71
msgid ""
"OpenOCD is an open-source software tool used for debugging, testing, and "
"programming embedded systems. It provides an interface between the host "
"system and embedded hardware, supporting various transport layers like JTAG "
"and SWD (Serial Wire Debug). OpenOCD integrates with GDB, which is a "
"debugger. OpenOCD is widely supported, with extensive documentation and a "
"large community, but may require complex configuration, especially for "
"custom embedded setups."
msgstr "OpenOCD는 임베디드 시스템 디버깅, 테스트 및 프로그래밍에 사용되는 오픈 소스 소프트웨어 도구입니다. 호스트 시스템과 임베디드 하드웨어 간의 인터페이스를 제공하며 JTAG 및 SWD(Serial Wire Debug)와 같은 다양한 전송 계층을 지원합니다. OpenOCD는 디버거인 GDB와 통합됩니다. OpenOCD는 광범위한 문서와 대규모 커뮤니티를 통해 널리 지원되지만, 특히 사용자 정의 임베디드 설정의 경우 복잡한 구성이 필요할 수 있습니다."

#: src/intro/tooling.md:73
msgid "Debuggers"
msgstr "디버거"

#: src/intro/tooling.md:75
msgid ""
"A debugger allows developers to inspect and control the execution of a "
"program in order to identify and correct errors or bugs. It provides "
"functionalities such as setting breakpoints, stepping through code line by "
"line, and examining the values of variables and memory states. Debuggers are "
"essential for thorough software development and maintenance, enabling "
"developers to ensure that their code behaves as intended under various "
"conditions."
msgstr "디버거는 개발자가 오류나 버그를 식별하고 수정하기 위해 프로그램 실행을 검사하고 제어할 수 있도록 합니다. 중단점 설정, 코드 한 줄씩 실행, 변수 값 및 메모리 상태 검사와 같은 기능을 제공합니다. 디버거는 철저한 소프트웨어 개발 및 유지 관리에 필수적이며, 개발자가 다양한 조건에서 코드가 의도한 대로 작동하는지 확인할 수 있도록 합니다."

#: src/intro/tooling.md:77
msgid "Debuggers know how to:"
msgstr "디버거는 다음을 수행하는 방법을 알고 있습니다:"

#: src/intro/tooling.md:78
msgid "Interact with the memory mapped registers."
msgstr "메모리 매핑 레지스터와 상호 작용합니다."

#: src/intro/tooling.md:79
msgid "Set Breakpoints/Watchpoints."
msgstr "중단점/감시점 설정."

#: src/intro/tooling.md:80
msgid "Read and write to the memory mapped registers."
msgstr "메모리 매핑 레지스터를 읽고 씁니다."

#: src/intro/tooling.md:81
msgid "Detect when the MCU has been halted for a debug event."
msgstr "디버그 이벤트로 인해 MCU가 중단되었을 때 감지합니다."

#: src/intro/tooling.md:82
msgid "Continue MCU execution after a debug event has been encountered."
msgstr "디버그 이벤트가 발생한 후 MCU 실행을 계속합니다."

#: src/intro/tooling.md:83
msgid "Erase and write to the microcontroller's FLASH."
msgstr "마이크로컨트롤러의 FLASH를 지우고 씁니다."

#: src/intro/tooling.md:85
msgid "Probe-rs Visual Studio Code Extension"
msgstr "Probe-rs Visual Studio Code 확장"

#: src/intro/tooling.md:87
msgid ""
"Probe-rs has a Visual Studio Code extension, providing a seamless debugging "
"experience without extensive setup. Through this connection, developers can "
"use Rust-specific features like pretty printing and detailed error messages, "
"ensuring that their debugging process aligns with the Rust ecosystem."
msgstr "Probe-rs는 Visual Studio Code 확장을 제공하여 광범위한 설정 없이 원활한 디버깅 경험을 제공합니다. 이 연결을 통해 개발자는 예쁜 출력 및 자세한 오류 메시지와 같은 Rust 특정 기능을 사용하여 디버깅 프로세스가 Rust 생태계와 일치하도록 할 수 있습니다."

#: src/intro/tooling.md:89
msgid "GDB (GNU Debugger)"
msgstr "GDB (GNU 디버거)"

#: src/intro/tooling.md:91
msgid ""
"GDB is a versatile debugging tool that allows developers to examine the "
"state of programs while they run or after they crash. For embedded Rust, GDB "
"connects to the target system via OpenOCD or other debugging servers to "
"interact with the embedded code. GDB is highly configurable and supports "
"features like remote debugging, variable inspection, and conditional "
"breakpoints. It can be used on a variety of platforms, and has extensive "
"support for Rust-specific debugging needs, such as pretty printing and "
"integration with IDEs."
msgstr "GDB는 개발자가 프로그램 실행 중 또는 충돌 후 프로그램 상태를 검사할 수 있도록 하는 다목적 디버깅 도구입니다. 임베디드 Rust의 경우 GDB는 OpenOCD 또는 다른 디버깅 서버를 통해 대상 시스템에 연결하여 임베디드 코드와 상호 작용합니다. GDB는 고도로 구성 가능하며 원격 디버깅, 변수 검사 및 조건부 중단점과 같은 기능을 지원합니다. 다양한 플랫폼에서 사용할 수 있으며 예쁜 출력 및 IDE 통합과 같은 Rust 특정 디버깅 요구 사항에 대한 광범위한 지원을 제공합니다."

#: src/intro/tooling.md:94
msgid "Probes"
msgstr "프로브"

#: src/intro/tooling.md:96
msgid ""
"A hardware probe is a device used in the development and debugging of "
"embedded systems to facilitate communication between a host computer and the "
"target embedded device. It typically supports protocols like JTAG or SWD, "
"enabling it to program, debug, and analyze the microcontroller or "
"microprocessor on the embedded system. Hardware probes are crucial for "
"developers to set breakpoints, step through code, and inspect memory and "
"processor registers, effectively allowing them to diagnose and fix issues in "
"real-time."
msgstr "하드웨어 프로브는 호스트 컴퓨터와 대상 임베디드 장치 간의 통신을 용이하게 하기 위해 임베디드 시스템 개발 및 디버깅에 사용되는 장치입니다. 일반적으로 JTAG 또는 SWD와 같은 프로토콜을 지원하여 임베디드 시스템의 마이크로컨트롤러 또는 마이크로프로세서를 프로그래밍, 디버깅 및 분석할 수 있습니다. 하드웨어 프로브는 개발자가 중단점을 설정하고, 코드를 단계별로 실행하고, 메모리 및 프로세서 레지스터를 검사하여 실시간으로 문제를 진단하고 해결할 수 있도록 하는 데 중요합니다."

#: src/intro/tooling.md:98
msgid "Rusty-probe"
msgstr "Rusty-probe"

#: src/intro/tooling.md:100
msgid ""
"Rusty-probe is an open-sourced USB-based hardware debugging probe designed "
"to work with probe-rs. The combination of Rusty-Probe and probe-rs provides "
"an easy-to-use, cost-effective solution for developers working with embedded "
"Rust applications."
msgstr "Rusty-probe는 probe-rs와 함께 작동하도록 설계된 오픈 소스 USB 기반 하드웨어 디버깅 프로브입니다. Rusty-Probe와 probe-rs의 조합은 임베디드 Rust 애플리케이션을 개발하는 개발자를 위한 사용하기 쉽고 비용 효율적인 솔루션을 제공합니다."

#: src/intro/tooling.md:102
msgid "ST-Link"
msgstr "ST-Link"

#: src/intro/tooling.md:104
msgid ""
"The ST-Link is a popular debugging and programming probe developed by "
"STMicroelectronics primarily for their STM32 and STM8 microcontroller "
"series. It supports both debugging and programming via JTAG or SWD (Serial "
"Wire Debug) interfaces. ST-Link is widely used due to its direct support "
"from STMicroelectronics' extensive range of development boards and its "
"integration into major IDEs, making it a convenient choice for developers "
"working with STM microcontrollers."
msgstr "ST-Link는 STMicroelectronics에서 주로 STM32 및 STM8 마이크로컨트롤러 시리즈를 위해 개발한 인기 있는 디버깅 및 프로그래밍 프로브입니다. JTAG 또는 SWD(Serial Wire Debug) 인터페이스를 통해 디버깅 및 프로그래밍을 모두 지원합니다. ST-Link는 STMicroelectronics의 광범위한 개발 보드에서 직접 지원하고 주요 IDE에 통합되어 STM 마이크로컨트롤러를 사용하는 개발자에게 편리한 선택이므로 널리 사용됩니다."

#: src/intro/tooling.md:106
msgid "J-Link"
msgstr "J-Link"

#: src/intro/tooling.md:108
msgid ""
"J-Link, developed by SEGGER Microcontroller, is a robust and versatile "
"debugger supporting a wide range of CPU cores and devices beyond just ARM, "
"such as RISC-V. Known for its high performance and reliability, J-Link "
"supports various communication interfaces, including JTAG, SWD, and fine-"
"pitch JTAG interfaces. It is favored for its advanced features like "
"unlimited breakpoints in flash memory and its compatibility with a multitude "
"of development environments."
msgstr "SEGGER Microcontroller에서 개발한 J-Link는 RISC-V와 같은 ARM 외에도 광범위한 CPU 코어 및 장치를 지원하는 강력하고 다재다능한 디버거입니다. 고성능과 신뢰성으로 유명한 J-Link는 JTAG, SWD 및 미세 피치 JTAG 인터페이스를 포함한 다양한 통신 인터페이스를 지원합니다. 플래시 메모리의 무제한 중단점과 다양한 개발 환경과의 호환성과 같은 고급 기능으로 선호됩니다."

#: src/intro/tooling.md:110
msgid "MCU-Link"
msgstr "MCU-Link"

#: src/intro/tooling.md:112
msgid ""
"MCU-Link is a debugging probe that also functions as a programmer, provided "
"by NXP Semiconductors. It supports a variety of ARM Cortex microcontrollers "
"and interfaces seamlessly with development tools like MCUXpresso IDE. MCU-"
"Link is particularly notable for its versatility and affordability, making "
"it an accessible option for hobbyists, educators, and professional "
"developers alike."
msgstr "MCU-Link는 NXP Semiconductors에서 제공하는 프로그래머 역할도 하는 디버깅 프로브입니다. 다양한 ARM Cortex 마이크로컨트롤러를 지원하며 MCUXpresso IDE와 같은 개발 도구와 원활하게 인터페이스합니다. MCU-Link는 특히 다용도성과 경제성으로 유명하여 취미 개발자, 교육자 및 전문 개발자 모두에게 접근 가능한 옵션입니다."

#: src/intro/install.md:1
msgid "Installing the tools"
msgstr "도구 설치"

#: src/intro/install.md:3
msgid ""
"This page contains OS-agnostic installation instructions for a few of the "
"tools:"
msgstr "이 페이지에는 몇 가지 도구에 대한 OS 독립적인 설치 지침이 포함되어 있습니다:"

#: src/intro/install.md:5
msgid "Rust Toolchain"
msgstr "Rust 툴체인"

#: src/intro/install.md:7
msgid ""
"Install rustup by following the instructions at [https://rustup.rs](https://"
"rustup.rs)."
msgstr "[https://rustup.rs](https://rustup.rs)의 지침에 따라 rustup을 설치하세요."

#: src/intro/install.md:9
msgid ""
"**NOTE** Make sure you have a compiler version equal to or newer than "
"`1.31`. `rustc -V` should return a date newer than the one shown below."
msgstr "**참고** 컴파일러 버전이 `1.31` 이상인지 확인하세요. `rustc -V`는 아래 표시된 날짜보다 최신 날짜를 반환해야 합니다."

#: src/intro/install.md:17
msgid ""
"For bandwidth and disk usage concerns the default installation only supports "
"native compilation. To add cross compilation support for the ARM Cortex-M "
"architectures choose one of the following compilation targets. For the "
"STM32F3DISCOVERY board used for the examples in this book, use the "
"`thumbv7em-none-eabihf` target. [Find the best Cortex-M for you.](https://"
"developer.arm.com/ip-products/processors/cortex-"
"m#c-7d3b69ce-5b17-4c9e-8f06-59b605713133)"
msgstr "대역폭 및 디스크 사용량 문제로 인해 기본 설치는 네이티브 컴파일만 지원합니다. ARM Cortex-M 아키텍처에 대한 크로스 컴파일 지원을 추가하려면 다음 컴파일 대상 중 하나를 선택하세요. 이 책의 예제에 사용된 STM32F3DISCOVERY 보드의 경우 `thumbv7em-none-eabihf` 대상을 사용하세요. [자신에게 가장 적합한 Cortex-M을 찾으세요.](https://developer.arm.com/ip-products/processors/cortex-m#c-7d3b69ce-5b17-4c9e-8f06-59b605713133)"

#: src/intro/install.md:23
msgid "Cortex-M0, M0+, and M1 (ARMv6-M architecture):"
msgstr "Cortex-M0, M0+, M1 (ARMv6-M 아키텍처):"

#: src/intro/install.md:28
msgid "Cortex-M3 (ARMv7-M architecture):"
msgstr "Cortex-M3 (ARMv7-M 아키텍처):"

#: src/intro/install.md:33
msgid ""
"Cortex-M4 and M7 without hardware floating point (ARMv7E-M architecture):"
msgstr "하드웨어 부동 소수점 없는 Cortex-M4 및 M7 (ARMv7E-M 아키텍처):"

#: src/intro/install.md:38
msgid ""
"Cortex-M4F and M7F with hardware floating point (ARMv7E-M architecture):"
msgstr "하드웨어 부동 소수점 있는 Cortex-M4F 및 M7F (ARMv7E-M 아키텍처):"

#: src/intro/install.md:43
msgid "Cortex-M23 (ARMv8-M architecture):"
msgstr "Cortex-M23 (ARMv8-M 아키텍처):"

#: src/intro/install.md:48
msgid "Cortex-M33 and M35P (ARMv8-M architecture):"
msgstr "Cortex-M33 및 M35P (ARMv8-M 아키텍처):"

#: src/intro/install.md:53
msgid ""
"Cortex-M33F and M35PF with hardware floating point (ARMv8-M architecture):"
msgstr "하드웨어 부동 소수점 있는 Cortex-M33F 및 M35PF (ARMv8-M 아키텍처):"

#: src/intro/install.md:66
msgid ""
"WINDOWS: prerequisite C++ Build Tools for Visual Studio 2019 is installed. "
"https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?"
"sku=BuildTools&rel=16"
msgstr "WINDOWS: Visual Studio 2019용 C++ 빌드 도구 필수 구성 요소가 설치되어 있습니다. https://visualstudio.microsoft.com/thank-you-downloading-visual-studio/?sku=BuildTools&rel=16"

#: src/intro/install.md:67
msgid "`cargo-generate`"
msgstr "`cargo-generate`"

#: src/intro/install.md:69
msgid "We'll use this later to generate a project from a template."
msgstr "나중에 템플릿에서 프로젝트를 생성하는 데 사용할 것입니다."

#: src/intro/install.md:75
msgid ""
"Note: on some Linux distros (e.g. Ubuntu) you may need to install the "
"packages `libssl-dev` and `pkg-config` prior to installing cargo-generate."
msgstr "참고: 일부 Linux 배포판(예: Ubuntu)에서는 cargo-generate를 설치하기 전에 `libssl-dev` 및 `pkg-config` 패키지를 설치해야 할 수 있습니다."

#: src/intro/install.md:77
msgid "OS-Specific Instructions"
msgstr "OS별 지침"

#: src/intro/install.md:79
msgid "Now follow the instructions specific to the OS you are using:"
msgstr "이제 사용 중인 OS에 특정한 지침을 따르세요:"

#: src/intro/install.md:81
msgid "[Linux](install/linux.md)"
msgstr "[리눅스](install/linux.md)"

#: src/intro/install.md:82
msgid "[Windows](install/windows.md)"
msgstr "[윈도우](install/windows.md)"

#: src/intro/install.md:83
msgid "[macOS](install/macos.md)"
msgstr "[macOS](install/macos.md)"

#: src/intro/install/linux.md:3
msgid "Here are the installation commands for a few Linux distributions."
msgstr "다음은 몇 가지 Linux 배포판에 대한 설치 명령어입니다."

#: src/intro/install/linux.md:5
msgid "Packages"
msgstr "패키지"

#: src/intro/install/linux.md:7
msgid "Ubuntu 18.04 or newer / Debian stretch or newer"
msgstr "Ubuntu 18.04 이상 / Debian stretch 이상"

#: src/intro/install/linux.md:9
msgid ""
"**NOTE** `gdb-multiarch` is the GDB command you'll use to debug your ARM "
"Cortex-M programs"
msgstr "**참고** `gdb-multiarch`는 ARM Cortex-M 프로그램을 디버깅하는 데 사용할 GDB 명령어입니다."

#: src/intro/install/linux.md:26
msgid "Ubuntu 14.04 and 16.04"
msgstr "Ubuntu 14.04 및 16.04"

#: src/intro/install/linux.md:28
msgid ""
"**NOTE** `arm-none-eabi-gdb` is the GDB command you'll use to debug your ARM "
"Cortex-M programs"
msgstr "**참고** `arm-none-eabi-gdb`는 ARM Cortex-M 프로그램을 디버깅하는 데 사용할 GDB 명령어입니다."

#: src/intro/install/linux.md:40
msgid "Fedora 27 or newer"
msgstr "Fedora 27 이상"

#: src/intro/install/linux.md:51
msgid "Arch Linux"
msgstr "Arch Linux"

#: src/intro/install/linux.md:53
msgid ""
"**NOTE** `arm-none-eabi-gdb` is the GDB command you'll use to debug ARM "
"Cortex-M programs"
msgstr "**참고** `arm-none-eabi-gdb`는 ARM Cortex-M 프로그램을 디버깅하는 데 사용할 GDB 명령어입니다."

#: src/intro/install/linux.md:60
msgid "udev rules"
msgstr "udev 규칙"

#: src/intro/install/linux.md:62
msgid ""
"This rule lets you use OpenOCD with the Discovery board without root "
"privilege."
msgstr "이 규칙을 사용하면 루트 권한 없이 Discovery 보드와 함께 OpenOCD를 사용할 수 있습니다."

#: src/intro/install/linux.md:64
msgid ""
"Create the file `/etc/udev/rules.d/70-st-link.rules` with the contents shown "
"below."
msgstr "아래에 표시된 내용으로 `/etc/udev/rules.d/70-st-link.rules` 파일을 생성하세요."

#: src/intro/install/linux.md:66
msgid ""
"```text\n"
"# STM32F3DISCOVERY rev A/B - ST-LINK/V2\n"
"ATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"3748\", TAG+=\"uaccess\"\n"
"\n"
"# STM32F3DISCOVERY rev C+ - ST-LINK/V2-1\n"
"ATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"374b\", TAG+=\"uaccess\"\n"
"```"
msgstr "```text\n# STM32F3DISCOVERY rev A/B - ST-LINK/V2\nATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"3748\", TAG+=\"uaccess\"\n\n# STM32F3DISCOVERY rev C+ - ST-LINK/V2-1\nATTRS{idVendor}==\"0483\", ATTRS{idProduct}==\"374b\", TAG+=\"uaccess\"\n```"

#: src/intro/install/linux.md:74
msgid "Then reload all the udev rules with:"
msgstr "그런 다음 다음 명령으로 모든 udev 규칙을 다시 로드하세요:"

#: src/intro/install/linux.md:80
msgid ""
"If you had the board plugged to your laptop, unplug it and then plug it "
"again."
msgstr "보드가 노트북에 연결되어 있었다면, 플러그를 뽑았다가 다시 연결하세요."

#: src/intro/install/linux.md:82
msgid "You can check the permissions by running this command:"
msgstr "이 명령을 실행하여 권한을 확인할 수 있습니다:"

#: src/intro/install/linux.md:88
msgid "Which should show something like"
msgstr "다음과 같이 표시되어야 합니다."

#: src/intro/install/linux.md:96
msgid ""
"Take note of the bus and device numbers. Use those numbers to create a path "
"like `/dev/bus/usb/<bus>/<device>`. Then use this path like so:"
msgstr "버스 및 장치 번호를 기록해 두세요. 이 번호를 사용하여 `/dev/bus/usb/<bus>/<device>`와 같은 경로를 생성하세요. 그런 다음 이 경로를 다음과 같이 사용하세요:"

#: src/intro/install/linux.md:116
msgid ""
"The `+` appended to permissions indicates the existence of an extended "
"permission. The `getfacl` command tells the user `you` can make use of this "
"device."
msgstr "권한에 추가된 `+`는 확장 권한의 존재를 나타냅니다. `getfacl` 명령은 사용자 `당신`이 이 장치를 사용할 수 있음을 알려줍니다."

#: src/intro/install/linux.md:120
msgid "Now, go to the [next section](verify.md)."
msgstr "이제 [다음 섹션](verify.md)으로 이동하세요."

#: src/intro/install/macos.md:1
msgid "macOS"
msgstr "macOS"

#: src/intro/install/macos.md:3
msgid ""
"All the tools can be installed using [Homebrew](http://brew.sh/) or "
"[MacPorts](https://www.macports.org/):"
msgstr "모든 도구는 [Homebrew](http://brew.sh/) 또는 [MacPorts](https://www.macports.org/)를 사용하여 설치할 수 있습니다:"

#: src/intro/install/macos.md:8
msgid "Install tools with [Homebrew](http://brew.sh/)"
msgstr "[Homebrew](http://brew.sh/)로 도구 설치"

#: src/intro/install/macos.md:21
msgid ""
"**NOTE** If OpenOCD crashes you may need to install the latest version using:"
msgstr "**참고** OpenOCD가 충돌하면 다음을 사용하여 최신 버전을 설치해야 할 수 있습니다:"

#: src/intro/install/macos.md:26
msgid "Install tools with [MacPorts](https://www.macports.org/)"
msgstr "[MacPorts](https://www.macports.org/)로 도구 설치"

#: src/intro/install/macos.md:41 src/intro/install/windows.md:48
msgid "That's all! Go to the [next section](verify.md)."
msgstr "그게 다입니다! [다음 섹션](verify.md)으로 이동하세요."

#: src/intro/install/windows.md:3
msgid "`arm-none-eabi-gdb`"
msgstr "`arm-none-eabi-gdb`"

#: src/intro/install/windows.md:5
msgid ""
"ARM provides `.exe` installers for Windows. Grab one from [here](https://"
"developer.arm.com/downloads/-/arm-gnu-toolchain-downloads), and follow the "
"instructions. Just before the installation process finishes tick/select the "
"\"Add path to environment variable\" option. Then verify that the tools are "
"in your `%PATH%`:"
msgstr "ARM은 Windows용 `.exe` 설치 프로그램을 제공합니다. [여기](https://developer.arm.com/downloads/-/arm-gnu-toolchain-downloads)에서 다운로드하여 지침을 따르세요. 설치 프로세스가 끝나기 직전에 "환경 변수에 경로 추가" 옵션을 선택/체크하세요. 그런 다음 도구가 `%PATH%`에 있는지 확인하세요:"

#: src/intro/install/windows.md:17
msgid "OpenOCD"
msgstr "OpenOCD"

#: src/intro/install/windows.md:19
msgid ""
"There's no official binary release of OpenOCD for Windows but if you're not "
"in the mood to compile it yourself, the xPack project provides a binary "
"distribution, [here](https://xpack.github.io/openocd/). Follow the provided "
"installation instructions. Then update your `%PATH%` environment variable to "
"include the path where the binaries were installed. (`C:"
"\\Users\\USERNAME\\AppData\\Roaming\\xPacks\\@xpack-dev-"
"tools\\openocd\\0.10.0-13.1\\.content\\bin\\`, if you've been using the easy "
"install)"
msgstr "Windows용 OpenOCD 공식 바이너리 릴리스는 없지만 직접 컴파일할 의향이 없다면 xPack 프로젝트에서 [여기](https://xpack.github.io/openocd/)에서 바이너리 배포판을 제공합니다. 제공된 설치 지침을 따르세요. 그런 다음 바이너리가 설치된 경로를 포함하도록 `%PATH%` 환경 변수를 업데이트하세요. (쉬운 설치를 사용했다면 `C:\Users\USERNAME\AppData\Roaming\xPacks\@xpack-dev-tools\openocd\0.10.0-13.1\.content\bin\`)"

#: src/intro/install/windows.md:27
msgid "Verify that OpenOCD is in your `%PATH%` with:"
msgstr "다음 명령으로 OpenOCD가 `%PATH%`에 있는지 확인하세요:"

#: src/intro/install/windows.md:37
msgid ""
"Grab QEMU from [the official website](https://www.qemu.org/download/"
"#windows)."
msgstr "[공식 웹사이트](https://www.qemu.org/download/#windows)에서 QEMU를 다운로드하세요."

#: src/intro/install/windows.md:41
msgid "ST-LINK USB driver"
msgstr "ST-LINK USB 드라이버"

#: src/intro/install/windows.md:43
msgid ""
"You'll also need to install [this USB driver](http://www.st.com/en/embedded-"
"software/stsw-link009.html) or OpenOCD won't work. Follow the installer "
"instructions and make sure you install the right version (32-bit or 64-bit) "
"of the driver."
msgstr "또한 [이 USB 드라이버](http://www.st.com/en/embedded-software/stsw-link009.html)를 설치해야 합니다. 그렇지 않으면 OpenOCD가 작동하지 않습니다. 설치 프로그램 지침을 따르고 올바른 버전(32비트 또는 64비트)의 드라이버를 설치했는지 확인하세요."

#: src/intro/install/verify.md:3
msgid ""
"In this section we check that some of the required tools / drivers have been "
"correctly installed and configured."
msgstr "이 섹션에서는 필요한 도구/드라이버 중 일부가 올바르게 설치 및 구성되었는지 확인합니다."

#: src/intro/install/verify.md:6
msgid ""
"Connect your laptop / PC to the discovery board using a Mini-USB USB cable. "
"The discovery board has two USB connectors; use the one labeled \"USB ST-"
"LINK\" that sits on the center of the edge of the board."
msgstr "미니 USB 케이블을 사용하여 노트북/PC를 디스커버리 보드에 연결하세요. 디스커버리 보드에는 두 개의 USB 커넥터가 있습니다. 보드 가장자리 중앙에 있는 \"USB ST-LINK\"라고 표시된 커넥터를 사용하세요."

#: src/intro/install/verify.md:10
msgid ""
"Also check that the ST-LINK header is populated. See the picture below; the "
"ST-LINK header is highlighted."
msgstr "또한 ST-LINK 헤더가 채워져 있는지 확인하세요. 아래 그림을 참조하세요. ST-LINK 헤더가 강조 표시되어 있습니다."

#: src/intro/install/verify.md:17
msgid "Now run the following command:"
msgstr "이제 다음 명령을 실행하세요:"

#: src/intro/install/verify.md:23
msgid ""
"**NOTE**: Old versions of openocd, including the 0.10.0 release from 2017, "
"do not contain the new (and preferable) `interface/stlink.cfg` file; instead "
"you may need to use `interface/stlink-v2.cfg` or `interface/stlink-v2-1.cfg`."
msgstr "**참고**: 2017년 0.10.0 릴리스를 포함한 이전 버전의 OpenOCD에는 새롭고 선호되는 `interface/stlink.cfg` 파일이 포함되어 있지 않습니다. 대신 `interface/stlink-v2.cfg` 또는 `interface/stlink-v2-1.cfg`를 사용해야 할 수 있습니다."

#: src/intro/install/verify.md:27
msgid ""
"You should get the following output and the program should block the console:"
msgstr "다음과 같은 출력이 표시되고 프로그램이 콘솔을 차단해야 합니다:"

#: src/intro/install/verify.md:29
msgid ""
"```text\n"
"Open On-Chip Debugger 0.10.0\n"
"Licensed under GNU GPL v2\n"
"For bug reports, read\n"
"        http://openocd.org/doc/doxygen/bugs.html\n"
"Info : auto-selecting first available session transport \"hla_swd\". To "
"override use 'transport select <transport>'.\n"
"adapter speed: 1000 kHz\n"
"adapter_nsrst_delay: 100\n"
"Info : The selected transport took over low-level target control. The "
"results might differ compared to plain JTAG/SWD\n"
"none separate\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : clock speed 950 kHz\n"
"Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B\n"
"Info : using stlink api v2\n"
"Info : Target voltage: 2.919881\n"
"Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints\n"
"```"
msgstr "```text\nOpen On-Chip Debugger 0.10.0\nLicensed under GNU GPL v2\nFor bug reports, read\n        http://openocd.org/doc/doxygen/bugs.html\nInfo : auto-selecting first available session transport \"hla_swd\". To override use 'transport select <transport>'.\nadapter speed: 1000 kHz\nadapter_nsrst_delay: 100\nInfo : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD\nnone separate\nInfo : Unable to match requested speed 1000 kHz, using 950 kHz\nInfo : Unable to match requested speed 1000 kHz, using 950 kHz\nInfo : clock speed 950 kHz\nInfo : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B\nInfo : using stlink api v2\nInfo : Target voltage: 2.919881\nInfo : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints\n```"

#: src/intro/install/verify.md:48
msgid ""
"The contents may not match exactly but you should get the last line about "
"breakpoints and watchpoints. If you got it then terminate the OpenOCD "
"process and move to the [next section](../../start/index.md)."
msgstr "내용이 정확히 일치하지 않을 수 있지만 중단점 및 감시점에 대한 마지막 줄이 표시되어야 합니다. 이 줄이 표시되면 OpenOCD 프로세스를 종료하고 [다음 섹션](../../start/index.md)으로 이동하세요."

#: src/intro/install/verify.md:54
msgid ""
"If you didn't get the "breakpoints" line then try one of the following "
"commands."
msgstr "breakpoints" 줄이 표시되지 않았다면 다음 명령 중 하나를 시도해 보세요."

#: src/intro/install/verify.md:64
msgid ""
"If one of those commands works it means you got an old hardware revision of "
"the discovery board. That won't be a problem but commit that fact to memory "
"as you'll need to configure things a bit differently later on. You can move "
"to the [next section](../../start/index.md)."
msgstr "이 명령 중 하나가 작동한다면 Discovery 보드의 이전 하드웨어 개정판을 사용하고 있다는 의미입니다. 이는 문제가 되지 않지만 나중에 설정을 약간 다르게 구성해야 하므로 이 사실을 기억해 두세요. [다음 섹션](../../start/index.md)으로 이동할 수 있습니다."

#: src/intro/install/verify.md:69
msgid ""
"If none of the commands work as a normal user then try to run them with root "
"permission (e.g. `sudo openocd ..`). If the commands do work with root "
"permission then check that the [udev rules](linux.md#udev-rules) have been "
"correctly set."
msgstr "일반 사용자로는 어떤 명령도 작동하지 않는다면 루트 권한으로 실행해 보세요(예: `sudo openocd ..`). 명령이 루트 권한으로 작동한다면 [udev 규칙](linux.md#udev-rules)이 올바르게 설정되었는지 확인하세요."

#: src/intro/install/verify.md:75
msgid ""
"If you have reached this point and OpenOCD is not working please open [an "
"issue](https://github.com/rust-embedded/book/issues) and we'll help you out!"
msgstr "이 시점까지 OpenOCD가 작동하지 않는다면 [이슈](https://github.com/rust-embedded/book/issues)를 열어주세요. 저희가 도와드리겠습니다!"

#: src/start/index.md:1
msgid "Getting Started"
msgstr "시작하기"

#: src/start/index.md:3
msgid ""
"In this section we'll walk you through the process of writing, building, "
"flashing and debugging embedded programs. You will be able to try most of "
"the examples without any special hardware as we will show you the basics "
"using QEMU, a popular open-source hardware emulator. The only section where "
"hardware is required is, naturally enough, the [Hardware](./hardware.md) "
"section, where we use OpenOCD to program an [STM32F3DISCOVERY](http://"
"www.st.com/en/evaluation-tools/stm32f3discovery.html)."
msgstr "이 섹션에서는 임베디드 프로그램을 작성, 빌드, 플래싱 및 디버깅하는 과정을 안내합니다. 인기 있는 오픈 소스 하드웨어 에뮬레이터인 QEMU를 사용하여 기본 사항을 보여주므로 특별한 하드웨어 없이도 대부분의 예제를 시도할 수 있습니다. 하드웨어가 필요한 유일한 섹션은 당연히 OpenOCD를 사용하여 [STM32F3DISCOVERY](http://www.st.com/en/evaluation-tools/stm32f3discovery.html)를 프로그래밍하는 [하드웨어](./hardware.md) 섹션입니다."

#: src/start/qemu.md:3
msgid ""
"We'll start writing a program for the [LM3S6965](http://www.ti.com/product/"
"LM3S6965), a Cortex-M3 microcontroller. We have chosen this as our initial "
"target because it [can be emulated](https://wiki.qemu.org/Documentation/"
"Platforms/ARM#Supported_in_qemu-system-arm) using QEMU so you don't need to "
"fiddle with hardware in this section and we can focus on the tooling and the "
"development process."
msgstr ""
"[LM3S6965](http://www.ti.com/product/"
"LM3S6965), Cortex-M3 마이크로컨트롤러를 위한 프로그램 작성을 시작하겠습니다. "
"이를 초기 타겟으로 선택한 이유는 QEMU를 사용하여 [에뮬레이션할 수 있기](https://wiki.qemu.org/Documentation/"
"Platforms/ARM#Supported_in_qemu-system-arm) 때문에 이 섹션에서는 "
"하드웨어를 만질 필요가 없고 툴링과 "
"개발 과정에 집중할 수 있습니다."

#: src/start/qemu.md:10
msgid ""
"**IMPORTANT** We'll use the name \"app\" for the project name in this "
"tutorial. Whenever you see the word \"app\" you should replace it with the "
"name you selected for your project. Or, you could also name your project "
"\"app\" and avoid the substitutions."
msgstr ""
"**중요** 이 튜토리얼에서는 프로젝트 이름으로 \"app\"을 사용하겠습니다. "
"\"app\"이라는 단어를 볼 때마다 프로젝트에 대해 선택한 "
"이름으로 바꿔야 합니다. 또는 프로젝트 이름을 "
"\"app\"으로 지정하여 치환을 피할 수도 있습니다."

#: src/start/qemu.md:16
msgid "Creating a non standard Rust program"
msgstr "비표준 Rust 프로그램 만들기"

#: src/start/qemu.md:18
msgid ""
"We'll use the [`cortex-m-quickstart`](https://github.com/rust-embedded/"
"cortex-m-quickstart) project template to generate a new project from it. The "
"created project will contain a barebone application: a good starting point "
"for a new embedded rust application. In addition, the project will contain "
"an `examples` directory, with several separate applications, highlighting "
"some of the key embedded rust functionality."
msgstr ""
"[`cortex-m-quickstart`](https://github.com/rust-embedded/"
"cortex-m-quickstart) 프로젝트 템플릿을 사용하여 새 프로젝트를 생성하겠습니다. "
"생성된 프로젝트는 기본 애플리케이션을 포함할 것입니다: 새로운 임베디드 rust 애플리케이션을 위한 "
"좋은 시작점입니다. 또한 프로젝트에는 "
"핵심 임베디드 rust 기능을 강조하는 여러 개별 애플리케이션이 있는 "
"`examples` 디렉토리가 포함됩니다."

#: src/start/qemu.md:26
msgid "Using `cargo-generate`"
msgstr "`cargo-generate` 사용하기"

#: src/start/qemu.md:27
msgid "First install cargo-generate"
msgstr "먼저 cargo-generate를 설치하세요"

#: src/start/qemu.md:31
msgid "Then generate a new project"
msgstr "그런 다음 새 프로젝트를 생성하세요"

#: src/start/qemu.md:32
msgid ""
"```console\n"
"cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart\n"
"```"
msgstr ""
"```console\n"
"cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart\n"
"```"

#: src/start/qemu.md:46
msgid "Using `git`"
msgstr "`git` 사용하기"

#: src/start/qemu.md:48
msgid "Clone the repository"
msgstr "저장소를 클론하세요"

#: src/start/qemu.md:50
msgid ""
"```console\n"
"git clone https://github.com/rust-embedded/cortex-m-quickstart app\n"
"cd app\n"
"```"
msgstr ""
"```console\n"
"git clone https://github.com/rust-embedded/cortex-m-quickstart app\n"
"cd app\n"
"```"

#: src/start/qemu.md:55
msgid "And then fill in the placeholders in the `Cargo.toml` file"
msgstr "그런 다음 `Cargo.toml` 파일의 플레이스홀더를 채우세요"

#: src/start/qemu.md:57
msgid ""
"```toml\n"
"[package]\n"
"authors = [\"{{authors}}\"] # \"{{authors}}\" -> \"John Smith\"\n"
"edition = \"2018\"\n"
"name = \"{{project-name}}\" # \"{{project-name}}\" -> \"app\"\n"
"version = \"0.1.0\"\n"
"\n"
"# ..\n"
"\n"
"[[bin]]\n"
"name = \"{{project-name}}\" # \"{{project-name}}\" -> \"app\"\n"
"test = false\n"
"bench = false\n"
"```"
msgstr ""
"```toml\n"
"[package]\n"
"authors = [\"{{authors}}\"] # \"{{authors}}\" -> \"John Smith\"\n"
"edition = \"2018\"\n"
"name = \"{{project-name}}\" # \"{{project-name}}\" -> \"app\"\n"
"version = \"0.1.0\"\n"
"\n"
"# ..\n"
"\n"
"[[bin]]\n"
"name = \"{{project-name}}\" # \"{{project-name}}\" -> \"app\"\n"
"test = false\n"
"bench = false\n"
"```"

#: src/start/qemu.md:72
msgid "Using neither"
msgstr "둘 다 사용하지 않기"

#: src/start/qemu.md:74
msgid ""
"Grab the latest snapshot of the `cortex-m-quickstart` template and extract "
"it."
msgstr ""
"`cortex-m-quickstart` 템플릿의 최신 스냅샷을 가져와서 "
"압축을 해제하세요."

#: src/start/qemu.md:76
msgid ""
"```console\n"
"curl -LO https://github.com/rust-embedded/cortex-m-quickstart/archive/"
"master.zip\n"
"unzip master.zip\n"
"mv cortex-m-quickstart-master app\n"
"cd app\n"
"```"
msgstr ""
"```console\n"
"curl -LO https://github.com/rust-embedded/cortex-m-quickstart/archive/"
"master.zip\n"
"unzip master.zip\n"
"mv cortex-m-quickstart-master app\n"
"cd app\n"
"```"

#: src/start/qemu.md:83
msgid ""
"Or you can browse to [`cortex-m-quickstart`](https://github.com/rust-"
"embedded/cortex-m-quickstart), click the green \"Clone or download\" button "
"and then click \"Download ZIP\"."
msgstr ""
"또는 [`cortex-m-quickstart`](https://github.com/rust-"
"embedded/cortex-m-quickstart)로 이동하여 녹색 \"Clone or download\" 버튼을 클릭한 다음 "
"\"Download ZIP\"을 클릭할 수 있습니다."

#: src/start/qemu.md:86
msgid ""
"Then fill in the placeholders in the `Cargo.toml` file as done in the second "
"part of the \"Using `git`\" version."
msgstr "그런 다음 "`git` 사용하기" 버전의 두 번째 부분에서 수행한 대로 `Cargo.toml` 파일의 플레이스홀더를 채우세요."

#: src/start/qemu.md:89
msgid "Program Overview"
msgstr "프로그램 개요"

#: src/start/qemu.md:91
msgid ""
"For convenience here are the most important parts of the source code in `src/"
"main.rs`:"
msgstr "편의를 위해 `src/main.rs`의 소스 코드에서 가장 중요한 부분을 소개합니다:"

#: src/start/qemu.md:104
msgid "// your code goes here\n"
msgstr "// 여기에 코드를 작성하세요\n"

#: src/start/qemu.md:109
msgid ""
"This program is a bit different from a standard Rust program so let's take a "
"closer look."
msgstr "이 프로그램은 표준 Rust 프로그램과 약간 다르므로 자세히 살펴보겠습니다."

#: src/start/qemu.md:112
msgid ""
"`#![no_std]` indicates that this program will _not_ link to the standard "
"crate, `std`. Instead it will link to its subset: the `core` crate."
msgstr "`#![no_std]`는 이 프로그램이 표준 크레이트인 `std`에 링크되지 않을 것임을 나타냅니다. 대신 그 하위 집합인 `core` 크레이트에 링크될 것입니다."

#: src/start/qemu.md:115
msgid ""
"`#![no_main]` indicates that this program won't use the standard `main` "
"interface that most Rust programs use. The main (no pun intended) reason to "
"go with `no_main` is that using the `main` interface in `no_std` context "
"requires nightly."
msgstr "`#![no_main]`은 이 프로그램이 대부분의 Rust 프로그램이 사용하는 표준 `main` 인터페이스를 사용하지 않을 것임을 나타냅니다. `no_main`을 사용하는 주된 이유는 `no_std` 컨텍스트에서 `main` 인터페이스를 사용하려면 nightly가 필요하기 때문입니다."

#: src/start/qemu.md:120
msgid ""
"`use panic_halt as _;`. This crate provides a `panic_handler` that defines "
"the panicking behavior of the program. We will cover this in more detail in "
"the [Panicking](panicking.md) chapter of the book."
msgstr "`use panic_halt as _;`. 이 크레이트는 프로그램의 패닉 동작을 정의하는 `panic_handler`를 제공합니다. 이에 대해서는 책의 [패닉](panicking.md) 장에서 더 자세히 다룰 것입니다."

#: src/start/qemu.md:124
msgid ""
"[`#[entry]`](https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/"
"attr.entry.html) is an attribute provided by the [`cortex-m-rt`](https://"
"crates.io/crates/cortex-m-rt) crate that's used to mark the entry point of "
"the program. As we are not using the standard `main` interface we need "
"another way to indicate the entry point of the program and that'd be "
"`#[entry]`."
msgstr "[`#[entry]`](https://docs.rs/cortex-m-rt-macros/latest/cortex_m_rt_macros/attr.entry.html)는 프로그램의 진입점을 표시하는 데 사용되는 [`cortex-m-rt`](https://crates.io/crates/cortex-m-rt) 크레이트에서 제공하는 속성입니다. 표준 `main` 인터페이스를 사용하지 않으므로 프로그램의 진입점을 나타내는 다른 방법이 필요하며, 그것이 `#[entry]`입니다."

#: src/start/qemu.md:132
msgid ""
"`fn main() -> !`. Our program will be the _only_ process running on the "
"target hardware so we don't want it to end! We use a [divergent function]"
"(https://doc.rust-lang.org/rust-by-example/fn/diverging.html) (the `-> !` "
"bit in the function signature) to ensure at compile time that'll be the case."
msgstr "`fn main() -> !`. 우리 프로그램은 대상 하드웨어에서 실행되는 _유일한_ 프로세스이므로 종료되기를 원하지 않습니다! 컴파일 시점에 그렇게 될 것임을 보장하기 위해 [발산 함수](https://doc.rust-lang.org/rust-by-example/fn/diverging.html)(함수 시그니처의 `-> !` 부분)를 사용합니다."

#: src/start/qemu.md:136
msgid "Cross compiling"
msgstr "크로스 컴파일"

#: src/start/qemu.md:138
msgid ""
"The next step is to _cross_ compile the program for the Cortex-M3 "
"architecture. That's as simple as running `cargo build --target $TRIPLE` if "
"you know what the compilation target (`$TRIPLE`) should be. Luckily, the "
"`.cargo/config.toml` in the template has the answer:"
msgstr "다음 단계는 Cortex-M3 아키텍처용 프로그램을 _크로스_ 컴파일하는 것입니다. 컴파일 대상(`$TRIPLE`)이 무엇인지 안다면 `cargo build --target $TRIPLE`을 실행하는 것만큼 간단합니다. 다행히 템플릿의 `.cargo/config.toml`에 답이 있습니다:"

#: src/start/qemu.md:147
msgid ""
"```toml\n"
"[build]\n"
"# Pick ONE of these compilation targets\n"
"# target = \"thumbv6m-none-eabi\"    # Cortex-M0 and Cortex-M0+\n"
"target = \"thumbv7m-none-eabi\"    # Cortex-M3\n"
"# target = \"thumbv7em-none-eabi\"   # Cortex-M4 and Cortex-M7 (no FPU)\n"
"# target = \"thumbv7em-none-eabihf\" # Cortex-M4F and Cortex-M7F (with FPU)\n"
"```"
msgstr ""

#: src/start/qemu.md:156
msgid ""
"To cross compile for the Cortex-M3 architecture we have to use `thumbv7m-"
"none-eabi`. That target is not automatically installed when installing the "
"Rust toolchain, it would now be a good time to add that target to the "
"toolchain, if you haven't done it yet:"
msgstr "Cortex-M3 아키텍처용으로 크로스 컴파일하려면 `thumbv7m-none-eabi`를 사용해야 합니다. 이 대상은 Rust 툴체인을 설치할 때 자동으로 설치되지 않으므로, 아직 추가하지 않았다면 지금 툴체인에 이 대상을 추가하는 것이 좋습니다:"

#: src/start/qemu.md:163
msgid ""
"Since the `thumbv7m-none-eabi` compilation target has been set as the "
"default in your `.cargo/config.toml` file, the two commands below do the "
"same:"
msgstr "`.cargo/config.toml` 파일에 `thumbv7m-none-eabi` 컴파일 대상이 기본값으로 설정되어 있으므로 아래 두 명령은 동일하게 작동합니다:"

#: src/start/qemu.md:171
msgid "Inspecting"
msgstr "검사"

#: src/start/qemu.md:173
msgid ""
"Now we have a non-native ELF binary in `target/thumbv7m-none-eabi/debug/"
"app`. We can inspect it using `cargo-binutils`."
msgstr "이제 `target/thumbv7m-none-eabihf/debug/app`에 비네이티브 ELF 바이너리가 있습니다. `cargo-binutils`를 사용하여 검사할 수 있습니다."

#: src/start/qemu.md:176
msgid ""
"With `cargo-readobj` we can print the ELF headers to confirm that this is an "
"ARM binary."
msgstr "`cargo-readobj`를 사용하여 ELF 헤더를 출력하여 이것이 ARM 바이너리임을 확인할 수 있습니다."

#: src/start/qemu.md:183
msgid "Note that:"
msgstr "참고:"

#: src/start/qemu.md:184
msgid ""
"`--bin app` is sugar for inspect the binary at `target/$TRIPLE/debug/app`"
msgstr "`--bin app`은 `target/$TRIPLE/debug/app`의 바이너리를 검사하는 간편한 방법입니다."

#: src/start/qemu.md:185
msgid "`--bin app` will also (re)compile the binary, if necessary"
msgstr "`--bin app`은 필요한 경우 바이너리를 (재)컴파일합니다."

#: src/start/qemu.md:211
msgid "`cargo-size` can print the size of the linker sections of the binary."
msgstr "`cargo-size`는 바이너리의 링커 섹션 크기를 출력할 수 있습니다."

#: src/start/qemu.md:217
msgid "we use `--release` to inspect the optimized version"
msgstr "최적화된 버전을 검사하기 위해 `--release`를 사용합니다."

#: src/start/qemu.md:241
msgid "A refresher on ELF linker sections"
msgstr "ELF 링커 섹션에 대한 복습"

#: src/start/qemu.md:243
msgid "`.text` contains the program instructions"
msgstr "`.text`는 프로그램 명령어를 포함합니다."

#: src/start/qemu.md:244
msgid "`.rodata` contains constant values like strings"
msgstr "`.rodata`는 문자열과 같은 상수 값을 포함합니다."

#: src/start/qemu.md:245
msgid ""
"`.data` contains statically allocated variables whose initial values are "
"_not_ zero"
msgstr "`.data`는 초기 값이 0이 _아닌_ 정적으로 할당된 변수를 포함합니다."

#: src/start/qemu.md:247
msgid ""
"`.bss` also contains statically allocated variables whose initial values "
"_are_ zero"
msgstr "`.bss`는 초기 값이 0인 정적으로 할당된 변수도 포함합니다."

#: src/start/qemu.md:249
msgid ""
"`.vector_table` is a _non_\\-standard section that we use to store the "
"vector (interrupt) table"
msgstr "`.vector_table`은 벡터(인터럽트) 테이블을 저장하는 데 사용하는 _비_표준 섹션입니다."

#: src/start/qemu.md:251
msgid ""
"`.ARM.attributes` and the `.debug_*` sections contain metadata and will "
"_not_ be loaded onto the target when flashing the binary."
msgstr "`.ARM.attributes` 및 `.debug_*` 섹션은 메타데이터를 포함하며 바이너리를 플래싱할 때 대상에 로드되지 _않습니다_."

#: src/start/qemu.md:254
msgid ""
"**IMPORTANT**: ELF files contain metadata like debug information so their "
"_size on disk_ does _not_ accurately reflect the space the program will "
"occupy when flashed on a device. _Always_ use `cargo-size` to check how big "
"a binary really is."
msgstr "**중요**: ELF 파일은 디버그 정보와 같은 메타데이터를 포함하므로 디스크상의 _크기_는 장치에 플래싱될 때 프로그램이 차지할 공간을 정확하게 반영하지 _않습니다_. 바이너리의 실제 크기를 확인하려면 _항상_ `cargo-size`를 사용하세요."

#: src/start/qemu.md:259
msgid "`cargo-objdump` can be used to disassemble the binary."
msgstr "`cargo-objdump`를 사용하여 바이너리를 역어셈블할 수 있습니다."

#: src/start/qemu.md:265
msgid ""
"**NOTE** if the above command complains about `Unknown command line "
"argument` see the following bug report: https://github.com/rust-embedded/"
"book/issues/269"
msgstr "**참고** 위 명령이 `Unknown command line argument`에 대해 불평하면 다음 버그 보고서를 참조하세요: https://github.com/rust-embedded/book/issues/269"

#: src/start/qemu.md:268
msgid ""
"**NOTE** this output can differ on your system. New versions of rustc, LLVM "
"and libraries can generate different assembly. We truncated some of the "
"instructions to keep the snippet small."
msgstr "**참고** 이 출력은 시스템에 따라 다를 수 있습니다. rustc, LLVM 및 라이브러리의 새 버전은 다른 어셈블리를 생성할 수 있습니다. 스니펫을 작게 유지하기 위해 일부 명령어를 잘라냈습니다."

#: src/start/qemu.md:311
msgid "Running"
msgstr ""

#: src/start/qemu.md:313
msgid ""
"Next, let's see how to run an embedded program on QEMU! This time we'll use "
"the `hello` example which actually does something."
msgstr ""

#: src/start/qemu.md:316
msgid "For convenience here's the source code of `examples/hello.rs`:"
msgstr ""

#: src/start/qemu.md:319
msgid "//! Prints \"Hello, world!\" on the host console using semihosting\n"
msgstr ""

#: src/start/qemu.md:331 src/start/hardware.md:97 src/start/semihosting.md:26
msgid "\"Hello, world!\""
msgstr ""

#: src/start/qemu.md:333
msgid ""
"// exit QEMU\n"
"    // NOTE do not run this on hardware; it can corrupt OpenOCD state\n"
msgstr ""

#: src/start/qemu.md:341
msgid ""
"This program uses something called semihosting to print text to the _host_ "
"console. When using real hardware this requires a debug session but when "
"using QEMU this Just Works."
msgstr ""

#: src/start/qemu.md:345
msgid "Let's start by compiling the example:"
msgstr ""

#: src/start/qemu.md:351
msgid ""
"The output binary will be located at `target/thumbv7m-none-eabi/debug/"
"examples/hello`."
msgstr ""

#: src/start/qemu.md:354
msgid "To run this binary on QEMU run the following command:"
msgstr ""

#: src/start/qemu.md:369
msgid ""
"The command should successfully exit (exit code = 0) after printing the "
"text. On \\*nix you can check that with the following command:"
msgstr ""

#: src/start/qemu.md:380
msgid "Let's break down that QEMU command:"
msgstr ""

#: src/start/qemu.md:382
msgid ""
"`qemu-system-arm`. This is the QEMU emulator. There are a few variants of "
"these QEMU binaries; this one does full _system_ emulation of _ARM_ machines "
"hence the name."
msgstr ""

#: src/start/qemu.md:386
msgid ""
"`-cpu cortex-m3`. This tells QEMU to emulate a Cortex-M3 CPU. Specifying the "
"CPU model lets us catch some miscompilation errors: for example, running a "
"program compiled for the Cortex-M4F, which has a hardware FPU, will make "
"QEMU error during its execution."
msgstr ""

#: src/start/qemu.md:391
msgid ""
"`-machine lm3s6965evb`. This tells QEMU to emulate the LM3S6965EVB, an "
"evaluation board that contains a LM3S6965 microcontroller."
msgstr ""

#: src/start/qemu.md:394
msgid "`-nographic`. This tells QEMU to not launch its GUI."
msgstr ""

#: src/start/qemu.md:396
msgid ""
"`-semihosting-config (..)`. This tells QEMU to enable semihosting. "
"Semihosting lets the emulated device, among other things, use the host "
"stdout, stderr and stdin and create files on the host."
msgstr ""

#: src/start/qemu.md:400
msgid ""
"`-kernel $file`. This tells QEMU which binary to load and run on the "
"emulated machine."
msgstr ""

#: src/start/qemu.md:403
msgid ""
"Typing out that long QEMU command is too much work! We can set a custom "
"runner to simplify the process. `.cargo/config.toml` has a commented out "
"runner that invokes QEMU; let's uncomment it:"
msgstr ""

#: src/start/qemu.md:411
msgid ""
"```toml\n"
"[target.thumbv7m-none-eabi]\n"
"# uncomment this to make `cargo run` execute programs on QEMU\n"
"runner = \"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic "
"-semihosting-config enable=on,target=native -kernel\"\n"
"```"
msgstr ""

#: src/start/qemu.md:417
msgid ""
"This runner only applies to the `thumbv7m-none-eabi` target, which is our "
"default compilation target. Now `cargo run` will compile the program and run "
"it on QEMU:"
msgstr ""

#: src/start/qemu.md:425
msgid ""
"```text\n"
"   Compiling app v0.1.0 (file:///tmp/app)\n"
"    Finished release [optimized + debuginfo] target(s) in 0.26s\n"
"     Running `qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic "
"-semihosting-config enable=on,target=native -kernel target/thumbv7m-none-"
"eabi/release/examples/hello`\n"
"Hello, world!\n"
"```"
msgstr ""

#: src/start/qemu.md:432 src/start/hardware.md:116
msgid "Debugging"
msgstr ""

#: src/start/qemu.md:434
msgid "Debugging is critical to embedded development. Let's see how it's done."
msgstr ""

#: src/start/qemu.md:436
msgid ""
"Debugging an embedded device involves _remote_ debugging as the program that "
"we want to debug won't be running on the machine that's running the debugger "
"program (GDB or LLDB)."
msgstr ""

#: src/start/qemu.md:440
msgid ""
"Remote debugging involves a client and a server. In a QEMU setup, the client "
"will be a GDB (or LLDB) process and the server will be the QEMU process "
"that's also running the embedded program."
msgstr ""

#: src/start/qemu.md:444
msgid "In this section we'll use the `hello` example we already compiled."
msgstr ""

#: src/start/qemu.md:446
msgid "The first debugging step is to launch QEMU in debugging mode:"
msgstr ""

#: src/start/qemu.md:459
msgid ""
"This command won't print anything to the console and will block the "
"terminal. We have passed two extra flags this time:"
msgstr ""

#: src/start/qemu.md:462
msgid ""
"`-gdb tcp::3333`. This tells QEMU to wait for a GDB connection on TCP port "
"3333."
msgstr ""

#: src/start/qemu.md:465
msgid ""
"`-S`. This tells QEMU to freeze the machine at startup. Without this the "
"program would have reached the end of main before we had a chance to launch "
"the debugger!"
msgstr ""

#: src/start/qemu.md:469
msgid ""
"Next we launch GDB in another terminal and tell it to load the debug symbols "
"of the example:"
msgstr ""

#: src/start/qemu.md:476
msgid ""
"**NOTE**: you might need another version of gdb instead of `gdb-multiarch` "
"depending on which one you installed in the installation chapter. This could "
"also be `arm-none-eabi-gdb` or just `gdb`."
msgstr ""

#: src/start/qemu.md:480
msgid ""
"Then within the GDB shell we connect to QEMU, which is waiting for a "
"connection on TCP port 3333."
msgstr ""

#: src/start/qemu.md:487
msgid ""
"```text\n"
"Remote debugging using :3333\n"
"Reset () at $REGISTRY/cortex-m-rt-0.6.1/src/lib.rs:473\n"
"473     pub unsafe extern \"C\" fn Reset() -> ! {\n"
"```"
msgstr ""

#: src/start/qemu.md:494
msgid ""
"You'll see that the process is halted and that the program counter is "
"pointing to a function named `Reset`. That is the reset handler: what Cortex-"
"M cores execute upon booting."
msgstr ""

#: src/start/qemu.md:498
msgid ""
"Note that on some setup, instead of displaying the line `Reset () at "
"$REGISTRY/cortex-m-rt-0.6.1/src/lib.rs:473` as shown above, gdb may print "
"some warnings like :"
msgstr ""

#: src/start/qemu.md:500
msgid ""
"`core::num::bignum::Big32x40::mul_small () at src/libcore/num/bignum.rs:254` "
"`    src/libcore/num/bignum.rs: No such file or directory.`"
msgstr ""

#: src/start/qemu.md:503
msgid ""
"That's a known glitch. You can safely ignore those warnings, you're most "
"likely at Reset()."
msgstr ""

#: src/start/qemu.md:506
msgid ""
"This reset handler will eventually call our main function. Let's skip all "
"the way there using a breakpoint and the `continue` command. To set the "
"breakpoint, let's first take a look where we would like to break in our "
"code, with the `list` command."
msgstr ""

#: src/start/qemu.md:512
msgid "This will show the source code, from the file examples/hello.rs."
msgstr ""

#: src/start/qemu.md:514
msgid ""
"```text\n"
"6       use panic_halt as _;\n"
"7\n"
"8       use cortex_m_rt::entry;\n"
"9       use cortex_m_semihosting::{debug, hprintln};\n"
"10\n"
"11      #[entry]\n"
"12      fn main() -> ! {\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"14\n"
"15          // exit QEMU\n"
"```"
msgstr ""

#: src/start/qemu.md:526
msgid ""
"We would like to add a breakpoint just before the \"Hello, world!\", which "
"is on line 13. We do that with the `break` command:"
msgstr ""

#: src/start/qemu.md:531
msgid ""
"We can now instruct gdb to run up to our main function, with the `continue` "
"command:"
msgstr ""

#: src/start/qemu.md:537
msgid ""
"```text\n"
"Continuing.\n"
"\n"
"Breakpoint 1, hello::__cortex_m_rt_main () at examples\\hello.rs:13\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"```"
msgstr ""

#: src/start/qemu.md:544
msgid ""
"We are now close to the code that prints \"Hello, world!\". Let's move "
"forward using the `next` command."
msgstr ""

#: src/start/qemu.md:555
msgid ""
"At this point you should see \"Hello, world!\" printed on the terminal "
"that's running `qemu-system-arm`."
msgstr ""

#: src/start/qemu.md:563
msgid "Calling `next` again will terminate the QEMU process."
msgstr ""

#: src/start/qemu.md:573
msgid "You can now exit the GDB session."
msgstr ""

#: src/start/hardware.md:3
msgid ""
"By now you should be somewhat familiar with the tooling and the development "
"process. In this section we'll switch to real hardware; the process will "
"remain largely the same. Let's dive in."
msgstr ""

#: src/start/hardware.md:7
msgid "Know your hardware"
msgstr ""

#: src/start/hardware.md:9
msgid ""
"Before we begin you need to identify some characteristics of the target "
"device as these will be used to configure the project:"
msgstr ""

#: src/start/hardware.md:12
msgid "The ARM core. e.g. Cortex-M3."
msgstr ""

#: src/start/hardware.md:14
msgid ""
"Does the ARM core include an FPU? Cortex-M4**F** and Cortex-M7**F** cores do."
msgstr ""

#: src/start/hardware.md:16
msgid ""
"How much Flash memory and RAM does the target device have? e.g. 256 KiB of "
"Flash and 32 KiB of RAM."
msgstr ""

#: src/start/hardware.md:19
msgid ""
"Where are Flash memory and RAM mapped in the address space? e.g. RAM is "
"commonly located at address `0x2000_0000`."
msgstr ""

#: src/start/hardware.md:22
msgid ""
"You can find this information in the data sheet or the reference manual of "
"your device."
msgstr ""

#: src/start/hardware.md:25
msgid ""
"In this section we'll be using our reference hardware, the STM32F3DISCOVERY. "
"This board contains an STM32F303VCT6 microcontroller. This microcontroller "
"has:"
msgstr ""

#: src/start/hardware.md:28
msgid "A Cortex-M4F core that includes a single precision FPU"
msgstr ""

#: src/start/hardware.md:30
msgid "256 KiB of Flash located at address 0x0800_0000."
msgstr ""

#: src/start/hardware.md:32
msgid ""
"40 KiB of RAM located at address 0x2000_0000. (There's another RAM region "
"but for simplicity we'll ignore it)."
msgstr ""

#: src/start/hardware.md:35
msgid "Configuring"
msgstr ""

#: src/start/hardware.md:37
msgid ""
"We'll start from scratch with a fresh template instance. Refer to the "
"[previous section on QEMU](qemu.md) for a refresher on how to do this "
"without `cargo-generate`."
msgstr ""

#: src/start/hardware.md:43
msgid ""
"```text\n"
"$ cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart\n"
" Project Name: app\n"
" Creating project called `app`...\n"
" Done! New project created /tmp/app\n"
"\n"
"$ cd app\n"
"```"
msgstr ""

#: src/start/hardware.md:52
msgid ""
"Step number one is to set a default compilation target in `.cargo/"
"config.toml`."
msgstr ""

#: src/start/hardware.md:58
msgid ""
"```toml\n"
"# Pick ONE of these compilation targets\n"
"# target = \"thumbv6m-none-eabi\"    # Cortex-M0 and Cortex-M0+\n"
"# target = \"thumbv7m-none-eabi\"    # Cortex-M3\n"
"# target = \"thumbv7em-none-eabi\"   # Cortex-M4 and Cortex-M7 (no FPU)\n"
"target = \"thumbv7em-none-eabihf\" # Cortex-M4F and Cortex-M7F (with FPU)\n"
"```"
msgstr ""

#: src/start/hardware.md:66
msgid "We'll use `thumbv7em-none-eabihf` as that covers the Cortex-M4F core."
msgstr ""

#: src/start/hardware.md:67
msgid ""
"**NOTE**: As you may remember from the previous chapter, we have to install "
"all targets and this is a new one. So don't forget to run the installation "
"process `rustup target add thumbv7em-none-eabihf` for this target."
msgstr ""

#: src/start/hardware.md:71
msgid ""
"The second step is to enter the memory region information into the "
"`memory.x` file."
msgstr ""

#: src/start/hardware.md:84
msgid ""
"**NOTE**: If you for some reason changed the `memory.x` file after you had "
"made the first build of a specific build target, then do `cargo clean` "
"before `cargo build`, because `cargo build` may not track updates of "
"`memory.x`."
msgstr ""

#: src/start/hardware.md:88
msgid ""
"We'll start with the hello example again, but first we have to make a small "
"change."
msgstr ""

#: src/start/hardware.md:91
msgid ""
"In `examples/hello.rs`, make sure the `debug::exit()` call is commented out "
"or removed. It is used only for running in QEMU."
msgstr ""

#: src/start/hardware.md:99 src/unsorted/math.md:61
msgid ""
"// exit QEMU\n"
"    // NOTE do not run this on hardware; it can corrupt OpenOCD state\n"
"    // debug::exit(debug::EXIT_SUCCESS);\n"
msgstr ""

#: src/start/hardware.md:107
msgid ""
"You can now cross compile programs using `cargo build` and inspect the "
"binaries using `cargo-binutils` as you did before. The `cortex-m-rt` crate "
"handles all the magic required to get your chip running, as helpfully, "
"pretty much all Cortex-M CPUs boot in the same fashion."
msgstr ""

#: src/start/hardware.md:118
msgid ""
"Debugging will look a bit different. In fact, the first steps can look "
"different depending on the target device. In this section we'll show the "
"steps required to debug a program running on the STM32F3DISCOVERY. This is "
"meant to serve as a reference; for device specific information about "
"debugging check out [the Debugonomicon](https://github.com/rust-embedded/"
"debugonomicon)."
msgstr ""

#: src/start/hardware.md:124
msgid ""
"As before we'll do remote debugging and the client will be a GDB process. "
"This time, however, the server will be OpenOCD."
msgstr ""

#: src/start/hardware.md:127
msgid ""
"As done during the [verify](../intro/install/verify.md) section connect the "
"discovery board to your laptop / PC and check that the ST-LINK header is "
"populated."
msgstr ""

#: src/start/hardware.md:132
msgid ""
"On a terminal run `openocd` to connect to the ST-LINK on the discovery "
"board. Run this command from the root of the template; `openocd` will pick "
"up the `openocd.cfg` file which indicates which interface file and target "
"file to use."
msgstr ""

#: src/start/hardware.md:155
msgid ""
"**NOTE** If you found out that you have an older revision of the discovery "
"board during the [verify](../intro/install/verify.md) section then you "
"should modify the `openocd.cfg` file at this point to use `interface/stlink-"
"v2.cfg`."
msgstr ""

#: src/start/hardware.md:159
msgid ""
"```text\n"
"$ openocd\n"
"Open On-Chip Debugger 0.10.0\n"
"Licensed under GNU GPL v2\n"
"For bug reports, read\n"
"        http://openocd.org/doc/doxygen/bugs.html\n"
"Info : auto-selecting first available session transport \"hla_swd\". To "
"override use 'transport select <transport>'.\n"
"adapter speed: 1000 kHz\n"
"adapter_nsrst_delay: 100\n"
"Info : The selected transport took over low-level target control. The "
"results might differ compared to plain JTAG/SWD\n"
"none separate\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : Unable to match requested speed 1000 kHz, using 950 kHz\n"
"Info : clock speed 950 kHz\n"
"Info : STLINK v2 JTAG v27 API v2 SWIM v15 VID 0x0483 PID 0x374B\n"
"Info : using stlink api v2\n"
"Info : Target voltage: 2.913879\n"
"Info : stm32f3x.cpu: hardware has 6 breakpoints, 4 watchpoints\n"
"```"
msgstr ""

#: src/start/hardware.md:179
msgid "On another terminal run GDB, also from the root of the template."
msgstr ""

#: src/start/hardware.md:185
msgid ""
"**NOTE**: like before you might need another version of gdb instead of `gdb-"
"multiarch` depending on which one you installed in the installation chapter. "
"This could also be `arm-none-eabi-gdb` or just `gdb`."
msgstr ""

#: src/start/hardware.md:189
msgid ""
"Next connect GDB to OpenOCD, which is waiting for a TCP connection on port "
"3333."
msgstr ""

#: src/start/hardware.md:197
msgid ""
"Now proceed to _flash_ (load) the program onto the microcontroller using the "
"`load` command."
msgstr ""

#: src/start/hardware.md:209
msgid ""
"The program is now loaded. This program uses semihosting so before we do any "
"semihosting call we have to tell OpenOCD to enable semihosting. You can send "
"commands to OpenOCD using the `monitor` command."
msgstr ""

#: src/start/hardware.md:218
msgid ""
"You can see all the OpenOCD commands by invoking the `monitor help` command."
msgstr ""

#: src/start/hardware.md:220
msgid ""
"Like before we can skip all the way to `main` using a breakpoint and the "
"`continue` command."
msgstr ""

#: src/start/hardware.md:235
msgid ""
"**NOTE** If GDB blocks the terminal instead of hitting the breakpoint after "
"you issue the `continue` command above, you might want to double check that "
"the memory region information in the `memory.x` file is correctly set up for "
"your device (both the starts _and_ lengths)."
msgstr ""

#: src/start/hardware.md:240
msgid "Step into the main function with `step`."
msgstr ""

#: src/start/hardware.md:242
msgid ""
"```console\n"
"(gdb) step\n"
"halted: PC: 0x08000496\n"
"hello::__cortex_m_rt_main () at examples/hello.rs:13\n"
"13          hprintln!(\"Hello, world!\").unwrap();\n"
"```"
msgstr ""

#: src/start/hardware.md:249
msgid ""
"After advancing the program with `next` you should see \"Hello, world!\" "
"printed on the OpenOCD console, among other stuff."
msgstr ""

#: src/start/hardware.md:264
msgid ""
"The message is only displayed once as the program is about to enter the "
"infinite loop defined in line 19: `loop {}`"
msgstr ""

#: src/start/hardware.md:266
msgid "You can now exit GDB using the `quit` command."
msgstr ""

#: src/start/hardware.md:277
msgid ""
"Debugging now requires a few more steps so we have packed all those steps "
"into a single GDB script named `openocd.gdb`. The file was created during "
"the `cargo generate` step, and should work without any modifications. Let's "
"have a peek:"
msgstr ""

#: src/start/hardware.md:303
msgid ""
"Now running `<gdb> -x openocd.gdb target/thumbv7em-none-eabihf/debug/"
"examples/hello` will immediately connect GDB to OpenOCD, enable semihosting, "
"load the program and start the process."
msgstr ""

#: src/start/hardware.md:306
msgid ""
"Alternatively, you can turn `<gdb> -x openocd.gdb` into a custom runner to "
"make `cargo run` build a program _and_ start a GDB session. This runner is "
"included in `.cargo/config.toml` but it's commented out."
msgstr ""

#: src/start/hardware.md:314
msgid ""
"```toml\n"
"[target.thumbv7m-none-eabi]\n"
"# uncomment this to make `cargo run` execute programs on QEMU\n"
"# runner = \"qemu-system-arm -cpu cortex-m3 -machine lm3s6965evb -nographic "
"-semihosting-config enable=on,target=native -kernel\"\n"
"\n"
"[target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))']\n"
"# uncomment ONE of these three option to make `cargo run` start a GDB "
"session\n"
"# which option to pick depends on your system\n"
"runner = \"arm-none-eabi-gdb -x openocd.gdb\"\n"
"# runner = \"gdb-multiarch -x openocd.gdb\"\n"
"# runner = \"gdb -x openocd.gdb\"\n"
"```"
msgstr ""

#: src/start/registers.md:1
msgid "Memory Mapped Registers"
msgstr ""

#: src/start/registers.md:3
msgid ""
"Embedded systems can only get so far by executing normal Rust code and "
"moving data around in RAM. If we want to get any information into or out of "
"our system (be that blinking an LED, detecting a button press or "
"communicating with an off-chip peripheral on some sort of bus) we're going "
"to have to dip into the world of Peripherals and their 'memory mapped "
"registers'."
msgstr ""

#: src/start/registers.md:5
msgid ""
"You may well find that the code you need to access the peripherals in your "
"micro-controller has already been written, at one of the following levels:"
msgstr ""

#: src/start/registers.md:10
msgid ""
"Micro-architecture Crate - This sort of crate handles any useful routines "
"common to the processor core your microcontroller is using, as well as any "
"peripherals that are common to all micro-controllers that use that "
"particular type of processor core. For example the [cortex-m](https://"
"crates.io/crates/cortex-m) crate gives you functions to enable and disable "
"interrupts, which are the same for all Cortex-M based micro-controllers. It "
"also gives you access to the 'SysTick' peripheral included with all Cortex-M "
"based micro-controllers."
msgstr ""

#: src/start/registers.md:11
msgid ""
"Peripheral Access Crate (PAC) - This sort of crate is a thin wrapper over "
"the various memory-wrapper registers defined for your particular part-number "
"of micro-controller you are using. For example, [tm4c123x](https://crates.io/"
"crates/tm4c123x) for the Texas Instruments Tiva-C TM4C123 series, or "
"[stm32f30x](https://crates.io/crates/stm32f30x) for the ST-Micro STM32F30x "
"series. Here, you'll be interacting with the registers directly, following "
"each peripheral's operating instructions given in your micro-controller's "
"Technical Reference Manual."
msgstr ""

#: src/start/registers.md:12
msgid ""
"HAL Crate - These crates offer a more user-friendly API for your particular "
"processor, often by implementing some common traits defined in [embedded-hal]"
"(https://crates.io/crates/embedded-hal). For example, this crate might offer "
"a `Serial` struct, with a constructor that takes an appropriate set of GPIO "
"pins and a baud rate, and offers some sort of `write_byte` function for "
"sending data. See the chapter on [Portability](../portability/index.md) for "
"more information on [embedded-hal](https://crates.io/crates/embedded-hal)."
msgstr ""

#: src/start/registers.md:13
msgid ""
"Board Crate - These crates go one step further than a HAL Crate by pre-"
"configuring various peripherals and GPIO pins to suit the specific developer "
"kit or board you are using, such as [stm32f3-discovery](https://crates.io/"
"crates/stm32f3-discovery) for the STM32F3DISCOVERY board."
msgstr ""

#: src/start/registers.md:23
msgid "Board Crate"
msgstr ""

#: src/start/registers.md:25
msgid ""
"A board crate is the perfect starting point, if you're new to embedded Rust. "
"They nicely abstract the HW details that might be overwhelming when starting "
"studying this subject, and makes standard tasks easy, like turning a LED on "
"or off. The functionality it exposes varies a lot between boards. Since this "
"book aims at staying hardware agnostic, the board crates won't be covered by "
"this book."
msgstr ""

#: src/start/registers.md:27
msgid ""
"If you want to experiment with the STM32F3DISCOVERY board, it is highly "
"recommended to take a look at the [stm32f3-discovery](https://crates.io/"
"crates/stm32f3-discovery) board crate, which provides functionality to blink "
"the board LEDs, access its compass, bluetooth and more. The [Discovery]"
"(https://rust-embedded.github.io/discovery/) book offers a great "
"introduction to the use of a board crate."
msgstr ""

#: src/start/registers.md:29
msgid ""
"But if you're working on a system that doesn't yet have dedicated board "
"crate, or you need functionality not provided by existing crates, read on as "
"we start from the bottom, with the micro-architecture crates."
msgstr ""

#: src/start/registers.md:31
msgid "Micro-architecture crate"
msgstr ""

#: src/start/registers.md:33
msgid ""
"Let's look at the SysTick peripheral that's common to all Cortex-M based "
"micro-controllers. We can find a pretty low-level API in the [cortex-m]"
"(https://crates.io/crates/cortex-m) crate, and we can use it like this:"
msgstr ""

#: src/start/registers.md:51
msgid "// Loop\n"
msgstr ""

#: src/start/registers.md:57
msgid ""
"The functions on the `SYST` struct map pretty closely to the functionality "
"defined by the ARM Technical Reference Manual for this peripheral. There's "
"nothing in this API about 'delaying for X milliseconds' - we have to crudely "
"implement that ourselves using a `while` loop. Note that we can't access our "
"`SYST` struct until we have called `Peripherals::take()` - this is a special "
"routine that guarantees that there is only one `SYST` structure in our "
"entire program. For more on that, see the [Peripherals](../peripherals/"
"index.md) section."
msgstr ""

#: src/start/registers.md:61
msgid "Using a Peripheral Access Crate (PAC)"
msgstr ""

#: src/start/registers.md:63
msgid ""
"We won't get very far with our embedded software development if we restrict "
"ourselves to only the basic peripherals included with every Cortex-M. At "
"some point, we're going to need to write some code that's specific to the "
"particular micro-controller we're using. In this example, let's assume we "
"have an Texas Instruments TM4C123 - a middling 80MHz Cortex-M4 with 256 KiB "
"of Flash. We're going to pull in the [tm4c123x](https://crates.io/crates/"
"tm4c123x) crate to make use of this chip."
msgstr ""

#: src/start/registers.md:69 src/start/registers.md:145
msgid "// panic handler\n"
msgstr ""

#: src/start/registers.md:81
msgid "// Mode = 1 => Count up/down mode\n"
msgstr ""

#: src/start/registers.md:84
msgid ""
"// 528 cycles (264 up and down) = 4 loops per video line (2112 cycles)\n"
msgstr ""

#: src/start/registers.md:92
msgid ""
"We've accessed the `PWM0` peripheral in exactly the same way as we accessed "
"the `SYST` peripheral earlier, except we called "
"`tm4c123x::Peripherals::take()`. As this crate was auto-generated using "
"[svd2rust](https://crates.io/crates/svd2rust), the access functions for our "
"register fields take a closure, rather than a numeric argument. While this "
"looks like a lot of code, the Rust compiler can use it to perform a bunch of "
"checks for us, but then generate machine-code which is pretty close to hand-"
"written assembler! Where the auto-generated code isn't able to determine "
"that all possible arguments to a particular accessor function are valid (for "
"example, if the SVD defines the register as 32-bit but doesn't say if some "
"of those 32-bit values have a special meaning), then the function is marked "
"as `unsafe`. We can see this in the example above when setting the `load` "
"and `compa` sub-fields using the `bits()` function."
msgstr ""

#: src/start/registers.md:94
msgid "Reading"
msgstr ""

#: src/start/registers.md:96
msgid ""
"The `read()` function returns an object which gives read-only access to the "
"various sub-fields within this register, as defined by the manufacturer's "
"SVD file for this chip. You can find all the functions available on special "
"`R` return type for this particular register, in this particular peripheral, "
"on this particular chip, in the [tm4c123x documentation](https://docs.rs/"
"tm4c123x/0.7.0/tm4c123x/pwm0/ctl/struct.R.html)."
msgstr ""

#: src/start/registers.md:100
msgid "// Do a thing\n"
msgstr ""

#: src/start/registers.md:104
msgid "Writing"
msgstr ""

#: src/start/registers.md:106
msgid ""
"The `write()` function takes a closure with a single argument. Typically we "
"call this `w`. This argument then gives read-write access to the various sub-"
"fields within this register, as defined by the manufacturer's SVD file for "
"this chip. Again, you can find all the functions available on the 'w' for "
"this particular register, in this particular peripheral, on this particular "
"chip, in the [tm4c123x documentation](https://docs.rs/tm4c123x/0.7.0/"
"tm4c123x/pwm0/ctl/struct.W.html). Note that all of the sub-fields that we do "
"not set will be set to a default value for us - any existing content in the "
"register will be lost."
msgstr ""

#: src/start/registers.md:112
msgid "Modifying"
msgstr ""

#: src/start/registers.md:114
msgid ""
"If we wish to change only one particular sub-field in this register and "
"leave the other sub-fields unchanged, we can use the `modify` function. This "
"function takes a closure with two arguments - one for reading and one for "
"writing. Typically we call these `r` and `w` respectively. The `r` argument "
"can be used to inspect the current contents of the register, and the `w` "
"argument can be used to modify the register contents."
msgstr ""

#: src/start/registers.md:120
msgid ""
"The `modify` function really shows the power of closures here. In C, we'd "
"have to read into some temporary value, modify the correct bits and then "
"write the value back. This means there's considerable scope for error:"
msgstr ""

#: src/start/registers.md:128
msgid "// Uh oh! Wrong variable!\n"
msgstr ""

#: src/start/registers.md:135
msgid "Using a HAL crate"
msgstr ""

#: src/start/registers.md:137
msgid ""
"The HAL crate for a chip typically works by implementing a custom Trait for "
"the raw structures exposed by the PAC. Often this trait will define a "
"function called `constrain()` for single peripherals or `split()` for things "
"like GPIO ports with multiple pins. This function will consume the "
"underlying raw peripheral structure and return a new object with a higher-"
"level API. This API may also do things like have the Serial port `new` "
"function require a borrow on some `Clock` structure, which can only be "
"generated by calling the function which configures the PLLs and sets up all "
"the clock frequencies. In this way, it is statically impossible to create a "
"Serial port object without first having configured the clock rates, or for "
"the Serial port object to misconvert the baud rate into clock ticks. Some "
"crates even define special traits for the states each GPIO pin can be in, "
"requiring the user to put a pin into the correct state (say, by selecting "
"the appropriate Alternate Function Mode) before passing the pin into "
"Peripheral. All with no run-time cost!"
msgstr ""

#: src/start/registers.md:139
msgid "Let's see an example:"
msgstr ""

#: src/start/registers.md:158
msgid "// Wrap up the SYSCTL struct into an object with a higher-layer API\n"
msgstr ""

#: src/start/registers.md:160
msgid "// Pick our oscillation settings\n"
msgstr ""

#: src/start/registers.md:165
msgid "// Configure the PLL with those settings\n"
msgstr ""

#: src/start/registers.md:168
msgid ""
"// Wrap up the GPIO_PORTA struct into an object with a higher-layer API.\n"
"    // Note it needs to borrow `sc.power_control` so it can power up the "
"GPIO\n"
"    // peripheral automatically.\n"
msgstr ""

#: src/start/registers.md:173
msgid "// Activate the UART.\n"
msgstr ""

#: src/start/registers.md:176
msgid "// The transmit pin\n"
msgstr ""

#: src/start/registers.md:180
msgid "// The receive pin\n"
msgstr ""

#: src/start/registers.md:184
msgid "// No RTS or CTS required\n"
msgstr ""

#: src/start/registers.md:187
msgid "// The baud rate\n"
msgstr ""

#: src/start/registers.md:189
msgid "// Output handling\n"
msgstr ""

#: src/start/registers.md:191
msgid "// We need the clock rates to calculate the baud rate divisors\n"
msgstr ""

#: src/start/registers.md:193
msgid "// We need this to power up the UART peripheral\n"
msgstr ""

#: src/start/registers.md:198
msgid "\"Hello, World!\\r\\n\""
msgstr ""

#: src/start/semihosting.md:3
msgid ""
"Semihosting is a mechanism that lets embedded devices do I/O on the host and "
"is mainly used to log messages to the host console. Semihosting requires a "
"debug session and pretty much nothing else (no extra wires!) so it's super "
"convenient to use. The downside is that it's super slow: each write "
"operation can take several milliseconds depending on the hardware debugger "
"(e.g. ST-Link) you use."
msgstr ""

#: src/start/semihosting.md:9
msgid ""
"The [`cortex-m-semihosting`](https://crates.io/crates/cortex-m-semihosting) "
"crate provides an API to do semihosting operations on Cortex-M devices. The "
"program below is the semihosting version of \"Hello, world!\":"
msgstr ""

#: src/start/semihosting.md:32
msgid ""
"If you run this program on hardware you'll see the \"Hello, world!\" message "
"within the OpenOCD logs."
msgstr ""

#: src/start/semihosting.md:42
msgid "You do need to enable semihosting in OpenOCD from GDB first:"
msgstr ""

#: src/start/semihosting.md:48
msgid ""
"QEMU understands semihosting operations so the above program will also work "
"with `qemu-system-arm` without having to start a debug session. Note that "
"you'll need to pass the `-semihosting-config` flag to QEMU to enable "
"semihosting support; these flags are already included in the `.cargo/"
"config.toml` file of the template."
msgstr ""

#: src/start/semihosting.md:61
msgid ""
"There's also an `exit` semihosting operation that can be used to terminate "
"the QEMU process. Important: do **not** use `debug::exit` on hardware; this "
"function can corrupt your OpenOCD session and you will not be able to debug "
"more programs until you restart it."
msgstr ""

#: src/start/semihosting.md:77 src/start/semihosting.md:115
msgid "\"blue\""
msgstr ""

#: src/start/semihosting.md:79 src/start/semihosting.md:117
msgid "\"red\""
msgstr ""

#: src/start/semihosting.md:97
msgid ""
"One last tip: you can set the panicking behavior to `exit(EXIT_FAILURE)`. "
"This will let you write `no_std` run-pass tests that you can run on QEMU."
msgstr ""

#: src/start/semihosting.md:100
msgid ""
"For convenience, the `panic-semihosting` crate has an \"exit\" feature that "
"when enabled invokes `exit(EXIT_FAILURE)` after logging the panic message to "
"the host stderr."
msgstr ""

#: src/start/semihosting.md:108
msgid "// features = [\"exit\"]\n"
msgstr ""

#: src/start/semihosting.md:123
msgid ""
"```text\n"
"$ cargo run\n"
"     Running `qemu-system-arm (..)\n"
"panicked at 'assertion failed: `(left == right)`\n"
"  left: `\"blue\"`,\n"
" right: `\"red\"`', examples/hello.rs:15:5\n"
"\n"
"$ echo $?\n"
"1\n"
"```"
msgstr ""

#: src/start/semihosting.md:134
msgid ""
"**NOTE**: To enable this feature on `panic-semihosting`, edit your "
"`Cargo.toml` dependencies section where `panic-semihosting` is specified "
"with:"
msgstr ""

#: src/start/semihosting.md:137
msgid ""
"```toml\n"
"panic-semihosting = { version = \"VERSION\", features = [\"exit\"] }\n"
"```"
msgstr ""

#: src/start/semihosting.md:141
msgid ""
"where `VERSION` is the version desired. For more information on dependencies "
"features check the [`specifying dependencies`](https://doc.rust-lang.org/"
"cargo/reference/specifying-dependencies.html) section of the Cargo book."
msgstr ""

#: src/start/panicking.md:3
msgid ""
"Panicking is a core part of the Rust language. Built-in operations like "
"indexing are runtime checked for memory safety. When out of bounds indexing "
"is attempted this results in a panic."
msgstr ""

#: src/start/panicking.md:7
msgid ""
"In the standard library panicking has a defined behavior: it unwinds the "
"stack of the panicking thread, unless the user opted for aborting the "
"program on panics."
msgstr ""

#: src/start/panicking.md:11
msgid ""
"In programs without standard library, however, the panicking behavior is "
"left undefined. A behavior can be chosen by declaring a `#[panic_handler]` "
"function. This function must appear exactly _once_ in the dependency graph "
"of a program, and must have the following signature: `fn(&PanicInfo) -> !`, "
"where [`PanicInfo`](https://doc.rust-lang.org/core/panic/"
"struct.PanicInfo.html) is a struct containing information about the location "
"of the panic."
msgstr ""

#: src/start/panicking.md:19
msgid ""
"Given that embedded systems range from user facing to safety critical "
"(cannot crash) there's no one size fits all panicking behavior but there are "
"plenty of commonly used behaviors. These common behaviors have been packaged "
"into crates that define the `#[panic_handler]` function. Some examples "
"include:"
msgstr ""

#: src/start/panicking.md:24
msgid ""
"[`panic-abort`](https://crates.io/crates/panic-abort). A panic causes the "
"abort instruction to be executed."
msgstr ""

#: src/start/panicking.md:25
msgid ""
"[`panic-halt`](https://crates.io/crates/panic-halt). A panic causes the "
"program, or the current thread, to halt by entering an infinite loop."
msgstr ""

#: src/start/panicking.md:27
msgid ""
"[`panic-itm`](https://crates.io/crates/panic-itm). The panicking message is "
"logged using the ITM, an ARM Cortex-M specific peripheral."
msgstr ""

#: src/start/panicking.md:29
msgid ""
"[`panic-semihosting`](https://crates.io/crates/panic-semihosting). The "
"panicking message is logged to the host using the semihosting technique."
msgstr ""

#: src/start/panicking.md:37
msgid ""
"You may be able to find even more crates searching for the [`panic-handler`]"
"(https://crates.io/keywords/panic-handler) keyword on crates.io."
msgstr ""

#: src/start/panicking.md:42
msgid ""
"A program can pick one of these behaviors simply by linking to the "
"corresponding crate. The fact that the panicking behavior is expressed in "
"the source of an application as a single line of code is not only useful as "
"documentation but can also be used to change the panicking behavior "
"according to the compilation profile. For example:"
msgstr ""

#: src/start/panicking.md:51
msgid ""
"// dev profile: easier to debug panics; can put a breakpoint on "
"`rust_begin_unwind`\n"
msgstr ""

#: src/start/panicking.md:55
msgid "// release profile: minimize the binary size of the application\n"
msgstr ""

#: src/start/panicking.md:59 src/start/exceptions.md:17
#: src/collections/index.md:132
msgid "// ..\n"
msgstr ""

#: src/start/panicking.md:63
msgid ""
"In this example the crate links to the `panic-halt` crate when built with "
"the dev profile (`cargo build`), but links to the `panic-abort` crate when "
"built with the release profile (`cargo build --release`)."
msgstr ""

#: src/start/panicking.md:67
msgid ""
"The `use panic_abort as _;` form of the `use` statement is used to ensure "
"the `panic_abort` panic handler is included in our final executable while "
"making it clear to the compiler that we won't explicitly use anything from "
"the crate. Without the `as _` rename, the compiler would warn that we have "
"an unused import. Sometimes you might see `extern crate panic_abort` "
"instead, which is an older style used before the 2018 edition of Rust, and "
"should now only be used for \"sysroot\" crates (those distributed with Rust "
"itself) such as `proc_macro`, `alloc`, `std`, and `test`."
msgstr ""

#: src/start/panicking.md:74
msgid "An example"
msgstr ""

#: src/start/panicking.md:76
msgid ""
"Here's an example that tries to index an array beyond its length. The "
"operation results in a panic."
msgstr ""

#: src/start/panicking.md:91
msgid "// out of bounds access\n"
msgstr ""

#: src/start/panicking.md:97
msgid ""
"This example chose the `panic-semihosting` behavior which prints the panic "
"message to the host console using semihosting."
msgstr ""

#: src/start/panicking.md:106
msgid ""
"You can try changing the behavior to `panic-halt` and confirm that no "
"message is printed in that case."
msgstr ""

#: src/start/exceptions.md:3
msgid ""
"Exceptions, and interrupts, are a hardware mechanism by which the processor "
"handles asynchronous events and fatal errors (e.g. executing an invalid "
"instruction). Exceptions imply preemption and involve exception handlers, "
"subroutines executed in response to the signal that triggered the event."
msgstr ""

#: src/start/exceptions.md:8
msgid ""
"The `cortex-m-rt` crate provides an [`exception`](https://docs.rs/cortex-m-"
"rt-macros/latest/cortex_m_rt_macros/attr.exception.html) attribute to "
"declare exception handlers."
msgstr ""

#: src/start/exceptions.md:14
msgid "// Exception handler for the SysTick (System Timer) exception\n"
msgstr ""

#: src/start/exceptions.md:21
msgid ""
"Other than the `exception` attribute exception handlers look like plain "
"functions but there's one more difference: `exception` handlers can _not_ be "
"called by software. Following the previous example, the statement "
"`SysTick();` would result in a compilation error."
msgstr ""

#: src/start/exceptions.md:26
msgid ""
"This behavior is pretty much intended and it's required to provide a "
"feature: `static mut` variables declared _inside_ `exception` handlers are "
"_safe_ to use."
msgstr ""

#: src/start/exceptions.md:34
msgid "// `COUNT` has transformed to type `&mut u32` and it's safe to use\n"
msgstr ""

#: src/start/exceptions.md:39
msgid ""
"As you may know, using `static mut` variables in a function makes it [_non-"
"reentrant_](https://en.wikipedia.org/wiki/Reentrancy_(computing)). It's "
"undefined behavior to call a non-reentrant function, directly or indirectly, "
"from more than one exception / interrupt handler or from `main` and one or "
"more exception / interrupt handlers."
msgstr ""

#: src/start/exceptions.md:44
msgid ""
"Safe Rust must never result in undefined behavior so non-reentrant functions "
"must be marked as `unsafe`. Yet I just told that `exception` handlers can "
"safely use `static mut` variables. How is this possible? This is possible "
"because `exception` handlers can _not_ be called by software thus reentrancy "
"is not possible. These handlers are called by the hardware itself which is "
"assumed to be physically non-concurrent."
msgstr ""

#: src/start/exceptions.md:50
msgid ""
"As a result, in the context of exception handlers in embedded systems, the "
"absence of concurrent invocations of the same handler ensures that there are "
"no reentrancy issues, even if the handler uses static mutable variables."
msgstr ""

#: src/start/exceptions.md:52
msgid ""
"In a multicore system, where multiple processor cores are executing code "
"concurrently, the potential for reentrancy issues becomes relevant again, "
"even within exception handlers. While each core may have its own set of "
"exception handlers, there can still be scenarios where multiple cores "
"attempt to execute the same exception handler simultaneously.  \n"
"To address this concern in a multicore environment, proper synchronization "
"mechanisms need to be employed within the exception handlers to ensure that "
"access to shared resources is properly coordinated among the cores. This "
"typically involves the use of techniques such as locks, semaphores, or "
"atomic operations to prevent data races and maintain data integrity"
msgstr ""

#: src/start/exceptions.md:55
msgid ""
"Note that the `exception` attribute transforms definitions of static "
"variables inside the function by wrapping them into `unsafe` blocks and "
"providing us with new appropriate variables of type `&mut` of the same name. "
"Thus we can dereference the reference via `*` to access the values of the "
"variables without needing to wrap them in an `unsafe` block."
msgstr ""

#: src/start/exceptions.md:61
msgid "A complete example"
msgstr ""

#: src/start/exceptions.md:63
msgid ""
"Here's an example that uses the system timer to raise a `SysTick` exception "
"roughly every second. The `SysTick` exception handler keeps track of how "
"many times it has been called in the `COUNT` variable and then prints the "
"value of `COUNT` to the host console using semihosting."
msgstr ""

#: src/start/exceptions.md:68
msgid ""
"**NOTE**: You can run this example on any Cortex-M device; you can also run "
"it on QEMU"
msgstr ""

#: src/start/exceptions.md:92
msgid ""
"// configures the system timer to trigger a SysTick exception every second\n"
msgstr ""

#: src/start/exceptions.md:94
msgid ""
"// this is configured for the LM3S6965 which has a default CPU clock of 12 "
"MHz\n"
msgstr ""

#: src/start/exceptions.md:110
msgid "// Lazy initialization\n"
msgstr ""

#: src/start/exceptions.md:116
msgid "\"{}\""
msgstr ""

#: src/start/exceptions.md:119
msgid ""
"// IMPORTANT omit this `if` block if running on real hardware or your\n"
"    // debugger will end in an inconsistent state\n"
msgstr ""

#: src/start/exceptions.md:122
msgid "// This will terminate the QEMU process\n"
msgstr ""

#: src/start/exceptions.md:132
msgid ""
"```toml\n"
"[dependencies]\n"
"cortex-m = \"0.5.7\"\n"
"cortex-m-rt = \"0.6.3\"\n"
"panic-halt = \"0.2.0\"\n"
"cortex-m-semihosting = \"0.3.1\"\n"
"```"
msgstr ""

#: src/start/exceptions.md:146
msgid ""
"If you run this on the Discovery board you'll see the output on the OpenOCD "
"console. Also, the program will _not_ stop when the count reaches 9."
msgstr ""

#: src/start/exceptions.md:149
msgid "The default exception handler"
msgstr ""

#: src/start/exceptions.md:151
msgid ""
"What the `exception` attribute actually does is _override_ the default "
"exception handler for a specific exception. If you don't override the "
"handler for a particular exception it will be handled by the "
"`DefaultHandler` function, which defaults to:"
msgstr ""

#: src/start/exceptions.md:162
msgid ""
"This function is provided by the `cortex-m-rt` crate and marked as "
"`#[no_mangle]` so you can put a breakpoint on \"DefaultHandler\" and catch "
"_unhandled_ exceptions."
msgstr ""

#: src/start/exceptions.md:166
msgid ""
"It's possible to override this `DefaultHandler` using the `exception` "
"attribute:"
msgstr ""

#: src/start/exceptions.md:171
msgid "// custom default handler\n"
msgstr ""

#: src/start/exceptions.md:175
msgid ""
"The `irqn` argument indicates which exception is being serviced. A negative "
"value indicates that a Cortex-M exception is being serviced; and zero or a "
"positive value indicate that a device specific exception, AKA interrupt, is "
"being serviced."
msgstr ""

#: src/start/exceptions.md:180
msgid "The hard fault handler"
msgstr ""

#: src/start/exceptions.md:182
msgid ""
"The `HardFault` exception is a bit special. This exception is fired when the "
"program enters an invalid state so its handler can _not_ return as that "
"could result in undefined behavior. Also, the runtime crate does a bit of "
"work before the user defined `HardFault` handler is invoked to improve "
"debuggability."
msgstr ""

#: src/start/exceptions.md:187
msgid ""
"The result is that the `HardFault` handler must have the following "
"signature: `fn(&ExceptionFrame) -> !`. The argument of the handler is a "
"pointer to registers that were pushed into the stack by the exception. These "
"registers are a snapshot of the processor state at the moment the exception "
"was triggered and are useful to diagnose a hard fault."
msgstr ""

#: src/start/exceptions.md:193
msgid ""
"Here's an example that performs an illegal operation: a read to a "
"nonexistent memory location."
msgstr ""

#: src/start/exceptions.md:196
msgid ""
"**NOTE**: This program won't work, i.e. it won't crash, on QEMU because "
"`qemu-system-arm -machine lm3s6965evb` doesn't check memory loads and will "
"happily return `0 `on reads to invalid memory."
msgstr ""

#: src/start/exceptions.md:214
msgid "// read a nonexistent memory location\n"
msgstr ""

#: src/start/exceptions.md:225
#: src/static-guarantees/typestate-programming.md:48
msgid "\"{:#?}\""
msgstr ""

#: src/start/exceptions.md:232
msgid ""
"The `HardFault` handler prints the `ExceptionFrame` value. If you run this "
"you'll see something like this on the OpenOCD console."
msgstr ""

#: src/start/exceptions.md:250
msgid ""
"The `pc` value is the value of the Program Counter at the time of the "
"exception and it points to the instruction that triggered the exception."
msgstr ""

#: src/start/exceptions.md:253
msgid "If you look at the disassembly of the program:"
msgstr ""

#: src/start/exceptions.md:266
msgid ""
"You can lookup the value of the program counter `0x0800094a` in the "
"disassembly. You'll see that a load operation (`ldr r0, [r0]` ) caused the "
"exception. The `r0` field of `ExceptionFrame` will tell you the value of "
"register `r0` was `0x3fff_fffe` at that time."
msgstr ""

#: src/start/interrupts.md:3
msgid ""
"Interrupts differ from exceptions in a variety of ways but their operation "
"and use is largely similar and they are also handled by the same interrupt "
"controller. Whereas exceptions are defined by the Cortex-M architecture, "
"interrupts are always vendor (and often even chip) specific implementations, "
"both in naming and functionality."
msgstr ""

#: src/start/interrupts.md:9
msgid ""
"Interrupts do allow for a lot of flexibility which needs to be accounted for "
"when attempting to use them in an advanced way. We will not cover those uses "
"in this book, however it is a good idea to keep the following in mind:"
msgstr ""

#: src/start/interrupts.md:13
msgid ""
"Interrupts have programmable priorities which determine their handlers' "
"execution order"
msgstr ""

#: src/start/interrupts.md:14
msgid ""
"Interrupts can nest and preempt, i.e. execution of an interrupt handler "
"might be interrupted by another higher-priority interrupt"
msgstr ""

#: src/start/interrupts.md:15
msgid ""
"In general the reason causing the interrupt to trigger needs to be cleared "
"to prevent re-entering the interrupt handler endlessly"
msgstr ""

#: src/start/interrupts.md:17
msgid "The general initialization steps at runtime are always the same:"
msgstr ""

#: src/start/interrupts.md:18
msgid ""
"Setup the peripheral(s) to generate interrupts requests at the desired "
"occasions"
msgstr ""

#: src/start/interrupts.md:19
msgid ""
"Set the desired priority of the interrupt handler in the interrupt controller"
msgstr ""

#: src/start/interrupts.md:20
msgid "Enable the interrupt handler in the interrupt controller"
msgstr ""

#: src/start/interrupts.md:22
msgid ""
"Similarly to exceptions, the `cortex-m-rt` crate provides an [`interrupt`]"
"(https://docs.rs/cortex-m-rt-macros/0.1.5/cortex_m_rt_macros/"
"attr.interrupt.html) attribute to declare interrupt handlers. The available "
"interrupts (and their position in the interrupt handler table) are usually "
"automatically generated via `svd2rust` from a SVD description."
msgstr ""

#: src/start/interrupts.md:30
msgid "// Interrupt handler for the Timer2 interrupt\n"
msgstr ""

#: src/start/interrupts.md:33
msgid ""
"// ..\n"
"    // Clear reason for the generated interrupt request\n"
msgstr ""

#: src/start/interrupts.md:38
msgid ""
"Interrupt handlers look like plain functions (except for the lack of "
"arguments) similar to exception handlers. However they can not be called "
"directly by other parts of the firmware due to the special calling "
"conventions. It is however possible to generate interrupt requests in "
"software to trigger a diversion to the interrupt handler."
msgstr ""

#: src/start/interrupts.md:44
msgid ""
"Similar to exception handlers it is also possible to declare `static mut` "
"variables inside the interrupt handlers for _safe_ state keeping."
msgstr ""

#: src/start/interrupts.md:52
msgid "// `COUNT` has type `&mut u32` and it's safe to use\n"
msgstr ""

#: src/start/interrupts.md:57
msgid ""
"For a more detailed description about the mechanisms demonstrated here "
"please refer to the [exceptions section](./exceptions.md)."
msgstr ""

#: src/start/io.md:3
msgid "**TODO** Cover memory mapped I/O using registers."
msgstr ""

#: src/peripherals/index.md:3
msgid "What are Peripherals?"
msgstr ""

#: src/peripherals/index.md:5
msgid ""
"Most Microcontrollers have more than just a CPU, RAM, or Flash Memory - they "
"contain sections of silicon which are used for interacting with systems "
"outside of the microcontroller, as well as directly and indirectly "
"interacting with their surroundings in the world via sensors, motor "
"controllers, or human interfaces such as a display or keyboard. These "
"components are collectively known as Peripherals."
msgstr ""

#: src/peripherals/index.md:7
msgid ""
"These peripherals are useful because they allow a developer to offload "
"processing to them, avoiding having to handle everything in software. "
"Similar to how a desktop developer would offload graphics processing to a "
"video card, embedded developers can offload some tasks to peripherals "
"allowing the CPU to spend its time doing something else important, or doing "
"nothing in order to save power."
msgstr ""

#: src/peripherals/index.md:9
msgid ""
"If you look at the main circuit board in an old-fashioned home computer from "
"the 1970s or 1980s (and actually, the desktop PCs of yesterday are not so "
"far removed from the embedded systems of today) you would expect to see:"
msgstr ""

#: src/peripherals/index.md:11
msgid "A processor"
msgstr ""

#: src/peripherals/index.md:12
msgid "A RAM chip"
msgstr ""

#: src/peripherals/index.md:13
msgid "A ROM chip"
msgstr ""

#: src/peripherals/index.md:14
msgid "An I/O controller"
msgstr ""

#: src/peripherals/index.md:16
msgid ""
"The RAM chip, ROM chip and I/O controller (the peripheral in this system) "
"would be joined to the processor through a series of parallel traces known "
"as a 'bus'. This bus carries address information, which selects which device "
"on the bus the processor wishes to communicate with, and a data bus which "
"carries the actual data. In our embedded microcontrollers, the same "
"principles apply - it's just that everything is packed on to a single piece "
"of silicon."
msgstr ""

#: src/peripherals/index.md:18
msgid ""
"However, unlike graphics cards, which typically have a Software API like "
"Vulkan, Metal, or OpenGL, peripherals are exposed to our Microcontroller "
"with a hardware interface, which is mapped to a chunk of the memory."
msgstr ""

#: src/peripherals/index.md:20
msgid "Linear and Real Memory Space"
msgstr ""

#: src/peripherals/index.md:22
msgid ""
"On a microcontroller, writing some data to some other arbitrary address, "
"such as `0x4000_0000` or `0x0000_0000`, may also be a completely valid "
"action."
msgstr ""

#: src/peripherals/index.md:24
msgid ""
"On a desktop system, access to memory is tightly controlled by the MMU, or "
"Memory Management Unit. This component has two major responsibilities: "
"enforcing access permission to sections of memory (preventing one process "
"from reading or modifying the memory of another process); and re-mapping "
"segments of the physical memory to virtual memory ranges used in software. "
"Microcontrollers do not typically have an MMU, and instead only use real "
"physical addresses in software."
msgstr ""

#: src/peripherals/index.md:26
msgid ""
"Although 32 bit microcontrollers have a real and linear address space from "
"`0x0000_0000`, and `0xFFFF_FFFF`, they generally only use a few hundred "
"kilobytes of that range for actual memory. This leaves a significant amount "
"of address space remaining. In earlier chapters, we were talking about RAM "
"being located at address `0x2000_0000`. If our RAM was 64 KiB long (i.e. "
"with a maximum address of 0xFFFF) then addresses `0x2000_0000` to "
"`0x2000_FFFF` would correspond to our RAM. When we write to a variable which "
"lives at address `0x2000_1234`, what happens internally is that some logic "
"detects the upper portion of the address (0x2000 in this example) and then "
"activates the RAM so that it can act upon the lower portion of the address "
"(0x1234 in this case). On a Cortex-M we also have our Flash ROM mapped in at "
"address `0x0000_0000` up to, say, address `0x0007_FFFF` (if we have a 512 "
"KiB Flash ROM). Rather than ignore all remaining space between these two "
"regions, Microcontroller designers instead mapped the interface for "
"peripherals in certain memory locations. This ends up looking something like "
"this:"
msgstr ""

#: src/peripherals/index.md:28
msgid "![](../assets/nrf52-memory-map.png)"
msgstr ""

#: src/peripherals/index.md:30 src/peripherals/index.md:40
msgid ""
"[Nordic nRF52832 Datasheet (pdf)](http://infocenter.nordicsemi.com/pdf/"
"nRF52832_PS_v1.1.pdf)"
msgstr ""

#: src/peripherals/index.md:34
msgid ""
"Interaction with these peripherals is simple at a first glance - write the "
"right data to the correct address. For example, sending a 32 bit word over a "
"serial port could be as direct as writing that 32 bit word to a certain "
"memory address. The Serial Port Peripheral would then take over and send out "
"the data automatically."
msgstr ""

#: src/peripherals/index.md:36
msgid ""
"Configuration of these peripherals works similarly. Instead of calling a "
"function to configure a peripheral, a chunk of memory is exposed which "
"serves as the hardware API. Write `0x8000_0000` to a SPI Frequency "
"Configuration Register, and the SPI port will send data at 8 Megabits per "
"second. Write `0x0200_0000` to the same address, and the SPI port will send "
"data at 125 Kilobits per second. These configuration registers look a little "
"bit like this:"
msgstr ""

#: src/peripherals/index.md:38
msgid "![](../assets/nrf52-spi-frequency-register.png)"
msgstr ""

#: src/peripherals/index.md:42
msgid ""
"This interface is how interactions with the hardware are made, no matter "
"what language is used, whether that language is Assembly, C, or Rust."
msgstr ""

#: src/peripherals/a-first-attempt.md:1
msgid "A First Attempt"
msgstr ""

#: src/peripherals/a-first-attempt.md:3
msgid "The Registers"
msgstr ""

#: src/peripherals/a-first-attempt.md:5
msgid ""
"Let's look at the 'SysTick' peripheral - a simple timer which comes with "
"every Cortex-M processor core. Typically you'll be looking these up in the "
"chip manufacturer's data sheet or _Technical Reference Manual_, but this "
"example is common to all ARM Cortex-M cores, let's look in the [ARM "
"reference manual](http://infocenter.arm.com/help/topic/com.arm.doc.dui0553a/"
"Babieigh.html). We see there are four registers:"
msgstr ""

#: src/peripherals/a-first-attempt.md:9
msgid "Offset"
msgstr ""

#: src/peripherals/a-first-attempt.md:9
#: src/static-guarantees/state-machines.md:40
#: src/static-guarantees/design-contracts.md:5
msgid "Name"
msgstr ""

#: src/peripherals/a-first-attempt.md:9
msgid "Width"
msgstr ""

#: src/peripherals/a-first-attempt.md:11
msgid "0x00"
msgstr ""

#: src/peripherals/a-first-attempt.md:11
msgid "SYST_CSR"
msgstr ""

#: src/peripherals/a-first-attempt.md:11
msgid "Control and Status Register"
msgstr ""

#: src/peripherals/a-first-attempt.md:11 src/peripherals/a-first-attempt.md:12
#: src/peripherals/a-first-attempt.md:13 src/peripherals/a-first-attempt.md:14
msgid "32 bits"
msgstr ""

#: src/peripherals/a-first-attempt.md:12
msgid "0x04"
msgstr ""

#: src/peripherals/a-first-attempt.md:12
msgid "SYST_RVR"
msgstr ""

#: src/peripherals/a-first-attempt.md:12
msgid "Reload Value Register"
msgstr ""

#: src/peripherals/a-first-attempt.md:13
msgid "0x08"
msgstr ""

#: src/peripherals/a-first-attempt.md:13
msgid "SYST_CVR"
msgstr ""

#: src/peripherals/a-first-attempt.md:13
msgid "Current Value Register"
msgstr ""

#: src/peripherals/a-first-attempt.md:14
msgid "0x0C"
msgstr ""

#: src/peripherals/a-first-attempt.md:14
msgid "SYST_CALIB"
msgstr ""

#: src/peripherals/a-first-attempt.md:14
msgid "Calibration Value Register"
msgstr ""

#: src/peripherals/a-first-attempt.md:16
msgid "The C Approach"
msgstr ""

#: src/peripherals/a-first-attempt.md:18
msgid ""
"In Rust, we can represent a collection of registers in exactly the same way "
"as we do in C - with a `struct`."
msgstr ""

#: src/peripherals/a-first-attempt.md:30
msgid ""
"The qualifier `#[repr(C)]` tells the Rust compiler to lay this structure out "
"like a C compiler would. That's very important, as Rust allows structure "
"fields to be re-ordered, while C does not. You can imagine the debugging "
"we'd have to do if these fields were silently re-arranged by the compiler! "
"With this qualifier in place, we have our four 32-bit fields which "
"correspond to the table above. But of course, this `struct` is of no use by "
"itself - we need a variable."
msgstr ""

#: src/peripherals/a-first-attempt.md:37
msgid "Volatile Accesses"
msgstr ""

#: src/peripherals/a-first-attempt.md:39
msgid "Now, there are a couple of problems with the approach above."
msgstr ""

#: src/peripherals/a-first-attempt.md:41
msgid "We have to use unsafe every time we want to access our Peripheral."
msgstr ""

#: src/peripherals/a-first-attempt.md:42
msgid ""
"We've got no way of specifying which registers are read-only or read-write."
msgstr ""

#: src/peripherals/a-first-attempt.md:43
msgid ""
"Any piece of code anywhere in your program could access the hardware through "
"this structure."
msgstr ""

#: src/peripherals/a-first-attempt.md:45
msgid "Most importantly, it doesn't actually work..."
msgstr ""

#: src/peripherals/a-first-attempt.md:47
msgid ""
"Now, the problem is that compilers are clever. If you make two writes to the "
"same piece of RAM, one after the other, the compiler can notice this and "
"just skip the first write entirely. In C, we can mark variables as "
"`volatile` to ensure that every read or write occurs as intended. In Rust, "
"we instead mark the _accesses_ as volatile, not the variable."
msgstr ""

#: src/peripherals/a-first-attempt.md:54
msgid ""
"So, we've fixed one of our four problems, but now we have even more `unsafe` "
"code! Fortunately, there's a third party crate which can help - "
"[`volatile_register`](https://crates.io/crates/volatile_register)."
msgstr ""

#: src/peripherals/a-first-attempt.md:79
msgid ""
"Now, the volatile accesses are performed automatically through the `read` "
"and `write` methods. It's still `unsafe` to perform writes, but to be fair, "
"hardware is a bunch of mutable state and there's no way for the compiler to "
"know whether these writes are actually safe, so this is a good default "
"position."
msgstr ""

#: src/peripherals/a-first-attempt.md:81
msgid "The Rusty Wrapper"
msgstr ""

#: src/peripherals/a-first-attempt.md:83
msgid ""
"We need to wrap this `struct` up into a higher-layer API that is safe for "
"our users to call. As the driver author, we manually verify the unsafe code "
"is correct, and then present a safe API for our users so they don't have to "
"worry about it (provided they trust us to get it right!)."
msgstr ""

#: src/peripherals/a-first-attempt.md:85
msgid "One example might be:"
msgstr ""

#: src/peripherals/a-first-attempt.md:121
msgid "\"Time is now 0x{:08x}\""
msgstr ""

#: src/peripherals/a-first-attempt.md:125
msgid ""
"Now, the problem with this approach is that the following code is perfectly "
"acceptable to the compiler:"
msgstr ""

#: src/peripherals/a-first-attempt.md:139
msgid ""
"Our `&mut self` argument to the `set_reload` function checks that there are "
"no other references to _that_ particular `SystemTimer` struct, but they "
"don't stop the user creating a second `SystemTimer` which points to the "
"exact same peripheral! Code written in this fashion will work if the author "
"is diligent enough to spot all of these 'duplicate' driver instances, but "
"once the code is spread out over multiple modules, drivers, developers, and "
"days, it gets easier and easier to make these kinds of mistakes."
msgstr ""

#: src/peripherals/borrowck.md:1
msgid "Mutable Global State"
msgstr ""

#: src/peripherals/borrowck.md:3
msgid ""
"Unfortunately, hardware is basically nothing but mutable global state, which "
"can feel very frightening for a Rust developer. Hardware exists "
"independently from the structures of the code we write, and can be modified "
"at any time by the real world."
msgstr ""

#: src/peripherals/borrowck.md:5
msgid "What should our rules be?"
msgstr ""

#: src/peripherals/borrowck.md:7
msgid "How can we reliably interact with these peripherals?"
msgstr ""

#: src/peripherals/borrowck.md:9
msgid ""
"Always use `volatile` methods to read or write to peripheral memory, as it "
"can change at any time"
msgstr ""

#: src/peripherals/borrowck.md:10
msgid ""
"In software, we should be able to share any number of read-only accesses to "
"these peripherals"
msgstr ""

#: src/peripherals/borrowck.md:11
msgid ""
"If some software should have read-write access to a peripheral, it should "
"hold the only reference to that peripheral"
msgstr ""

#: src/peripherals/borrowck.md:15
msgid ""
"The last two of these rules sound suspiciously similar to what the Borrow "
"Checker does already!"
msgstr ""

#: src/peripherals/borrowck.md:17
msgid ""
"Imagine if we could pass around ownership of these peripherals, or offer "
"immutable or mutable references to them?"
msgstr ""

#: src/peripherals/borrowck.md:19
msgid ""
"Well, we can, but for the Borrow Checker, we need to have exactly one "
"instance of each peripheral, so Rust can handle this correctly. Well, "
"luckily in the hardware, there is only one instance of any given peripheral, "
"but how can we expose that in the structure of our code?"
msgstr ""

#: src/peripherals/singletons.md:3
msgid ""
"In software engineering, the singleton pattern is a software design pattern "
"that restricts the instantiation of a class to one object."
msgstr ""

#: src/peripherals/singletons.md:5
msgid ""
"_Wikipedia: [Singleton Pattern](https://en.wikipedia.org/wiki/"
"Singleton_pattern)_"
msgstr ""

#: src/peripherals/singletons.md:10
msgid "But why can't we just use global variable(s)?"
msgstr ""

#: src/peripherals/singletons.md:12
msgid "We could make everything a public static, like this"
msgstr ""

#: src/peripherals/singletons.md:24
msgid ""
"But this has a few problems. It is a mutable global variable, and in Rust, "
"these are always unsafe to interact with. These variables are also visible "
"across your whole program, which means the borrow checker is unable to help "
"you track references and ownership of these variables."
msgstr ""

#: src/peripherals/singletons.md:26
msgid "How do we do this in Rust?"
msgstr ""

#: src/peripherals/singletons.md:28
msgid ""
"Instead of just making our peripheral a global variable, we might instead "
"decide to make a structure, in this case called `PERIPHERALS`, which "
"contains an `Option<T>` for each of our peripherals."
msgstr ""

#: src/peripherals/singletons.md:45
msgid ""
"This structure allows us to obtain a single instance of our peripheral. If "
"we try to call `take_serial()` more than once, our code will panic!"
msgstr ""

#: src/peripherals/singletons.md:50
msgid ""
"// This panics!\n"
"    // let serial_2 = unsafe { PERIPHERALS.take_serial() };\n"
msgstr ""

#: src/peripherals/singletons.md:55
msgid ""
"Although interacting with this structure is `unsafe`, once we have the "
"`SerialPort` it contained, we no longer need to use `unsafe`, or the "
"`PERIPHERALS` structure at all."
msgstr ""

#: src/peripherals/singletons.md:57
msgid ""
"This has a small runtime overhead because we must wrap the `SerialPort` "
"structure in an option, and we'll need to call `take_serial()` once, however "
"this small up-front cost allows us to leverage the borrow checker throughout "
"the rest of our program."
msgstr ""

#: src/peripherals/singletons.md:59
msgid "Existing library support"
msgstr ""

#: src/peripherals/singletons.md:61
msgid ""
"Although we created our own `Peripherals` structure above, it is not "
"necessary to do this for your code. the `cortex_m` crate contains a macro "
"called `singleton!()` that will perform this action for you."
msgstr ""

#: src/peripherals/singletons.md:67
msgid "// OK if `main` is executed only once\n"
msgstr ""

#: src/peripherals/singletons.md:73
msgid ""
"[cortex_m docs](https://docs.rs/cortex-m/latest/cortex_m/"
"macro.singleton.html)"
msgstr ""

#: src/peripherals/singletons.md:75
msgid ""
"Additionally, if you use [`cortex-m-rtic`](https://github.com/rtic-rs/cortex-"
"m-rtic), the entire process of defining and obtaining these peripherals are "
"abstracted for you, and you are instead handed a `Peripherals` structure "
"that contains a non-`Option<T>` version of all of the items you define."
msgstr ""

#: src/peripherals/singletons.md:78
msgid "// cortex-m-rtic v0.5.x\n"
msgstr ""

#: src/peripherals/singletons.md:85
msgid "// Cortex-M peripherals\n"
msgstr ""

#: src/peripherals/singletons.md:88
msgid "// Device specific peripherals\n"
msgstr ""

#: src/peripherals/singletons.md:94
msgid "But why?"
msgstr ""

#: src/peripherals/singletons.md:96
msgid ""
"But how do these Singletons make a noticeable difference in how our Rust "
"code works?"
msgstr ""

#: src/peripherals/singletons.md:103
msgid "// <------ This is really, really important\n"
msgstr ""

#: src/peripherals/singletons.md:112
msgid "There are two important factors in play here:"
msgstr ""

#: src/peripherals/singletons.md:114
msgid ""
"Because we are using a singleton, there is only one way or place to obtain a "
"`SerialPort` structure"
msgstr ""

#: src/peripherals/singletons.md:115
msgid ""
"To call the `read_speed()` method, we must have ownership or a reference to "
"a `SerialPort` structure"
msgstr ""

#: src/peripherals/singletons.md:117
msgid ""
"These two factors put together means that it is only possible to access the "
"hardware if we have appropriately satisfied the borrow checker, meaning that "
"at no point do we have multiple mutable references to the same hardware!"
msgstr ""

#: src/peripherals/singletons.md:121
msgid ""
"// missing reference to `self`! Won't work.\n"
"    // SerialPort::read_speed();\n"
msgstr ""

#: src/peripherals/singletons.md:126
msgid "// you can only read what you have access to\n"
msgstr ""

#: src/peripherals/singletons.md:131
msgid "Treat your hardware like data"
msgstr ""

#: src/peripherals/singletons.md:133
msgid ""
"Additionally, because some references are mutable, and some are immutable, "
"it becomes possible to see whether a function or method could potentially "
"modify the state of the hardware. For example,"
msgstr ""

#: src/peripherals/singletons.md:135
msgid "This is allowed to change hardware settings:"
msgstr ""

#: src/peripherals/singletons.md:142 src/peripherals/singletons.md:150
#: src/design-patterns/hal/gpio.md:17 src/design-patterns/hal/gpio.md:27
#: src/design-patterns/hal/gpio.md:35 src/design-patterns/hal/gpio.md:138
msgid "// ...\n"
msgstr ""

#: src/peripherals/singletons.md:146
msgid "This isn't:"
msgstr ""

#: src/peripherals/singletons.md:154
msgid ""
"This allows us to enforce whether code should or should not make changes to "
"hardware at **compile time**, rather than at runtime. As a note, this "
"generally only works across one application, but for bare metal systems, our "
"software will be compiled into a single application, so this is not usually "
"a restriction."
msgstr ""

#: src/static-guarantees/index.md:3
msgid ""
"Rust's type system prevents data races at compile time (see [`Send`](https://"
"doc.rust-lang.org/core/marker/trait.Send.html) and [`Sync`](https://doc.rust-"
"lang.org/core/marker/trait.Sync.html) traits). The type system can also be "
"used to check other properties at compile time; reducing the need for "
"runtime checks in some cases."
msgstr ""

#: src/static-guarantees/index.md:10
msgid ""
"When applied to embedded programs these _static checks_ can be used, for "
"example, to enforce that configuration of I/O interfaces is done properly. "
"For instance, one can design an API where it is only possible to initialize "
"a serial interface by first configuring the pins that will be used by the "
"interface."
msgstr ""

#: src/static-guarantees/index.md:15
msgid ""
"One can also statically check that operations, like setting a pin low, can "
"only be performed on correctly configured peripherals. For example, trying "
"to change the output state of a pin configured in floating input mode would "
"raise a compile error."
msgstr ""

#: src/static-guarantees/index.md:20
msgid ""
"And, as seen in the previous chapter, the concept of ownership can be "
"applied to peripherals to ensure that only certain parts of a program can "
"modify a peripheral. This _access control_ makes software easier to reason "
"about compared to the alternative of treating peripherals as global mutable "
"state."
msgstr ""

#: src/static-guarantees/typestate-programming.md:3
msgid ""
"The concept of [typestates](https://en.wikipedia.org/wiki/"
"Typestate_analysis) describes the encoding of information about the current "
"state of an object into the type of that object. Although this can sound a "
"little arcane, if you have used the [Builder Pattern](https://doc.rust-"
"lang.org/1.0.0/style/ownership/builders.html) in Rust, you have already "
"started using Typestate Programming!"
msgstr ""

#: src/static-guarantees/typestate-programming.md:52
msgid ""
"In this example, there is no direct way to create a `Foo` object. We must "
"create a `FooBuilder`, and properly initialize it before we can obtain the "
"`Foo` object we want."
msgstr ""

#: src/static-guarantees/typestate-programming.md:54
msgid "This minimal example encodes two states:"
msgstr ""

#: src/static-guarantees/typestate-programming.md:56
msgid ""
"`FooBuilder`, which represents an \"unconfigured\", or \"configuration in "
"process\" state"
msgstr ""

#: src/static-guarantees/typestate-programming.md:57
msgid "`Foo`, which represents a \"configured\", or \"ready to use\" state."
msgstr ""

#: src/static-guarantees/typestate-programming.md:59
msgid "Strong Types"
msgstr ""

#: src/static-guarantees/typestate-programming.md:61
msgid ""
"Because Rust has a [Strong Type System](https://en.wikipedia.org/wiki/"
"Strong_and_weak_typing), there is no easy way to magically create an "
"instance of `Foo`, or to turn a `FooBuilder` into a `Foo` without calling "
"the `into_foo()` method. Additionally, calling the `into_foo()` method "
"consumes the original `FooBuilder` structure, meaning it can not be reused "
"without the creation of a new instance."
msgstr ""

#: src/static-guarantees/typestate-programming.md:65
msgid ""
"This allows us to represent the states of our system as types, and to "
"include the necessary actions for state transitions into the methods that "
"exchange one type for another. By creating a `FooBuilder`, and exchanging it "
"for a `Foo` object, we have walked through the steps of a basic state "
"machine."
msgstr ""

#: src/static-guarantees/state-machines.md:3
msgid ""
"The peripherals of a microcontroller can be thought of as set of state "
"machines. For example, the configuration of a simplified [GPIO pin](https://"
"en.wikipedia.org/wiki/General-purpose_input/output) could be represented as "
"the following tree of states:"
msgstr ""

#: src/static-guarantees/state-machines.md:7
#: src/static-guarantees/state-machines.md:19
msgid "Disabled"
msgstr ""

#: src/static-guarantees/state-machines.md:8
#: src/static-guarantees/state-machines.md:20
msgid "Enabled"
msgstr ""

#: src/static-guarantees/state-machines.md:9
#: src/static-guarantees/state-machines.md:33
msgid "Configured as Output"
msgstr ""

#: src/static-guarantees/state-machines.md:10
#: src/static-guarantees/state-machines.md:34
msgid "Output: High"
msgstr ""

#: src/static-guarantees/state-machines.md:11
msgid "Output: Low"
msgstr ""

#: src/static-guarantees/state-machines.md:12
#: src/static-guarantees/state-machines.md:21
#: src/static-guarantees/state-machines.md:32
msgid "Configured as Input"
msgstr ""

#: src/static-guarantees/state-machines.md:13
#: src/static-guarantees/state-machines.md:22
#: src/static-guarantees/state-machines.md:26
msgid "Input: High Resistance"
msgstr ""

#: src/static-guarantees/state-machines.md:14
#: src/static-guarantees/state-machines.md:27
#: src/static-guarantees/state-machines.md:31
msgid "Input: Pulled Low"
msgstr ""

#: src/static-guarantees/state-machines.md:15
msgid "Input: Pulled High"
msgstr ""

#: src/static-guarantees/state-machines.md:17
msgid ""
"If the peripheral starts in the `Disabled` mode, to move to the `Input: High "
"Resistance` mode, we must perform the following steps:"
msgstr ""

#: src/static-guarantees/state-machines.md:24
msgid ""
"If we wanted to move from `Input: High Resistance` to `Input: Pulled Low`, "
"we must perform the following steps:"
msgstr ""

#: src/static-guarantees/state-machines.md:29
msgid ""
"Similarly, if we want to move a GPIO pin from configured as `Input: Pulled "
"Low` to `Output: High`, we must perform the following steps:"
msgstr ""

#: src/static-guarantees/state-machines.md:36
msgid "Hardware Representation"
msgstr ""

#: src/static-guarantees/state-machines.md:38
msgid ""
"Typically the states listed above are set by writing values to given "
"registers mapped to a GPIO peripheral. Let's define an imaginary GPIO "
"Configuration Register to illustrate this:"
msgstr ""

#: src/static-guarantees/state-machines.md:40
#: src/static-guarantees/design-contracts.md:5
msgid "Bit Number(s)"
msgstr ""

#: src/static-guarantees/state-machines.md:40
#: src/static-guarantees/design-contracts.md:5
msgid "Value"
msgstr ""

#: src/static-guarantees/state-machines.md:40
#: src/static-guarantees/design-contracts.md:5
msgid "Meaning"
msgstr ""

#: src/static-guarantees/state-machines.md:40
#: src/static-guarantees/design-contracts.md:5
msgid "Notes"
msgstr ""

#: src/static-guarantees/state-machines.md:42
#: src/static-guarantees/design-contracts.md:7
msgid "enable"
msgstr ""

#: src/static-guarantees/state-machines.md:42
#: src/static-guarantees/state-machines.md:44
#: src/static-guarantees/state-machines.md:50
#: src/static-guarantees/design-contracts.md:7
#: src/static-guarantees/design-contracts.md:9
#: src/static-guarantees/design-contracts.md:15
msgid "0"
msgstr ""

#: src/static-guarantees/state-machines.md:42
#: src/static-guarantees/design-contracts.md:7
msgid "disabled"
msgstr ""

#: src/static-guarantees/state-machines.md:42
#: src/static-guarantees/design-contracts.md:7
msgid "Disables the GPIO"
msgstr ""

#: src/static-guarantees/state-machines.md:43
#: src/static-guarantees/state-machines.md:44
#: src/static-guarantees/state-machines.md:45
#: src/static-guarantees/state-machines.md:51
#: src/static-guarantees/design-contracts.md:8
#: src/static-guarantees/design-contracts.md:9
#: src/static-guarantees/design-contracts.md:10
#: src/static-guarantees/design-contracts.md:16
msgid "1"
msgstr ""

#: src/static-guarantees/state-machines.md:43
#: src/static-guarantees/design-contracts.md:8
msgid "enabled"
msgstr ""

#: src/static-guarantees/state-machines.md:43
#: src/static-guarantees/design-contracts.md:8
msgid "Enables the GPIO"
msgstr ""

#: src/static-guarantees/state-machines.md:44
#: src/static-guarantees/design-contracts.md:9
msgid "direction"
msgstr ""

#: src/static-guarantees/state-machines.md:44
#: src/static-guarantees/design-contracts.md:9
msgid "input"
msgstr ""

#: src/static-guarantees/state-machines.md:44
#: src/static-guarantees/design-contracts.md:9
msgid "Sets the direction to Input"
msgstr ""

#: src/static-guarantees/state-machines.md:45
#: src/static-guarantees/design-contracts.md:10
msgid "output"
msgstr ""

#: src/static-guarantees/state-machines.md:45
#: src/static-guarantees/design-contracts.md:10
msgid "Sets the direction to Output"
msgstr ""

#: src/static-guarantees/state-machines.md:46
#: src/static-guarantees/design-contracts.md:11
msgid "input_mode"
msgstr ""

#: src/static-guarantees/state-machines.md:46
#: src/static-guarantees/design-contracts.md:11
msgid "2..3"
msgstr ""

#: src/static-guarantees/state-machines.md:46
#: src/static-guarantees/design-contracts.md:11
msgid "00"
msgstr ""

#: src/static-guarantees/state-machines.md:46
#: src/static-guarantees/design-contracts.md:11
msgid "hi-z"
msgstr ""

#: src/static-guarantees/state-machines.md:46
#: src/static-guarantees/design-contracts.md:11
msgid "Sets the input as high resistance"
msgstr ""

#: src/static-guarantees/state-machines.md:47
#: src/static-guarantees/design-contracts.md:12
msgid "01"
msgstr ""

#: src/static-guarantees/state-machines.md:47
#: src/static-guarantees/design-contracts.md:12
msgid "pull-low"
msgstr ""

#: src/static-guarantees/state-machines.md:47
#: src/static-guarantees/design-contracts.md:12
msgid "Input pin is pulled low"
msgstr ""

#: src/static-guarantees/state-machines.md:48
#: src/static-guarantees/design-contracts.md:13
msgid "10"
msgstr ""

#: src/static-guarantees/state-machines.md:48
#: src/static-guarantees/design-contracts.md:13
msgid "pull-high"
msgstr ""

#: src/static-guarantees/state-machines.md:48
#: src/static-guarantees/design-contracts.md:13
msgid "Input pin is pulled high"
msgstr ""

#: src/static-guarantees/state-machines.md:49
#: src/static-guarantees/design-contracts.md:14
msgid "11"
msgstr ""

#: src/static-guarantees/state-machines.md:49
#: src/static-guarantees/design-contracts.md:14
msgid "n/a"
msgstr ""

#: src/static-guarantees/state-machines.md:49
#: src/static-guarantees/design-contracts.md:14
msgid "Invalid state. Do not set"
msgstr ""

#: src/static-guarantees/state-machines.md:50
#: src/static-guarantees/design-contracts.md:15
msgid "output_mode"
msgstr ""

#: src/static-guarantees/state-machines.md:50
#: src/static-guarantees/design-contracts.md:15
msgid "4"
msgstr ""

#: src/static-guarantees/state-machines.md:50
#: src/static-guarantees/design-contracts.md:15
msgid "set-low"
msgstr ""

#: src/static-guarantees/state-machines.md:50
#: src/static-guarantees/design-contracts.md:15
msgid "Output pin is driven low"
msgstr ""

#: src/static-guarantees/state-machines.md:51
#: src/static-guarantees/design-contracts.md:16
msgid "set-high"
msgstr ""

#: src/static-guarantees/state-machines.md:51
#: src/static-guarantees/design-contracts.md:16
msgid "Output pin is driven high"
msgstr ""

#: src/static-guarantees/state-machines.md:52
#: src/static-guarantees/design-contracts.md:17
msgid "input_status"
msgstr ""

#: src/static-guarantees/state-machines.md:52
#: src/static-guarantees/design-contracts.md:17
msgid "5"
msgstr ""

#: src/static-guarantees/state-machines.md:52
#: src/static-guarantees/design-contracts.md:17
msgid "x"
msgstr ""

#: src/static-guarantees/state-machines.md:52
#: src/static-guarantees/design-contracts.md:17
msgid "in-val"
msgstr ""

#: src/static-guarantees/state-machines.md:52
#: src/static-guarantees/design-contracts.md:17
msgid "0 if input is \\< 1.5v, 1 if input >= 1.5v"
msgstr ""

#: src/static-guarantees/state-machines.md:54
msgid "We _could_ expose the following structure in Rust to control this GPIO:"
msgstr ""

#: src/static-guarantees/state-machines.md:57
#: src/static-guarantees/design-contracts.md:22
#: src/static-guarantees/design-contracts.md:107
msgid "/// GPIO interface\n"
msgstr ""

#: src/static-guarantees/state-machines.md:59
#: src/static-guarantees/design-contracts.md:24
#: src/static-guarantees/design-contracts.md:109
msgid "/// GPIO Configuration structure generated by svd2rust\n"
msgstr ""

#: src/static-guarantees/state-machines.md:94
msgid ""
"However, this would allow us to modify certain registers that do not make "
"sense. For example, what happens if we set the `output_mode` field when our "
"GPIO is configured as an input?"
msgstr ""

#: src/static-guarantees/state-machines.md:96
msgid ""
"In general, use of this structure would allow us to reach states not defined "
"by our state machine above: e.g. an output that is pulled low, or an input "
"that is set high. For some hardware, this may not matter. On other hardware, "
"it could cause unexpected or undefined behavior!"
msgstr ""

#: src/static-guarantees/state-machines.md:98
msgid ""
"Although this interface is convenient to write, it doesn't enforce the "
"design contracts set out by our hardware implementation."
msgstr ""

#: src/static-guarantees/design-contracts.md:3
msgid ""
"In our last chapter, we wrote an interface that _didn't_ enforce design "
"contracts. Let's take another look at our imaginary GPIO configuration "
"register:"
msgstr ""

#: src/static-guarantees/design-contracts.md:19
msgid ""
"If we instead checked the state before making use of the underlying "
"hardware, enforcing our design contracts at runtime, we might write code "
"that looks like this instead:"
msgstr ""

#: src/static-guarantees/design-contracts.md:37
msgid "// Must be enabled to set direction\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:50
msgid "// Must be enabled to set input mode\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:55
#: src/static-guarantees/design-contracts.md:91
msgid "// Direction must be input\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:68
msgid "// Must be enabled to set output status\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:73
msgid "// Direction must be output\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:86
msgid "// Must be enabled to get status\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:100
msgid ""
"Because we need to enforce the restrictions on the hardware, we end up doing "
"a lot of runtime checking which wastes time and resources, and this code "
"will be much less pleasant for the developer to use."
msgstr ""

#: src/static-guarantees/design-contracts.md:102
msgid "Type States"
msgstr ""

#: src/static-guarantees/design-contracts.md:104
msgid ""
"But what if instead, we used Rust's type system to enforce the state "
"transition rules? Take this example:"
msgstr ""

#: src/static-guarantees/design-contracts.md:115
msgid "// Type states for MODE in GpioConfig\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:125
msgid "/// These functions may be used on any GPIO Pin\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:166
msgid "/// This function may be used on an Output Pin\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:173
msgid "/// These methods may be used on any enabled input GPIO\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:212
msgid "Now let's see what the code using this would look like:"
msgstr ""

#: src/static-guarantees/design-contracts.md:215
msgid ""
"/*\n"
" * Example 1: Unconfigured to High-Z input\n"
" */"
msgstr ""

#: src/static-guarantees/design-contracts.md:219
msgid ""
"// Can't do this, pin isn't enabled!\n"
"// pin.into_input_pull_down();\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:222
msgid "// Now turn the pin from unconfigured to a high-z input\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:225
msgid "// Read from the pin\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:228
msgid ""
"// Can't do this, input pins don't have this interface!\n"
"// input_pin.set_bit(true);\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:231
msgid ""
"/*\n"
" * Example 2: High-Z input to Pulled Low input\n"
" */"
msgstr ""

#: src/static-guarantees/design-contracts.md:237
msgid ""
"/*\n"
" * Example 3: Pulled Low input to Output, set high\n"
" */"
msgstr ""

#: src/static-guarantees/design-contracts.md:243
msgid ""
"// Can't do this, output pins don't have this interface!\n"
"// output_pin.into_input_pull_down();\n"
msgstr ""

#: src/static-guarantees/design-contracts.md:248
msgid ""
"This is definitely a convenient way to store the state of the pin, but why "
"do it this way? Why is this better than storing the state as an `enum` "
"inside of our `GpioConfig` structure?"
msgstr ""

#: src/static-guarantees/design-contracts.md:250
msgid "Compile Time Functional Safety"
msgstr ""

#: src/static-guarantees/design-contracts.md:252
msgid ""
"Because we are enforcing our design constraints entirely at compile time, "
"this incurs no runtime cost. It is impossible to set an output mode when you "
"have a pin in an input mode. Instead, you must walk through the states by "
"converting it to an output pin, and then setting the output mode. Because of "
"this, there is no runtime penalty due to checking the current state before "
"executing a function."
msgstr ""

#: src/static-guarantees/design-contracts.md:254
msgid ""
"Also, because these states are enforced by the type system, there is no "
"longer room for errors by consumers of this interface. If they try to "
"perform an illegal state transition, the code will not compile!"
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:3
msgid ""
"Type states are also an excellent example of Zero Cost Abstractions - the "
"ability to move certain behaviors to compile time execution or analysis. "
"These type states contain no actual data, and are instead used as markers. "
"Since they contain no data, they have no actual representation in memory at "
"runtime:"
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:8
#: src/static-guarantees/zero-cost-abstractions.md:9
#: src/static-guarantees/zero-cost-abstractions.md:10
#: src/static-guarantees/zero-cost-abstractions.md:11
msgid "// == 0\n"
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:14
msgid "Zero Sized Types"
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:20
msgid ""
"Structures defined like this are called Zero Sized Types, as they contain no "
"actual data. Although these types act \"real\" at compile time - you can "
"copy them, move them, take references to them, etc., however the optimizer "
"will completely strip them away."
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:22
msgid "In this snippet of code:"
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:36
msgid ""
"The GpioConfig we return never exists at runtime. Calling this function will "
"generally boil down to a single assembly instruction - storing a constant "
"register value to a register location. This means that the type state "
"interface we've developed is a zero cost abstraction - it uses no more CPU, "
"RAM, or code space tracking the state of `GpioConfig`, and renders to the "
"same machine code as a direct register access."
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:38
msgid "Nesting"
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:40
msgid ""
"In general, these abstractions may be nested as deeply as you would like. As "
"long as all components used are zero sized types, the whole structure will "
"not exist at runtime."
msgstr ""

#: src/static-guarantees/zero-cost-abstractions.md:42
msgid ""
"For complex or deeply nested structures, it may be tedious to define all "
"possible combinations of state. In these cases, macros may be used to "
"generate all implementations."
msgstr ""

#: src/portability/index.md:3
msgid ""
"In embedded environments portability is a very important topic: Every vendor "
"and even each family from a single manufacturer offers different peripherals "
"and capabilities and similarly the ways to interact with the peripherals "
"will vary."
msgstr ""

#: src/portability/index.md:5
msgid ""
"A common way to equalize such differences is via a layer called Hardware "
"Abstraction layer or **HAL**."
msgstr ""

#: src/portability/index.md:7
msgid ""
"Hardware abstractions are sets of routines in software that emulate some "
"platform-specific details, giving programs direct access to the hardware "
"resources."
msgstr ""

#: src/portability/index.md:9
msgid ""
"They often allow programmers to write device-independent, high performance "
"applications by providing standard operating system (OS) calls to hardware."
msgstr ""

#: src/portability/index.md:11
msgid ""
"_Wikipedia: [Hardware Abstraction Layer](https://en.wikipedia.org/wiki/"
"Hardware_abstraction)_"
msgstr ""

#: src/portability/index.md:15
msgid ""
"Embedded systems are a bit special in this regard since we typically do not "
"have operating systems and user installable software but firmware images "
"which are compiled as a whole as well as a number of other constraints. So "
"while the traditional approach as defined by Wikipedia could potentially "
"work it is likely not the most productive approach to ensure portability."
msgstr ""

#: src/portability/index.md:17
msgid "How do we do this in Rust? Enter **embedded-hal**..."
msgstr ""

#: src/portability/index.md:19
msgid "What is embedded-hal?"
msgstr ""

#: src/portability/index.md:21
msgid ""
"In a nutshell it is a set of traits which define implementation contracts "
"between **HAL implementations**, **drivers** and **applications (or "
"firmwares)**. Those contracts include both capabilities (i.e. if a trait is "
"implemented for a certain type, the **HAL implementation** provides a "
"certain capability) and methods (i.e. if you can construct a type "
"implementing a trait it is guaranteed that you have the methods specified in "
"the trait available)."
msgstr ""

#: src/portability/index.md:23
msgid "A typical layering might look like this:"
msgstr ""

#: src/portability/index.md:25
msgid "![](../assets/rust_layers.svg)"
msgstr ""

#: src/portability/index.md:27
msgid "Some of the defined traits in **embedded-hal** are:"
msgstr ""

#: src/portability/index.md:28
msgid "GPIO (input and output pins)"
msgstr ""

#: src/portability/index.md:29
msgid "Serial communication"
msgstr ""

#: src/portability/index.md:30 src/appendix/glossary.md:26
msgid "I2C"
msgstr ""

#: src/portability/index.md:31 src/appendix/glossary.md:42
msgid "SPI"
msgstr ""

#: src/portability/index.md:32
msgid "Timers/Countdowns"
msgstr ""

#: src/portability/index.md:33
msgid "Analog Digital Conversion"
msgstr ""

#: src/portability/index.md:35
msgid ""
"The main reason for having the **embedded-hal** traits and crates "
"implementing and using them is to keep complexity in check. If you consider "
"that an application might have to implement the use of the peripheral in the "
"hardware as well as the application and potentially drivers for additional "
"hardware components, then it should be easy to see that the re-usability is "
"very limited. Expressed mathematically, if **M** is the number of peripheral "
"HAL implementations and **N** the number of drivers then if we were to "
"reinvent the wheel for every application then we would end up with **M\\*N** "
"implementations while by using the _API_ provided by the **embedded-hal** "
"traits will make the implementation complexity approach **M+N**. Of course "
"there're additional benefits to be had, such as less trial-and-error due to "
"a well-defined and ready-to-use APIs."
msgstr ""

#: src/portability/index.md:37
msgid "Users of the embedded-hal"
msgstr ""

#: src/portability/index.md:39
msgid "As said above there are three main users of the HAL:"
msgstr ""

#: src/portability/index.md:41
msgid "HAL implementation"
msgstr ""

#: src/portability/index.md:43
msgid ""
"A HAL implementation provides the interfacing between the hardware and the "
"users of the HAL traits. Typical implementations consist of three parts:"
msgstr ""

#: src/portability/index.md:44
msgid "One or more hardware specific types"
msgstr ""

#: src/portability/index.md:45
msgid ""
"Functions to create and initialize such a type, often providing various "
"configuration options (speed, operation mode, use pins, etc.)"
msgstr ""

#: src/portability/index.md:46
msgid "one or more `trait` `impl` of **embedded-hal** traits for that type"
msgstr ""

#: src/portability/index.md:48
msgid "Such a **HAL implementation** can come in various flavours:"
msgstr ""

#: src/portability/index.md:49
msgid "Via low-level hardware access, e.g. via registers"
msgstr ""

#: src/portability/index.md:50
msgid "Via operating system, e.g. by using the `sysfs` under Linux"
msgstr ""

#: src/portability/index.md:51
msgid "Via adapter, e.g. a mock of types for unit testing"
msgstr ""

#: src/portability/index.md:52
msgid "Via driver for hardware adapters, e.g. I2C multiplexer or GPIO expander"
msgstr ""

#: src/portability/index.md:54
msgid "Driver"
msgstr ""

#: src/portability/index.md:56
msgid ""
"A driver implements a set of custom functionality for an internal or "
"external component, connected to a peripheral implementing the embedded-hal "
"traits. Typical examples for such drivers include various sensors "
"(temperature, magnetometer, accelerometer, light), display devices (LED "
"arrays, LCD displays) and actuators (motors, transmitters)."
msgstr ""

#: src/portability/index.md:58
msgid ""
"A driver has to be initialized with an instance of type that implements a "
"certain `trait` of the embedded-hal which is ensured via trait bound and "
"provides its own type instance with a custom set of methods allowing to "
"interact with the driven device."
msgstr ""

#: src/portability/index.md:60
msgid "Application"
msgstr ""

#: src/portability/index.md:62
msgid ""
"The application binds the various parts together and ensures that the "
"desired functionality is achieved. When porting between different systems, "
"this is the part which requires the most adaptation efforts, since the "
"application needs to correctly initialize the real hardware via the HAL "
"implementation and the initialisation of different hardware differs, "
"sometimes drastically so. Also the user choice often plays a big role, since "
"components can be physically connected to different terminals, hardware "
"buses sometimes need external hardware to match the configuration or there "
"are different trade-offs to be made in the use of internal peripherals (e.g. "
"multiple timers with different capabilities are available or peripherals "
"conflict with others)."
msgstr ""

#: src/concurrency/index.md:3
msgid ""
"Concurrency happens whenever different parts of your program might execute "
"at different times or out of order. In an embedded context, this includes:"
msgstr ""

#: src/concurrency/index.md:6
msgid ""
"interrupt handlers, which run whenever the associated interrupt happens,"
msgstr ""

#: src/concurrency/index.md:7
msgid ""
"various forms of multithreading, where your microprocessor regularly swaps "
"between parts of your program,"
msgstr ""

#: src/concurrency/index.md:9
msgid ""
"and in some systems, multiple-core microprocessors, where each core can be "
"independently running a different part of your program at the same time."
msgstr ""

#: src/concurrency/index.md:12
msgid ""
"Since many embedded programs need to deal with interrupts, concurrency will "
"usually come up sooner or later, and it's also where many subtle and "
"difficult bugs can occur. Luckily, Rust provides a number of abstractions "
"and safety guarantees to help us write correct code."
msgstr ""

#: src/concurrency/index.md:17
msgid "No Concurrency"
msgstr ""

#: src/concurrency/index.md:19
msgid ""
"The simplest concurrency for an embedded program is no concurrency: your "
"software consists of a single main loop which just keeps running, and there "
"are no interrupts at all. Sometimes this is perfectly suited to the problem "
"at hand! Typically your loop will read some inputs, perform some processing, "
"and write some outputs."
msgstr ""

#: src/concurrency/index.md:37
msgid ""
"Since there's no concurrency, there's no need to worry about sharing data "
"between parts of your program or synchronising access to peripherals. If you "
"can get away with such a simple approach this can be a great solution."
msgstr ""

#: src/concurrency/index.md:41
msgid "Global Mutable Data"
msgstr ""

#: src/concurrency/index.md:43
msgid ""
"Unlike non-embedded Rust, we will not usually have the luxury of creating "
"heap allocations and passing references to that data into a newly-created "
"thread. Instead, our interrupt handlers might be called at any time and must "
"know how to access whatever shared memory we are using. At the lowest level, "
"this means we must have _statically allocated_ mutable memory, which both "
"the interrupt handler and the main code can refer to."
msgstr ""

#: src/concurrency/index.md:50
msgid ""
"In Rust, such [`static mut`](https://doc.rust-lang.org/book/ch19-01-unsafe-"
"rust.html#accessing-or-modifying-a-mutable-static-variable) variables are "
"always unsafe to read or write, because without taking special care, you "
"might trigger a race condition, where your access to the variable is "
"interrupted halfway through by an interrupt which also accesses that "
"variable."
msgstr ""

#: src/concurrency/index.md:57
msgid ""
"For an example of how this behaviour can cause subtle errors in your code, "
"consider an embedded program which counts rising edges of some input signal "
"in each one-second period (a frequency counter):"
msgstr ""

#: src/concurrency/index.md:71
msgid "// DANGER - Not actually safe! Could cause data races.\n"
msgstr ""

#: src/concurrency/index.md:84
msgid ""
"Each second, the timer interrupt sets the counter back to 0. Meanwhile, the "
"main loop continually measures the signal, and incremements the counter when "
"it sees a change from low to high. We've had to use `unsafe` to access "
"`COUNTER`, as it's `static mut`, and that means we're promising the compiler "
"we won't cause any undefined behaviour. Can you spot the race condition? The "
"increment on `COUNTER` is _not_ guaranteed to be atomic — in fact, on most "
"embedded platforms, it will be split into a load, then the increment, then a "
"store. If the interrupt fired after the load but before the store, the reset "
"back to 0 would be ignored after the interrupt returns — and we would count "
"twice as many transitions for that period."
msgstr ""

#: src/concurrency/index.md:95
msgid "Critical Sections"
msgstr ""

#: src/concurrency/index.md:97
msgid ""
"So, what can we do about data races? A simple approach is to use _critical "
"sections_, a context where interrupts are disabled. By wrapping the access "
"to `COUNTER` in `main` in a critical section, we can be sure the timer "
"interrupt will not fire until we're finished incrementing `COUNTER`:"
msgstr ""

#: src/concurrency/index.md:112
msgid "// New critical section ensures synchronised access to COUNTER\n"
msgstr ""

#: src/concurrency/index.md:127
msgid ""
"In this example, we use `cortex_m::interrupt::free`, but other platforms "
"will have similar mechanisms for executing code in a critical section. This "
"is also the same as disabling interrupts, running some code, and then re-"
"enabling interrupts."
msgstr ""

#: src/concurrency/index.md:132
msgid ""
"Note we didn't need to put a critical section inside the timer interrupt, "
"for two reasons:"
msgstr ""

#: src/concurrency/index.md:135
msgid ""
"Writing 0 to `COUNTER` can't be affected by a race since we don't read it"
msgstr ""

#: src/concurrency/index.md:136
msgid "It will never be interrupted by the `main` thread anyway"
msgstr ""

#: src/concurrency/index.md:138
msgid ""
"If `COUNTER` was being shared by multiple interrupt handlers that might "
"_preempt_ each other, then each one might require a critical section as well."
msgstr ""

#: src/concurrency/index.md:141
msgid ""
"This solves our immediate problem, but we're still left writing a lot of "
"unsafe code which we need to carefully reason about, and we might be using "
"critical sections needlessly. Since each critical section temporarily pauses "
"interrupt processing, there is an associated cost of some extra code size "
"and higher interrupt latency and jitter (interrupts may take longer to be "
"processed, and the time until they are processed will be more variable). "
"Whether this is a problem depends on your system, but in general, we'd like "
"to avoid it."
msgstr ""

#: src/concurrency/index.md:143
msgid ""
"It's worth noting that while a critical section guarantees no interrupts "
"will fire, it does not provide an exclusivity guarantee on multi-core "
"systems!  The other core could be happily accessing the same memory as your "
"core, even without interrupts. You will need stronger synchronisation "
"primitives if you are using multiple cores."
msgstr ""

#: src/concurrency/index.md:149
msgid "Atomic Access"
msgstr ""

#: src/concurrency/index.md:151
msgid ""
"On some platforms, special atomic instructions are available, which provide "
"guarantees about read-modify-write operations. Specifically for Cortex-M: "
"`thumbv6` (Cortex-M0, Cortex-M0+) only provide atomic load and store "
"instructions, while `thumbv7` (Cortex-M3 and above) provide full Compare and "
"Swap (CAS) instructions. These CAS instructions give an alternative to the "
"heavy-handed disabling of all interrupts: we can attempt the increment, it "
"will succeed most of the time, but if it was interrupted it will "
"automatically retry the entire increment operation. These atomic operations "
"are safe even across multiple cores."
msgstr ""

#: src/concurrency/index.md:173
msgid "// Use `fetch_add` to atomically add 1 to COUNTER\n"
msgstr ""

#: src/concurrency/index.md:182
msgid "// Use `store` to write 0 directly to COUNTER\n"
msgstr ""

#: src/concurrency/index.md:187
msgid ""
"This time `COUNTER` is a safe `static` variable. Thanks to the `AtomicUsize` "
"type `COUNTER` can be safely modified from both the interrupt handler and "
"the main thread without disabling interrupts. When possible, this is a "
"better solution — but it may not be supported on your platform."
msgstr ""

#: src/concurrency/index.md:192
msgid ""
"A note on [`Ordering`](https://doc.rust-lang.org/core/sync/atomic/"
"enum.Ordering.html): this affects how the compiler and hardware may reorder "
"instructions, and also has consequences on cache visibility. Assuming that "
"the target is a single core platform `Relaxed` is sufficient and the most "
"efficient choice in this particular case. Stricter ordering will cause the "
"compiler to emit memory barriers around the atomic operations; depending on "
"what you're using atomics for you may or may not need this! The precise "
"details of the atomic model are complicated and best described elsewhere."
msgstr ""

#: src/concurrency/index.md:200
msgid ""
"For more details on atomics and ordering, see the [nomicon](https://doc.rust-"
"lang.org/nomicon/atomics.html)."
msgstr ""

#: src/concurrency/index.md:206
msgid "Abstractions, Send, and Sync"
msgstr ""

#: src/concurrency/index.md:208
msgid ""
"None of the above solutions are especially satisfactory. They require "
"`unsafe` blocks which must be very carefully checked and are not ergonomic. "
"Surely we can do better in Rust!"
msgstr ""

#: src/concurrency/index.md:212
msgid ""
"We can abstract our counter into a safe interface which can be safely used "
"anywhere else in our code. For this example, we'll use the critical-section "
"counter, but you could do something very similar with atomics."
msgstr ""

#: src/concurrency/index.md:219
msgid ""
"// Our counter is just a wrapper around UnsafeCell<u32>, which is the heart\n"
"// of interior mutability in Rust. By using interior mutability, we can "
"have\n"
"// COUNTER be `static` instead of `static mut`, but still able to mutate\n"
"// its counter value.\n"
msgstr ""

#: src/concurrency/index.md:230
msgid ""
"// By requiring a CriticalSection be passed in, we know we must\n"
"        // be operating inside a CriticalSection, and so can confidently\n"
"        // use this unsafe block (required to call UnsafeCell::get).\n"
msgstr ""

#: src/concurrency/index.md:240
msgid "// Required to allow static CSCounter. See explanation below.\n"
msgstr ""

#: src/concurrency/index.md:243
msgid ""
"// COUNTER is no longer `mut` as it uses interior mutability;\n"
"// therefore it also no longer requires unsafe blocks to access.\n"
msgstr ""

#: src/concurrency/index.md:255
msgid "// No unsafe here!\n"
msgstr ""

#: src/concurrency/index.md:264
msgid ""
"// We do need to enter a critical section here just to obtain a valid\n"
"    // cs token, even though we know no other interrupt could pre-empt\n"
"    // this one.\n"
msgstr ""

#: src/concurrency/index.md:269
msgid ""
"// We could use unsafe code to generate a fake CriticalSection if we\n"
"    // really wanted to, avoiding the overhead:\n"
"    // let cs = unsafe { interrupt::CriticalSection::new() };\n"
msgstr ""

#: src/concurrency/index.md:275
msgid ""
"We've moved our `unsafe` code to inside our carefully-planned abstraction, "
"and now our application code does not contain any `unsafe` blocks."
msgstr ""

#: src/concurrency/index.md:278
msgid ""
"This design requires that the application pass a `CriticalSection` token in: "
"these tokens are only safely generated by `interrupt::free`, so by requiring "
"one be passed in, we ensure we are operating inside a critical section, "
"without having to actually do the lock ourselves. This guarantee is provided "
"statically by the compiler: there won't be any runtime overhead associated "
"with `cs`. If we had multiple counters, they could all be given the same "
"`cs`, without requiring multiple nested critical sections."
msgstr ""

#: src/concurrency/index.md:286
msgid ""
"This also brings up an important topic for concurrency in Rust: the [`Send` "
"and `Sync`](https://doc.rust-lang.org/nomicon/send-and-sync.html) traits. To "
"summarise the Rust book, a type is Send when it can safely be moved to "
"another thread, while it is Sync when it can be safely shared between "
"multiple threads. In an embedded context, we consider interrupts to be "
"executing in a separate thread to the application code, so variables "
"accessed by both an interrupt and the main code must be Sync."
msgstr ""

#: src/concurrency/index.md:296
msgid ""
"For most types in Rust, both of these traits are automatically derived for "
"you by the compiler. However, because `CSCounter` contains an [`UnsafeCell`]"
"(https://doc.rust-lang.org/core/cell/struct.UnsafeCell.html), it is not "
"Sync, and therefore we could not make a `static CSCounter`: `static` "
"variables _must_ be Sync, since they can be accessed by multiple threads."
msgstr ""

#: src/concurrency/index.md:303
msgid ""
"To tell the compiler we have taken care that the `CSCounter` is in fact safe "
"to share between threads, we implement the Sync trait explicitly. As with "
"the previous use of critical sections, this is only safe on single-core "
"platforms: with multiple cores, you would need to go to greater lengths to "
"ensure safety."
msgstr ""

#: src/concurrency/index.md:308
msgid "Mutexes"
msgstr ""

#: src/concurrency/index.md:310
msgid ""
"We've created a useful abstraction specific to our counter problem, but "
"there are many common abstractions used for concurrency."
msgstr ""

#: src/concurrency/index.md:313
msgid ""
"One such _synchronisation primitive_ is a mutex, short for mutual exclusion. "
"These constructs ensure exclusive access to a variable, such as our counter. "
"A thread can attempt to _lock_ (or _acquire_) the mutex, and either succeeds "
"immediately, or blocks waiting for the lock to be acquired, or returns an "
"error that the mutex could not be locked. While that thread holds the lock, "
"it is granted access to the protected data. When the thread is done, it "
"_unlocks_ (or _releases_) the mutex, allowing another thread to lock it. In "
"Rust, we would usually implement the unlock using the [`Drop`](https://"
"doc.rust-lang.org/core/ops/trait.Drop.html) trait to ensure it is always "
"released when the mutex goes out of scope."
msgstr ""

#: src/concurrency/index.md:325
msgid ""
"Using a mutex with interrupt handlers can be tricky: it is not normally "
"acceptable for the interrupt handler to block, and it would be especially "
"disastrous for it to block waiting for the main thread to release a lock, "
"since we would then _deadlock_ (the main thread will never release the lock "
"because execution stays in the interrupt handler). Deadlocking is not "
"considered unsafe: it is possible even in safe Rust."
msgstr ""

#: src/concurrency/index.md:332
msgid ""
"To avoid this behaviour entirely, we could implement a mutex which requires "
"a critical section to lock, just like our counter example. So long as the "
"critical section must last as long as the lock, we can be sure we have "
"exclusive access to the wrapped variable without even needing to track the "
"lock/unlock state of the mutex."
msgstr ""

#: src/concurrency/index.md:338
msgid ""
"This is in fact done for us in the `cortex_m` crate! We could have written "
"our counter using it:"
msgstr ""

#: src/concurrency/index.md:363
msgid ""
"// We still need to enter a critical section here to satisfy the Mutex.\n"
msgstr ""

#: src/concurrency/index.md:368
msgid ""
"We're now using [`Cell`](https://doc.rust-lang.org/core/cell/"
"struct.Cell.html), which along with its sibling `RefCell` is used to provide "
"safe interior mutability. We've already seen `UnsafeCell` which is the "
"bottom layer of interior mutability in Rust: it allows you to obtain "
"multiple mutable references to its value, but only with unsafe code. A "
"`Cell` is like an `UnsafeCell` but it provides a safe interface: it only "
"permits taking a copy of the current value or replacing it, not taking a "
"reference, and since it is not Sync, it cannot be shared between threads. "
"These constraints mean it's safe to use, but we couldn't use it directly in "
"a `static` variable as a `static` must be Sync."
msgstr ""

#: src/concurrency/index.md:380
msgid ""
"So why does the example above work? The `Mutex<T>` implements Sync for any "
"`T` which is Send — such as a `Cell`. It can do this safely because it only "
"gives access to its contents during a critical section. We're therefore able "
"to get a safe counter with no unsafe code at all!"
msgstr ""

#: src/concurrency/index.md:385
msgid ""
"This is great for simple types like the `u32` of our counter, but what about "
"more complex types which are not Copy? An extremely common example in an "
"embedded context is a peripheral struct, which generally is not Copy. For "
"that, we can turn to `RefCell`."
msgstr ""

#: src/concurrency/index.md:390
msgid "Sharing Peripherals"
msgstr ""

#: src/concurrency/index.md:392
msgid ""
"Device crates generated using `svd2rust` and similar abstractions provide "
"safe access to peripherals by enforcing that only one instance of the "
"peripheral struct can exist at a time. This ensures safety, but makes it "
"difficult to access a peripheral from both the main thread and an interrupt "
"handler."
msgstr ""

#: src/concurrency/index.md:398
msgid ""
"To safely share peripheral access, we can use the `Mutex` we saw before. "
"We'll also need to use [`RefCell`](https://doc.rust-lang.org/core/cell/"
"struct.RefCell.html), which uses a runtime check to ensure only one "
"reference to a peripheral is given out at a time. This has more overhead "
"than the plain `Cell`, but since we are giving out references rather than "
"copies, we must be sure only one exists at a time."
msgstr ""

#: src/concurrency/index.md:406
msgid ""
"Finally, we'll also have to account for somehow moving the peripheral into "
"the shared variable after it has been initialised in the main code. To do "
"this we can use the `Option` type, initialised to `None` and later set to "
"the instance of the peripheral."
msgstr ""

#: src/concurrency/index.md:421
msgid ""
"// Obtain the peripheral singletons and configure it.\n"
"    // This example is from an svd2rust-generated crate, but\n"
"    // most embedded device crates will be similar.\n"
msgstr ""

#: src/concurrency/index.md:427
msgid ""
"// Some sort of configuration function.\n"
"    // Assume it sets PA0 to an input and PA1 to an output.\n"
msgstr ""

#: src/concurrency/index.md:431
msgid "// Store the GPIOA in the mutex, moving it.\n"
msgstr ""

#: src/concurrency/index.md:433
msgid ""
"// We can no longer use `gpioa` or `dp.GPIOA`, and instead have to\n"
"    // access it via the mutex.\n"
msgstr ""

#: src/concurrency/index.md:436
msgid ""
"// Be careful to enable the interrupt only after setting MY_GPIO:\n"
"    // otherwise the interrupt might fire while it still contains None,\n"
"    // and as-written (with `unwrap()`), it would panic.\n"
msgstr ""

#: src/concurrency/index.md:442
msgid "// We'll now read state as a digital input, via the mutex\n"
msgstr ""

#: src/concurrency/index.md:449
msgid "// Set PA1 high if we've seen a rising edge on PA0.\n"
msgstr ""

#: src/concurrency/index.md:461
msgid "// This time in the interrupt we'll just clear PA0.\n"
msgstr ""

#: src/concurrency/index.md:463
msgid ""
"// We can use `unwrap()` because we know the interrupt wasn't enabled\n"
"        // until after MY_GPIO was set; otherwise we should handle the "
"potential\n"
"        // for a None value.\n"
msgstr ""

#: src/concurrency/index.md:472
msgid "That's quite a lot to take in, so let's break down the important lines."
msgstr ""

#: src/concurrency/index.md:479
msgid ""
"Our shared variable is now a `Mutex` around a `RefCell` which contains an "
"`Option`. The `Mutex` ensures we only have access during a critical section, "
"and therefore makes the variable Sync, even though a plain `RefCell` would "
"not be Sync. The `RefCell` gives us interior mutability with references, "
"which we'll need to use our `GPIOA`. The `Option` lets us initialise this "
"variable to something empty, and only later actually move the variable in. "
"We cannot access the peripheral singleton statically, only at runtime, so "
"this is required."
msgstr ""

#: src/concurrency/index.md:492
msgid ""
"Inside a critical section we can call `borrow()` on the mutex, which gives "
"us a reference to the `RefCell`. We then call `replace()` to move our new "
"value into the `RefCell`."
msgstr ""

#: src/concurrency/index.md:503
msgid ""
"Finally, we use `MY_GPIO` in a safe and concurrent fashion. The critical "
"section prevents the interrupt firing as usual, and lets us borrow the "
"mutex.  The `RefCell` then gives us an `&Option<GPIOA>`, and tracks how long "
"it remains borrowed - once that reference goes out of scope, the `RefCell` "
"will be updated to indicate it is no longer borrowed."
msgstr ""

#: src/concurrency/index.md:509
msgid ""
"Since we can't move the `GPIOA` out of the `&Option`, we need to convert it "
"to an `&Option<&GPIOA>` with `as_ref()`, which we can finally `unwrap()` to "
"obtain the `&GPIOA` which lets us modify the peripheral."
msgstr ""

#: src/concurrency/index.md:513
msgid ""
"If we need a mutable reference to a shared resource, then `borrow_mut` and "
"`deref_mut` should be used instead. The following code shows an example "
"using the TIM2 timer."
msgstr ""

#: src/concurrency/index.md:531
msgid ""
"// Some sort of timer configuration function.\n"
"    // Assume it configures the TIM2 timer, its NVIC interrupt,\n"
"    // and finally starts the timer.\n"
msgstr ""

#: src/concurrency/index.md:556
msgid ""
"Whew! This is safe, but it is also a little unwieldy. Is there anything else "
"we can do?"
msgstr ""

#: src/concurrency/index.md:559
msgid "RTIC"
msgstr ""

#: src/concurrency/index.md:561
msgid ""
"One alternative is the [RTIC framework](https://github.com/rtic-rs/cortex-m-"
"rtic), short for Real Time Interrupt-driven Concurrency. It enforces static "
"priorities and tracks accesses to `static mut` variables (\"resources\") to "
"statically ensure that shared resources are always accessed safely, without "
"requiring the overhead of always entering critical sections and using "
"reference counting (as in `RefCell`). This has a number of advantages such "
"as guaranteeing no deadlocks and giving extremely low time and memory "
"overhead."
msgstr ""

#: src/concurrency/index.md:570
msgid ""
"The framework also includes other features like message passing, which "
"reduces the need for explicit shared state, and the ability to schedule "
"tasks to run at a given time, which can be used to implement periodic tasks. "
"Check out [the documentation](https://rtic.rs) for more information!"
msgstr ""

#: src/concurrency/index.md:577
msgid "Real Time Operating Systems"
msgstr ""

#: src/concurrency/index.md:579
msgid ""
"Another common model for embedded concurrency is the real-time operating "
"system (RTOS). While currently less well explored in Rust, they are widely "
"used in traditional embedded development. Open source examples include "
"[FreeRTOS](https://freertos.org/) and [ChibiOS](http://chibios.org/). These "
"RTOSs provide support for running multiple application threads which the CPU "
"swaps between, either when the threads yield control (called cooperative "
"multitasking) or based on a regular timer or interrupts (preemptive "
"multitasking). The RTOS typically provide mutexes and other synchronisation "
"primitives, and often interoperate with hardware features such as DMA "
"engines."
msgstr ""

#: src/concurrency/index.md:591
msgid ""
"At the time of writing, there are not many Rust RTOS examples to point to, "
"but it's an interesting area so watch this space!"
msgstr ""

#: src/concurrency/index.md:594
msgid "Multiple Cores"
msgstr ""

#: src/concurrency/index.md:596
msgid ""
"It is becoming more common to have two or more cores in embedded processors, "
"which adds an extra layer of complexity to concurrency. All the examples "
"using a critical section (including the `cortex_m::interrupt::Mutex`) assume "
"the only other execution thread is the interrupt thread, but on a multi-core "
"system that's no longer true. Instead, we'll need synchronisation primitives "
"designed for multiple cores (also called SMP, for symmetric multi-"
"processing)."
msgstr ""

#: src/concurrency/index.md:603
msgid ""
"These typically use the atomic instructions we saw earlier, since the "
"processing system will ensure that atomicity is maintained over all cores."
msgstr ""

#: src/concurrency/index.md:606
msgid ""
"Covering these topics in detail is currently beyond the scope of this book, "
"but the general patterns are the same as for the single-core case."
msgstr ""

#: src/collections/index.md:3
msgid ""
"Eventually you'll want to use dynamic data structures (AKA collections) in "
"your program. `std` provides a set of common collections: [`Vec`](https://"
"doc.rust-lang.org/std/vec/struct.Vec.html), [`String`](https://doc.rust-"
"lang.org/std/string/struct.String.html), [`HashMap`](https://doc.rust-"
"lang.org/std/collections/struct.HashMap.html), etc. All the collections "
"implemented in `std` use a global dynamic memory allocator (AKA the heap)."
msgstr ""

#: src/collections/index.md:12
msgid ""
"As `core` is, by definition, free of memory allocations these "
"implementations are not available there, but they can be found in the "
"`alloc` crate that's shipped with the compiler."
msgstr ""

#: src/collections/index.md:16
msgid ""
"If you need collections, a heap allocated implementation is not your only "
"option. You can also use _fixed capacity_ collections; one such "
"implementation can be found in the [`heapless`](https://crates.io/crates/"
"heapless) crate."
msgstr ""

#: src/collections/index.md:22
msgid "In this section, we'll explore and compare these two implementations."
msgstr ""

#: src/collections/index.md:24
msgid "Using `alloc`"
msgstr ""

#: src/collections/index.md:26
msgid ""
"The `alloc` crate is shipped with the standard Rust distribution. To import "
"the crate you can directly `use` it _without_ declaring it as a dependency "
"in your `Cargo.toml` file."
msgstr ""

#: src/collections/index.md:38
msgid ""
"To be able to use any collection you'll first need use the "
"`global_allocator` attribute to declare the global allocator your program "
"will use. It's required that the allocator you select implements the "
"[`GlobalAlloc`](https://doc.rust-lang.org/core/alloc/trait.GlobalAlloc.html) "
"trait."
msgstr ""

#: src/collections/index.md:44
msgid ""
"For completeness and to keep this section as self-contained as possible "
"we'll implement a simple bump pointer allocator and use that as the global "
"allocator. However, we _strongly_ suggest you use a battle tested allocator "
"from crates.io in your program instead of this allocator."
msgstr ""

#: src/collections/index.md:50
msgid "// Bump pointer allocator implementation\n"
msgstr ""

#: src/collections/index.md:57
msgid "// Bump pointer allocator for *single* core systems\n"
msgstr ""

#: src/collections/index.md:68
msgid ""
"// `interrupt::free` is a critical section that makes our allocator safe\n"
"        // to use from within interrupts\n"
msgstr ""

#: src/collections/index.md:76
msgid "// move start up to the next alignment boundary\n"
msgstr ""

#: src/collections/index.md:80
msgid "// a null pointer signal an Out Of Memory condition\n"
msgstr ""

#: src/collections/index.md:90
msgid "// this allocator never deallocates memory\n"
msgstr ""

#: src/collections/index.md:93
msgid ""
"// Declaration of the global memory allocator\n"
"// NOTE the user must ensure that the memory region `[0x2000_0100, "
"0x2000_0200]`\n"
"// is not used by other parts of the program\n"
msgstr ""

#: src/collections/index.md:104
msgid ""
"Apart from selecting a global allocator the user will also have to define "
"how Out Of Memory (OOM) errors are handled using the _unstable_ "
"`alloc_error_handler` attribute."
msgstr ""

#: src/collections/index.md:121
msgid ""
"Once all that is in place, the user can finally use the collections in "
"`alloc`."
msgstr ""

#: src/collections/index.md:137
msgid ""
"If you have used the collections in the `std` crate then these will be "
"familiar as they are exact same implementation."
msgstr ""

#: src/collections/index.md:140
msgid "Using `heapless`"
msgstr ""

#: src/collections/index.md:142
msgid ""
"`heapless` requires no setup as its collections don't depend on a global "
"memory allocator. Just `use` its collections and proceed to instantiate them:"
msgstr ""

#: src/collections/index.md:146
msgid "// heapless version: v0.4.x\n"
msgstr ""

#: src/collections/index.md:160
msgid ""
"You'll note two differences between these collections and the ones in "
"`alloc`."
msgstr ""

#: src/collections/index.md:162
msgid ""
"First, you have to declare upfront the capacity of the collection. "
"`heapless` collections never reallocate and have fixed capacities; this "
"capacity is part of the type signature of the collection. In this case we "
"have declared that `xs` has a capacity of 8 elements that is the vector can, "
"at most, hold 8 elements. This is indicated by the `U8` (see [`typenum`]"
"(https://crates.io/crates/typenum)) in the type signature."
msgstr ""

#: src/collections/index.md:170
msgid ""
"Second, the `push` method, and many other methods, return a `Result`. Since "
"the `heapless` collections have fixed capacity all operations that insert "
"elements into the collection can potentially fail. The API reflects this "
"problem by returning a `Result` indicating whether the operation succeeded "
"or not. In contrast, `alloc` collections will reallocate themselves on the "
"heap to increase their capacity."
msgstr ""

#: src/collections/index.md:177
msgid ""
"As of version v0.4.x all `heapless` collections store all their elements "
"inline. This means that an operation like `let x = heapless::Vec::new();` "
"will allocate the collection on the stack, but it's also possible to "
"allocate the collection on a `static` variable, or even on the heap "
"(`Box<Vec<_, _>>`)."
msgstr ""

#: src/collections/index.md:182
msgid "Trade-offs"
msgstr ""

#: src/collections/index.md:184
msgid ""
"Keep these in mind when choosing between heap allocated, relocatable "
"collections and fixed capacity collections."
msgstr ""

#: src/collections/index.md:187
msgid "Out Of Memory and error handling"
msgstr ""

#: src/collections/index.md:189
msgid ""
"With heap allocations Out Of Memory is always a possibility and can occur in "
"any place where a collection may need to grow: for example, all "
"`alloc::Vec.push` invocations can potentially generate an OOM condition. "
"Thus some operations can _implicitly_ fail. Some `alloc` collections expose "
"`try_reserve` methods that let you check for potential OOM conditions when "
"growing the collection but you need be proactive about using them."
msgstr ""

#: src/collections/index.md:196
msgid ""
"If you exclusively use `heapless` collections and you don't use a memory "
"allocator for anything else then an OOM condition is impossible. Instead, "
"you'll have to deal with collections running out of capacity on a case by "
"case basis. That is you'll have deal with _all_ the `Result`s returned by "
"methods like `Vec.push`."
msgstr ""

#: src/collections/index.md:202
msgid ""
"OOM failures can be harder to debug than say `unwrap`\\-ing on all `Result`s "
"returned by `heapless::Vec.push` because the observed location of failure "
"may _not_ match with the location of the cause of the problem. For example, "
"even `vec.reserve(1)` can trigger an OOM if the allocator is nearly "
"exhausted because some other collection was leaking memory (memory leaks are "
"possible in safe Rust)."
msgstr ""

#: src/collections/index.md:209
msgid "Memory usage"
msgstr ""

#: src/collections/index.md:211
msgid ""
"Reasoning about memory usage of heap allocated collections is hard because "
"the capacity of long lived collections can change at runtime. Some "
"operations may implicitly reallocate the collection increasing its memory "
"usage, and some collections expose methods like `shrink_to_fit` that can "
"potentially reduce the memory used by the collection -- ultimately, it's up "
"to the allocator to decide whether to actually shrink the memory allocation "
"or not. Additionally, the allocator may have to deal with memory "
"fragmentation which can increase the _apparent_ memory usage."
msgstr ""

#: src/collections/index.md:220
msgid ""
"On the other hand if you exclusively use fixed capacity collections, store "
"most of them in `static` variables and set a maximum size for the call stack "
"then the linker will detect if you try to use more memory than what's "
"physically available."
msgstr ""

#: src/collections/index.md:225
msgid ""
"Furthermore, fixed capacity collections allocated on the stack will be "
"reported by [`-Z emit-stack-sizes`](https://doc.rust-lang.org/beta/unstable-"
"book/compiler-flags/emit-stack-sizes.html) flag which means that tools that "
"analyze stack usage (like [`stack-sizes`](https://crates.io/crates/stack-"
"sizes)) will include them in their analysis."
msgstr ""

#: src/collections/index.md:232
msgid ""
"However, fixed capacity collections can _not_ be shrunk which can result in "
"lower load factors (the ratio between the size of the collection and its "
"capacity) than what relocatable collections can achieve."
msgstr ""

#: src/collections/index.md:236
msgid "Worst Case Execution Time (WCET)"
msgstr ""

#: src/collections/index.md:238
msgid ""
"If you are building time sensitive applications or hard real time "
"applications then you care, maybe a lot, about the worst case execution time "
"of the different parts of your program."
msgstr ""

#: src/collections/index.md:242
msgid ""
"The `alloc` collections can reallocate so the WCET of operations that may "
"grow the collection will also include the time it takes to reallocate the "
"collection, which itself depends on the _runtime_ capacity of the "
"collection. This makes it hard to determine the WCET of, for example, the "
"`alloc::Vec.push` operation as it depends on both the allocator being used "
"and its runtime capacity."
msgstr ""

#: src/collections/index.md:248
msgid ""
"On the other hand fixed capacity collections never reallocate so all "
"operations have a predictable execution time. For example, "
"`heapless::Vec.push` executes in constant time."
msgstr ""

#: src/collections/index.md:252
msgid "Ease of use"
msgstr ""

#: src/collections/index.md:254
msgid ""
"`alloc` requires setting up a global allocator whereas `heapless` does not. "
"However, `heapless` requires you to pick the capacity of each collection "
"that you instantiate."
msgstr ""

#: src/collections/index.md:258
msgid ""
"The `alloc` API will be familiar to virtually every Rust developer. The "
"`heapless` API tries to closely mimic the `alloc` API but it will never be "
"exactly the same due to its explicit error handling -- some developers may "
"feel the explicit error handling is excessive or too cumbersome."
msgstr ""

#: src/design-patterns/index.md:3
msgid ""
"This chapter aims to collect various useful design patterns for embedded "
"Rust."
msgstr ""

#: src/design-patterns/hal/index.md:1
msgid "HAL Design Patterns"
msgstr ""

#: src/design-patterns/hal/index.md:3
msgid ""
"This is a set of common and recommended patterns for writing hardware "
"abstraction layers (HALs) for microcontrollers in Rust. These patterns are "
"intended to be used in addition to the existing [Rust API Guidelines]"
"(https://rust-lang.github.io/api-guidelines/) when writing HALs for "
"microcontrollers."
msgstr ""

#: src/design-patterns/hal/index.md:10
msgid "[Checklist](checklist.md)"
msgstr ""

#: src/design-patterns/hal/index.md:12
msgid "[Naming](naming.md)"
msgstr ""

#: src/design-patterns/hal/index.md:13
msgid "[Interoperability](interoperability.md)"
msgstr ""

#: src/design-patterns/hal/index.md:14
msgid "[Predictability](predictability.md)"
msgstr ""

#: src/design-patterns/hal/index.md:15
msgid "[GPIO](gpio.md)"
msgstr ""

#: src/design-patterns/hal/checklist.md:1
msgid "HAL Design Patterns Checklist"
msgstr ""

#: src/design-patterns/hal/checklist.md:3
msgid "**Naming** _(crate aligns with Rust naming conventions)_"
msgstr ""

#: src/design-patterns/hal/checklist.md:4
msgid ""
"The crate is named appropriately ([C-CRATE-NAME](naming.html#c-crate-name))"
msgstr ""

#: src/design-patterns/hal/checklist.md:5
msgid ""
"**Interoperability** _(crate interacts nicely with other library "
"functionality)_"
msgstr ""

#: src/design-patterns/hal/checklist.md:6
msgid ""
"Wrapper types provide a destructor method ([C-FREE](interoperability.html#c-"
"free))"
msgstr ""

#: src/design-patterns/hal/checklist.md:7
msgid ""
"HALs reexport their register access crate ([C-REEXPORT-PAC]"
"(interoperability.html#c-reexport-pac))"
msgstr ""

#: src/design-patterns/hal/checklist.md:8
msgid ""
"Types implement the `embedded-hal` traits ([C-HAL-TRAITS]"
"(interoperability.html#c-hal-traits))"
msgstr ""

#: src/design-patterns/hal/checklist.md:9
msgid ""
"**Predictability** _(crate enables legible code that acts how it looks)_"
msgstr ""

#: src/design-patterns/hal/checklist.md:10
msgid ""
"Constructors are used instead of extension traits ([C-CTOR]"
"(predictability.html#c-ctor))"
msgstr ""

#: src/design-patterns/hal/checklist.md:11
msgid "**GPIO Interfaces** _(GPIO Interfaces follow a common pattern)_"
msgstr ""

#: src/design-patterns/hal/checklist.md:12
msgid "Pin types are zero-sized by default ([C-ZST-PIN](gpio.md#c-zst-pin))"
msgstr ""

#: src/design-patterns/hal/checklist.md:13
msgid ""
"Pin types provide methods to erase pin and port ([C-ERASED-PIN](gpio.md#c-"
"erased-pin))"
msgstr ""

#: src/design-patterns/hal/checklist.md:14
msgid ""
"Pin state should be encoded as type parameters ([C-PIN-STATE](gpio.md#c-pin-"
"state))"
msgstr ""

#: src/design-patterns/hal/naming.md:4
msgid "<a id=\"c-crate-name\"></a>"
msgstr ""

#: src/design-patterns/hal/naming.md:5
msgid "The crate is named appropriately (C-CRATE-NAME)"
msgstr ""

#: src/design-patterns/hal/naming.md:7
msgid ""
"HAL crates should be named after the chip or family of chips they aim to "
"support. Their name should end with `-hal` to distinguish them from register "
"access crates. The name should not contain underscores (use dashes instead)."
msgstr ""

#: src/design-patterns/hal/interoperability.md:4
msgid "<a id=\"c-free\"></a>"
msgstr ""

#: src/design-patterns/hal/interoperability.md:5
msgid "Wrapper types provide a destructor method (C-FREE)"
msgstr ""

#: src/design-patterns/hal/interoperability.md:7
msgid ""
"Any non-`Copy` wrapper type provided by the HAL should provide a `free` "
"method that consumes the wrapper and returns back the raw peripheral (and "
"possibly other objects) it was created from."
msgstr ""

#: src/design-patterns/hal/interoperability.md:11
msgid ""
"The method should shut down and reset the peripheral if necessary. Calling "
"`new` with the raw peripheral returned by `free` should not fail due to an "
"unexpected state of the peripheral."
msgstr ""

#: src/design-patterns/hal/interoperability.md:15
msgid ""
"If the HAL type requires other non-`Copy` objects to be constructed (for "
"example I/O pins), any such object should be released and returned by `free` "
"as well. `free` should return a tuple in that case."
msgstr ""

#: src/design-patterns/hal/interoperability.md:19
msgid "For example:"
msgstr ""

#: src/design-patterns/hal/interoperability.md:36
msgid "<a id=\"c-reexport-pac\"></a>"
msgstr ""

#: src/design-patterns/hal/interoperability.md:37
msgid "HALs reexport their register access crate (C-REEXPORT-PAC)"
msgstr ""

#: src/design-patterns/hal/interoperability.md:39
msgid ""
"HALs can be written on top of [svd2rust](https://github.com/rust-embedded/"
"svd2rust)\\-generated PACs, or on top of other crates that provide raw "
"register access. HALs should always reexport the register access crate they "
"are based on in their crate root."
msgstr ""

#: src/design-patterns/hal/interoperability.md:43
msgid ""
"A PAC should be reexported under the name `pac`, regardless of the actual "
"name of the crate, as the name of the HAL should already make it clear what "
"PAC is being accessed."
msgstr ""

#: src/design-patterns/hal/interoperability.md:49
msgid "<a id=\"c-hal-traits\"></a>"
msgstr ""

#: src/design-patterns/hal/interoperability.md:50
msgid "Types implement the `embedded-hal` traits (C-HAL-TRAITS)"
msgstr ""

#: src/design-patterns/hal/interoperability.md:52
msgid ""
"Types provided by the HAL should implement all applicable traits provided by "
"the [`embedded-hal`](https://github.com/rust-embedded/embedded-hal) crate."
msgstr ""

#: src/design-patterns/hal/interoperability.md:55
msgid "Multiple traits may be implemented for the same type."
msgstr ""

#: src/design-patterns/hal/predictability.md:4
msgid "<a id=\"c-ctor\"></a>"
msgstr ""

#: src/design-patterns/hal/predictability.md:5
msgid "Constructors are used instead of extension traits (C-CTOR)"
msgstr ""

#: src/design-patterns/hal/predictability.md:7
msgid ""
"All peripherals to which the HAL adds functionality should be wrapped in a "
"new type, even if no additional fields are required for that functionality."
msgstr ""

#: src/design-patterns/hal/predictability.md:10
msgid "Extension traits implemented for the raw peripheral should be avoided."
msgstr ""

#: src/design-patterns/hal/predictability.md:12
msgid "<a id=\"c-inline\"></a>"
msgstr ""

#: src/design-patterns/hal/predictability.md:13
msgid "Methods are decorated with `#[inline]` where appropriate (C-INLINE)"
msgstr ""

#: src/design-patterns/hal/predictability.md:15
msgid ""
"The Rust compiler does not by default perform full inlining across crate "
"boundaries. As embedded applications are sensitive to unexpected code size "
"increases, `#[inline]` should be used to guide the compiler as follows:"
msgstr ""

#: src/design-patterns/hal/predictability.md:19
msgid ""
"All \"small\" functions should be marked `#[inline]`. What qualifies as "
"\"small\" is subjective, but generally all functions that are expected to "
"compile down to single-digit instruction sequences qualify as small."
msgstr ""

#: src/design-patterns/hal/predictability.md:22
msgid ""
"Functions that are very likely to take constant values as parameters should "
"be marked as `#[inline]`. This enables the compiler to compute even "
"complicated initialization logic at compile time, provided the function "
"inputs are known."
msgstr ""

#: src/design-patterns/hal/gpio.md:1
msgid "Recommendations for GPIO Interfaces"
msgstr ""

#: src/design-patterns/hal/gpio.md:3
msgid "<a id=\"c-zst-pin\"></a>"
msgstr ""

#: src/design-patterns/hal/gpio.md:4
msgid "Pin types are zero-sized by default (C-ZST-PIN)"
msgstr ""

#: src/design-patterns/hal/gpio.md:6
msgid ""
"GPIO Interfaces exposed by the HAL should provide dedicated zero-sized types "
"for each pin on every interface or port, resulting in a zero-cost GPIO "
"abstraction when all pin assignments are statically known."
msgstr ""

#: src/design-patterns/hal/gpio.md:10
msgid ""
"Each GPIO Interface or Port should implement a `split` method returning a "
"struct with every pin."
msgstr ""

#: src/design-patterns/hal/gpio.md:13 src/design-patterns/hal/gpio.md:45
#: src/design-patterns/hal/gpio.md:127
msgid "Example:"
msgstr ""

#: src/design-patterns/hal/gpio.md:39
msgid "<a id=\"c-erased-pin\"></a>"
msgstr ""

#: src/design-patterns/hal/gpio.md:40
msgid "Pin types provide methods to erase pin and port (C-ERASED-PIN)"
msgstr ""

#: src/design-patterns/hal/gpio.md:42
msgid ""
"Pins should provide type erasure methods that move their properties from "
"compile time to runtime, and allow more flexibility in applications."
msgstr ""

#: src/design-patterns/hal/gpio.md:48
msgid "/// Port A, pin 0.\n"
msgstr ""

#: src/design-patterns/hal/gpio.md:56
msgid "/// A pin on port A.\n"
msgstr ""

#: src/design-patterns/hal/gpio.md:59
msgid "/// The pin number.\n"
msgstr ""

#: src/design-patterns/hal/gpio.md:75
msgid "// (these fields can be packed to reduce the memory footprint)\n"
msgstr ""

#: src/design-patterns/hal/gpio.md:86
msgid "<a id=\"c-pin-state\"></a>"
msgstr ""

#: src/design-patterns/hal/gpio.md:87
msgid "Pin state should be encoded as type parameters (C-PIN-STATE)"
msgstr ""

#: src/design-patterns/hal/gpio.md:89
msgid ""
"Pins may be configured as input or output with different characteristics "
"depending on the chip or family. This state should be encoded in the type "
"system to prevent use of pins in incorrect states."
msgstr ""

#: src/design-patterns/hal/gpio.md:93
msgid ""
"Additional, chip-specific state (eg. drive strength) may also be encoded in "
"this way, using additional type parameters."
msgstr ""

#: src/design-patterns/hal/gpio.md:96
msgid ""
"Methods for changing the pin state should be provided as `into_input` and "
"`into_output` methods."
msgstr ""

#: src/design-patterns/hal/gpio.md:99
msgid ""
"Additionally, `with_{input,output}_state` methods should be provided that "
"temporarily reconfigure a pin in a different state without moving it."
msgstr ""

#: src/design-patterns/hal/gpio.md:102
msgid ""
"The following methods should be provided for every pin type (that is, both "
"erased and non-erased pin types should provide the same API):"
msgstr ""

#: src/design-patterns/hal/gpio.md:105
msgid "`pub fn into_input<N: InputState>(self, input: N) -> Pin<N>`"
msgstr ""

#: src/design-patterns/hal/gpio.md:106
msgid "`pub fn into_output<N: OutputState>(self, output: N) -> Pin<N>`"
msgstr ""

#: src/design-patterns/hal/gpio.md:123
msgid ""
"Pin state should be bounded by sealed traits. Users of the HAL should have "
"no need to add their own state. The traits can provide HAL-specific methods "
"required to implement the pin state API."
msgstr ""

#: src/design-patterns/hal/gpio.md:203
msgid "// Same for `PA` and `Pin`, and other pin types.\n"
msgstr ""

#: src/c-tips/index.md:3
msgid ""
"This chapter collects a variety of tips that might be useful to experienced "
"embedded C developers looking to start writing Rust. It will especially "
"highlight how things you might already be used to in C are different in Rust."
msgstr ""

#: src/c-tips/index.md:7
msgid "Preprocessor"
msgstr ""

#: src/c-tips/index.md:9
msgid ""
"In embedded C it is very common to use the preprocessor for a variety of "
"purposes, such as:"
msgstr ""

#: src/c-tips/index.md:12
msgid "Compile-time selection of code blocks with `#ifdef`"
msgstr ""

#: src/c-tips/index.md:13
msgid "Compile-time array sizes and computations"
msgstr ""

#: src/c-tips/index.md:14
msgid "Macros to simplify common patterns (to avoid function call overhead)"
msgstr ""

#: src/c-tips/index.md:16
msgid ""
"In Rust there is no preprocessor, and so many of these use cases are "
"addressed differently. In the rest of this section we cover various "
"alternatives to using the preprocessor."
msgstr ""

#: src/c-tips/index.md:20
msgid "Compile-Time Code Selection"
msgstr ""

#: src/c-tips/index.md:22
msgid ""
"The closest match to `#ifdef ... #endif` in Rust are [Cargo features]"
"(https://doc.rust-lang.org/cargo/reference/manifest.html#the-features-"
"section). These are a little more formal than the C preprocessor: all "
"possible features are explicitly listed per crate, and can only be either on "
"or off. Features are turned on when you list a crate as a dependency, and "
"are additive: if any crate in your dependency tree enables a feature for "
"another crate, that feature will be enabled for all users of that crate."
msgstr ""

#: src/c-tips/index.md:31
msgid ""
"For example, you might have a crate which provides a library of signal "
"processing primitives. Each one might take some extra time to compile or "
"declare some large table of constants which you'd like to avoid. You could "
"declare a Cargo feature for each component in your `Cargo.toml`:"
msgstr ""

#: src/c-tips/index.md:42
msgid ""
"Then, in your code, use `#[cfg(feature=\"FIR\")]` to control what is "
"included."
msgstr ""

#: src/c-tips/index.md:45
msgid "/// In your top-level lib.rs\n"
msgstr ""

#: src/c-tips/index.md:47
msgid "\"FIR\""
msgstr ""

#: src/c-tips/index.md:50
msgid "\"IIR\""
msgstr ""

#: src/c-tips/index.md:54
msgid ""
"You can similarly include code blocks only if a feature is _not_ enabled, or "
"if any combination of features are or are not enabled."
msgstr ""

#: src/c-tips/index.md:57
msgid ""
"Additionally, Rust provides a number of automatically-set conditions you can "
"use, such as `target_arch` to select different code based on architecture. "
"For full details of the conditional compilation support, refer to the "
"[conditional compilation](https://doc.rust-lang.org/reference/conditional-"
"compilation.html) chapter of the Rust reference."
msgstr ""

#: src/c-tips/index.md:64
msgid ""
"The conditional compilation will only apply to the next statement or block. "
"If a block can not be used in the current scope then the `cfg` attribute "
"will need to be used multiple times.  It's worth noting that most of the "
"time it is better to simply include all the code and allow the compiler to "
"remove dead code when optimising: it's simpler for you and your users, and "
"in general the compiler will do a good job of removing unused code."
msgstr ""

#: src/c-tips/index.md:71
msgid "Compile-Time Sizes and Computation"
msgstr ""

#: src/c-tips/index.md:73
msgid ""
"Rust supports `const fn`, functions which are guaranteed to be evaluable at "
"compile-time and can therefore be used where constants are required, such as "
"in the size of arrays. This can be used alongside features mentioned above, "
"for example:"
msgstr ""

#: src/c-tips/index.md:80 src/c-tips/index.md:82
msgid "\"use_more_ram\""
msgstr ""

#: src/c-tips/index.md:89
msgid ""
"These are new to stable Rust as of 1.31, so documentation is still sparse. "
"The functionality available to `const fn` is also very limited at the time "
"of writing; in future Rust releases it is expected to expand on what is "
"permitted in a `const fn`."
msgstr ""

#: src/c-tips/index.md:94
msgid "Macros"
msgstr ""

#: src/c-tips/index.md:96
msgid ""
"Rust provides an extremely powerful [macro system](https://doc.rust-lang.org/"
"book/ch19-06-macros.html). While the C preprocessor operates almost directly "
"on the text of your source code, the Rust macro system operates at a higher "
"level. There are two varieties of Rust macro: _macros by example_ and "
"_procedural macros_. The former are simpler and most common; they look like "
"function calls and can expand to a complete expression, statement, item, or "
"pattern. Procedural macros are more complex but permit extremely powerful "
"additions to the Rust language: they can transform arbitrary Rust syntax "
"into new Rust syntax."
msgstr ""

#: src/c-tips/index.md:107
msgid ""
"In general, where you might have used a C preprocessor macro, you probably "
"want to see if a macro-by-example can do the job instead. They can be "
"defined in your crate and easily used by your own crate or exported for "
"other users. Be aware that since they must expand to complete expressions, "
"statements, items, or patterns, some use cases of C preprocessor macros will "
"not work, for example a macro that expands to part of a variable name or an "
"incomplete set of items in a list."
msgstr ""

#: src/c-tips/index.md:115
msgid ""
"As with Cargo features, it is worth considering if you even need the macro. "
"In many cases a regular function is easier to understand and will be inlined "
"to the same code as a macro. The `#[inline]` and `#[inline(always)]` "
"[attributes](https://doc.rust-lang.org/reference/attributes.html#inline-"
"attribute) give you further control over this process, although care should "
"be taken here as well — the compiler will automatically inline functions "
"from the same crate where appropriate, so forcing it to do so "
"inappropriately might actually lead to decreased performance."
msgstr ""

#: src/c-tips/index.md:125
msgid ""
"Explaining the entire Rust macro system is out of scope for this tips page, "
"so you are encouraged to consult the Rust documentation for full details."
msgstr ""

#: src/c-tips/index.md:128
msgid "Build System"
msgstr ""

#: src/c-tips/index.md:130
msgid ""
"Most Rust crates are built using Cargo (although it is not required). This "
"takes care of many difficult problems with traditional build systems. "
"However, you may wish to customise the build process. Cargo provides "
"[`build.rs` scripts](https://doc.rust-lang.org/cargo/reference/build-"
"scripts.html) for this purpose. They are Rust scripts which can interact "
"with the Cargo build system as required."
msgstr ""

#: src/c-tips/index.md:138
msgid "Common use cases for build scripts include:"
msgstr ""

#: src/c-tips/index.md:140
msgid ""
"provide build-time information, for example statically embedding the build "
"date or Git commit hash into your executable"
msgstr ""

#: src/c-tips/index.md:142
msgid ""
"generate linker scripts at build time depending on selected features or "
"other logic"
msgstr ""

#: src/c-tips/index.md:144
msgid "change the Cargo build configuration"
msgstr ""

#: src/c-tips/index.md:145
msgid "add extra static libraries to link against"
msgstr ""

#: src/c-tips/index.md:147
msgid ""
"At present there is no support for post-build scripts, which you might "
"traditionally have used for tasks like automatic generation of binaries from "
"the build objects or printing build information."
msgstr ""

#: src/c-tips/index.md:151
msgid "Cross-Compiling"
msgstr ""

#: src/c-tips/index.md:153
msgid ""
"Using Cargo for your build system also simplifies cross-compiling. In most "
"cases it suffices to tell Cargo `--target thumbv6m-none-eabi` and find a "
"suitable executable in `target/thumbv6m-none-eabi/debug/myapp`."
msgstr ""

#: src/c-tips/index.md:157
msgid ""
"For platforms not natively supported by Rust, you will need to build "
"`libcore` for that target yourself. On such platforms, [Xargo](https://"
"github.com/japaric/xargo) can be used as a stand-in for Cargo which "
"automatically builds `libcore` for you."
msgstr ""

#: src/c-tips/index.md:163
msgid "Iterators vs Array Access"
msgstr ""

#: src/c-tips/index.md:165
msgid "In C you are probably used to accessing arrays directly by their index:"
msgstr ""

#: src/c-tips/index.md:175
msgid ""
"In Rust this is an anti-pattern: indexed access can be slower (as it needs "
"to be bounds checked) and may prevent various compiler optimisations. This "
"is an important distinction and worth repeating: Rust will check for out-of-"
"bounds access on manual array indexing to guarantee memory safety, while C "
"will happily index outside the array."
msgstr ""

#: src/c-tips/index.md:181
msgid "Instead, use iterators:"
msgstr ""

#: src/c-tips/index.md:190
msgid ""
"Iterators provide a powerful array of functionality you would have to "
"implement manually in C, such as chaining, zipping, enumerating, finding the "
"min or max, summing, and more. Iterator methods can also be chained, giving "
"very readable data processing code."
msgstr ""

#: src/c-tips/index.md:195
msgid ""
"See the [Iterators in the Book](https://doc.rust-lang.org/book/ch13-02-"
"iterators.html) and [Iterator documentation](https://doc.rust-lang.org/core/"
"iter/trait.Iterator.html) for more details."
msgstr ""

#: src/c-tips/index.md:200
msgid "References vs Pointers"
msgstr ""

#: src/c-tips/index.md:202
msgid ""
"In Rust, pointers (called [_raw pointers_](https://doc.rust-lang.org/book/"
"ch19-01-unsafe-rust.html#dereferencing-a-raw-pointer)) exist but are only "
"used in specific circumstances, as dereferencing them is always considered "
"`unsafe` -- Rust cannot provide its usual guarantees about what might be "
"behind the pointer."
msgstr ""

#: src/c-tips/index.md:208
msgid ""
"In most cases, we instead use _references_, indicated by the `&` symbol, or "
"_mutable references_, indicated by `&mut`. References behave similarly to "
"pointers, in that they can be dereferenced to access the underlying values, "
"but they are a key part of Rust's ownership system: Rust will strictly "
"enforce that you may only have one mutable reference _or_ multiple non-"
"mutable references to the same value at any given time."
msgstr ""

#: src/c-tips/index.md:215
msgid ""
"In practice this means you have to be more careful about whether you need "
"mutable access to data: where in C the default is mutable and you must be "
"explicit about `const`, in Rust the opposite is true."
msgstr ""

#: src/c-tips/index.md:219
msgid ""
"One situation where you might still use raw pointers is interacting directly "
"with hardware (for example, writing a pointer to a buffer into a DMA "
"peripheral register), and they are also used under the hood for all "
"peripheral access crates to allow you to read and write memory-mapped "
"registers."
msgstr ""

#: src/c-tips/index.md:224
msgid "Volatile Access"
msgstr ""

#: src/c-tips/index.md:226
msgid ""
"In C, individual variables may be marked `volatile`, indicating to the "
"compiler that the value in the variable may change between accesses. "
"Volatile variables are commonly used in an embedded context for memory-"
"mapped registers."
msgstr ""

#: src/c-tips/index.md:230
msgid ""
"In Rust, instead of marking a variable as `volatile`, we use specific "
"methods to perform volatile access: [`core::ptr::read_volatile`](https://"
"doc.rust-lang.org/core/ptr/fn.read_volatile.html) and "
"[`core::ptr::write_volatile`](https://doc.rust-lang.org/core/ptr/"
"fn.write_volatile.html). These methods take a `*const T` or a `*mut T` (_raw "
"pointers_, as discussed above) and perform a volatile read or write."
msgstr ""

#: src/c-tips/index.md:238
msgid "For example, in C you might write:"
msgstr ""

#: src/c-tips/index.md:244
msgid "// Signal that the interrupt has occurred\n"
msgstr ""

#: src/c-tips/index.md:250 src/c-tips/index.md:275
msgid "// Sleep until signalled\n"
msgstr ""

#: src/c-tips/index.md:252 src/c-tips/index.md:277
msgid "// Reset signalled indicator\n"
msgstr ""

#: src/c-tips/index.md:254 src/c-tips/index.md:279
msgid "// Perform some task that was waiting for the interrupt\n"
msgstr ""

#: src/c-tips/index.md:260
msgid "The equivalent in Rust would use volatile methods on each access:"
msgstr ""

#: src/c-tips/index.md:267
msgid ""
"// Signal that the interrupt has occurred\n"
"    // (In real code, you should consider a higher level primitive,\n"
"    //  such as an atomic type).\n"
msgstr ""

#: src/c-tips/index.md:285
msgid "A few things are worth noting in the code sample:"
msgstr ""

#: src/c-tips/index.md:286
msgid ""
"We can pass `&mut SIGNALLED` into the function requiring `*mut T`, since "
"`&mut T` automatically converts to a `*mut T` (and the same for `*const T`)"
msgstr ""

#: src/c-tips/index.md:288
msgid ""
"We need `unsafe` blocks for the `read_volatile`/`write_volatile` methods, "
"since they are `unsafe` functions. It is the programmer's responsibility to "
"ensure safe use: see the methods' documentation for further details."
msgstr ""

#: src/c-tips/index.md:292
msgid ""
"It is rare to require these functions directly in your code, as they will "
"usually be taken care of for you by higher-level libraries. For memory "
"mapped peripherals, the peripheral access crates will implement volatile "
"access automatically, while for concurrency primitives there are better "
"abstractions available (see the [Concurrency chapter](../concurrency/"
"index.md))."
msgstr ""

#: src/c-tips/index.md:300
msgid "Packed and Aligned Types"
msgstr ""

#: src/c-tips/index.md:302
msgid ""
"In embedded C it is common to tell the compiler a variable must have a "
"certain alignment or a struct must be packed rather than aligned, usually to "
"meet specific hardware or protocol requirements."
msgstr ""

#: src/c-tips/index.md:306
msgid ""
"In Rust this is controlled by the `repr` attribute on a struct or union. The "
"default representation provides no guarantees of layout, so should not be "
"used for code that interoperates with hardware or C. The compiler may re-"
"order struct members or insert padding and the behaviour may change with "
"future versions of Rust."
msgstr ""

#: src/c-tips/index.md:321 src/c-tips/index.md:340 src/c-tips/index.md:366
#: src/c-tips/index.md:390 src/c-tips/index.md:391
msgid "\"{:p} {:p} {:p}\""
msgstr ""

#: src/c-tips/index.md:323
msgid ""
"// 0x7ffecb3511d0 0x7ffecb3511d4 0x7ffecb3511d2\n"
"// Note ordering has been changed to x, z, y to improve packing.\n"
msgstr ""

#: src/c-tips/index.md:328
msgid "To ensure layouts that are interoperable with C, use `repr(C)`:"
msgstr ""

#: src/c-tips/index.md:342
msgid ""
"// 0x7fffd0d84c60 0x7fffd0d84c62 0x7fffd0d84c64\n"
"// Ordering is preserved and the layout will not change over time.\n"
"// `z` is two-byte aligned so a byte of padding exists between `y` and `z`.\n"
msgstr ""

#: src/c-tips/index.md:348
msgid "To ensure a packed representation, use `repr(packed)`:"
msgstr ""

#: src/c-tips/index.md:360
msgid ""
"// References must always be aligned, so to check the addresses of the\n"
"    // struct's fields, we use `std::ptr::addr_of!()` to get a raw pointer\n"
"    // instead of just printing `&v.x`.\n"
msgstr ""

#: src/c-tips/index.md:368
msgid ""
"// 0x7ffd33598490 0x7ffd33598492 0x7ffd33598493\n"
"// No padding has been inserted between `y` and `z`, so now `z` is "
"unaligned.\n"
msgstr ""

#: src/c-tips/index.md:373
msgid ""
"Note that using `repr(packed)` also sets the alignment of the type to `1`."
msgstr ""

#: src/c-tips/index.md:375
msgid ""
"Finally, to specify a specific alignment, use `repr(align(n))`, where `n` is "
"the number of bytes to align to (and must be a power of two):"
msgstr ""

#: src/c-tips/index.md:393
msgid ""
"// 0x7ffec909a000 0x7ffec909a002 0x7ffec909a004\n"
"// 0x7ffec909b000 0x7ffec909b002 0x7ffec909b004\n"
"// The two instances `u` and `v` have been placed on 4096-byte alignments,\n"
"// evidenced by the `000` at the end of their addresses.\n"
msgstr ""

#: src/c-tips/index.md:400
msgid ""
"Note we can combine `repr(C)` with `repr(align(n))` to obtain an aligned and "
"C-compatible layout. It is not permissible to combine `repr(align(n))` with "
"`repr(packed)`, since `repr(packed)` sets the alignment to `1`. It is also "
"not permissible for a `repr(packed)` type to contain a `repr(align(n))` type."
msgstr ""

#: src/c-tips/index.md:405
msgid ""
"For further details on type layouts, refer to the [type layout](https://"
"doc.rust-lang.org/reference/type-layout.html) chapter of the Rust Reference."
msgstr ""

#: src/c-tips/index.md:412
msgid "In this book:"
msgstr ""

#: src/c-tips/index.md:413
msgid "[A little C with your Rust](../interoperability/c-with-rust.md)"
msgstr ""

#: src/c-tips/index.md:414
msgid "[A little Rust with your C](../interoperability/rust-with-c.md)"
msgstr ""

#: src/c-tips/index.md:415
msgid "[The Rust Embedded FAQs](https://docs.rust-embedded.org/faq.html)"
msgstr ""

#: src/c-tips/index.md:416
msgid "[Rust Pointers for C Programmers](http://blahg.josefsipek.net/?p=580)"
msgstr ""

#: src/c-tips/index.md:417
msgid ""
"[I used to use pointers - now what?](https://github.com/diwic/reffers-rs/"
"blob/master/docs/Pointers.md)"
msgstr ""

#: src/interoperability/index.md:3
msgid ""
"Interoperability between Rust and C code is always dependent on transforming "
"data between the two languages. For this purpose, there is a dedicated "
"module in the `stdlib` called [`std::ffi`](https://doc.rust-lang.org/std/ffi/"
"index.html)."
msgstr ""

#: src/interoperability/index.md:9
msgid ""
"`std::ffi` provides type definitions for C primitive types, such as `char`, "
"`int`, and `long`. It also provides some utility for converting more complex "
"types such as strings, mapping both `&str` and `String` to C types that are "
"easier and safer to handle."
msgstr ""

#: src/interoperability/index.md:15
msgid ""
"As of Rust 1.30, functionalities of `std::ffi` are available in either "
"`core::ffi` or `alloc::ffi` depending on whether or not memory allocation is "
"involved. The [`cty`](https://crates.io/crates/cty) crate and the "
"[`cstr_core`](https://crates.io/crates/cstr_core) crate also offer similar "
"functionalities."
msgstr ""

#: src/interoperability/index.md:25
msgid "Rust type"
msgstr ""

#: src/interoperability/index.md:25
msgid "Intermediate"
msgstr ""

#: src/interoperability/index.md:25
msgid "C type"
msgstr ""

#: src/interoperability/index.md:27
msgid "`String`"
msgstr ""

#: src/interoperability/index.md:27
msgid "`CString`"
msgstr ""

#: src/interoperability/index.md:27
msgid "`char *`"
msgstr ""

#: src/interoperability/index.md:28
msgid "`&str`"
msgstr ""

#: src/interoperability/index.md:28
msgid "`CStr`"
msgstr ""

#: src/interoperability/index.md:28
msgid "`const char *`"
msgstr ""

#: src/interoperability/index.md:29
msgid "`()`"
msgstr ""

#: src/interoperability/index.md:29
msgid "`c_void`"
msgstr ""

#: src/interoperability/index.md:29
msgid "`void`"
msgstr ""

#: src/interoperability/index.md:30
msgid "`u32` or `u64`"
msgstr ""

#: src/interoperability/index.md:30
msgid "`c_uint`"
msgstr ""

#: src/interoperability/index.md:30
msgid "`unsigned int`"
msgstr ""

#: src/interoperability/index.md:31
msgid "etc"
msgstr ""

#: src/interoperability/index.md:31
msgid "..."
msgstr ""

#: src/interoperability/index.md:33
msgid ""
"A value of a C primitive type can be used as one of the corresponding Rust "
"type and vice versa, since the former is simply a type alias of the latter. "
"For example, the following code compiles on platforms where `unsigned int` "
"is 32-bit long."
msgstr ""

#: src/interoperability/index.md:46
msgid "Interoperability with other build systems"
msgstr ""

#: src/interoperability/index.md:48
msgid ""
"A common requirement for including Rust in your embedded project is "
"combining Cargo with your existing build system, such as make or cmake."
msgstr ""

#: src/interoperability/index.md:51
msgid ""
"We are collecting examples and use cases for this on our issue tracker in "
"[issue #61](https://github.com/rust-embedded/book/issues/61)."
msgstr ""

#: src/interoperability/index.md:56
msgid "Interoperability with RTOSs"
msgstr ""

#: src/interoperability/index.md:58
msgid ""
"Integrating Rust with an RTOS such as FreeRTOS or ChibiOS is still a work in "
"progress; especially calling RTOS functions from Rust can be tricky."
msgstr ""

#: src/interoperability/index.md:61
msgid ""
"We are collecting examples and use cases for this on our issue tracker in "
"[issue #62](https://github.com/rust-embedded/book/issues/62)."
msgstr ""

#: src/interoperability/c-with-rust.md:3
msgid "Using C or C++ inside of a Rust project consists of two major parts:"
msgstr ""

#: src/interoperability/c-with-rust.md:5
msgid "Wrapping the exposed C API for use with Rust"
msgstr ""

#: src/interoperability/c-with-rust.md:6
msgid "Building your C or C++ code to be integrated with the Rust code"
msgstr ""

#: src/interoperability/c-with-rust.md:8
msgid ""
"As C++ does not have a stable ABI for the Rust compiler to target, it is "
"recommended to use the `C` ABI when combining Rust with C or C++."
msgstr ""

#: src/interoperability/c-with-rust.md:10
msgid "Defining the interface"
msgstr ""

#: src/interoperability/c-with-rust.md:12
msgid ""
"Before consuming C or C++ code from Rust, it is necessary to define (in "
"Rust) what data types and function signatures exist in the linked code. In C "
"or C++, you would include a header (`.h` or `.hpp`) file which defines this "
"data. In Rust, it is necessary to either manually translate these "
"definitions to Rust, or use a tool to generate these definitions."
msgstr ""

#: src/interoperability/c-with-rust.md:14
msgid ""
"First, we will cover manually translating these definitions from C/C++ to "
"Rust."
msgstr ""

#: src/interoperability/c-with-rust.md:16
msgid "Wrapping C functions and Datatypes"
msgstr ""

#: src/interoperability/c-with-rust.md:18
msgid ""
"Typically, libraries written in C or C++ will provide a header file defining "
"all types and functions used in public interfaces. An example file may look "
"like this:"
msgstr ""

#: src/interoperability/c-with-rust.md:21
msgid "/* File: cool.h */"
msgstr ""

#: src/interoperability/c-with-rust.md:30
msgid "When translated to Rust, this interface would look as such:"
msgstr ""

#: src/interoperability/c-with-rust.md:33
msgid "/* File: cool_bindings.rs */"
msgstr ""

#: src/interoperability/c-with-rust.md:40
#: src/interoperability/c-with-rust.md:66
#: src/interoperability/rust-with-c.md:56
#: src/interoperability/rust-with-c.md:82
msgid "\"C\""
msgstr ""

#: src/interoperability/c-with-rust.md:49
msgid ""
"Let's take a look at this definition one piece at a time, to explain each of "
"the parts."
msgstr ""

#: src/interoperability/c-with-rust.md:56
msgid ""
"By default, Rust does not guarantee order, padding, or the size of data "
"included in a `struct`. In order to guarantee compatibility with C code, we "
"include the `#[repr(C)]` attribute, which instructs the Rust compiler to "
"always use the same rules C does for organizing data within a struct."
msgstr ""

#: src/interoperability/c-with-rust.md:63
msgid ""
"Due to the flexibility of how C or C++ defines an `int` or `char`, it is "
"recommended to use primitive data types defined in `cty`, which will map "
"types from C to types in Rust."
msgstr ""

#: src/interoperability/c-with-rust.md:69
msgid ""
"This statement defines the signature of a function that uses the C ABI, "
"called `cool_function`. By defining the signature without defining the body "
"of the function, the definition of this function will need to be provided "
"elsewhere, or linked into the final library or binary from a static library."
msgstr ""

#: src/interoperability/c-with-rust.md:77
msgid ""
"Similar to our datatype above, we define the datatypes of the function "
"arguments using C-compatible definitions. We also retain the same argument "
"names, for clarity."
msgstr ""

#: src/interoperability/c-with-rust.md:79
msgid ""
"We have one new type here, `*mut CoolStruct`. As C does not have a concept "
"of Rust's references, which would look like this: `&mut CoolStruct`, we "
"instead have a raw pointer. As dereferencing this pointer is `unsafe`, and "
"the pointer may in fact be a `null` pointer, care must be taken to ensure "
"the guarantees typical of Rust when interacting with C or C++ code."
msgstr ""

#: src/interoperability/c-with-rust.md:81
msgid "Automatically generating the interface"
msgstr ""

#: src/interoperability/c-with-rust.md:83
msgid ""
"Rather than manually generating these interfaces, which may be tedious and "
"error prone, there is a tool called [bindgen](https://github.com/rust-lang/"
"rust-bindgen) which will perform these conversions automatically. For "
"instructions of the usage of [bindgen](https://github.com/rust-lang/rust-"
"bindgen), please refer to the [bindgen user's manual](https://rust-"
"lang.github.io/rust-bindgen/), however the typical process consists of the "
"following:"
msgstr ""

#: src/interoperability/c-with-rust.md:85
msgid ""
"Gather all C or C++ headers defining interfaces or datatypes you would like "
"to use with Rust."
msgstr ""

#: src/interoperability/c-with-rust.md:86
msgid ""
"Write a `bindings.h` file, which `#include \"...\"`'s each of the files you "
"gathered in step one."
msgstr ""

#: src/interoperability/c-with-rust.md:87
msgid ""
"Feed this `bindings.h` file, along with any compilation flags used to "
"compile your code into `bindgen`. Tip: use "
"`Builder.ctypes_prefix(\"cty\")` / `--ctypes-prefix=cty` and "
"`Builder.use_core()` / `--use-core` to make the generated code `#![no_std]` "
"compatible."
msgstr ""

#: src/interoperability/c-with-rust.md:90
msgid ""
"`bindgen` will produce the generated Rust code to the output of the terminal "
"window. This output may be piped to a file in your project, such as "
"`bindings.rs`. You may use this file in your Rust project to interact with C/"
"C++ code compiled and linked as an external library. Tip: don't forget to "
"use the [`cty`](https://crates.io/crates/cty) crate if your types in the "
"generated bindings are prefixed with `cty`."
msgstr ""

#: src/interoperability/c-with-rust.md:95
msgid "Building your C/C++ code"
msgstr ""

#: src/interoperability/c-with-rust.md:97
msgid ""
"As the Rust compiler does not directly know how to compile C or C++ code (or "
"code from any other language, which presents a C interface), it is necessary "
"to compile your non-Rust code ahead of time."
msgstr ""

#: src/interoperability/c-with-rust.md:99
msgid ""
"For embedded projects, this most commonly means compiling the C/C++ code to "
"a static archive (such as `cool-library.a`), which can then be combined with "
"your Rust code at the final linking step."
msgstr ""

#: src/interoperability/c-with-rust.md:101
msgid ""
"If the library you would like to use is already distributed as a static "
"archive, it is not necessary to rebuild your code. Just convert the provided "
"interface header file as described above, and include the static archive at "
"compile/link time."
msgstr ""

#: src/interoperability/c-with-rust.md:103
msgid ""
"If your code exists as a source project, it will be necessary to compile "
"your C/C++ code to a static library, either by triggering your existing "
"build system (such as `make`, `CMake`, etc.), or by porting the necessary "
"compilation steps to use a tool called the `cc` crate. For both of these "
"steps, it is necessary to use a `build.rs` script."
msgstr ""

#: src/interoperability/c-with-rust.md:105
msgid "Rust `build.rs` build scripts"
msgstr ""

#: src/interoperability/c-with-rust.md:107
msgid ""
"A `build.rs` script is a file written in Rust syntax, that is executed on "
"your compilation machine, AFTER dependencies of your project have been "
"built, but BEFORE your project is built."
msgstr ""

#: src/interoperability/c-with-rust.md:109
msgid ""
"The full reference may be found [here](https://doc.rust-lang.org/cargo/"
"reference/build-scripts.html). `build.rs` scripts are useful for generating "
"code (such as via [bindgen](https://github.com/rust-lang/rust-bindgen)), "
"calling out to external build systems such as `Make`, or directly compiling "
"C/C++ through use of the `cc` crate."
msgstr ""

#: src/interoperability/c-with-rust.md:111
msgid "Triggering external build systems"
msgstr ""

#: src/interoperability/c-with-rust.md:113
msgid ""
"For projects with complex external projects or build systems, it may be "
"easiest to use [`std::process::Command`](https://doc.rust-lang.org/std/"
"process/struct.Command.html) to \"shell out\" to your other build systems by "
"traversing relative paths, calling a fixed command (such as `make library`), "
"and then copying the resulting static library to the proper location in the "
"`target` build directory."
msgstr ""

#: src/interoperability/c-with-rust.md:115
msgid ""
"While your crate may be targeting a `no_std` embedded platform, your "
"`build.rs` executes only on machines compiling your crate. This means you "
"may use any Rust crates which will run on your compilation host."
msgstr ""

#: src/interoperability/c-with-rust.md:119
msgid "Building C/C++ code with the `cc` crate"
msgstr ""

#: src/interoperability/c-with-rust.md:121
msgid ""
"For projects with limited dependencies or complexity, or for projects where "
"it is difficult to modify the build system to produce a static library "
"(rather than a final binary or executable), it may be easier to instead "
"utilize the [`cc` crate](https://github.com/alexcrichton/cc-rs), which "
"provides an idiomatic Rust interface to the compiler provided by the host."
msgstr ""

#: src/interoperability/c-with-rust.md:125
msgid ""
"In the simplest case of compiling a single C file as a dependency to a "
"static library, an example `build.rs` script using the [`cc` crate](https://"
"github.com/alexcrichton/cc-rs) would look like this:"
msgstr ""

#: src/interoperability/c-with-rust.md:130
msgid "\"src/foo.c\""
msgstr ""

#: src/interoperability/c-with-rust.md:131
msgid "\"foo\""
msgstr ""

#: src/interoperability/c-with-rust.md:135
msgid ""
"The `build.rs` is placed at the root of the package. Then `cargo build` will "
"compile and execute it before the build of the package. A static archive "
"named `libfoo.a` is generated and placed in the `target` directory."
msgstr ""

#: src/interoperability/rust-with-c.md:3
msgid "Using Rust code inside a C or C++ project mostly consists of two parts."
msgstr ""

#: src/interoperability/rust-with-c.md:5
msgid "Creating a C-friendly API in Rust"
msgstr ""

#: src/interoperability/rust-with-c.md:6
msgid "Embedding your Rust project into an external build system"
msgstr ""

#: src/interoperability/rust-with-c.md:8
msgid ""
"Apart from `cargo` and `meson`, most build systems don't have native Rust "
"support. So you're most likely best off just using `cargo` for compiling "
"your crate and any dependencies."
msgstr ""

#: src/interoperability/rust-with-c.md:12
msgid "Setting up a project"
msgstr ""

#: src/interoperability/rust-with-c.md:14
msgid "Create a new `cargo` project as usual."
msgstr ""

#: src/interoperability/rust-with-c.md:16
msgid ""
"There are flags to tell `cargo` to emit a systems library, instead of its "
"regular rust target. This also allows you to set a different output name for "
"your library, if you want it to differ from the rest of your crate."
msgstr ""

#: src/interoperability/rust-with-c.md:21
msgid ""
"```toml\n"
"[lib]\n"
"name = \"your_crate\"\n"
"crate-type = [\"cdylib\"]      # Creates dynamic lib\n"
"# crate-type = [\"staticlib\"] # Creates static lib\n"
"```"
msgstr ""

#: src/interoperability/rust-with-c.md:28
msgid "Building a `C` API"
msgstr ""

#: src/interoperability/rust-with-c.md:30
msgid ""
"Because C++ has no stable ABI for the Rust compiler to target, we use `C` "
"for any interoperability between different languages. This is no exception "
"when using Rust inside of C and C++ code."
msgstr ""

#: src/interoperability/rust-with-c.md:34
msgid "`#[no_mangle]`"
msgstr ""

#: src/interoperability/rust-with-c.md:36
msgid ""
"The Rust compiler mangles symbol names differently than native code linkers "
"expect. As such, any function that Rust exports to be used outside of Rust "
"needs to be told not to be mangled by the compiler."
msgstr ""

#: src/interoperability/rust-with-c.md:40
msgid "`extern \"C\"`"
msgstr ""

#: src/interoperability/rust-with-c.md:42
msgid ""
"By default, any function you write in Rust will use the Rust ABI (which is "
"also not stabilized). Instead, when building outwards facing FFI APIs we "
"need to tell the compiler to use the system ABI."
msgstr ""

#: src/interoperability/rust-with-c.md:47
msgid ""
"Depending on your platform, you might want to target a specific ABI version, "
"which are documented [here](https://doc.rust-lang.org/reference/items/"
"external-blocks.html)."
msgstr ""

#: src/interoperability/rust-with-c.md:52
msgid ""
"Putting these parts together, you get a function that looks roughly like "
"this."
msgstr ""

#: src/interoperability/rust-with-c.md:61
msgid ""
"Just as when using `C` code in your Rust project you now need to transform "
"data from and to a form that the rest of the application will understand."
msgstr ""

#: src/interoperability/rust-with-c.md:64
msgid "Linking and greater project context."
msgstr ""

#: src/interoperability/rust-with-c.md:66
msgid ""
"So then, that's one half of the problem solved. How do you use this now?"
msgstr ""

#: src/interoperability/rust-with-c.md:69
msgid "**This very much depends on your project and/or build system**"
msgstr ""

#: src/interoperability/rust-with-c.md:71
msgid ""
"`cargo` will create a `my_lib.so`/`my_lib.dll` or `my_lib.a` file, depending "
"on your platform and settings. This library can simply be linked by your "
"build system."
msgstr ""

#: src/interoperability/rust-with-c.md:75
msgid ""
"However, calling a Rust function from C requires a header file to declare "
"the function signatures."
msgstr ""

#: src/interoperability/rust-with-c.md:78
msgid ""
"Every function in your Rust-ffi API needs to have a corresponding header "
"function."
msgstr ""

#: src/interoperability/rust-with-c.md:85
msgid "would then become"
msgstr ""

#: src/interoperability/rust-with-c.md:91
msgid "etc."
msgstr ""

#: src/interoperability/rust-with-c.md:93
msgid ""
"There is a tool to automate this process, called [cbindgen](https://"
"github.com/eqrion/cbindgen) which analyses your Rust code and then generates "
"headers for your C and C++ projects from it."
msgstr ""

#: src/interoperability/rust-with-c.md:99
msgid ""
"At this point, using the Rust functions from C is as simple as including the "
"header and calling them!"
msgstr ""

#: src/interoperability/rust-with-c.md:103
msgid "\"my-rust-project.h\""
msgstr ""

#: src/unsorted/speed-vs-size.md:1
msgid "Optimizations: the speed size tradeoff"
msgstr ""

#: src/unsorted/speed-vs-size.md:3
msgid ""
"Everyone wants their program to be super fast and super small but it's "
"usually not possible to have both characteristics. This section discusses "
"the different optimization levels that `rustc` provides and how they affect "
"the execution time and binary size of a program."
msgstr ""

#: src/unsorted/speed-vs-size.md:8
msgid "No optimizations"
msgstr ""

#: src/unsorted/speed-vs-size.md:10
msgid ""
"This is the default. When you call `cargo build` you use the development "
"(AKA `dev`) profile. This profile is optimized for debugging so it enables "
"debug information and does _not_ enable any optimizations, i.e. it uses `-C "
"opt-level = 0`."
msgstr ""

#: src/unsorted/speed-vs-size.md:15
msgid ""
"At least for bare metal development, debuginfo is zero cost in the sense "
"that it won't occupy space in Flash / ROM so we actually recommend that you "
"enable debuginfo in the release profile -- it is disabled by default. That "
"will let you use breakpoints when debugging release builds."
msgstr ""

#: src/unsorted/speed-vs-size.md:26
msgid ""
"No optimizations is great for debugging because stepping through the code "
"feels like you are executing the program statement by statement, plus you "
"can `print` stack variables and function arguments in GDB. When the code is "
"optimized, trying to print variables results in `$0 = <value optimized out>` "
"being printed."
msgstr ""

#: src/unsorted/speed-vs-size.md:31
msgid ""
"The biggest downside of the `dev` profile is that the resulting binary will "
"be huge and slow. The size is usually more of a problem because unoptimized "
"binaries can occupy dozens of KiB of Flash, which your target device may not "
"have -- the result: your unoptimized binary doesn't fit in your device!"
msgstr ""

#: src/unsorted/speed-vs-size.md:36
msgid "Can we have smaller, debugger friendly binaries? Yes, there's a trick."
msgstr ""

#: src/unsorted/speed-vs-size.md:38
msgid "Optimizing dependencies"
msgstr ""

#: src/unsorted/speed-vs-size.md:40
msgid ""
"There's a Cargo feature named [`profile-overrides`](https://doc.rust-"
"lang.org/cargo/reference/profiles.html#overrides) that lets you override the "
"optimization level of dependencies. You can use that feature to optimize all "
"dependencies for size while keeping the top crate unoptimized and debugger "
"friendly."
msgstr ""

#: src/unsorted/speed-vs-size.md:45
msgid ""
"Beware that generic code can sometimes be optimized alongside the crate "
"where it is instantiated, rather than the crate where it is defined. If you "
"create an instance of a generic struct in your application and find that it "
"pulls in code with a large footprint, it may be that increasing the "
"optimisation level of the relevant dependencies has no effect."
msgstr ""

#: src/unsorted/speed-vs-size.md:53
msgid "Here's an example:"
msgstr ""

#: src/unsorted/speed-vs-size.md:55
msgid ""
"```toml\n"
"# Cargo.toml\n"
"[package]\n"
"name = \"app\"\n"
"# ..\n"
"\n"
"[profile.dev.package.\"*\"] # +\n"
"opt-level = \"z\" # +\n"
"```"
msgstr ""

#: src/unsorted/speed-vs-size.md:65
msgid "Without the override:"
msgstr ""

#: src/unsorted/speed-vs-size.md:78
msgid "With the override:"
msgstr ""

#: src/unsorted/speed-vs-size.md:91
msgid ""
"That's a 6 KiB reduction in Flash usage without any loss in the "
"debuggability of the top crate. If you step into a dependency then you'll "
"start seeing those `<value optimized out>` messages again but it's usually "
"the case that you want to debug the top crate and not the dependencies. And "
"if you _do_ need to debug a dependency then you can use the `profile-"
"overrides` feature to exclude a particular dependency from being optimized. "
"See example below:"
msgstr ""

#: src/unsorted/speed-vs-size.md:98
msgid ""
"```toml\n"
"# ..\n"
"\n"
"# don't optimize the `cortex-m-rt` crate\n"
"[profile.dev.package.cortex-m-rt] # +\n"
"opt-level = 0 # +\n"
"\n"
"# but do optimize all the other dependencies\n"
"[profile.dev.package.\"*\"]\n"
"codegen-units = 1 # better optimizations\n"
"opt-level = \"z\"\n"
"```"
msgstr ""

#: src/unsorted/speed-vs-size.md:111
msgid "Now the top crate and `cortex-m-rt` are debugger friendly!"
msgstr ""

#: src/unsorted/speed-vs-size.md:113
msgid "Optimize for speed"
msgstr ""

#: src/unsorted/speed-vs-size.md:115
msgid ""
"As of 2018-09-18 `rustc` supports three \"optimize for speed\" levels: `opt-"
"level = 1`, `2` and `3`. When you run `cargo build --release` you are using "
"the release profile which defaults to `opt-level = 3`."
msgstr ""

#: src/unsorted/speed-vs-size.md:119
msgid ""
"Both `opt-level = 2` and `3` optimize for speed at the expense of binary "
"size, but level `3` does more vectorization and inlining than level `2`. In "
"particular, you'll see that at `opt-level` equal to or greater than `2` LLVM "
"will unroll loops. Loop unrolling has a rather high cost in terms of Flash / "
"ROM (e.g. from 26 bytes to 194 for a zero this array loop) but can also "
"halve the execution time given the right conditions (e.g. number of "
"iterations is big enough)."
msgstr ""

#: src/unsorted/speed-vs-size.md:127
msgid ""
"Currently there's no way to disable loop unrolling in `opt-level = 2` and "
"`3` so if you can't afford its cost you should optimize your program for "
"size."
msgstr ""

#: src/unsorted/speed-vs-size.md:130
msgid "Optimize for size"
msgstr ""

#: src/unsorted/speed-vs-size.md:132
msgid ""
"As of 2018-09-18 `rustc` supports two \"optimize for size\" levels: `opt-"
"level = \"s\"` and `\"z\"`. These names were inherited from clang / LLVM and "
"are not too descriptive but `\"z\"` is meant to give the idea that it "
"produces smaller binaries than `\"s\"`."
msgstr ""

#: src/unsorted/speed-vs-size.md:137
msgid ""
"If you want your release binaries to be optimized for size then change the "
"`profile.release.opt-level` setting in `Cargo.toml` as shown below."
msgstr ""

#: src/unsorted/speed-vs-size.md:140
msgid ""
"```toml\n"
"[profile.release]\n"
"# or \"z\"\n"
"opt-level = \"s\"\n"
"```"
msgstr ""

#: src/unsorted/speed-vs-size.md:146
msgid ""
"These two optimization levels greatly reduce LLVM's inline threshold, a "
"metric used to decide whether to inline a function or not. One of Rust "
"principles are zero cost abstractions; these abstractions tend to use a lot "
"of newtypes and small functions to hold invariants (e.g. functions that "
"borrow an inner value like `deref`, `as_ref`) so a low inline threshold can "
"make LLVM miss optimization opportunities (e.g. eliminate dead branches, "
"inline calls to closures)."
msgstr ""

#: src/unsorted/speed-vs-size.md:154
msgid ""
"When optimizing for size you may want to try increasing the inline threshold "
"to see if that has any effect on the binary size. The recommended way to "
"change the inline threshold is to append the `-C inline-threshold` flag to "
"the other rustflags in `.cargo/config.toml`."
msgstr ""

#: src/unsorted/speed-vs-size.md:159
msgid ""
"```toml\n"
"# .cargo/config.toml\n"
"# this assumes that you are using the cortex-m-quickstart template\n"
"[target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))']\n"
"rustflags = [\n"
"  # ..\n"
"  \"-C\", \"inline-threshold=123\", # +\n"
"]\n"
"```"
msgstr ""

#: src/unsorted/speed-vs-size.md:169
msgid ""
"What value to use? [As of 1.29.0 these are the inline thresholds that the "
"different optimization levels use](https://github.com/rust-lang/rust/blob/"
"1.29.0/src/librustc_codegen_llvm/back/write.rs#L2105-L2122):"
msgstr ""

#: src/unsorted/speed-vs-size.md:174
msgid "`opt-level = 3` uses 275"
msgstr ""

#: src/unsorted/speed-vs-size.md:175
msgid "`opt-level = 2` uses 225"
msgstr ""

#: src/unsorted/speed-vs-size.md:176
msgid "`opt-level = \"s\"` uses 75"
msgstr ""

#: src/unsorted/speed-vs-size.md:177
msgid "`opt-level = \"z\"` uses 25"
msgstr ""

#: src/unsorted/speed-vs-size.md:179
msgid "You should try `225` and `275` when optimizing for size."
msgstr ""

#: src/unsorted/math.md:1
msgid "Performing math functionality with `#[no_std]`"
msgstr ""

#: src/unsorted/math.md:3
msgid ""
"If you want to perform math related functionality like calculating the "
"squareroot or the exponential of a number and you have the full standard "
"library available, your code might look like this:"
msgstr ""

#: src/unsorted/math.md:8
msgid "//! Some mathematical functions with standard support available\n"
msgstr ""

#: src/unsorted/math.md:19 src/unsorted/math.md:53
msgid "\"Floored test float {} to {}\""
msgstr ""

#: src/unsorted/math.md:20 src/unsorted/math.md:54
msgid "\"The square root of {} is {}\""
msgstr ""

#: src/unsorted/math.md:21 src/unsorted/math.md:55
msgid "\"The sinus of four is {}\""
msgstr ""

#: src/unsorted/math.md:23 src/unsorted/math.md:57
msgid "\"The exponential of four to the base e is {}\""
msgstr ""

#: src/unsorted/math.md:29
msgid ""
"Without standard library support, these functions are not available. An "
"external crate like [`libm`](https://crates.io/crates/libm) can be used "
"instead. The example code would then look like this:"
msgstr ""

#: src/unsorted/math.md:69
msgid ""
"If you need to perform more complex operations like DSP signal processing or "
"advanced linear algebra on your MCU, the following crates might help you"
msgstr ""

#: src/unsorted/math.md:72
msgid ""
"[CMSIS DSP library binding](https://github.com/jacobrosenthal/cmsis-dsp-sys)"
msgstr ""

#: src/unsorted/math.md:73
msgid "[`constgebra`](https://crates.io/crates/constgebra)"
msgstr ""

#: src/unsorted/math.md:74
msgid "[`micromath`](https://github.com/tarcieri/micromath)"
msgstr ""

#: src/unsorted/math.md:75
msgid "[`microfft`](https://crates.io/crates/microfft)"
msgstr ""

#: src/unsorted/math.md:76
msgid "[`nalgebra`](https://github.com/dimforge/nalgebra)"
msgstr ""

#: src/appendix/glossary.md:3
msgid ""
"The embedded ecosystem is full of different protocols, hardware components "
"and vendor-specific things that use their own terms and abbreviations. This "
"Glossary attempts to list them with pointers for understanding them better."
msgstr ""

#: src/appendix/glossary.md:7
msgid "BSP"
msgstr ""

#: src/appendix/glossary.md:9
msgid ""
"A Board Support Crate provides a high level interface configured for a "
"specific board. It usually depends on a [HAL](#hal) crate. There is a more "
"detailed description on the [memory-mapped registers page](../start/"
"registers.md) or for a broader overview see [this video](https://youtu.be/"
"vLYit_HHPaY)."
msgstr ""

#: src/appendix/glossary.md:14
msgid "FPU"
msgstr ""

#: src/appendix/glossary.md:16
msgid ""
"Floating-point Unit. A 'math processor' running only operations on floating-"
"point numbers."
msgstr ""

#: src/appendix/glossary.md:18
msgid "HAL"
msgstr ""

#: src/appendix/glossary.md:20
msgid ""
"A Hardware Abstraction Layer crate provides a developer friendly interface "
"to a microcontroller's features and peripherals. It is usually implemented "
"on top of a [Peripheral Access Crate (PAC)](#pac). It may also implement "
"traits from the [`embedded-hal`](https://crates.io/crates/embedded-hal) "
"crate. There is a more detailed description on the [memory-mapped registers "
"page](../start/registers.md) or for a broader overview see [this video]"
"(https://youtu.be/vLYit_HHPaY)."
msgstr ""

#: src/appendix/glossary.md:28
msgid ""
"Sometimes referred to as `I²C` or Inter-IC. It is a protocol meant for "
"hardware communication within a single integrated circuit. See [here]"
"(https://en.wikipedia.org/wiki/I2c) for more details"
msgstr ""

#: src/appendix/glossary.md:33
msgid "PAC"
msgstr ""

#: src/appendix/glossary.md:35
msgid ""
"A Peripheral Access Crate provides access to a microcontroller's "
"peripherals. It is one of the lower level crates and is usually generated "
"directly from the provided [SVD](#svd), often using [svd2rust](https://"
"github.com/rust-embedded/svd2rust/). The [Hardware Abstraction Layer](#hal) "
"would usually depend on this crate. There is a more detailed description on "
"the [memory-mapped registers page](../start/registers.md) or for a broader "
"overview see [this video](https://youtu.be/vLYit_HHPaY)."
msgstr ""

#: src/appendix/glossary.md:44
msgid ""
"Serial Peripheral Interface. See [here](https://en.wikipedia.org/wiki/"
"Serial_peripheral_interface) for more information."
msgstr ""

#: src/appendix/glossary.md:48
msgid "SVD"
msgstr ""

#: src/appendix/glossary.md:50
msgid ""
"System View Description is an XML file format used to describe the "
"programmers view of a microcontroller device. You can read more about it on "
"[the ARM CMSIS documentation site](https://www.keil.com/pack/doc/CMSIS/SVD/"
"html/index.html)."
msgstr ""

#: src/appendix/glossary.md:54
msgid "UART"
msgstr ""

#: src/appendix/glossary.md:56
msgid ""
"Universal asynchronous receiver-transmitter. See [here](https://"
"en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter) for more "
"information."
msgstr ""

#: src/appendix/glossary.md:60
msgid "USART"
msgstr ""

#: src/appendix/glossary.md:62
msgid ""
"Universal synchronous and asynchronous receiver-transmitter. See [here]"
"(https://en.wikipedia.org/wiki/"
"Universal_synchronous_and_asynchronous_receiver-transmitter) for more "
"information."
msgstr ""
