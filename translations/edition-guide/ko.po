msgid ""
msgstr ""
"Project-Id-Version: The Rust Edition Guide\n"
"POT-Creation-Date: 2025-10-17T17:47:24+09:00\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: ko\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"PO-Revision-Date: 2025-10-17T17:47:24+09:00\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"

#: src/SUMMARY.md:1
msgid "The Rust Edition Guide"
msgstr ""

#: src/SUMMARY.md:3 src/introduction.md:1
msgid "Introduction"
msgstr ""

#: src/SUMMARY.md:5 src/SUMMARY.md:7
msgid "What are editions?"
msgstr ""

#: src/SUMMARY.md:8 src/editions/creating-a-new-project.md:1
msgid "Creating a new project"
msgstr ""

#: src/SUMMARY.md:9
#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:1
msgid "Transitioning an existing project to a new edition"
msgstr ""

#: src/SUMMARY.md:10
msgid "Advanced migrations"
msgstr ""

#: src/SUMMARY.md:12 src/SUMMARY.md:14 src/rust-2015/index.md:1
msgid "Rust 2015"
msgstr ""

#: src/SUMMARY.md:16 src/SUMMARY.md:18 src/rust-2018/index.md:1
msgid "Rust 2018"
msgstr ""

#: src/SUMMARY.md:19 src/rust-2018/path-changes.md:1
msgid "Path and module system changes"
msgstr ""

#: src/SUMMARY.md:20 src/rust-2018/trait-fn-parameters.md:1
msgid "Anonymous trait function parameters deprecated"
msgstr ""

#: src/SUMMARY.md:21 src/rust-2018/new-keywords.md:1
msgid "New keywords"
msgstr ""

#: src/SUMMARY.md:22 src/rust-2018/tyvar-behind-raw-pointer.md:1
msgid "Method dispatch for raw pointers to inference variables"
msgstr ""

#: src/SUMMARY.md:23 src/rust-2018/cargo.md:1
msgid "Cargo changes"
msgstr ""

#: src/SUMMARY.md:25 src/SUMMARY.md:27 src/rust-2021/index.md:1
msgid "Rust 2021"
msgstr ""

#: src/SUMMARY.md:28 src/rust-2021/prelude.md:1
msgid "Additions to the prelude"
msgstr ""

#: src/SUMMARY.md:29 src/rust-2021/default-cargo-resolver.md:1
msgid "Default Cargo feature resolver"
msgstr ""

#: src/SUMMARY.md:30 src/rust-2021/IntoIterator-for-arrays.md:1
msgid "IntoIterator for arrays"
msgstr ""

#: src/SUMMARY.md:31 src/rust-2021/disjoint-capture-in-closures.md:1
msgid "Disjoint capture in closures"
msgstr ""

#: src/SUMMARY.md:32 src/rust-2021/panic-macro-consistency.md:1
msgid "Panic macro consistency"
msgstr ""

#: src/SUMMARY.md:33 src/SUMMARY.md:55 src/rust-2021/reserved-syntax.md:1
#: src/rust-2024/reserved-syntax.md:1
msgid "Reserved syntax"
msgstr ""

#: src/SUMMARY.md:34 src/rust-2021/raw-lifetimes.md:1
msgid "Raw lifetimes"
msgstr ""

#: src/SUMMARY.md:35 src/rust-2021/warnings-promoted-to-error.md:1
msgid "Warnings promoted to errors"
msgstr ""

#: src/SUMMARY.md:36 src/rust-2021/or-patterns-macro-rules.md:1
msgid "Or patterns in macro-rules"
msgstr ""

#: src/SUMMARY.md:37 src/rust-2021/c-string-literals.md:1
msgid "C-string literals"
msgstr ""

#: src/SUMMARY.md:39 src/SUMMARY.md:41 src/rust-2024/index.md:1
msgid "Rust 2024"
msgstr ""

#: src/SUMMARY.md:42 src/rust-2024/language.md:1
msgid "Language"
msgstr ""

#: src/SUMMARY.md:43 src/rust-2024/rpit-lifetime-capture.md:1
msgid "RPIT lifetime capture rules"
msgstr ""

#: src/SUMMARY.md:44 src/rust-2024/temporary-if-let-scope.md:1
msgid "`if let` temporary scope"
msgstr ""

#: src/SUMMARY.md:45 src/rust-2024/temporary-tail-expr-scope.md:1
msgid "Tail expression temporary scope"
msgstr ""

#: src/SUMMARY.md:46 src/rust-2024/match-ergonomics.md:1
msgid "Match ergonomics reservations"
msgstr ""

#: src/SUMMARY.md:47 src/rust-2024/unsafe-extern.md:1
msgid "Unsafe `extern` blocks"
msgstr ""

#: src/SUMMARY.md:48 src/rust-2024/unsafe-attributes.md:1
msgid "Unsafe attributes"
msgstr ""

#: src/SUMMARY.md:49
msgid "`unsafe_op_in_unsafe_fn` warning"
msgstr ""

#: src/SUMMARY.md:50
msgid "Disallow references to `static mut`"
msgstr ""

#: src/SUMMARY.md:51 src/rust-2024/never-type-fallback.md:1
msgid "Never type fallback change"
msgstr ""

#: src/SUMMARY.md:52
msgid "Macro fragment specifiers"
msgstr ""

#: src/SUMMARY.md:53 src/rust-2024/missing-macro-fragment-specifiers.md:1
msgid "Missing macro fragment specifiers"
msgstr ""

#: src/SUMMARY.md:54 src/rust-2024/gen-keyword.md:1
msgid "`gen` keyword"
msgstr ""

#: src/SUMMARY.md:56 src/rust-2024/standard-library.md:1
msgid "Standard library"
msgstr ""

#: src/SUMMARY.md:57 src/rust-2024/prelude.md:1
msgid "Changes to the prelude"
msgstr ""

#: src/SUMMARY.md:58 src/rust-2024/intoiterator-box-slice.md:1
msgid "Add `IntoIterator` for `Box<[T]>`"
msgstr ""

#: src/SUMMARY.md:59
msgid "Newly unsafe functions"
msgstr ""

#: src/SUMMARY.md:60 src/rust-2024/cargo.md:1
msgid "Cargo"
msgstr ""

#: src/SUMMARY.md:61 src/rust-2024/cargo-resolver.md:1
msgid "Cargo: Rust-version aware resolver"
msgstr ""

#: src/SUMMARY.md:62 src/rust-2024/cargo-table-key-names.md:1
msgid "Cargo: Table and key name consistency"
msgstr ""

#: src/SUMMARY.md:63 src/rust-2024/cargo-inherited-default-features.md:1
msgid "Cargo: Reject unused inherited default-features"
msgstr ""

#: src/SUMMARY.md:64 src/rust-2024/rustdoc.md:1
msgid "Rustdoc"
msgstr ""

#: src/SUMMARY.md:65 src/rust-2024/rustdoc-doctests.md:1
msgid "Rustdoc combined tests"
msgstr ""

#: src/SUMMARY.md:66 src/rust-2024/rustdoc-nested-includes.md:1
msgid "Rustdoc nested `include!` change"
msgstr ""

#: src/SUMMARY.md:67 src/rust-2024/rustfmt.md:1
msgid "Rustfmt"
msgstr ""

#: src/SUMMARY.md:68 src/rust-2024/rustfmt-style-edition.md:1
msgid "Rustfmt: Style edition"
msgstr ""

#: src/SUMMARY.md:69 src/rust-2024/rustfmt-formatting-fixes.md:1
msgid "Rustfmt: Formatting fixes"
msgstr ""

#: src/SUMMARY.md:70 src/rust-2024/rustfmt-raw-identifier-sorting.md:1
msgid "Rustfmt: Raw identifier sorting"
msgstr ""

#: src/SUMMARY.md:71 src/rust-2024/rustfmt-version-sorting.md:1
msgid "Rustfmt: Version sorting"
msgstr ""

#: src/introduction.md:3
msgid ""
"Welcome to The Rust Edition Guide! \"Editions\" are Rust's way of "
"introducing changes into the language that would not otherwise be backwards "
"compatible."
msgstr ""

#: src/introduction.md:7
msgid "In this guide, we'll discuss:"
msgstr ""

#: src/introduction.md:9
msgid "What editions are"
msgstr ""

#: src/introduction.md:10
msgid "Which changes are contained in each edition"
msgstr ""

#: src/introduction.md:11
msgid "How to migrate your code from one edition to another"
msgstr ""

#: src/editions/index.md:1
msgid "What are Editions?"
msgstr ""

#: src/editions/index.md:3
msgid ""
"In May 2015, the [release of Rust 1.0](https://blog.rust-lang.org/2015/05/15/"
"Rust-1.0.html) established \"[stability without stagnation](https://"
"blog.rust-lang.org/2014/10/30/Stability.html)\" as a core Rust axiom. Since "
"then, Rust has committed to a pivotal rule: once a feature is [released "
"through stable](https://doc.rust-lang.org/book/appendix-07-nightly-"
"rust.html), contributors will continue to support that feature for all "
"future releases."
msgstr ""

#: src/editions/index.md:5
msgid ""
"However, there are times when it's useful to make backwards-incompatible "
"changes to the language. A common example is the introduction of a new "
"keyword. For instance, early versions of Rust didn't feature the `async` and "
"`await` keywords."
msgstr ""

#: src/editions/index.md:7
msgid ""
"If Rust had suddenly introduced these new keywords, some code would have "
"broken: `let async = 1;` would no longer work."
msgstr ""

#: src/editions/index.md:9
msgid ""
"Rust uses **editions** to solve this problem. When there are backwards-"
"incompatible changes, they are pushed into the next edition. Since editions "
"are opt-in, existing crates won't use the changes unless they explicitly "
"migrate into the new edition. For example, the latest version of Rust "
"doesn't treat `async` as a keyword unless edition 2018 or later is chosen."
msgstr ""

#: src/editions/index.md:11
msgid ""
"Each crate chooses its edition [within its `Cargo.toml` file](https://"
"doc.rust-lang.org/cargo/reference/manifest.html#the-edition-field). When "
"creating a new crate with Cargo, it will automatically select the newest "
"stable edition."
msgstr ""

#: src/editions/index.md:13
msgid "Editions do not split the ecosystem"
msgstr ""

#: src/editions/index.md:15
msgid ""
"When creating editions, there is one most consequential rule: crates in one "
"edition **must** seamlessly interoperate with those compiled with other "
"editions."
msgstr ""

#: src/editions/index.md:17
msgid ""
"In other words, each crate can decide when to migrate to a new edition "
"independently. This decision is 'private' - it won't affect other crates in "
"the ecosystem."
msgstr ""

#: src/editions/index.md:19
msgid ""
"For Rust, this required compatibility implies some limits on the kinds of "
"changes that can be featured in an edition. As a result, changes found in "
"new Rust editions tend to be 'skin deep'. All Rust code - regardless of "
"edition - will ultimately compile down to the same internal representation "
"within the compiler."
msgstr ""

#: src/editions/index.md:21
msgid "Edition migration is easy and largely automated"
msgstr ""

#: src/editions/index.md:23
msgid ""
"Rust aims to make upgrading to a new edition an easy process. When a new "
"edition releases, crate authors may use [automatic migration tooling within "
"`cargo`](https://doc.rust-lang.org/cargo/commands/cargo-fix.html) to "
"migrate. Cargo will then make minor changes to the code to make it "
"compatible with the new version."
msgstr ""

#: src/editions/index.md:25
msgid ""
"For example, when migrating to Rust 2018, anything named `async` will now "
"use the equivalent [raw identifier syntax](https://doc.rust-lang.org/rust-by-"
"example/compatibility/raw_identifiers.html): `r#async`."
msgstr ""

#: src/editions/index.md:27
msgid ""
"Cargo's automatic migrations aren't perfect: there may still be corner cases "
"where manual changes are required. It aims to avoid changes to semantics "
"that could affect the correctness or performance of the code."
msgstr ""

#: src/editions/index.md:29
msgid "What this guide covers"
msgstr ""

#: src/editions/index.md:31
msgid ""
"In addition to tooling, this Rust Edition Guide also covers the changes that "
"are part of each edition. It describes each change and links to additional "
"details, if available. It also covers corner cases or tricky details crate "
"authors should be aware of."
msgstr ""

#: src/editions/index.md:33
msgid "Crate authors should find:"
msgstr ""

#: src/editions/index.md:35
msgid "An overview of editions"
msgstr ""

#: src/editions/index.md:36
msgid "A migration guide for specific editions"
msgstr ""

#: src/editions/index.md:37
msgid "A quick troubleshooting reference when automated tooling isn't working."
msgstr ""

#: src/editions/creating-a-new-project.md:3
msgid ""
"A new project created with Cargo is configured to use the latest edition by "
"default:"
msgstr ""

#: src/editions/creating-a-new-project.md:6
msgid ""
"```console\n"
"$ cargo new foo\n"
"    Creating binary (application) `foo` package\n"
"note: see more `Cargo.toml` keys and their definitions at https://doc.rust-"
"lang.org/cargo/reference/manifest.html\n"
"$ cat foo/Cargo.toml\n"
"[package]\n"
"name = \"foo\"\n"
"version = \"0.1.0\"\n"
"edition = \"2024\"\n"
"\n"
"[dependencies]\n"
"```"
msgstr ""

#: src/editions/creating-a-new-project.md:19
msgid ""
"That `edition = \"2024\"` setting configures your package to be built using "
"the Rust 2024 edition. No further configuration needed!"
msgstr ""

#: src/editions/creating-a-new-project.md:22
msgid ""
"You can use the `--edition <YEAR>` option of `cargo new` to create the "
"project using some specific edition. For example, creating a new project to "
"use the Rust 2018 edition could be done like this:"
msgstr ""

#: src/editions/creating-a-new-project.md:26
msgid ""
"```console\n"
"$ cargo new --edition 2018 foo\n"
"    Creating binary (application) `foo` package\n"
"note: see more `Cargo.toml` keys and their definitions at https://doc.rust-"
"lang.org/cargo/reference/manifest.html\n"
"$ cat foo/Cargo.toml\n"
"[package]\n"
"name = \"foo\"\n"
"version = \"0.1.0\"\n"
"edition = \"2018\"\n"
"\n"
"[dependencies]\n"
"```"
msgstr ""

#: src/editions/creating-a-new-project.md:39
msgid ""
"Don't worry about accidentally using an invalid year for the edition; the "
"`cargo new` invocation will not accept an invalid edition year value:"
msgstr ""

#: src/editions/creating-a-new-project.md:52
msgid ""
"You can change the value of the `edition` key by simply editing the "
"`Cargo.toml` file. For example, to cause your package to be built using the "
"Rust 2015 edition, you would set the key as in the following example:"
msgstr ""

#: src/editions/creating-a-new-project.md:56
msgid ""
"```toml\n"
"[package]\n"
"name = \"foo\"\n"
"version = \"0.1.0\"\n"
"edition = \"2015\"\n"
"\n"
"[dependencies]\n"
"```"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:3
msgid ""
"Rust includes tooling to automatically transition a project from one edition "
"to the next. It will update your source code so that it is compatible with "
"the next edition. Briefly, the steps to update to the next edition are:"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:7
msgid "Run `cargo update` to update your dependencies to the latest versions."
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:8
msgid "Run `cargo fix --edition`"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:9
msgid ""
"Edit `Cargo.toml` and set the `edition` field to the next edition, for "
"example `edition = \"2024\"`"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:10
msgid "Run `cargo build` or `cargo test` to verify the fixes worked."
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:11
msgid "Run `cargo fmt` to reformat your project."
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:13
msgid ""
"The following sections dig into the details of these steps, and some of the "
"issues you may encounter along the way."
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:15
msgid ""
"It's our intention that the migration to new editions is as smooth an "
"experience as possible. If it's difficult for you to upgrade to the latest "
"edition, we consider that a bug. If you run into problems with this process, "
"please [file a bug report](https://github.com/rust-lang/rust/issues/new/"
"choose). Thank you!"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:20
msgid "Starting the migration"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:22
msgid ""
"As an example, let's take a look at transitioning from the 2015 edition to "
"the 2018 edition. The steps are essentially the same when transitioning to "
"other editions like 2021."
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:25
msgid "Imagine we have a crate that has this code in `src/lib.rs`:"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:33
msgid ""
"This code uses an anonymous parameter, that `i32`. This is [not supported in "
"Rust 2018](../rust-2018/trait-system/no-anon-params.md), and so this would "
"fail to compile. Let's get this code up to date!"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:37
msgid "Updating your dependencies"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:39
msgid ""
"Before we get started, it is recommended to update your dependencies. Some "
"dependencies, particularly some proc-macros or dependencies that do build-"
"time code generation, may have compatibility issues with newer editions. New "
"releases may have been made since you last updated which may fix these "
"issues. Run the following:"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:45
msgid ""
"After updating, you may want to run your tests to verify everything is "
"working. If you are using a source control tool such as `git`, you may want "
"to commit these changes separately to keep a logical separation of commits."
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:47
msgid "Updating your code to be compatible with the new edition"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:49
msgid ""
"Your code may or may not use features that are incompatible with the new "
"edition. In order to help transition to the next edition, Cargo includes the "
"[`cargo fix`](../../cargo/commands/cargo-fix.html) subcommand to "
"automatically update your source code. To start, let's run it:"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:57
msgid ""
"This will check your code, and automatically fix any issues that it can. "
"Let's look at `src/lib.rs` again:"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:66
msgid ""
"It's re-written our code to introduce a parameter name for that `i32` value. "
"In this case, since it had no name, `cargo fix` will replace it with `_`, "
"which is conventional for unused variables."
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:70
msgid ""
"`cargo fix` can't always fix your code automatically. If `cargo fix` can't "
"fix something, it will print the warning that it cannot fix to the console. "
"If you see one of these warnings, you'll have to update your code manually. "
"See the [Advanced migration strategies](advanced-migrations.md) chapter for "
"more on working with the migration process, and read the chapters in this "
"guide which explain which changes are needed. If you have problems, please "
"seek help at the [user's forums](https://users.rust-lang.org/)."
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:76
msgid "Enabling the new edition to use new features"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:78
msgid ""
"In order to use some new features, you must explicitly opt in to the new "
"edition. Once you're ready to continue, change your `Cargo.toml` to add the "
"new `edition` key/value pair. For example:"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:82
msgid ""
"```toml\n"
"[package]\n"
"name = \"foo\"\n"
"version = \"0.1.0\"\n"
"edition = \"2018\"\n"
"```"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:89
msgid ""
"If there's no `edition` key, Cargo will default to Rust 2015. But in this "
"case, we've chosen `2018`, and so our code will compile with Rust 2018!"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:92
msgid "Testing your code in the new edition"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:94
msgid ""
"The next step is to test your project on the new edition. Run your project "
"tests to verify that everything still works, such as running [`cargo test`]"
"(../../cargo/commands/cargo-test.html). If new warnings are issued, you may "
"want to consider running `cargo fix` again (without the `--edition` flag) to "
"apply any suggestions given by the compiler."
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:98
msgid ""
"At this point, you may still need to do some manual changes. For example, "
"the automatic migration does not update doctests, and build-time code "
"generation or macros may need manual updating. See the [advanced migrations "
"chapter](advanced-migrations.md) for more information."
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:100
msgid "Congrats! Your code is now valid in both Rust 2015 and Rust 2018!"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:104
msgid "Reformatting with rustfmt"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:106
msgid ""
"If you use [rustfmt](https://github.com/rust-lang/rustfmt) to automatically "
"maintain formatting within your project, then you should consider "
"reformatting using the new formatting rules of the new edition."
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:108
msgid ""
"Before reformatting, if you are using a source control tool such as `git`, "
"you may want to commit all the changes you have made up to this point before "
"taking this step. It can be useful to put formatting changes in a separate "
"commit, because then you can see which changes are just formatting versus "
"other code changes, and also possibly ignore the formatting changes in `git "
"blame`."
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:114
msgid ""
"See the [style editions chapter](../rust-2024/rustfmt-style-edition.md) for "
"more information."
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:119
msgid "Migrating to an unstable edition"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:121
msgid ""
"After an edition is released, there is roughly a three year window before "
"the next edition. During that window, new features may be added to the next "
"edition, which will only be available on the [nightly channel](../../book/"
"appendix-07-nightly-rust.html). If you want to help test those new features "
"before they are stabilized, you can use the nightly channel to try them out."
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:125
msgid "The steps are roughly similar to the stable channel:"
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:127
msgid "Install the most recent nightly: `rustup update nightly`."
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:128
msgid "Run `cargo +nightly fix --edition`."
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:129
msgid ""
"Edit `Cargo.toml` and place `cargo-features = [\"edition20xx\"]` at the top "
"(above `[package]`), and change the edition field to say `edition = "
"\"20xx\"` where `20xx` is the edition you are upgrading to."
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:130
msgid "Run `cargo +nightly check` to verify it now works in the new edition."
msgstr ""

#: src/editions/transitioning-an-existing-project-to-a-new-edition.md:132
msgid ""
"**⚠ Caution**: Features implemented in the next edition may not have "
"automatic migrations implemented with `cargo fix`, and the features "
"themselves may not be finished. When possible, this guide should contain "
"information about which features are implemented on nightly along with more "
"information about their status. A few months before the edition is "
"stabilized, all of the new features should be fully implemented, and the "
"[Rust Blog](https://blog.rust-lang.org/) will announce a call for testing."
msgstr ""

#: src/editions/advanced-migrations.md:1
msgid "Advanced migration strategies"
msgstr ""

#: src/editions/advanced-migrations.md:3
msgid "How migrations work"
msgstr ""

#: src/editions/advanced-migrations.md:5
msgid ""
"[`cargo fix --edition`](../../cargo/commands/cargo-fix.html) works by "
"running the equivalent of [`cargo check`](../../cargo/commands/cargo-"
"check.html) on your project with special [lints](../../rustc/lints/"
"index.html) enabled which will detect code that may not compile in the next "
"edition. These lints include instructions on how to modify the code to make "
"it compatible on both the current and the next edition. `cargo fix` applies "
"these changes to the source code, and then runs `cargo check` again to "
"verify that the fixes work. If the fixes fail, then it will back out the "
"changes and display a warning."
msgstr ""

#: src/editions/advanced-migrations.md:10
msgid ""
"Changing the code to be simultaneously compatible with both the current and "
"next edition makes it easier to incrementally migrate the code. If the "
"automated migration does not completely succeed, or requires manual help, "
"you can iterate while staying on the original edition before changing "
"`Cargo.toml` to use the next edition."
msgstr ""

#: src/editions/advanced-migrations.md:13
msgid ""
"The lints that `cargo fix --edition` apply are part of a [lint group](../../"
"rustc/lints/groups.html). For example, when migrating from 2018 to 2021, "
"Cargo uses the `rust-2021-compatibility` group of lints to fix the code. "
"Check the [Partial migration](#partial-migration-with-broken-code) section "
"below for tips on using individual lints to help with migration."
msgstr ""

#: src/editions/advanced-migrations.md:17
msgid ""
"`cargo fix` may run `cargo check` multiple times. For example, after "
"applying one set of fixes, this may trigger new warnings which require "
"further fixes. Cargo repeats this until no new warnings are generated."
msgstr ""

#: src/editions/advanced-migrations.md:21
msgid "Migrating multiple configurations"
msgstr ""

#: src/editions/advanced-migrations.md:23
msgid ""
"`cargo fix` can only work with a single configuration at a time. If you use "
"[Cargo features](../../cargo/reference/features.html) or [conditional "
"compilation](../../reference/conditional-compilation.html), then you may "
"need to run `cargo fix` multiple times with different flags."
msgstr ""

#: src/editions/advanced-migrations.md:26
msgid ""
"For example, if you have code that uses `#[cfg]` attributes to include "
"different code for different platforms, you may need to run `cargo fix` with "
"the `--target` option to fix for different targets. This may require moving "
"your code between machines if you don't have cross-compiling available."
msgstr ""

#: src/editions/advanced-migrations.md:29
msgid ""
"Similarly, if you have conditions on Cargo features, like `#[cfg(feature = "
"\"my-optional-thing\")]`, it is recommended to use the `--all-features` flag "
"to allow `cargo fix` to migrate all the code behind those feature gates. If "
"you want to migrate feature code individually, you can use the `--features` "
"flag to migrate one at a time."
msgstr ""

#: src/editions/advanced-migrations.md:32
msgid "Migrating a large project or workspace"
msgstr ""

#: src/editions/advanced-migrations.md:34
msgid ""
"You can migrate a large project incrementally to make the process easier if "
"you run into problems."
msgstr ""

#: src/editions/advanced-migrations.md:36
msgid ""
"In a [Cargo workspace](../../cargo/reference/workspaces.html), each package "
"defines its own edition, so the process naturally involves migrating one "
"package at a time."
msgstr ""

#: src/editions/advanced-migrations.md:38
msgid ""
"Within a [Cargo package](../../cargo/reference/manifest.html#the-package-"
"section), you can either migrate the entire package at once, or migrate "
"individual [Cargo targets](../../cargo/reference/cargo-targets.html) one at "
"a time. For example, if you have multiple binaries, tests, and examples, you "
"can use specific target selection flags with `cargo fix --edition` to "
"migrate just that one target. By default, `cargo fix` uses `--all-targets`."
msgstr ""

#: src/editions/advanced-migrations.md:42
msgid ""
"For even more advanced cases, you can specify the edition for each "
"individual target in `Cargo.toml` like this:"
msgstr ""

#: src/editions/advanced-migrations.md:44
msgid ""
"```toml\n"
"[[bin]]\n"
"name = \"my-binary\"\n"
"edition = \"2018\"\n"
"```"
msgstr ""

#: src/editions/advanced-migrations.md:50
msgid ""
"This usually should not be required, but is an option if you have a lot of "
"targets and are having difficulty migrating them all together."
msgstr ""

#: src/editions/advanced-migrations.md:52
msgid "Partial migration with broken code"
msgstr ""

#: src/editions/advanced-migrations.md:54
msgid ""
"Sometimes the fixes suggested by the compiler may fail to work. When this "
"happens, Cargo will report a warning indicating what happened and what the "
"error was. However, by default it will automatically back out the changes it "
"made. It can be helpful to keep the code in the broken state and manually "
"resolve the issue. Some of the fixes may have been correct, and the broken "
"fix may be _mostly_ correct, but just need minor tweaking."
msgstr ""

#: src/editions/advanced-migrations.md:60
msgid ""
"In this situation, use the `--broken-code` option with `cargo fix` to tell "
"Cargo not to back out the changes. Then, you can go manually inspect the "
"error and investigate what is needed to fix it."
msgstr ""

#: src/editions/advanced-migrations.md:63
msgid ""
"Another option to incrementally migrate a project is to apply individual "
"fixes separately, one at a time. You can do this by adding the individual "
"lints as warnings, and then either running `cargo fix` (without the `--"
"edition` flag) or using your editor or IDE to apply its suggestions if it "
"supports \"Quick Fixes\"."
msgstr ""

#: src/editions/advanced-migrations.md:66
msgid ""
"For example, the 2018 edition uses the [`keyword-idents`](../../rustc/lints/"
"listing/allowed-by-default.html#keyword-idents) lint to fix any conflicting "
"keywords. You can add `#![warn(keyword_idents)]` to the top of each crate "
"(like at the top of `src/lib.rs` or `src/main.rs`). Then, running `cargo "
"fix` will apply just the suggestions for that lint."
msgstr ""

#: src/editions/advanced-migrations.md:70
msgid ""
"You can see the list of lints enabled for each edition in the [lint group]"
"(../../rustc/lints/groups.html) page, or run the `rustc -Whelp` command."
msgstr ""

#: src/editions/advanced-migrations.md:72
msgid "Migrating macros"
msgstr ""

#: src/editions/advanced-migrations.md:74
msgid ""
"Some macros may require manual work to fix them for the next edition. For "
"example, `cargo fix --edition` may not be able to automatically fix a macro "
"that generates syntax that does not work in the next edition."
msgstr ""

#: src/editions/advanced-migrations.md:77
msgid ""
"This may be a problem for both [proc macros](../../reference/procedural-"
"macros.html) and `macro_rules`\\-style macros. `macro_rules` macros can "
"sometimes be automatically updated if the macro is used within the same "
"crate, but there are several situations where it cannot. Proc macros in "
"general cannot be automatically fixed at all."
msgstr ""

#: src/editions/advanced-migrations.md:81
msgid ""
"For example, if we migrate a crate containing this (contrived) macro `foo` "
"from 2015 to 2018, `foo` would not be automatically fixed."
msgstr ""

#: src/editions/advanced-migrations.md:88
msgid "\"it is {}\""
msgstr ""

#: src/editions/advanced-migrations.md:93
msgid ""
"When this macro is defined in a 2015 crate, it can be used from a crate of "
"any other edition due to macro hygiene (discussed below). In 2015, `dyn` is "
"a normal identifier and can be used without restriction."
msgstr ""

#: src/editions/advanced-migrations.md:96
msgid ""
"However, in 2018, `dyn` is no longer a valid identifier. When using `cargo "
"fix --edition` to migrate to 2018, Cargo won't display any warnings or "
"errors at all. However, `foo` won't work when called from any crate."
msgstr ""

#: src/editions/advanced-migrations.md:100
msgid ""
"If you have macros, you are encouraged to make sure you have tests that "
"fully cover the macro's syntax. You may also want to test the macros by "
"importing and using them in crates from multiple editions, just to ensure it "
"works correctly everywhere. If you run into issues, you'll need to read "
"through the chapters of this guide to understand how the code can be changed "
"to work across all editions."
msgstr ""

#: src/editions/advanced-migrations.md:104
msgid "Macro hygiene"
msgstr ""

#: src/editions/advanced-migrations.md:106
msgid ""
"Macros use a system called \"edition hygiene\" where the tokens within a "
"macro are marked with which edition they come from. This allows external "
"macros to be called from crates of varying editions without needing to worry "
"about which edition it is called from."
msgstr ""

#: src/editions/advanced-migrations.md:109
msgid ""
"Let's take a closer look at the example above that defines a `macro_rules` "
"macro using `dyn` as an identifier. If that macro was defined in a crate "
"using the 2015 edition, then that macro works fine, even if it were called "
"from a 2018 crate where `dyn` is a keyword and that would normally be a "
"syntax error. The `let dyn = 1;` tokens are marked as being from 2015, and "
"the compiler will remember that wherever that code gets expanded. The parser "
"looks at the edition of the tokens to know how to interpret it."
msgstr ""

#: src/editions/advanced-migrations.md:114
msgid ""
"The problem arises when changing the edition to 2018 in the crate where it "
"is defined. Now, those tokens are tagged with the 2018 edition, and those "
"will fail to parse. However, since we never called the macro from our crate, "
"`cargo fix --edition` never had a chance to inspect the macro and fix it."
msgstr ""

#: src/editions/advanced-migrations.md:120
msgid "Documentation tests"
msgstr ""

#: src/editions/advanced-migrations.md:122
msgid ""
"At this time, `cargo fix` is not able to update [documentation tests](../../"
"rustdoc/documentation-tests.html). After updating the edition in "
"`Cargo.toml`, you should run `cargo test` to ensure everything still passes. "
"If your documentation tests use syntax that is not supported in the new "
"edition, you will need to update them manually."
msgstr ""

#: src/editions/advanced-migrations.md:126
msgid ""
"In rare cases, you can manually set the edition for each test. For example, "
"you can use the [`edition2018` annotation](../../rustdoc/documentation-"
"tests.html#attributes) on the triple backticks to tell `rustdoc` which "
"edition to use."
msgstr ""

#: src/editions/advanced-migrations.md:129
msgid "Generated code"
msgstr ""

#: src/editions/advanced-migrations.md:131
msgid ""
"Another area where the automated fixes cannot apply is if you have a build "
"script which generates Rust code at compile time (see [Code generation]"
"(../../cargo/reference/build-script-examples.html#code-generation) for an "
"example). In this situation, if you end up with code that doesn't work in "
"the next edition, you will need to manually change the build script to "
"generate code that is compatible."
msgstr ""

#: src/editions/advanced-migrations.md:134
msgid "Migrating non-Cargo projects"
msgstr ""

#: src/editions/advanced-migrations.md:136
msgid ""
"If your project is not using Cargo as a build system, it may still be "
"possible to make use of the automated lints to assist migrating to the next "
"edition. You can enable the migration lints as described above by enabling "
"the appropriate [lint group](../../rustc/lints/groups.html). For example, "
"you can use the `#![warn(rust_2021_compatibility)]` attribute or the `-"
"Wrust-2021-compatibility` or `--force-warns=rust-2021-compatibility` [CLI "
"flag](../../rustc/lints/levels.html#via-compiler-flag)."
msgstr ""

#: src/editions/advanced-migrations.md:140
msgid ""
"The next step is to apply those lints to your code. There are several "
"options here:"
msgstr ""

#: src/editions/advanced-migrations.md:143
msgid ""
"Manually read the warnings and apply the suggestions recommended by the "
"compiler."
msgstr ""

#: src/editions/advanced-migrations.md:144
msgid ""
"Use an editor or IDE that supports automatically applying suggestions. For "
"example, [Visual Studio Code](https://code.visualstudio.com/) with the [Rust "
"Analyzer extension](https://marketplace.visualstudio.com/items?"
"itemName=matklad.rust-analyzer) has the ability to use the \"Quick Fix\" "
"links to automatically apply suggestions. Many other editors and IDEs have "
"similar functionality."
msgstr ""

#: src/editions/advanced-migrations.md:147
msgid ""
"Write a migration tool using the [`rustfix`](https://crates.io/crates/"
"rustfix) library. This is the library that Cargo uses internally to take the "
"[JSON messages](../../rustc/json.html) from the compiler and modify the "
"source code. Check the [`examples` directory](https://github.com/rust-lang/"
"cargo/tree/master/crates/rustfix/examples) for examples of how to use the "
"library."
msgstr ""

#: src/editions/advanced-migrations.md:151
msgid "Writing idiomatic code in a new edition"
msgstr ""

#: src/editions/advanced-migrations.md:153
msgid ""
"Editions are not only about new features and removing old ones. In any "
"programming language, idioms change over time, and Rust is no exception. "
"While old code will continue to compile, it might be written with different "
"idioms today."
msgstr ""

#: src/editions/advanced-migrations.md:157
msgid ""
"For example, in Rust 2015, external crates must be listed with `extern "
"crate` like this:"
msgstr ""

#: src/editions/advanced-migrations.md:160
msgid "// src/lib.rs\n"
msgstr ""

#: src/editions/advanced-migrations.md:164
msgid ""
"In Rust 2018, it is [no longer necessary](../rust-2018/path-changes.md#no-"
"more-extern-crate) to include these items."
msgstr ""

#: src/editions/advanced-migrations.md:166
msgid ""
"`cargo fix` has the `--edition-idioms` option to automatically transition "
"some of these idioms to the new syntax."
msgstr ""

#: src/editions/advanced-migrations.md:168
msgid ""
"**Warning**: The current _\"idiom lints\"_ are known to have some problems. "
"They may make incorrect suggestions which may fail to compile. The current "
"lints are:"
msgstr ""

#: src/editions/advanced-migrations.md:171
msgid "Edition 2018:"
msgstr ""

#: src/editions/advanced-migrations.md:172
msgid ""
"[`unused-extern-crates`](../../rustc/lints/listing/allowed-by-"
"default.html#unused-extern-crates)"
msgstr ""

#: src/editions/advanced-migrations.md:173
msgid ""
"[`explicit-outlives-requirements`](../../rustc/lints/listing/allowed-by-"
"default.html#explicit-outlives-requirements)"
msgstr ""

#: src/editions/advanced-migrations.md:174
msgid "Edition 2021 does not have any idiom lints."
msgstr ""

#: src/editions/advanced-migrations.md:176
msgid ""
"The following instructions are recommended only for the intrepid who are "
"willing to work through a few compiler/Cargo bugs! If you run into problems, "
"you can try the `--broken-code` option [described above](#partial-migration-"
"with-broken-code) to make as much progress as possible, and then resolve the "
"remaining issues manually."
msgstr ""

#: src/editions/advanced-migrations.md:179
msgid ""
"With that out of the way, we can instruct Cargo to fix our code snippet with:"
msgstr ""

#: src/editions/advanced-migrations.md:185
msgid ""
"Afterwards, the line with `extern crate rand;` in `src/lib.rs` will be "
"removed."
msgstr ""

#: src/editions/advanced-migrations.md:187
msgid "We're now more idiomatic, and we didn't have to fix our code manually!"
msgstr ""

#: src/rust-2015/index.md:3
msgid ""
"Rust 2015 has a theme of \"stability\". It commenced with the release of "
"1.0, and is the \"default edition\". The edition system was conceived in "
"late 2017, but Rust 1.0 was released in May of 2015. As such, 2015 is the "
"edition that you get when you don't specify any particular edition, for "
"backwards compatibility reasons."
msgstr ""

#: src/rust-2015/index.md:9
msgid ""
"\"Stability\" is the theme of Rust 2015 because 1.0 marked a huge change in "
"Rust development. Previous to Rust 1.0, Rust was changing on a daily basis. "
"This made it very difficult to write large software in Rust, and made it "
"difficult to learn. With the release of Rust 1.0 and Rust 2015, we committed "
"to backwards compatibility, ensuring a solid foundation for people to build "
"projects on top of."
msgstr ""

#: src/rust-2015/index.md:16
msgid ""
"Since it's the default edition, there's no way to port your code to Rust "
"2015; it just _is_. You'll be transitioning _away_ from 2015, but never "
"really _to_ 2015. As such, there's not much else to say about it!"
msgstr ""

#: src/rust-2018/index.md:3 src/rust-2021/index.md:3 src/rust-2024/index.md:3
msgid "Info"
msgstr ""

#: src/rust-2018/index.md:5 src/rust-2021/index.md:5 src/rust-2024/index.md:5
msgid "RFC"
msgstr ""

#: src/rust-2018/index.md:5
msgid ""
"[\\#2052](https://rust-lang.github.io/rfcs/2052-epochs.html), which also "
"proposed the Edition system"
msgstr ""

#: src/rust-2018/index.md:6 src/rust-2021/index.md:6 src/rust-2024/index.md:6
msgid "Release version"
msgstr ""

#: src/rust-2018/index.md:6
msgid ""
"[1.31.0](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html)"
msgstr ""

#: src/rust-2018/index.md:8
msgid ""
"The edition system was created for the release of Rust 2018. The release of "
"the Rust 2018 edition coincided with a number of other features all "
"coordinated around the theme of _productivity_. The majority of those "
"features were backwards compatible and are now available on all editions; "
"however, some of those changes required the edition mechanism (most notably "
"the [module system changes](path-changes.md))."
msgstr ""

#: src/rust-2018/path-changes.md:3 src/rust-2018/trait-fn-parameters.md:3
msgid ""
"![Minimum Rust version: 1.31](https://img.shields.io/badge/"
"Minimum%20Rust%20Version-1.31-brightgreen.svg)"
msgstr ""

#: src/rust-2018/path-changes.md:5 src/rust-2018/trait-fn-parameters.md:5
#: src/rust-2018/new-keywords.md:5 src/rust-2018/tyvar-behind-raw-pointer.md:3
#: src/rust-2018/cargo.md:3 src/rust-2021/prelude.md:3
#: src/rust-2021/default-cargo-resolver.md:3
#: src/rust-2021/IntoIterator-for-arrays.md:3
#: src/rust-2021/disjoint-capture-in-closures.md:3
#: src/rust-2021/panic-macro-consistency.md:3
#: src/rust-2021/reserved-syntax.md:3 src/rust-2021/raw-lifetimes.md:3
#: src/rust-2021/warnings-promoted-to-error.md:3
#: src/rust-2021/or-patterns-macro-rules.md:3
#: src/rust-2021/c-string-literals.md:3
#: src/rust-2024/rpit-lifetime-capture.md:8
#: src/rust-2024/temporary-if-let-scope.md:3
#: src/rust-2024/temporary-tail-expr-scope.md:3
#: src/rust-2024/match-ergonomics.md:3 src/rust-2024/unsafe-extern.md:3
#: src/rust-2024/unsafe-attributes.md:3
#: src/rust-2024/unsafe-op-in-unsafe-fn.md:3
#: src/rust-2024/static-mut-references.md:3
#: src/rust-2024/never-type-fallback.md:3
#: src/rust-2024/macro-fragment-specifiers.md:3
#: src/rust-2024/missing-macro-fragment-specifiers.md:3
#: src/rust-2024/gen-keyword.md:3 src/rust-2024/reserved-syntax.md:3
#: src/rust-2024/prelude.md:3 src/rust-2024/intoiterator-box-slice.md:3
#: src/rust-2024/newly-unsafe-functions.md:3 src/rust-2024/cargo-resolver.md:3
#: src/rust-2024/cargo-table-key-names.md:3
#: src/rust-2024/cargo-inherited-default-features.md:3
#: src/rust-2024/rustdoc-doctests.md:3
#: src/rust-2024/rustdoc-nested-includes.md:3
#: src/rust-2024/rustfmt-style-edition.md:3
#: src/rust-2024/rustfmt-formatting-fixes.md:3
#: src/rust-2024/rustfmt-raw-identifier-sorting.md:3
#: src/rust-2024/rustfmt-version-sorting.md:3
msgid "Summary"
msgstr ""

#: src/rust-2018/path-changes.md:7
msgid "Paths in `use` declarations now work the same as other paths."
msgstr ""

#: src/rust-2018/path-changes.md:8
msgid "Paths starting with `::` must now be followed with an external crate."
msgstr ""

#: src/rust-2018/path-changes.md:9
msgid ""
"Paths in `pub(in path)` visibility modifiers must now start with `crate`, "
"`self`, or `super`."
msgstr ""

#: src/rust-2018/path-changes.md:11 src/rust-2018/new-keywords.md:15
msgid "Motivation"
msgstr ""

#: src/rust-2018/path-changes.md:13
msgid ""
"The module system is often one of the hardest things for people new to Rust. "
"Everyone has their own things that take time to master, of course, but "
"there's a root cause for why it's so confusing to many: while there are "
"simple and consistent rules defining the module system, their consequences "
"can feel inconsistent, counterintuitive and mysterious."
msgstr ""

#: src/rust-2018/path-changes.md:19
msgid ""
"As such, the 2018 edition of Rust introduces a few new module system "
"features, but they end up _simplifying_ the module system, to make it more "
"clear as to what is going on."
msgstr ""

#: src/rust-2018/path-changes.md:23
msgid "Here's a brief summary:"
msgstr ""

#: src/rust-2018/path-changes.md:25
msgid "`extern crate` is no longer needed in 99% of circumstances."
msgstr ""

#: src/rust-2018/path-changes.md:26
msgid "The `crate` keyword refers to the current crate."
msgstr ""

#: src/rust-2018/path-changes.md:27
msgid "Paths may start with a crate name, even within submodules."
msgstr ""

#: src/rust-2018/path-changes.md:28
msgid "Paths starting with `::` must reference an external crate."
msgstr ""

#: src/rust-2018/path-changes.md:29
msgid ""
"A `foo.rs` and `foo/` subdirectory may coexist; `mod.rs` is no longer needed "
"when placing submodules in a subdirectory."
msgstr ""

#: src/rust-2018/path-changes.md:31
msgid "Paths in `use` declarations work the same as other paths."
msgstr ""

#: src/rust-2018/path-changes.md:33
msgid ""
"These may seem like arbitrary new rules when put this way, but the mental "
"model is now significantly simplified overall. Read on for more details!"
msgstr ""

#: src/rust-2018/path-changes.md:36
msgid "More details"
msgstr ""

#: src/rust-2018/path-changes.md:38
msgid "Let's talk about each new feature in turn."
msgstr ""

#: src/rust-2018/path-changes.md:40
msgid "No more `extern crate`"
msgstr ""

#: src/rust-2018/path-changes.md:42
msgid ""
"This one is quite straightforward: you no longer need to write `extern "
"crate` to import a crate into your project. Before:"
msgstr ""

#: src/rust-2018/path-changes.md:46 src/rust-2018/path-changes.md:170
#: src/rust-2018/path-changes.md:282
msgid "// Rust 2015\n"
msgstr ""

#: src/rust-2018/path-changes.md:55
msgid "After:"
msgstr ""

#: src/rust-2018/path-changes.md:58 src/rust-2018/path-changes.md:191
#: src/rust-2018/path-changes.md:315 src/rust-2018/path-changes.md:345
#: src/rust-2021/panic-macro-consistency.md:19
#: src/rust-2021/panic-macro-consistency.md:28
msgid "// Rust 2018\n"
msgstr ""

#: src/rust-2018/path-changes.md:65
msgid ""
"Now, to add a new crate to your project, you can add it to your "
"`Cargo.toml`, and then there is no step two. If you're not using Cargo, you "
"already had to pass `--extern` flags to give `rustc` the location of "
"external crates, so you'd just keep doing what you were doing there as well."
msgstr ""

#: src/rust-2018/path-changes.md:70
msgid "An exception"
msgstr ""

#: src/rust-2018/path-changes.md:72
msgid ""
"There's one exception to this rule, and that's the \"sysroot\" crates. These "
"are the crates distributed with Rust itself."
msgstr ""

#: src/rust-2018/path-changes.md:75
msgid ""
"Usually these are only needed in very specialized situations. Starting in "
"1.41, `rustc` accepts the `--extern=CRATE_NAME` flag which automatically "
"adds the given crate name in a way similar to `extern crate`. Build tools "
"may use this to inject sysroot crates into the crate's prelude. Cargo does "
"not have a general way to express this, though it uses it for `proc_macro` "
"crates."
msgstr ""

#: src/rust-2018/path-changes.md:81
msgid "Some examples of needing to explicitly import sysroot crates are:"
msgstr ""

#: src/rust-2018/path-changes.md:83
msgid ""
"[`std`](../../std/index.html): Usually this is not necessary, because `std` "
"is automatically imported unless the crate is marked with [`#![no_std]`]"
"(../../reference/names/preludes.html#the-no_std-attribute)."
msgstr ""

#: src/rust-2018/path-changes.md:85
msgid ""
"[`core`](../../core/index.html): Usually this is not necessary, because "
"`core` is automatically imported, unless the crate is marked with [`#!"
"[no_core]`](https://github.com/rust-lang/rust/issues/29639). For example, "
"some of the internal crates used by the standard library itself need this."
msgstr ""

#: src/rust-2018/path-changes.md:89
msgid ""
"[`proc_macro`](../../proc_macro/index.html): This is automatically imported "
"by Cargo if it is a proc-macro crate starting in 1.42. `extern crate "
"proc_macro;` would be needed if you want to support older releases, or if "
"using another build tool that does not pass the appropriate `--extern` flags "
"to `rustc`."
msgstr ""

#: src/rust-2018/path-changes.md:93
msgid ""
"[`alloc`](../../alloc/index.html): Items in the `alloc` crate are usually "
"accessed via re-exports in the `std` crate. If you are working with a "
"`no_std` crate that supports allocation, then you may need to explicitly "
"import `alloc`."
msgstr ""

#: src/rust-2018/path-changes.md:96
msgid ""
"[`test`](../../test/index.html): This is only available on the [nightly "
"channel](../../book/appendix-07-nightly-rust.html), and is usually only used "
"for the unstable benchmark support."
msgstr ""

#: src/rust-2018/path-changes.md:108
msgid "Macros"
msgstr ""

#: src/rust-2018/path-changes.md:110
msgid ""
"One other use for `extern crate` was to import macros; that's no longer "
"needed. Macros may be imported with `use` like any other item. For example, "
"the following use of `extern crate`:"
msgstr ""

#: src/rust-2018/path-changes.md:123
msgid "Can be changed to something like the following:"
msgstr ""

#: src/rust-2018/path-changes.md:133
msgid "Renaming crates"
msgstr ""

#: src/rust-2018/path-changes.md:135
msgid "If you've been using `as` to rename your crate like this:"
msgstr ""

#: src/rust-2018/path-changes.md:143
msgid ""
"then removing the `extern crate` line on its own won't work. You'll need to "
"do this:"
msgstr ""

#: src/rust-2018/path-changes.md:151
msgid "This change will need to happen in any module that uses `f`."
msgstr ""

#: src/rust-2018/path-changes.md:153
msgid "The `crate` keyword refers to the current crate"
msgstr ""

#: src/rust-2018/path-changes.md:155
msgid ""
"In `use` declarations and in other code, you can refer to the root of the "
"current crate with the `crate::` prefix. For instance, `crate::foo::bar` "
"will always refer to the name `bar` inside the module `foo`, from anywhere "
"else in the same crate."
msgstr ""

#: src/rust-2018/path-changes.md:160
msgid ""
"The prefix `::` previously referred to either the crate root or an external "
"crate; it now unambiguously refers to an external crate. For instance, "
"`::foo::bar` always refers to the name `bar` inside the external crate `foo`."
msgstr ""

#: src/rust-2018/path-changes.md:164
msgid "Extern crate paths"
msgstr ""

#: src/rust-2018/path-changes.md:166
msgid ""
"Previously, using an external crate in a module without a `use` import "
"required a leading `::` on the path."
msgstr ""

#: src/rust-2018/path-changes.md:175 src/rust-2018/path-changes.md:194
msgid "// this works in the crate root\n"
msgstr ""

#: src/rust-2018/path-changes.md:181
msgid ""
"// but in a submodule it requires a leading :: if not imported with `use`\n"
msgstr ""

#: src/rust-2018/path-changes.md:187
msgid ""
"Now, extern crate names are in scope in the entire crate, including "
"submodules."
msgstr ""

#: src/rust-2018/path-changes.md:200
msgid "// crates may be referenced directly, even in submodules\n"
msgstr ""

#: src/rust-2018/path-changes.md:206
msgid ""
"If you have a local module or item with the same name as an external crate, "
"a path beginning with that name will be taken to refer to the local module "
"or item. To explicitly refer to the external crate, use the `::name` form."
msgstr ""

#: src/rust-2018/path-changes.md:211
msgid "No more `mod.rs`"
msgstr ""

#: src/rust-2018/path-changes.md:213
msgid "In Rust 2015, if you have a submodule:"
msgstr ""

#: src/rust-2018/path-changes.md:216
msgid ""
"// This `mod` declaration looks for the `foo` module in\n"
"// `foo.rs` or `foo/mod.rs`.\n"
msgstr ""

#: src/rust-2018/path-changes.md:221
msgid ""
"It can live in `foo.rs` or `foo/mod.rs`. If it has submodules of its own, it "
"_must_ be `foo/mod.rs`. So a `bar` submodule of `foo` would live at `foo/"
"bar.rs`."
msgstr ""

#: src/rust-2018/path-changes.md:225
msgid ""
"In Rust 2018 the restriction that a module with submodules must be named "
"`mod.rs` is lifted. `foo.rs` can just be `foo.rs`, and the submodule is "
"still `foo/bar.rs`. This eliminates the special name, and if you have a "
"bunch of files open in your editor, you can clearly see their names, instead "
"of having a bunch of tabs named `mod.rs`."
msgstr ""

#: src/rust-2018/path-changes.md:262
msgid "`use` paths"
msgstr ""

#: src/rust-2018/path-changes.md:264
msgid ""
"![Minimum Rust version: 1.32](https://img.shields.io/badge/"
"Minimum%20Rust%20Version-1.32-brightgreen.svg)"
msgstr ""

#: src/rust-2018/path-changes.md:266
msgid ""
"Rust 2018 simplifies and unifies path handling compared to Rust 2015. In "
"Rust 2015, paths work differently in `use` declarations than they do "
"elsewhere. In particular, paths in `use` declarations would always start "
"from the crate root, while paths in other code implicitly started from the "
"current scope. Those differences didn't have any effect in the top-level "
"module, which meant that everything would seem straightforward until working "
"on a project large enough to have submodules."
msgstr ""

#: src/rust-2018/path-changes.md:274
msgid ""
"In Rust 2018, paths in `use` declarations and in other code work the same "
"way, both in the top-level module and in any submodule. You can use a "
"relative path from the current scope, a path starting from an external crate "
"name, or a path starting with `::`, `crate`, `super`, or `self`."
msgstr ""

#: src/rust-2018/path-changes.md:279
msgid "Code that looked like this:"
msgstr ""

#: src/rust-2018/path-changes.md:311
msgid ""
"will look exactly the same in Rust 2018, except that you can delete the "
"`extern crate` line:"
msgstr ""

#: src/rust-2018/path-changes.md:342
msgid "The same code will also work completely unmodified in a submodule:"
msgstr ""

#: src/rust-2018/path-changes.md:374
msgid ""
"This makes it easy to move code around in a project, and avoids introducing "
"additional complexity to multi-module projects."
msgstr ""

#: src/rust-2018/trait-fn-parameters.md:7
msgid ""
"[Trait function parameters](https://doc.rust-lang.org/stable/reference/items/"
"traits.html#parameter-patterns) may use any irrefutable pattern when the "
"function has a body."
msgstr ""

#: src/rust-2018/trait-fn-parameters.md:12
#: src/rust-2018/tyvar-behind-raw-pointer.md:9 src/rust-2021/prelude.md:8
#: src/rust-2021/default-cargo-resolver.md:7
#: src/rust-2021/IntoIterator-for-arrays.md:11
#: src/rust-2021/disjoint-capture-in-closures.md:9
#: src/rust-2021/panic-macro-consistency.md:12
#: src/rust-2021/reserved-syntax.md:12 src/rust-2021/raw-lifetimes.md:7
#: src/rust-2021/warnings-promoted-to-error.md:7
#: src/rust-2021/or-patterns-macro-rules.md:10
#: src/rust-2021/c-string-literals.md:9
#: src/rust-2024/rpit-lifetime-capture.md:13
#: src/rust-2024/temporary-if-let-scope.md:7
#: src/rust-2024/temporary-tail-expr-scope.md:10
#: src/rust-2024/match-ergonomics.md:10 src/rust-2024/unsafe-extern.md:9
#: src/rust-2024/unsafe-attributes.md:14
#: src/rust-2024/unsafe-op-in-unsafe-fn.md:10
#: src/rust-2024/static-mut-references.md:10
#: src/rust-2024/never-type-fallback.md:10
#: src/rust-2024/macro-fragment-specifiers.md:10
#: src/rust-2024/missing-macro-fragment-specifiers.md:9
#: src/rust-2024/gen-keyword.md:9 src/rust-2024/reserved-syntax.md:8
#: src/rust-2024/prelude.md:11 src/rust-2024/intoiterator-box-slice.md:12
#: src/rust-2024/newly-unsafe-functions.md:15 src/rust-2024/cargo-resolver.md:7
#: src/rust-2024/cargo-table-key-names.md:13
#: src/rust-2024/cargo-inherited-default-features.md:7
#: src/rust-2024/rustdoc-doctests.md:7
#: src/rust-2024/rustdoc-nested-includes.md:7
#: src/rust-2024/rustfmt-style-edition.md:7
#: src/rust-2024/rustfmt-formatting-fixes.md:7
#: src/rust-2024/rustfmt-raw-identifier-sorting.md:9
#: src/rust-2024/rustfmt-version-sorting.md:7
msgid "Details"
msgstr ""

#: src/rust-2018/trait-fn-parameters.md:14
msgid ""
"In accordance with RFC [\\#1685](https://github.com/rust-lang/rfcs/pull/"
"1685), parameters in trait method declarations are no longer allowed to be "
"anonymous."
msgstr ""

#: src/rust-2018/trait-fn-parameters.md:17
msgid "For example, in the 2015 edition, this was allowed:"
msgstr ""

#: src/rust-2018/trait-fn-parameters.md:25
msgid ""
"In the 2018 edition, all parameters must be given an argument name  (even if "
"it's just `_`):"
msgstr ""

#: src/rust-2018/new-keywords.md:3
msgid ""
"![Minimum Rust version: 1.27](https://img.shields.io/badge/"
"Minimum%20Rust%20Version-1.27-brightgreen.svg)"
msgstr ""

#: src/rust-2018/new-keywords.md:7
msgid ""
"`dyn` is a [strict keyword](https://doc.rust-lang.org/reference/"
"keywords.html#strict-keywords), in 2015 it is a [weak keyword](https://"
"doc.rust-lang.org/reference/keywords.html#weak-keywords)."
msgstr ""

#: src/rust-2018/new-keywords.md:8
msgid ""
"`async` and `await` are [strict keywords](https://doc.rust-lang.org/"
"reference/keywords.html#strict-keywords)."
msgstr ""

#: src/rust-2018/new-keywords.md:9
msgid ""
"`try` is a [reserved keyword](https://doc.rust-lang.org/reference/"
"keywords.html#reserved-keywords)."
msgstr ""

#: src/rust-2018/new-keywords.md:17
msgid "`dyn Trait` for trait objects"
msgstr ""

#: src/rust-2018/new-keywords.md:19
msgid ""
"The `dyn Trait` feature is the new syntax for using trait objects. In short:"
msgstr ""

#: src/rust-2018/new-keywords.md:21
msgid "`Box<Trait>` becomes `Box<dyn Trait>`"
msgstr ""

#: src/rust-2018/new-keywords.md:22
msgid "`&Trait` and `&mut Trait` become `&dyn Trait` and `&mut dyn Trait`"
msgstr ""

#: src/rust-2018/new-keywords.md:24
msgid "And so on. In code:"
msgstr ""

#: src/rust-2018/new-keywords.md:30
msgid "// old\n"
msgstr ""

#: src/rust-2018/new-keywords.md:35
msgid "// new\n"
msgstr ""

#: src/rust-2018/new-keywords.md:42
msgid "That's it!"
msgstr ""

#: src/rust-2018/new-keywords.md:44
msgid "Why?"
msgstr ""

#: src/rust-2018/new-keywords.md:46
msgid ""
"Using just the trait name for trait objects turned out to be a bad decision. "
"The current syntax is often ambiguous and confusing, even to veterans, and "
"favors a feature that is not more frequently used than its alternatives, is "
"sometimes slower, and often cannot be used at all when its alternatives can."
msgstr ""

#: src/rust-2018/new-keywords.md:51
msgid ""
"Furthermore, with `impl Trait` arriving, \"`impl Trait` vs `dyn Trait`\" is "
"much more symmetric, and therefore a bit nicer, than \"`impl Trait` vs "
"`Trait`\". `impl Trait` is explained [here](../../rust-by-example/trait/"
"impl_trait.html)."
msgstr ""

#: src/rust-2018/new-keywords.md:55
msgid ""
"In the new edition, you should therefore prefer `dyn Trait` to just `Trait` "
"where you need a trait object."
msgstr ""

#: src/rust-2018/new-keywords.md:60
msgid "`async` and `await`"
msgstr ""

#: src/rust-2018/new-keywords.md:62
msgid ""
"These keywords are reserved to implement the async-await feature of Rust, "
"which was ultimately [released to stable in 1.39.0](https://blog.rust-"
"lang.org/2019/11/07/Async-await-stable.html)."
msgstr ""

#: src/rust-2018/new-keywords.md:64
msgid "`try` keyword"
msgstr ""

#: src/rust-2018/new-keywords.md:66
msgid ""
"The `try` keyword is reserved for use in `try` blocks, which have not (as of "
"this writing) been stabilized ([tracking issue](https://github.com/rust-lang/"
"rust/issues/31436))"
msgstr ""

#: src/rust-2018/tyvar-behind-raw-pointer.md:5
msgid ""
"The [`tyvar_behind_raw_pointer`](https://github.com/rust-lang/rust/issues/"
"46906) lint is now a hard error."
msgstr ""

#: src/rust-2018/tyvar-behind-raw-pointer.md:11
msgid ""
"See Rust issue [\\#46906](https://github.com/rust-lang/rust/issues/46906) "
"for details."
msgstr ""

#: src/rust-2018/cargo.md:5
msgid ""
"If there is a target definition in a `Cargo.toml` manifest, it no longer "
"automatically disables automatic discovery of other targets."
msgstr ""

#: src/rust-2018/cargo.md:7
msgid ""
"Target paths of the form `src/{target_name}.rs` are no longer inferred for "
"targets where the `path` field is not set."
msgstr ""

#: src/rust-2018/cargo.md:9
msgid ""
"`cargo install` for the current directory is no longer allowed, you must "
"specify `cargo install --path .` to install the current package."
msgstr ""

#: src/rust-2021/index.md:5
msgid "[\\#3085](https://github.com/rust-lang/rfcs/pull/3085)"
msgstr ""

#: src/rust-2021/index.md:6
msgid "1.56.0"
msgstr ""

#: src/rust-2021/index.md:8
msgid ""
"The Rust 2021 Edition contains several changes that bring new capabilities "
"and more consistency to the language, and opens up room for expansion in the "
"future. The following chapters dive into the details of each change, and "
"they include guidance on migrating your existing code."
msgstr ""

#: src/rust-2021/prelude.md:5
msgid ""
"The `TryInto`, `TryFrom` and `FromIterator` traits are now part of the "
"prelude."
msgstr ""

#: src/rust-2021/prelude.md:6 src/rust-2024/prelude.md:6
msgid ""
"This might make calls to trait methods ambiguous which could make some code "
"fail to compile."
msgstr ""

#: src/rust-2021/prelude.md:10
msgid ""
"The [prelude of the standard library](https://doc.rust-lang.org/stable/std/"
"prelude/index.html) is the module containing everything that is "
"automatically imported in every module. It contains commonly used items such "
"as `Option`, `Vec`, `drop`, and `Clone`."
msgstr ""

#: src/rust-2021/prelude.md:14 src/rust-2024/prelude.md:16
msgid ""
"The Rust compiler prioritizes any manually imported items over those from "
"the prelude, to make sure additions to the prelude will not break any "
"existing code. For example, if you have a crate or module called `example` "
"containing a `pub struct Option;`, then `use example::*;` will make `Option` "
"unambiguously refer to the one from `example`; not the one from the standard "
"library."
msgstr ""

#: src/rust-2021/prelude.md:20
msgid ""
"However, adding a _trait_ to the prelude can break existing code in a subtle "
"way. For example, a call to `x.try_into()` which comes from a `MyTryInto` "
"trait might fail to compile if `std`'s `TryInto` is also imported, because "
"the call to `try_into` is now ambiguous and could come from either trait. "
"This is the reason we haven't added `TryInto` to the prelude yet, since "
"there is a lot of code that would break this way."
msgstr ""

#: src/rust-2021/prelude.md:26
msgid ""
"As a solution, Rust 2021 will use a new prelude. It's identical to the "
"current one, except for three new additions:"
msgstr ""

#: src/rust-2021/prelude.md:29
msgid ""
"[`std::convert::TryInto`](https://doc.rust-lang.org/stable/std/convert/"
"trait.TryInto.html)"
msgstr ""

#: src/rust-2021/prelude.md:30
msgid ""
"[`std::convert::TryFrom`](https://doc.rust-lang.org/stable/std/convert/"
"trait.TryFrom.html)"
msgstr ""

#: src/rust-2021/prelude.md:31
msgid ""
"[`std::iter::FromIterator`](https://doc.rust-lang.org/stable/std/iter/"
"trait.FromIterator.html)"
msgstr ""

#: src/rust-2021/prelude.md:33
msgid ""
"The tracking issue [can be found here](https://github.com/rust-lang/rust/"
"issues/85684)."
msgstr ""

#: src/rust-2021/prelude.md:35 src/rust-2021/default-cargo-resolver.md:30
#: src/rust-2021/IntoIterator-for-arrays.md:53
#: src/rust-2021/disjoint-capture-in-closures.md:31
#: src/rust-2021/panic-macro-consistency.md:62
#: src/rust-2021/reserved-syntax.md:52 src/rust-2021/raw-lifetimes.md:15
#: src/rust-2021/or-patterns-macro-rules.md:37
#: src/rust-2021/c-string-literals.md:65
#: src/rust-2024/rpit-lifetime-capture.md:135
#: src/rust-2024/temporary-if-let-scope.md:61
#: src/rust-2024/temporary-tail-expr-scope.md:88
#: src/rust-2024/match-ergonomics.md:102 src/rust-2024/unsafe-extern.md:37
#: src/rust-2024/unsafe-attributes.md:60
#: src/rust-2024/unsafe-op-in-unsafe-fn.md:42
#: src/rust-2024/static-mut-references.md:353
#: src/rust-2024/never-type-fallback.md:62
#: src/rust-2024/macro-fragment-specifiers.md:34
#: src/rust-2024/missing-macro-fragment-specifiers.md:32
#: src/rust-2024/gen-keyword.md:15 src/rust-2024/reserved-syntax.md:46
#: src/rust-2024/prelude.md:32 src/rust-2024/intoiterator-box-slice.md:48
#: src/rust-2024/newly-unsafe-functions.md:38
#: src/rust-2024/cargo-resolver.md:30 src/rust-2024/cargo-table-key-names.md:37
#: src/rust-2024/cargo-inherited-default-features.md:37
#: src/rust-2024/rustdoc-doctests.md:73
#: src/rust-2024/rustdoc-nested-includes.md:43
#: src/rust-2024/rustfmt-style-edition.md:70
#: src/rust-2024/rustfmt-formatting-fixes.md:640
#: src/rust-2024/rustfmt-raw-identifier-sorting.md:32
#: src/rust-2024/rustfmt-version-sorting.md:37
msgid "Migration"
msgstr ""

#: src/rust-2021/prelude.md:37
msgid ""
"As a part of the 2021 edition a migration lint, "
"`rust_2021_prelude_collisions`, has been added in order to aid in automatic "
"migration of Rust 2018 codebases to Rust 2021."
msgstr ""

#: src/rust-2021/prelude.md:39 src/rust-2021/disjoint-capture-in-closures.md:35
#: src/rust-2021/reserved-syntax.md:56 src/rust-2021/raw-lifetimes.md:19
msgid "In order to migrate your code to be Rust 2021 Edition compatible, run:"
msgstr ""

#: src/rust-2021/prelude.md:45
msgid ""
"The lint detects cases where functions or methods are called that have the "
"same name as the methods defined in one of the new prelude traits. In some "
"cases, it may rewrite your calls in various ways to ensure that you continue "
"to call the same function you did before."
msgstr ""

#: src/rust-2021/prelude.md:47
msgid ""
"If you'd like to migrate your code manually or better understand what `cargo "
"fix` is doing, below we've outlined the situations where a migration is "
"needed along with a counter example of when it's not needed."
msgstr ""

#: src/rust-2021/prelude.md:49
msgid "Migration needed"
msgstr ""

#: src/rust-2021/prelude.md:51 src/rust-2024/prelude.md:34
msgid "Conflicting trait methods"
msgstr ""

#: src/rust-2021/prelude.md:53 src/rust-2024/prelude.md:36
msgid ""
"When two traits that are in scope have the same method name, it is ambiguous "
"which trait method should be used. For example:"
msgstr ""

#: src/rust-2021/prelude.md:57
msgid ""
"// This name is the same as the `from_iter` method on the `FromIterator` "
"trait from `std`.  \n"
msgstr ""

#: src/rust-2021/prelude.md:66
msgid ""
"// Vec<T> implements both `std::iter::FromIterator` and `MyTrait` \n"
"  // If both traits are in scope (as would be the case in Rust 2021),\n"
"  // then it becomes ambiguous which `from_iter` method to call\n"
msgstr ""

#: src/rust-2021/prelude.md:73
msgid "We can fix this by using fully qualified syntax:"
msgstr ""

#: src/rust-2021/prelude.md:77 src/rust-2024/prelude.md:60
msgid "// Now it is clear which trait method we're referring to\n"
msgstr ""

#: src/rust-2021/prelude.md:82
msgid "Inherent methods on `dyn Trait` objects"
msgstr ""

#: src/rust-2021/prelude.md:84
msgid ""
"Some users invoke methods on a `dyn Trait` value where the method name "
"overlaps with a new prelude trait:"
msgstr ""

#: src/rust-2021/prelude.md:89
msgid "// This has the same name as `TryInto::try_into`\n"
msgstr ""

#: src/rust-2021/prelude.md:93
msgid ""
"// `MyTrait` isn't in scope here and can only be referred to through the "
"path `submodule::MyTrait`\n"
msgstr ""

#: src/rust-2021/prelude.md:96
msgid ""
"// If `std::convert::TryInto` is in scope (as would be the case in Rust "
"2021),\n"
"  // then it becomes ambiguous which `try_into` method to call\n"
msgstr ""

#: src/rust-2021/prelude.md:102
msgid ""
"Unlike with static dispatch methods, calling a trait method on a trait "
"object does not require that the trait be in scope. The code above works as "
"long as there is no trait in scope with a conflicting method name. When the "
"`TryInto` trait is in scope (which is the case in Rust 2021), this causes an "
"ambiguity. Should the call be to `MyTrait::try_into` or "
"`std::convert::TryInto::try_into`?"
msgstr ""

#: src/rust-2021/prelude.md:106
msgid ""
"In these cases, we can fix this by adding an additional dereferences or "
"otherwise clarify the type of the method receiver. This ensures that the "
"`dyn Trait` method is chosen, versus the methods from the prelude trait. For "
"example, turning `f.try_into()` above into `(&*f).try_into()` ensures that "
"we're calling `try_into` on the `dyn MyTrait` which can only refer to the "
"`MyTrait::try_into` method."
msgstr ""

#: src/rust-2021/prelude.md:110
msgid "No migration needed"
msgstr ""

#: src/rust-2021/prelude.md:112
msgid "Inherent methods"
msgstr ""

#: src/rust-2021/prelude.md:114
msgid ""
"Many types define their own inherent methods with the same name as a trait "
"method. For instance, below the struct `MyStruct` implements `from_iter` "
"which shares the same name with the method from the trait `FromIterator` "
"found in the standard library:"
msgstr ""

#: src/rust-2021/prelude.md:124
msgid "// This has the same name as `std::iter::FromIterator::from_iter`\n"
msgstr ""

#: src/rust-2021/prelude.md:141
msgid ""
"Inherent methods always take precedent over trait methods so there's no need "
"for any migration."
msgstr ""

#: src/rust-2021/prelude.md:143
msgid "Implementation Reference"
msgstr ""

#: src/rust-2021/prelude.md:145
msgid ""
"The lint needs to take a couple of factors into account when determining "
"whether or not introducing 2021 Edition to a codebase will cause a name "
"resolution collision (thus breaking the code after changing edition). These "
"factors include:"
msgstr ""

#: src/rust-2021/prelude.md:147
msgid ""
"Is the call a [fully-qualified call](https://doc.rust-lang.org/reference/"
"expressions/call-expr.html#disambiguating-function-calls) or does it use "
"[dot-call method syntax](https://doc.rust-lang.org/reference/expressions/"
"method-call-expr.html)?"
msgstr ""

#: src/rust-2021/prelude.md:148
msgid ""
"This will affect how the name is resolved due to auto-reference and auto-"
"dereferencing on method call syntax. Manually dereferencing/referencing will "
"allow specifying priority in the case of dot-call method syntax, while fully-"
"qualified call requires specification of the type and the trait name in the "
"method path (e.g. `<Type as Trait>::method`)"
msgstr ""

#: src/rust-2021/prelude.md:149
msgid ""
"Is this an [inherent method](https://doc.rust-lang.org/reference/items/"
"implementations.html#inherent-implementations) or [a trait method](https://"
"doc.rust-lang.org/reference/items/implementations.html#trait-"
"implementations)?"
msgstr ""

#: src/rust-2021/prelude.md:150
msgid ""
"Inherent methods that take `self` will take priority over "
"`TryInto::try_into` as inherent methods take priority over trait methods, "
"but inherent methods that take `&self` or `&mut self` won't take priority "
"due to requiring a auto-reference (while `TryInto::try_into` does not, as it "
"takes `self`)"
msgstr ""

#: src/rust-2021/prelude.md:151
msgid ""
"Is the origin of this method from `core`/`std`? (As the traits can't have a "
"collision with themselves)"
msgstr ""

#: src/rust-2021/prelude.md:152
msgid ""
"Does the given type implement the trait it could have a collision against?"
msgstr ""

#: src/rust-2021/prelude.md:153
msgid ""
"Is the method being called via dynamic dispatch? (i.e. is the `self` type "
"`dyn Trait`)"
msgstr ""

#: src/rust-2021/prelude.md:154
msgid ""
"If so, trait imports don't affect resolution, and no migration lint needs to "
"occur"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:5
msgid "`edition = \"2021\"` implies `resolver = \"2\"` in `Cargo.toml`."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:9
msgid ""
"Since Rust 1.51.0, Cargo has opt-in support for a [new feature resolver]"
"(../../cargo/reference/resolver.html#feature-resolver-version-2) which can "
"be activated with `resolver = \"2\"` in `Cargo.toml`."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:12
msgid ""
"Starting in Rust 2021, this will be the default. That is, writing `edition = "
"\"2021\"` in `Cargo.toml` will imply `resolver = \"2\"`."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:15
#: src/rust-2024/cargo-resolver.md:17
msgid ""
"The resolver is a global setting for a [workspace](../../cargo/reference/"
"workspaces.html), and the setting is ignored in dependencies. The setting is "
"only honored for the top-level package of the workspace. If you are using a "
"[virtual workspace](../../cargo/reference/workspaces.html#virtual-"
"workspace), you will still need to explicitly set the [`resolver` field]"
"(../../cargo/reference/resolver.html#resolver-versions) in the `[workspace]` "
"definition if you want to opt-in to the new resolver."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:20
msgid ""
"The new feature resolver no longer merges all requested features for crates "
"that are depended on in multiple ways. See [the announcement of Rust 1.51]"
"(https://blog.rust-lang.org/2021/03/25/Rust-1.51.0.html#cargos-new-feature-"
"resolver) for details."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:32
msgid ""
"There are no automated migration tools for updating for the new resolver. "
"For most projects, there are usually few or no changes as a result of "
"updating."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:35
msgid ""
"When updating with `cargo fix --edition`, Cargo will display a report if the "
"new resolver will build dependencies with different features. It may look "
"something like this:"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:38
msgid ""
"note: Switching to Edition 2021 will enable the use of the version 2 feature "
"resolver in Cargo. This may cause some dependencies to be built with fewer "
"features enabled than previously. More information about the resolver "
"changes may be found at <https://doc.rust-lang.org/nightly/edition-guide/"
"rust-2021/default-cargo-resolver.html><br> When building the following "
"dependencies, the given features will no longer be used:"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:48
msgid ""
"This lets you know that certain dependencies will no longer be built with "
"the given features."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:50
msgid "Build failures"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:52
msgid ""
"There may be some circumstances where your project may not build correctly "
"after the change. If a dependency declaration in one package assumes that "
"certain features are enabled in another, and those features are now "
"disabled, it may fail to compile."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:55
msgid "For example, let's say we have a dependency like this:"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:57
msgid ""
"```toml\n"
"# Cargo.toml\n"
"\n"
"[dependencies]\n"
"bstr = { version = \"0.2.16\", default-features = false }\n"
"# ...\n"
"```"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:65
msgid "And somewhere in our dependency tree, another package has this:"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:67
msgid ""
"```toml\n"
"# Another package's Cargo.toml\n"
"\n"
"[build-dependencies]\n"
"bstr = \"0.2.16\"\n"
"```"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:74
msgid ""
"In our package, we've been using the [`words_with_breaks`](https://docs.rs/"
"bstr/0.2.16/bstr/trait.ByteSlice.html#method.words_with_breaks) method from "
"`bstr`, which requires `bstr`'s  \"unicode\" feature to be enabled. This has "
"historically worked because Cargo unified the features of `bstr` between the "
"two packages. However, after updating to Rust 2021, the new resolver will "
"build `bstr` twice, once with the default features (as a build dependency), "
"and once with no features (as our normal dependency). Since `bstr` is now "
"being built without the \"unicode\" feature, the `words_with_breaks` method "
"doesn't exist, and the build will fail with an error that the method is "
"missing."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:79
msgid ""
"The solution here is to ensure that the dependency is declared with the "
"features you are actually using. For example:"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:82
msgid ""
"```toml\n"
"[dependencies]\n"
"bstr = { version = \"0.2.16\", default-features = false, features = "
"[\"unicode\"] }\n"
"```"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:87
msgid ""
"In some cases, this may be a problem with a third-party dependency that you "
"don't have direct control over. You can consider submitting a patch to that "
"project to try to declare the correct set of features for the problematic "
"dependency. Alternatively, you can add features to any dependency from "
"within your own `Cargo.toml` file. For example, if the `bstr` example given "
"above was declared in some third-party dependency, you can just copy the "
"correct dependency declaration into your own project. The features will be "
"unified, as long as they match the unification rules of the new resolver. "
"Those are:"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:93
msgid ""
"Features enabled on platform-specific dependencies for targets not currently "
"being built are ignored."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:94
msgid ""
"Build-dependencies and proc-macros do not share features with normal "
"dependencies."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:95
msgid ""
"Dev-dependencies do not activate features unless building a target that "
"needs them (like tests or examples)."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:97
msgid ""
"A real-world example is using [`diesel`](https://crates.io/crates/diesel) "
"and [`diesel_migrations`](https://crates.io/crates/diesel_migrations). These "
"packages provide database support, and the database is selected using a "
"feature, like this:"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:100
msgid ""
"```toml\n"
"[dependencies]\n"
"diesel = { version = \"1.4.7\", features = [\"postgres\"] }\n"
"diesel_migrations = \"1.4.0\"\n"
"```"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:106
msgid ""
"The problem is that `diesel_migrations` has an internal proc-macro which "
"itself depends on `diesel`, and the proc-macro assumes its own copy of "
"`diesel` has the same features enabled as the rest of the dependency graph. "
"After updating to the new resolver, it fails to build because now there are "
"two copies of `diesel`, and the one built for the proc-macro is missing the "
"\"postgres\" feature."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:109
msgid ""
"A solution here is to add `diesel` as a build-dependency with the required "
"features, for example:"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:111
msgid ""
"```toml\n"
"[build-dependencies]\n"
"diesel = { version = \"1.4.7\", features = [\"postgres\"] }\n"
"```"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:116
msgid ""
"This causes Cargo to add \"postgres\" as a feature for host dependencies "
"(proc-macros and build-dependencies). Now, the `diesel_migrations` proc-"
"macro will get the \"postgres\" feature enabled, and it will build correctly."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:119
msgid ""
"The 2.0 release of `diesel` (currently in development) does not have this "
"problem as it has been restructured to not have this dependency requirement."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:121
msgid "Exploring features"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:123
msgid ""
"The [`cargo tree`](../../cargo/commands/cargo-tree.html) command has had "
"substantial improvements to help with the migration to the new resolver. "
"`cargo tree` can be used to explore the dependency graph, and to see which "
"features are being enabled, and importantly _why_ they are being enabled."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:126
msgid ""
"One option is to use the `--duplicates` flag (`-d` for short), which will "
"tell you when a package is being built multiple times. Taking the `bstr` "
"example from earlier, we might see:"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:141
msgid ""
"This output tells us that `bstr` is built twice, and shows the chain of "
"dependencies that led to its inclusion in both cases."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:143
msgid ""
"You can print which features each package is using with the `-f` flag, like "
"this:"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:149
msgid ""
"This tells Cargo to change the \"format\" of the output, where it will print "
"both the package and the enabled features."
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:151
msgid ""
"You can also use the `-e` flag to tell it which \"edges\" to display. For "
"example, `cargo tree -e features` will show in-between each dependency which "
"features are being added by each dependency. This option becomes more useful "
"with the `-i` flag which can be used to \"invert\" the tree. This allows you "
"to see how features _flow_ into a given dependency. For example, let's say "
"the dependency graph is large, and we're not quite sure who is depending on "
"`bstr`, the following command will show that:"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:157
msgid ""
"```console\n"
"> cargo tree -e features -i bstr\n"
"bstr v0.2.16\n"
"├── bstr feature \"default\"\n"
"│   [build-dependencies]\n"
"│   └── bar v0.1.0\n"
"│       └── bar feature \"default\"\n"
"│           └── foo v0.1.0 (/MyProjects/foo)\n"
"├── bstr feature \"lazy_static\"\n"
"│   └── bstr feature \"unicode\"\n"
"│       └── bstr feature \"default\" (*)\n"
"├── bstr feature \"regex-automata\"\n"
"│   └── bstr feature \"unicode\" (*)\n"
"├── bstr feature \"std\"\n"
"│   └── bstr feature \"default\" (*)\n"
"└── bstr feature \"unicode\" (*)\n"
"```"
msgstr ""

#: src/rust-2021/default-cargo-resolver.md:175
msgid ""
"This snippet of output shows that the project `foo` depends on `bar` with "
"the \"default\" feature. Then, `bar` depends on `bstr` as a build-dependency "
"with the \"default\" feature. We can further see that `bstr`'s  \"default\" "
"feature enables \"unicode\" (among other features)."
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:5
msgid "Arrays implement `IntoIterator` in _all_ editions."
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:6
msgid ""
"Calls to `IntoIterator::into_iter` are _hidden_ in Rust 2015 and Rust 2018 "
"when using method call syntax (i.e., `array.into_iter()`). So, "
"`array.into_iter()` still resolves to `(&array).into_iter()` as it has "
"before."
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:9
msgid ""
"`array.into_iter()` changes meaning to be the call to "
"`IntoIterator::into_iter` in Rust 2021."
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:13
msgid ""
"Until Rust 1.53, only _references_ to arrays implement `IntoIterator`. This "
"means you can iterate over `&[1, 2, 3]` and `&mut [1, 2, 3]`, but not over "
"`[1, 2, 3]` directly."
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:18
msgid "// Ok :)\n"
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:20
msgid "// Error :(\n"
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:23
msgid ""
"This has been [a long-standing issue](https://github.com/rust-lang/rust/"
"issues/25725), but the solution is not as simple as it seems. Just [adding "
"the trait implementation](https://github.com/rust-lang/rust/pull/65819) "
"would break existing code. `array.into_iter()` already compiles today "
"because that implicitly calls `(&array).into_iter()` due to [how method call "
"syntax works](https://doc.rust-lang.org/book/ch05-03-method-"
"syntax.html#wheres-the---operator). Adding the trait implementation would "
"change the meaning."
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:29
msgid ""
"Usually this type of breakage (adding a trait implementation) is categorized "
"as 'minor' and acceptable. But in this case there is too much code that "
"would be broken by it."
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:32
msgid ""
"It has been suggested many times to \"only implement `IntoIterator` for "
"arrays in Rust 2021\". However, this is simply not possible. You can't have "
"a trait implementation exist in one edition and not in another, since "
"editions can be mixed."
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:37
msgid ""
"Instead, the trait implementation was added in _all_ editions (starting in "
"Rust 1.53.0) but with a small hack to avoid breakage until Rust 2021. In "
"Rust 2015 and 2018 code, the compiler will still resolve `array.into_iter()` "
"to `(&array).into_iter()` like before, as if the trait implementation does "
"not exist. This _only_ applies to the `.into_iter()` method call syntax. It "
"does not affect any other syntax such as `for e in [1, 2, 3]`, `iter.zip([1, "
"2, 3])` or `IntoIterator::into_iter([1, 2, 3])`. Those will start to work in "
"_all_ editions."
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:46
msgid ""
"While it's a shame that this required a small hack to avoid breakage, this "
"solution keeps the difference between the editions to an absolute minimum."
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:55
msgid ""
"A lint, `array_into_iter`, gets triggered whenever there is some call to "
"`into_iter()` that will change meaning in Rust 2021. The `array_into_iter` "
"lint has already been a warning by default on all editions since the 1.41 "
"release (with several enhancements made in 1.55). If your code is already "
"warning free, then it should already be ready to go for Rust 2021!"
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:60
#: src/rust-2021/panic-macro-consistency.md:69
#: src/rust-2021/or-patterns-macro-rules.md:42
msgid ""
"You can automatically migrate your code to be Rust 2021 Edition compatible "
"or ensure it is already compatible by running:"
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:67
msgid ""
"Because the difference between editions is small, the migration to Rust 2021 "
"is fairly straight-forward."
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:69
msgid ""
"For method calls of `into_iter` on arrays, the elements being implemented "
"will change from references to owned values."
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:71
#: src/rust-2021/or-patterns-macro-rules.md:52
#: src/rust-2024/cargo-table-key-names.md:21
msgid "For example:"
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:77
msgid ""
"// x is a `&u8` in Rust 2015 and Rust 2018\n"
"    // x is a `u8` in Rust 2021\n"
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:83
msgid ""
"The most straightforward way to migrate in Rust 2021, is by keeping the "
"exact behavior from previous editions by calling `iter()` which also "
"iterates over owned arrays by reference:"
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:89
msgid ""
"// <- This line changed\n"
"    // x is a `&u8` in all editions\n"
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:95
msgid "Optional migration"
msgstr ""

#: src/rust-2021/IntoIterator-for-arrays.md:97
msgid ""
"If you are using fully qualified method syntax (i.e., "
"`IntoIterator::into_iter(array)`) in a previous edition, this can be "
"upgraded to method call syntax (i.e., `array.into_iter()`)."
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:5
msgid "`|| a.x + 1` now captures only `a.x` instead of `a`."
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:6
msgid ""
"This can cause things to be dropped at different times or affect whether "
"closures implement traits like `Send` or `Clone`."
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:7
msgid ""
"If possible changes are detected, `cargo fix` will insert statements like "
"`let _ = &a` to force a closure to capture the entire variable."
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:11
msgid ""
"[Closures](https://doc.rust-lang.org/book/ch13-01-closures.html) "
"automatically capture anything that you refer to from within their body. For "
"example, `|| a + 1` automatically captures a reference to `a` from the "
"surrounding context."
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:15
msgid ""
"In Rust 2018 and before, closures capture entire variables, even if the "
"closure only uses one field. For example, `|| a.x + 1` captures a reference "
"to `a` and not just `a.x`. Capturing `a` in its entirety prevents mutation "
"or moves from other fields of `a`, so that code like this does not compile:"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:21
msgid "// Move out of one field of the struct\n"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:22
#: src/rust-2021/disjoint-capture-in-closures.md:23
#: src/rust-2021/panic-macro-consistency.md:20
#: src/rust-2021/panic-macro-consistency.md:21
#: src/rust-2021/panic-macro-consistency.md:53
#: src/rust-2021/panic-macro-consistency.md:54
msgid "\"{}\""
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:22
msgid "// Ok: Still use another field of the struct\n"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:23
msgid "// Error: Tries to capture all of `a`\n"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:27
msgid ""
"Starting in Rust 2021, closures captures are more precise. Typically they "
"will only capture the fields they use (in some cases, they might capture "
"more than just what they use, see the Rust reference for full details). "
"Therefore, the above example will compile fine in Rust 2021."
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:29
msgid ""
"Disjoint capture was proposed as part of [RFC 2229](https://github.com/rust-"
"lang/rfcs/blob/master/text/2229-capture-disjoint-fields.md) and the RFC "
"contains details about the motivation."
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:33
msgid ""
"As a part of the 2021 edition a migration lint, "
"`rust_2021_incompatible_closure_captures`, has been added in order to aid in "
"automatic migration of Rust 2018 codebases to Rust 2021."
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:41
msgid ""
"Below is an examination of how to manually migrate code to use closure "
"captures that are compatible with Rust 2021 should the automatic migration "
"fail or you would like to better understand how the migration works."
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:44
msgid ""
"Changing the variables captured by a closure can cause programs to change "
"behavior or to stop compiling in two cases:"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:46
msgid ""
"changes to drop order, or when destructors run ([details](#drop-order));"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:47
msgid ""
"changes to which traits a closure implements ([details](#trait-"
"implementations))."
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:49
msgid ""
"Whenever any of the scenarios below are detected, `cargo fix` will insert a "
"\"dummy let\" into your closure to force it to capture the entire variable:"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:54
msgid "// \"Dummy let\" that forces `x` to be captured in its entirety\n"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:57
msgid "// Otherwise, only `x.0` would be captured here\n"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:58
msgid "\"{:?}\""
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:62
msgid ""
"This is a conservative analysis: in many cases, these dummy lets can be "
"safely removed and your program will work fine."
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:64
msgid "Wild Card Patterns"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:66
msgid ""
"Closures now only capture data that needs to be read, which means the "
"following closures will not capture `x`:"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:71
msgid "// no-op\n"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:75
msgid "\"Hello World!\""
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:79
msgid ""
"The `let _ = x` statement here is a no-op, since the `_` pattern completely "
"ignores the right-hand side, and `x` is a reference to a place in memory (in "
"this case, a variable)."
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:81
msgid ""
"This change by itself (capturing fewer values) doesn't trigger any "
"suggestions, but it may do so in conjunction with the \"drop order\" change "
"below."
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:83
msgid ""
"**Subtle:** There are other similar expressions, such as the \"dummy lets\" "
"`let _ = &x` that we insert, which are not no-ops. This is because the right-"
"hand side (`&x`) is not a reference to a place in memory, but rather an "
"expression that must first be evaluated (and whose result is then discarded)."
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:85
msgid "Drop Order"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:87
msgid ""
"When a closure takes ownership of a value from a variable `t`, that value is "
"then dropped when the closure is dropped, and not when the variable `t` goes "
"out of scope:"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:95
msgid "// t is moved here\n"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:96
msgid "// c is dropped, which drops the tuple `t` as well\n"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:97
msgid "// t goes out of scope here\n"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:100
msgid ""
"The above code will run the same in both Rust 2018 and Rust 2021. However, "
"in cases where the closure only takes ownership of _part_ of a variable, "
"there can be differences:"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:109
msgid ""
"// In Rust 2018, captures all of `t`.\n"
"            // In Rust 2021, captures only `t.0`\n"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:114
msgid ""
"// In Rust 2018, `c` (and `t`) are both dropped when we\n"
"        // exit this block.\n"
"        //\n"
"        // In Rust 2021, `c` and `t.0` are both dropped when we\n"
"        // exit this block.\n"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:120
msgid ""
"// In Rust 2018, the value from `t` has been moved and is\n"
"// not dropped.\n"
"//\n"
"// In Rust 2021, the value from `t.0` has been moved, but `t.1`\n"
"// remains, so it will be dropped here.\n"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:129
msgid ""
"In most cases, dropping values at different times just affects when memory "
"is freed and is not important. However, some `Drop` impls (aka, destructors) "
"have side-effects, and changing the drop order in those cases can alter the "
"semantics of your program. In such cases, the compiler will suggest "
"inserting a dummy `let` to force the entire variable to be captured."
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:131
msgid "Trait implementations"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:133
msgid ""
"Closures automatically implement the following traits based on what values "
"they capture:"
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:135
msgid ""
"[`Clone`](https://doc.rust-lang.org/std/clone/trait.Clone.html): if all "
"captured values are `Clone`."
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:136
msgid ""
"[Auto traits](https://doc.rust-lang.org/nightly/reference/special-types-and-"
"traits.html#auto-traits) like [`Send`](https://doc.rust-lang.org/std/marker/"
"trait.Send.html), [`Sync`](https://doc.rust-lang.org/std/marker/"
"trait.Sync.html), and [`UnwindSafe`](https://doc.rust-lang.org/std/panic/"
"trait.UnwindSafe.html): if all captured values implement the given trait."
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:144
msgid ""
"In Rust 2021, since different values are being captured, this can affect "
"what traits a closure will implement. The migration lints test each closure "
"to see whether it would have implemented a given trait before and whether it "
"still implements it now; if they find that a trait used to be implemented "
"but no longer is, then \"dummy lets\" are inserted."
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:146
msgid ""
"For instance, a common way to allow passing around raw pointers between "
"threads is to wrap them in a struct and then implement `Send`/`Sync` auto "
"trait for the wrapper. The closure that is passed to `thread::spawn` uses "
"the specific fields within the wrapper but the entire wrapper is captured "
"regardless. Since the wrapper is `Send`/`Sync`, the code is considered safe "
"and therefore compiles successfully."
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:148
msgid ""
"With disjoint captures, only the specific field mentioned in the closure "
"gets captured, which wasn't originally `Send`/`Sync` defeating the purpose "
"of the wrapper."
msgstr ""

#: src/rust-2021/disjoint-capture-in-closures.md:164
msgid "// Closure captured px.0 which is not Send\n"
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:5
msgid ""
"`panic!(..)` now always uses `format_args!(..)`, just like `println!()`."
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:6
msgid ""
"`panic!(\"{\")` is no longer accepted, without escaping the `{` as `{{`."
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:7
msgid "`panic!(x)` is no longer accepted if `x` is not a string literal."
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:8
msgid "Use `std::panic::panic_any(x)` to panic with a non-string payload."
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:9
msgid "Or use `panic!(\"{}\", x)` to use `x`'s `Display` implementation."
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:10
msgid "The same applies to `assert!(expr, ..)`."
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:14
msgid ""
"The `panic!()` macro is one of Rust's most well known macros. However, it "
"has [some subtle surprises](https://github.com/rust-lang/rfcs/blob/master/"
"text/3007-panic-plan.md) that we can't just change due to backwards "
"compatibility."
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:20
#: src/rust-2021/panic-macro-consistency.md:53
msgid "// Ok, panics with the message \"1\"\n"
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:21
msgid "// Ok, panics with the message \"{}\"\n"
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:24
msgid ""
"The `panic!()` macro only uses string formatting when it's invoked with more "
"than one argument. When invoked with a single argument, it doesn't even look "
"at that argument."
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:29
msgid "\"{\""
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:30
msgid "// Error: First argument must be a format string literal\n"
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:31
msgid "// Ok: The panic macro doesn't care\n"
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:34
msgid ""
"It even accepts non-strings such as `panic!(123)`, which is uncommon and "
"rarely useful since it produces a surprisingly unhelpful message: `panicked "
"at 'Box<Any>'`."
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:37
msgid ""
"This will especially be a problem once [implicit format arguments](https://"
"rust-lang.github.io/rfcs/2795-format-args-implicit-identifiers.html) are "
"stabilized. That feature will make `println!(\"hello {name}\")` a short-hand "
"for `println!(\"hello {}\", name)`. However, `panic!(\"hello {name}\")` "
"would not work as expected, since `panic!()` doesn't process a single "
"argument as format string."
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:44
msgid ""
"To avoid that confusing situation, Rust 2021 features a more consistent "
"`panic!()` macro. The new `panic!()` macro will no longer accept arbitrary "
"expressions as the only argument. It will, just like `println!()`, always "
"process the first argument as format string. Since `panic!()` will no longer "
"accept arbitrary payloads, [`panic_any()`](https://doc.rust-lang.org/stable/"
"std/panic/fn.panic_any.html) will be the only way to panic with something "
"other than a formatted string."
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:52
msgid "// Rust 2021\n"
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:54
msgid "// Error, missing argument\n"
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:55
msgid "// Error, must be a string literal\n"
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:58
msgid ""
"In addition, `core::panic!()` and `std::panic!()` will be identical in Rust "
"2021. Currently, there are some historical differences between those two, "
"which can be noticeable when switching `#![no_std]` on or off."
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:64
msgid ""
"A lint, `non_fmt_panics`, gets triggered whenever there is some call to "
"`panic` that uses some deprecated behavior that will error in Rust 2021. The "
"`non_fmt_panics` lint has already been a warning by default on all editions "
"since the 1.50 release (with several enhancements made in later releases). "
"If your code is already warning free, then it should already be ready to go "
"for Rust 2021!"
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:76
msgid ""
"Should you choose or need to manually migrate, you'll need to update all "
"panic invocations to either use the same formatting as `println` or use "
"`std::panic::panic_any` to panic with non-string data."
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:79
msgid ""
"For example, in the case of `panic!(MyStruct)`, you'll need to convert to "
"using `std::panic::panic_any` (note that this is a function not a macro): "
"`std::panic::panic_any(MyStruct)`."
msgstr ""

#: src/rust-2021/panic-macro-consistency.md:82
msgid ""
"In the case of panic messages that include curly braces but the wrong number "
"of arguments (e.g., `panic!(\"Some curlies: {}\")`), you can panic with the "
"string literal by either using the same syntax as `println!` (i.e., `panic!"
"(\"{}\", \"Some curlies: {}\")`) or by escaping the curly braces (i.e., "
"`panic!(\"Some curlies: {{}}\")`)."
msgstr ""

#: src/rust-2021/reserved-syntax.md:5
msgid ""
"`any_identifier#`, `any_identifier\"...\"`, `any_identifier'...'`, and "
"`'any_identifier#` are now reserved syntax, and no longer tokenize."
msgstr ""

#: src/rust-2021/reserved-syntax.md:6
msgid ""
"This is mostly relevant to macros. E.g. `quote!{ #a#b }` is no longer "
"accepted."
msgstr ""

#: src/rust-2021/reserved-syntax.md:7
msgid ""
"It doesn't treat keywords specially, so e.g. `match\"...\" {}` is no longer "
"accepted."
msgstr ""

#: src/rust-2021/reserved-syntax.md:8
msgid ""
"Insert whitespace between the identifier and the subsequent `#`, `\"`, or "
"`'` to avoid errors."
msgstr ""

#: src/rust-2021/reserved-syntax.md:10
msgid "Edition migrations will help you insert whitespace in such cases."
msgstr ""

#: src/rust-2021/reserved-syntax.md:14
msgid ""
"To make space for new syntax in the future, we've decided to reserve syntax "
"for prefixed identifiers, literals, and lifetimes: `prefix#identifier`, "
"`prefix\"string\"`, `prefix'c'`, `prefix#123`, and `'prefix#`, where "
"`prefix` can be any identifier. (Except those prefixes that already have a "
"meaning, such as `b'...'` (byte chars) and `r\"...\"` (raw strings).)"
msgstr ""

#: src/rust-2021/reserved-syntax.md:21
msgid ""
"This provides syntax we can expand into in the future without requiring an "
"edition boundary. We may use this for temporary syntax until the next "
"edition, or for permanent syntax if appropriate."
msgstr ""

#: src/rust-2021/reserved-syntax.md:25
msgid ""
"Without an edition, this would be a breaking change, since macros can "
"currently accept syntax such as `hello\"world\"`, which they will see as two "
"separate tokens: `hello` and `\"world\"`. The (automatic) fix is simple "
"though: just insert a space: `hello \"world\"`. Likewise, `prefix#ident` "
"should become `prefix #ident`. Edition migrations will help with this fix."
msgstr ""

#: src/rust-2021/reserved-syntax.md:31
msgid ""
"Other than turning these into a tokenization error, [the RFC](https://"
"github.com/rust-lang/rfcs/pull/3101) does not attach a meaning to any prefix "
"yet. Assigning meaning to specific prefixes is left to future proposals, "
"which will now—thanks to reserving these prefixes—not be breaking changes."
msgstr ""

#: src/rust-2021/reserved-syntax.md:36
msgid ""
"Some new prefixes you might potentially see in the future (though we haven't "
"committed to any of them yet):"
msgstr ""

#: src/rust-2021/reserved-syntax.md:39
msgid ""
"`k#keyword` to allow writing keywords that don't exist yet in the current "
"edition. For example, while `async` is not a keyword in edition 2015, this "
"prefix would've allowed us to accept `k#async` in edition 2015 without "
"having to wait for edition 2018 to reserve `async` as a keyword."
msgstr ""

#: src/rust-2021/reserved-syntax.md:44
msgid ""
"`f\"\"` as a short-hand for a format string. For example, `f\"hello {name}"
"\"` as a short-hand for the equivalent `format!()` invocation."
msgstr ""

#: src/rust-2021/reserved-syntax.md:47
msgid "`s\"\"` for `String` literals."
msgstr ""

#: src/rust-2021/reserved-syntax.md:54 src/rust-2021/raw-lifetimes.md:17
msgid ""
"As a part of the 2021 edition a migration lint, "
"[`rust_2021_prefixes_incompatible_syntax`](../../rustc/lints/listing/allowed-"
"by-default.html#rust-2021-prefixes-incompatible-syntax), has been added in "
"order to aid in automatic migration of Rust 2018 codebases to Rust 2021."
msgstr ""

#: src/rust-2021/reserved-syntax.md:62 src/rust-2021/raw-lifetimes.md:25
msgid ""
"Should you want or need to manually migrate your code, migration is fairly "
"straight-forward."
msgstr ""

#: src/rust-2021/reserved-syntax.md:64 src/rust-2021/raw-lifetimes.md:27
msgid "Let's say you have a macro that is defined like so:"
msgstr ""

#: src/rust-2021/reserved-syntax.md:72
msgid ""
"In Rust 2015 and 2018 it's legal for this macro to be called like so with no "
"space between the first token tree and the second:"
msgstr ""

#: src/rust-2021/reserved-syntax.md:75 src/rust-2021/reserved-syntax.md:81
msgid "\"hey\""
msgstr ""

#: src/rust-2021/reserved-syntax.md:78
msgid ""
"This `z` prefix is no longer allowed in Rust 2021, so in order to call this "
"macro, you must add a space after the prefix like so:"
msgstr ""

#: src/rust-2021/raw-lifetimes.md:5
msgid ""
"`'r#ident_or_keyword` is now allowed as a lifetime, which allows using "
"keywords such as `'r#fn`."
msgstr ""

#: src/rust-2021/raw-lifetimes.md:9
msgid ""
"Raw lifetimes are introduced in the 2021 edition to support the ability to "
"migrate to newer editions that introduce new keywords. This is analogous to "
"[raw identifiers](../../reference/identifiers.html#raw-identifiers) which "
"provide the same functionality for identifiers. For example, the 2024 "
"edition introduced the `gen` keyword. Since lifetimes cannot be keywords, "
"this would cause code that use a lifetime `'gen` to fail to compile. Raw "
"lifetimes allow the migration lint to modify those lifetimes to `'r#gen` "
"which do allow keywords."
msgstr ""

#: src/rust-2021/raw-lifetimes.md:11
msgid ""
"In editions prior to 2021, raw lifetimes are parsed as separate tokens. For "
"example `'r#foo` is parsed as three tokens: `'r`, `#`, and `foo`."
msgstr ""

#: src/rust-2021/raw-lifetimes.md:35
msgid ""
"In Rust 2015 and 2018 it's legal for this macro to be called like so with no "
"space between the tokens:"
msgstr ""

#: src/rust-2021/raw-lifetimes.md:41
msgid ""
"In the 2021 edition, this is now parsed as a single token. In order to call "
"this macro, you must add a space before the identifier like so:"
msgstr ""

#: src/rust-2021/warnings-promoted-to-error.md:5
msgid ""
"Code that triggered the `bare_trait_objects` and "
"`ellipsis_inclusive_range_patterns` lints will error in Rust 2021."
msgstr ""

#: src/rust-2021/warnings-promoted-to-error.md:9
msgid ""
"Two existing lints are becoming hard errors in Rust 2021, but these lints "
"will remain warnings in older editions."
msgstr ""

#: src/rust-2021/warnings-promoted-to-error.md:11
msgid "`bare_trait_objects`:"
msgstr ""

#: src/rust-2021/warnings-promoted-to-error.md:13
msgid ""
"The use of the `dyn` keyword to identify [trait objects](https://doc.rust-"
"lang.org/book/ch17-02-trait-objects.html) will be mandatory in Rust 2021."
msgstr ""

#: src/rust-2021/warnings-promoted-to-error.md:16
msgid ""
"For example, the following code which does not include the `dyn` keyword in "
"`&MyTrait` will produce an error instead of just a lint in Rust 2021:"
msgstr ""

#: src/rust-2021/warnings-promoted-to-error.md:22
msgid "// should be `&dyn MyTrait`\n"
msgstr ""

#: src/rust-2021/warnings-promoted-to-error.md:27
msgid "`ellipsis_inclusive_range_patterns`:"
msgstr ""

#: src/rust-2021/warnings-promoted-to-error.md:29
msgid ""
"The [deprecated `...` syntax](https://doc.rust-lang.org/stable/reference/"
"patterns.html#range-patterns) for inclusive range patterns (i.e., ranges "
"where the end value is _included_ in the range) is no longer accepted in "
"Rust 2021. It has been superseded by `..=`, which is consistent with "
"expressions."
msgstr ""

#: src/rust-2021/warnings-promoted-to-error.md:33
msgid ""
"For example, the following code which uses `...` in a pattern will produce "
"an error instead of just a lint in Rust 2021:"
msgstr ""

#: src/rust-2021/warnings-promoted-to-error.md:38
msgid "// should be `0..=100`\n"
msgstr ""

#: src/rust-2021/warnings-promoted-to-error.md:42
msgid "Migrations"
msgstr ""

#: src/rust-2021/warnings-promoted-to-error.md:44
msgid ""
"If your Rust 2015 or 2018 code does not produce any warnings for "
"`bare_trait_objects` or `ellipsis_inclusive_range_patterns` and you've not "
"allowed these lints through the use of `#![allow()]` or some other "
"mechanism, then there's no need to migrate."
msgstr ""

#: src/rust-2021/warnings-promoted-to-error.md:48
msgid ""
"To automatically migrate any crate that uses `...` in patterns or does not "
"use `dyn` with trait objects, you can run `cargo fix --edition`."
msgstr ""

#: src/rust-2021/or-patterns-macro-rules.md:5
msgid "How patterns work in `macro_rules` macros changes slightly:"
msgstr ""

#: src/rust-2021/or-patterns-macro-rules.md:6
msgid "`$_:pat` in `macro_rules` now matches usage of `|` too: e.g. `A | B`."
msgstr ""

#: src/rust-2021/or-patterns-macro-rules.md:7
msgid ""
"The new `$_:pat_param` behaves like `$_:pat` did before; it does not match "
"(top level) `|`."
msgstr ""

#: src/rust-2021/or-patterns-macro-rules.md:8
msgid "`$_:pat_param` is available in all editions."
msgstr ""

#: src/rust-2021/or-patterns-macro-rules.md:12
msgid ""
"Starting in Rust 1.53.0, [patterns](https://doc.rust-lang.org/stable/"
"reference/patterns.html) are extended to support `|` nested anywhere in the "
"pattern. This enables you to write `Some(1 | 2)` instead of `Some(1) | "
"Some(2)`. Since this was simply not allowed before, this is not a breaking "
"change."
msgstr ""

#: src/rust-2021/or-patterns-macro-rules.md:17
msgid ""
"However, this change also affects [`macro_rules` macros](https://doc.rust-"
"lang.org/stable/reference/macros-by-example.html). Such macros can accept "
"patterns using the `:pat` fragment specifier. Currently, `:pat` does _not_ "
"match top level `|`, since before Rust 1.53, not all patterns (at all nested "
"levels) could contain a `|`. Macros that accept patterns like `A | B`, such "
"as [`matches!()`](https://doc.rust-lang.org/1.51.0/std/macro.matches.html) "
"use something like `$($_:pat)|+`."
msgstr ""

#: src/rust-2021/or-patterns-macro-rules.md:25
msgid ""
"Because this would potentially break existing macros, the meaning of `:pat` "
"did not change in Rust 1.53.0 to include `|`. Instead, that change happens "
"in Rust 2021. In the new edition, the `:pat` fragment specifier _will_ match "
"`A | B`."
msgstr ""

#: src/rust-2021/or-patterns-macro-rules.md:29
msgid ""
"`$_:pat` fragments in Rust 2021 cannot be followed by an explicit `|`. Since "
"there are times that one still wishes to match pattern fragments followed by "
"a `|`, the fragment specified `:pat_param` has been added to retain the "
"older behavior."
msgstr ""

#: src/rust-2021/or-patterns-macro-rules.md:33
msgid ""
"It's important to remember that editions are _per crate_, so the only "
"relevant edition is the edition of the crate where the macro is defined. The "
"edition of the crate where the macro is used does not change how the macro "
"works."
msgstr ""

#: src/rust-2021/or-patterns-macro-rules.md:39
msgid ""
"A lint, `rust_2021_incompatible_or_patterns`, gets triggered whenever there "
"is a use `$_:pat` which will change meaning in Rust 2021."
msgstr ""

#: src/rust-2021/or-patterns-macro-rules.md:49
msgid ""
"If you have a macro which relies on `$_:pat` not matching the top level use "
"of `|` in patterns, you'll need to change each occurrence of `$_:pat` to "
"`$_:pat_param`."
msgstr ""

#: src/rust-2021/or-patterns-macro-rules.md:57
msgid "// TODO: implementation\n"
msgstr ""

#: src/rust-2021/or-patterns-macro-rules.md:60
msgid ""
"// This macro works in Rust 2018 since `$x:pat` does not match against `|`:\n"
msgstr ""

#: src/rust-2021/or-patterns-macro-rules.md:63
msgid ""
"// In Rust 2021 however, the `$_:pat` fragment matches `|` and is not "
"allowed\n"
"// to be followed by a `|`. To make sure this macro still works in Rust "
"2021\n"
"// change the macro to the following:\n"
msgstr ""

#: src/rust-2021/or-patterns-macro-rules.md:68
msgid ""
"// <- this line is different\n"
"\t\t// TODO: implementation\n"
msgstr ""

#: src/rust-2021/c-string-literals.md:5
msgid ""
"Literals of the form `c\"foo\"` or `cr\"foo\"` represent a string of type "
"[`&core::ffi::CStr`](../../core/ffi/struct.CStr.html)."
msgstr ""

#: src/rust-2021/c-string-literals.md:11
msgid ""
"Starting with Rust 1.77, C-strings can be written using C-string literal "
"syntax with the `c` or `cr` prefix."
msgstr ""

#: src/rust-2021/c-string-literals.md:13
msgid ""
"Previously, it was challenging to properly produce a valid string literal "
"that could interoperate with C APIs which terminate with a NUL byte. The "
"[`cstr`](https://crates.io/crates/cstr) crate was a popular solution, but "
"that required compiling a proc-macro which was quite expensive. Now, C-"
"strings can be written directly using literal syntax notation, which will "
"generate a value of type [`&core::ffi::CStr`](../../core/ffi/"
"struct.CStr.html) which is automatically terminated with a NUL byte."
msgstr ""

#: src/rust-2021/c-string-literals.md:20
msgid "\"hello\""
msgstr ""

#: src/rust-2021/c-string-literals.md:20
msgid "b\"hello\\0\""
msgstr ""

#: src/rust-2021/c-string-literals.md:22
msgid "\"byte escapes \\xff work\""
msgstr ""

#: src/rust-2021/c-string-literals.md:23
msgid "b\"byte escapes \\xff work\\0\""
msgstr ""

#: src/rust-2021/c-string-literals.md:26
msgid "\"unicode escapes \\u{00E6} work\""
msgstr ""

#: src/rust-2021/c-string-literals.md:27
msgid "b\"unicode escapes \\xc3\\xa6 work\\0\""
msgstr ""

#: src/rust-2021/c-string-literals.md:30
msgid "\"unicode characters αβγ encoded as UTF-8\""
msgstr ""

#: src/rust-2021/c-string-literals.md:32
msgid ""
"b\"unicode characters \\xce\\xb1\\xce\\xb2\\xce\\xb3 encoded as UTF-8\\0\""
msgstr ""

#: src/rust-2021/c-string-literals.md:37
msgid ""
"\"strings can continue \\\n"
"        on multiple lines\""
msgstr ""

#: src/rust-2021/c-string-literals.md:39
msgid "b\"strings can continue on multiple lines\\0\""
msgstr ""

#: src/rust-2021/c-string-literals.md:43
msgid ""
"C-strings do not allow interior NUL bytes (such as with a `\\0` escape)."
msgstr ""

#: src/rust-2021/c-string-literals.md:45
msgid ""
"Similar to regular strings, C-strings also support \"raw\" syntax with the "
"`cr` prefix. These raw C-strings do not process backslash escapes which can "
"make it easier to write strings that contain backslashes. Double-quotes can "
"be included by surrounding the quotes with the `#` character. Multiple `#` "
"characters can be used to avoid ambiguity with internal `\"#` sequences."
msgstr ""

#: src/rust-2021/c-string-literals.md:51
msgid "r\"foo\""
msgstr ""

#: src/rust-2021/c-string-literals.md:51 src/rust-2024/reserved-syntax.md:25
#: src/rust-2024/reserved-syntax.md:27
msgid "\"foo\""
msgstr ""

#: src/rust-2021/c-string-literals.md:51
msgid "// Number signs can be used to embed interior double quotes.\n"
msgstr ""

#: src/rust-2021/c-string-literals.md:53
msgid "r#\"\"foo\"\"#"
msgstr ""

#: src/rust-2021/c-string-literals.md:53
msgid "\"\\\"foo\\\"\""
msgstr ""

#: src/rust-2021/c-string-literals.md:53
msgid "// This requires two #.\n"
msgstr ""

#: src/rust-2021/c-string-literals.md:55
msgid "r##\"\"foo\"#\"##"
msgstr ""

#: src/rust-2021/c-string-literals.md:55
msgid "\"\\\"foo\\\"#\""
msgstr ""

#: src/rust-2021/c-string-literals.md:55
msgid "// Escapes are not processed.\n"
msgstr ""

#: src/rust-2021/c-string-literals.md:57
msgid "r\"C:\\foo\""
msgstr ""

#: src/rust-2021/c-string-literals.md:57
msgid "\"C:\\\\foo\""
msgstr ""

#: src/rust-2021/c-string-literals.md:60
msgid ""
"See [The Reference](../../reference/tokens.html#c-string-and-raw-c-string-"
"literals) for more details."
msgstr ""

#: src/rust-2021/c-string-literals.md:67
msgid ""
"Migration is only necessary for macros which may have been assuming a "
"sequence of tokens that looks similar to `c\"…\"` or `cr\"…\"`, which "
"previous to the 2021 edition would tokenize as two separate tokens, but in "
"2021 appears as a single token."
msgstr ""

#: src/rust-2021/c-string-literals.md:69
msgid ""
"As part of the [syntax reservation](reserved-syntax.md) for the 2021 "
"edition, any macro input which may run into this issue should issue a "
"warning from the `rust_2021_prefixes_incompatible_syntax` migration lint. "
"See that chapter for more detail."
msgstr ""

#: src/rust-2024/index.md:5
msgid "[\\#3501](https://rust-lang.github.io/rfcs/3501-edition-2024.html)"
msgstr ""

#: src/rust-2024/index.md:6
msgid "1.85.0"
msgstr ""

#: src/rust-2024/language.md:3
msgid ""
"The following chapters detail changes to the language in the 2024 Edition."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:3
msgid ""
"This chapter describes changes related to the **Lifetime Capture Rules "
"2024** introduced in [RFC 3498](https://github.com/rust-lang/rfcs/pull/"
"3498), including how to use opaque type _precise capturing_ (introduced in "
"[RFC 3617](https://github.com/rust-lang/rfcs/pull/3617)) to migrate your "
"code."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:10
msgid ""
"In Rust 2024, _all_ in-scope generic parameters, including lifetime "
"parameters, are implicitly captured when the `use<..>` bound is not present."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:11
msgid ""
"Uses of the `Captures` trick (`Captures<..>` bounds) and of the outlives "
"trick (e.g. `'_` bounds) can be replaced by `use<..>` bounds (in all "
"editions) or removed entirely (in Rust 2024)."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:15
msgid "Capturing"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:17
msgid ""
"_Capturing_ a generic parameter in an RPIT (return-position impl Trait) "
"opaque type allows for that parameter to be used in the corresponding hidden "
"type.  In Rust 1.82, we added `use<..>` bounds that allow specifying "
"explicitly which generic parameters to capture.  Those will be helpful for "
"migrating your code to Rust 2024, and will be helpful in this chapter for "
"explaining how the edition-specific implicit capturing rules work.  These "
"`use<..>` bounds look like this:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:21
msgid ""
"//                                ~~~~~~~~~~~~~~~~~~~~~~~\n"
"    //                             This is the RPIT opaque type.\n"
"    //\n"
"    //                                It captures `'a` and `T`.\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:26
msgid ""
"//~~~~~~\n"
"  // The hidden type is: `(&'a (), T)`.\n"
"  //\n"
"  // This type can use `'a` and `T` because they were captured.\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:33
msgid ""
"The generic parameters that are captured affect how the opaque type can be "
"used.  E.g., this is an error because the lifetime is captured despite the "
"fact that the hidden type does not use the lifetime:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:40
msgid "//~^ ERROR lifetime may not live long enough\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:44
msgid "Conversely, this is OK:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:50
msgid "//~ OK\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:54
msgid "Edition-specific rules when no `use<..>` bound is present"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:56
msgid ""
"If the `use<..>` bound is not present, then the compiler uses edition-"
"specific rules to decide which in-scope generic parameters to capture "
"implicitly."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:58
msgid ""
"In all editions, all in-scope type and const generic parameters are captured "
"implicitly when the `use<..>` bound is not present.  E.g.:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:61
msgid ""
"//                                    ~~~~~~~~~~\n"
"//                         No `use<..>` bound is present here.\n"
"//\n"
"// In all editions, the above is equivalent to:\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:69
msgid ""
"In Rust 2021 and earlier editions, when the `use<..>` bound is not present, "
"generic lifetime parameters are only captured when they appear syntactically "
"within a bound in RPIT opaque types in the signature of bare functions and "
"associated functions and methods within inherent impls.  However, starting "
"in Rust 2024, these in-scope generic lifetime parameters are unconditionally "
"captured.  E.g.:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:72
#: src/rust-2024/rpit-lifetime-capture.md:110
msgid "// In Rust 2021 and earlier, the above is equivalent to:\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:74
msgid "// In Rust 2024 and later, it's equivalent to:\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:79
msgid ""
"This makes the behavior consistent with RPIT opaque types in the signature "
"of associated functions and methods within trait impls, uses of RPIT within "
"trait definitions (RPITIT), and opaque `Future` types created by `async fn`, "
"all of which implicitly capture all in-scope generic lifetime parameters in "
"all editions when the `use<..>` bound is not present."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:81
msgid "Outer generic parameters"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:83
msgid ""
"Generic parameters from an outer impl are considered to be in scope when "
"deciding what is implicitly captured.  E.g.:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:87
msgid ""
"//   ~~~~~~~~~~~~~~~~~\n"
"// These generic parameters are in scope.\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:91
msgid ""
"//            ~       ~~~~~~~~~~\n"
"    //            ^ This generic is in scope too.\n"
"    //                    ^\n"
"    //                    |\n"
"    //     No `use<..>` bound is present here.\n"
"    //\n"
"    // In all editions, it's equivalent to:\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:102
msgid "Lifetimes from higher-ranked binders"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:104
msgid ""
"Similarly, generic lifetime parameters introduced into scope by a higher-"
"ranked `for<..>` binder are considered to be in scope.  E.g.:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:112
msgid ""
"// In Rust 2024 and later, it's equivalent to:\n"
"//fn f_2024() -> impl for<'a> Tr<'a, Ty = impl Copy + use<'a>> {}\n"
"//                                        ~~~~~~~~~~~~~~~~~~~~\n"
"// However, note that the capturing of higher-ranked lifetimes in\n"
"// nested opaque types is not yet supported.\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:120
msgid "Argument position impl Trait (APIT)"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:122
msgid ""
"Anonymous (i.e. unnamed) generic parameters created by the use of APIT "
"(argument position impl Trait) are considered to be in scope.  E.g.:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:125
msgid ""
"//               ~~~~~~~~~~\n"
"//           This is called APIT.\n"
"//\n"
"// The above is *roughly* equivalent to:\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:133
msgid ""
"Note that the former is not _exactly_ equivalent to the latter because, by "
"naming the generic parameter, turbofish syntax can now be used to provide an "
"argument for it.  There is no way to explicitly include an anonymous generic "
"parameter in a `use<..>` bound other than by converting it to a named "
"generic parameter."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:137
msgid "Migrating while avoiding overcapturing"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:139
msgid ""
"The `impl_trait_overcaptures` lint flags RPIT opaque types that will capture "
"additional lifetimes in Rust 2024.  This lint is part of the `rust-2024-"
"compatibility` lint group which is automatically applied when running `cargo "
"fix --edition`.  In most cases, the lint can automatically insert `use<..>` "
"bounds where needed such that no additional lifetimes are captured in Rust "
"2024."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:141
#: src/rust-2024/match-ergonomics.md:106
msgid "To migrate your code to be compatible with Rust 2024, run:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:147 src/rust-2024/gen-keyword.md:25
#: src/rust-2024/intoiterator-box-slice.md:56
#: src/rust-2024/newly-unsafe-functions.md:50
msgid "For example, this will change:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:153
msgid "...into:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:159
msgid ""
"Without this `use<>` bound, in Rust 2024, the opaque type would capture the "
"`'a` lifetime parameter.  By adding this bound, the migration lint preserves "
"the existing semantics."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:161
msgid "Migrating cases involving APIT"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:163
msgid ""
"In some cases, the lint cannot make the change automatically because a "
"generic parameter needs to be given a name so that it can appear within a "
"`use<..>` bound.  In these cases, the lint will alert you that a change may "
"need to be made manually.  E.g., given:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:166
msgid ""
"//   ^^                ~~~~~~~~~~\n"
"//               This is a use of APIT.\n"
"//\n"
"//~^ WARN `impl Sized` will capture more lifetimes than possibly intended in "
"edition 2024\n"
"//~| NOTE specifically, this lifetime is in scope but not mentioned in the "
"type's bounds\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:178
msgid ""
"The code cannot be converted automatically because of the use of APIT and "
"the fact that the generic type parameter must be named in the `use<..>` "
"bound.  To convert this code to Rust 2024 without capturing the lifetime, "
"you must name that type parameter.  E.g.:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:182
msgid ""
"//       ~~~~~~~~\n"
"// The type parameter has been named here.\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:191
msgid ""
"Note that this changes the API of the function slightly as a type argument "
"can now be explicitly provided for this parameter using turbofish syntax.  "
"If this is undesired, you might consider instead whether you can simply "
"continue to omit the `use<..>` bound and allow the lifetime to be captured.  "
"This might be particularly desirable if you might in the future want to use "
"that lifetime in the hidden type and would like to save space for that."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:193
msgid "Migrating away from the `Captures` trick"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:195
msgid ""
"Prior to the introduction of precise capturing `use<..>` bounds in Rust "
"1.82, correctly capturing a lifetime in an RPIT opaque type often required "
"using the `Captures` trick.  E.g.:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:202
msgid ""
"//                                           ~~~~~~~~~~~~~~~~~~~~~\n"
"//                            This is called the `Captures` trick.\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:213
msgid ""
"With the `use<..>` bound syntax, the `Captures` trick is no longer needed "
"and can be replaced with the following in all editions:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:225
#: src/rust-2024/rpit-lifetime-capture.md:269
msgid ""
"In Rust 2024, the `use<..>` bound can often be omitted entirely, and the "
"above can be written simply as:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:237
msgid ""
"There is no automatic migration for this, and the `Captures` trick still "
"works in Rust 2024, but you might want to consider migrating code manually "
"away from using this old trick."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:239
msgid "Migrating away from the outlives trick"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:241
msgid ""
"Prior to the introduction of precise capturing `use<..>` bounds in Rust "
"1.82, it was common to use the \"outlives trick\" when a lifetime needed to "
"be used in the hidden type of some opaque.  E.g.:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:245
msgid ""
"//    ~~~~                                 ~~~~\n"
"    //    ^                     This is the outlives trick.\n"
"    //    |\n"
"    // This bound is needed only for the trick.\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:249
msgid ""
"//  ~~~~~~\n"
"// The hidden type is `(&'a (), T)`.\n"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:255
msgid ""
"This trick was less baroque than the `Captures` trick, but also less "
"correct.  As we can see in the example above, even though any lifetime "
"components within `T` are independent from the lifetime `'a`, we're required "
"to add a `T: 'a` bound in order to make the trick work.  This created undue "
"and surprising restrictions on callers."
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:257
msgid ""
"Using precise capturing, you can write the above instead, in all editions, "
"as:"
msgstr ""

#: src/rust-2024/rpit-lifetime-capture.md:281
msgid ""
"There is no automatic migration for this, and the outlives trick still works "
"in Rust 2024, but you might want to consider migrating code manually away "
"from using this old trick."
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:5
msgid ""
"In an `if let $pat = $expr { .. } else { .. }` expression, the temporary "
"values generated from evaluating `$expr` will be dropped before the program "
"enters the `else` branch instead of after."
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:9
msgid ""
"The 2024 Edition changes the drop scope of [temporary values](../../"
"reference/expressions.html#temporaries) in the scrutinee[^scrutinee] of an "
"`if let` expression. This is intended to help reduce the potentially "
"unexpected behavior involved with the temporary living for too long."
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:11
msgid ""
"Before 2024, the temporaries could be extended beyond the `if let` "
"expression itself. For example:"
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:14
#: src/rust-2024/temporary-tail-expr-scope.md:17
msgid "// Before 2024\n"
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:19
#: src/rust-2024/temporary-if-let-scope.md:40
#: src/rust-2024/temporary-if-let-scope.md:72
msgid "\"value is {x}\""
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:26
msgid "// <--- Read lock is dropped here in 2021\n"
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:30
msgid ""
"In this example, the temporary read lock generated by the call to "
"`value.read()` will not be dropped until after the `if let` expression (that "
"is, after the `else` block). In the case where the `else` block is executed, "
"this causes a deadlock when it attempts to acquire a write lock."
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:32
msgid ""
"The 2024 Edition shortens the lifetime of the temporaries to the point where "
"the then-block is completely evaluated or the program control enters the "
"`else` block."
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:35
msgid "// Starting with 2024\n"
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:42
msgid "// <--- Read lock is dropped here in 2024\n"
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:52
msgid ""
"See the [temporary scope rules](../../reference/destructors.html#temporary-"
"scopes) for more information about how temporary scopes are extended. See "
"the [tail expression temporary scope](temporary-tail-expr-scope.md) chapter "
"for a similar change made to tail expressions."
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:54
msgid ""
"The [scrutinee](../../reference/glossary.html#scrutinee) is the expression "
"being matched on in the `if let` expression."
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:63
msgid ""
"It is always safe to rewrite `if let` with a `match`. The temporaries of the "
"`match` scrutinee are extended past the end of the `match` expression "
"(typically to the end of the statement), which is the same as the 2021 "
"behavior of `if let`."
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:65
msgid ""
"The [`if_let_rescope`](../../rustc/lints/listing/allowed-by-default.html#if-"
"let-rescope) lint suggests a fix when a lifetime issue arises due to this "
"change or the lint detects that a temporary value with a custom, non-trivial "
"`Drop` destructor is generated from the scrutinee of the `if let`. For "
"instance, the earlier example may be rewritten into the following when the "
"suggestion from `cargo fix` is accepted:"
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:81
msgid "// <--- Read lock is dropped here in both 2021 and 2024\n"
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:85
msgid ""
"In this particular example, that's probably not what you want due to the "
"aforementioned deadlock! However, some scenarios may be assuming that the "
"temporaries are held past the `else` clause, in which case you may want to "
"retain the old behavior."
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:87
msgid ""
"The [`if_let_rescope`](../../rustc/lints/listing/allowed-by-default.html#if-"
"let-rescope) lint is part of the `rust-2024-compatibility` lint group which "
"is included in the automatic edition migration. In order to migrate your "
"code to be Rust 2024 Edition compatible, run:"
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:93
msgid ""
"After the migration, it is recommended that you review all of the changes of "
"`if let` to `match` and decide what is the behavior that you need with "
"respect to when temporaries are dropped. If you determine that the change is "
"unnecessary, then you can revert the change back to `if let`."
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:95
#: src/rust-2024/temporary-tail-expr-scope.md:92
msgid ""
"If you want to manually inspect these warnings without performing the "
"edition migration, you can enable the lint with:"
msgstr ""

#: src/rust-2024/temporary-if-let-scope.md:98
#: src/rust-2024/temporary-tail-expr-scope.md:95
#: src/rust-2024/match-ergonomics.md:131 src/rust-2024/unsafe-extern.md:50
#: src/rust-2024/unsafe-attributes.md:73
#: src/rust-2024/unsafe-op-in-unsafe-fn.md:54
#: src/rust-2024/macro-fragment-specifiers.md:47
#: src/rust-2024/gen-keyword.md:52 src/rust-2024/reserved-syntax.md:59
#: src/rust-2024/prelude.md:74 src/rust-2024/newly-unsafe-functions.md:72
msgid "// Add this to the root of your crate to do a manual migration.\n"
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:5
msgid ""
"Temporary values generated in evaluation of the tail expression of a "
"[function](../../reference/items/functions.html) or closure body, or a "
"[block](../../reference/expressions/block-expr.html) may now be dropped "
"before local variables, and are sometimes not extended to the next larger "
"temporary scope."
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:12
msgid ""
"The 2024 Edition changes the drop order of [temporary values](../../"
"reference/expressions.html#temporaries) in tail expressions. It often comes "
"as a surprise that, before the 2024 Edition, temporary values in tail "
"expressions can live longer than the block itself, and are dropped later "
"than the local variable bindings, as in the following example:"
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:20
msgid "\"..\""
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:21
msgid "// error[E0597]: `c` does not live long enough\n"
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:25
msgid "This yields the following error with the 2021 Edition:"
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:27
msgid ""
"```text\n"
"error[E0597]: `c` does not live long enough\n"
" --> src/lib.rs:4:5\n"
"  |\n"
"3 |     let c = RefCell::new(\"..\");\n"
"  |         - binding `c` declared here\n"
"4 |     c.borrow().len() // error[E0597]: `c` does not live long enough\n"
"  |     ^---------\n"
"  |     |\n"
"  |     borrowed value does not live long enough\n"
"  |     a temporary with access to the borrow is created here ...\n"
"5 | }\n"
"  | -\n"
"  | |\n"
"  | `c` dropped here while still borrowed\n"
"  | ... and the borrow might be used here, when that temporary is dropped "
"and runs the destructor for type `Ref<'_, &str>`\n"
"  |\n"
"  = note: the temporary is part of an expression at the end of a block;\n"
"          consider forcing this temporary to be dropped sooner, before the "
"block's local variables are dropped\n"
"help: for example, you could save the expression's value in a new local "
"variable `x` and then make `x` be the expression at the end of the block\n"
"  |\n"
"4 |     let x = c.borrow().len(); x // error[E0597]: `c` does not live long "
"enough\n"
"  |     +++++++                 +++\n"
"\n"
"For more information about this error, try `rustc --explain E0597`.\n"
"```"
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:54
msgid ""
"In 2021 the local variable `c` is dropped before the temporary created by "
"`c.borrow()`. The 2024 Edition changes this so that the temporary value "
"`c.borrow()` is dropped first, followed by dropping the local variable `c`, "
"allowing the code to compile as expected."
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:56
msgid "Temporary scope may be narrowed"
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:58
msgid ""
"When a temporary is created in order to evaluate an expression, the "
"temporary is dropped based on the [temporary scope rules](../../reference/"
"destructors.html#temporary-scopes). Those rules define how long the "
"temporary will be kept alive. Before 2024, temporaries from tail expressions "
"of a block would be extended outside of the block to the next temporary "
"scope boundary. In many cases this would be the end of a statement or "
"function body. In 2024, the temporaries of the tail expression may now be "
"dropped immediately at the end of the block (before any local variables in "
"the block)."
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:60
msgid ""
"This narrowing of the temporary scope may cause programs to fail to compile "
"in 2024. For example:"
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:63
msgid "// This example works in 2021, but fails to compile in 2024.\n"
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:65
#: src/rust-2024/temporary-tail-expr-scope.md:75
msgid "\"1234\""
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:69
msgid ""
"In this example, in 2021, the temporary `String` is extended outside of the "
"block, past the call to `len()`, and is dropped at the end of the statement. "
"In 2024, it is dropped immediately at the end of the block, causing a "
"compile error about the temporary being dropped while borrowed."
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:71
msgid ""
"The solution for these kinds of situations is to lift the block expression "
"out to a local variable so that the temporary lives long enough:"
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:80
msgid ""
"This particular example takes advantage of [temporary lifetime extension]"
"(../../reference/destructors.html#temporary-lifetime-extension). Temporary "
"lifetime extension is a set of specific rules which allow temporaries to "
"live longer than they normally would. Because the `String` temporary is "
"behind a reference, the `String` temporary is extended long enough for the "
"next statement to call `len()` on it."
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:82
msgid ""
"See the [`if let` temporary scope](temporary-if-let-scope.md) chapter for a "
"similar change made to temporary scopes of `if let` expressions."
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:90
msgid ""
"Unfortunately, there are no semantics-preserving rewrites to shorten the "
"lifetime for temporary values in tail expressions[^RFC3606]. The "
"[`tail_expr_drop_order`](../../rustc/lints/listing/allowed-by-"
"default.html#tail-expr-drop-order) lint detects if a temporary value with a "
"custom, non-trivial `Drop` destructor is generated in a tail expression. "
"Warnings from this lint will appear when running `cargo fix --edition`, but "
"will otherwise not automatically make any changes. It is recommended to "
"manually inspect the warnings and determine whether or not you need to make "
"any adjustments."
msgstr ""

#: src/rust-2024/temporary-tail-expr-scope.md:99
msgid ""
"Details are documented at [RFC 3606](https://github.com/rust-lang/rfcs/pull/"
"3606)"
msgstr ""

#: src/rust-2024/match-ergonomics.md:5
msgid ""
"Writing `mut`, `ref`, or `ref mut` on a binding is only allowed within a "
"pattern when the pattern leading up to that binding is fully explicit (i.e. "
"when it does not use match ergonomics)."
msgstr ""

#: src/rust-2024/match-ergonomics.md:6
msgid ""
"Put differently, when the default binding mode is not `move`, writing `mut`, "
"`ref`, or `ref mut` on a binding is an error."
msgstr ""

#: src/rust-2024/match-ergonomics.md:7
msgid ""
"Reference patterns (`&` or `&mut`) are only allowed within the fully-"
"explicit prefix of a pattern."
msgstr ""

#: src/rust-2024/match-ergonomics.md:8
msgid ""
"Put differently, reference patterns can only match against references in the "
"scrutinee when the default binding mode is `move`."
msgstr ""

#: src/rust-2024/match-ergonomics.md:12
msgid "Background"
msgstr ""

#: src/rust-2024/match-ergonomics.md:14
msgid ""
"Within `match`, `let`, and other constructs, we match a _pattern_ against a "
"_scrutinee_.  E.g.:"
msgstr ""

#: src/rust-2024/match-ergonomics.md:17
msgid ""
"// x: &()\n"
"//  ~~~~~~~~~~~~~~~   ~~~~~~~~~~~~\n"
"//      Pattern        Scrutinee\n"
msgstr ""

#: src/rust-2024/match-ergonomics.md:22
msgid ""
"Such a pattern is called fully explicit because it does not elide (i.e. "
"\"skip\" or \"pass\") any references within the scrutinee.  By contrast, "
"this otherwise-equivalent pattern is not fully explicit:"
msgstr ""

#: src/rust-2024/match-ergonomics.md:25 src/rust-2024/match-ergonomics.md:73
#: src/rust-2024/match-ergonomics.md:81
msgid "// x: &()\n"
msgstr ""

#: src/rust-2024/match-ergonomics.md:28
msgid ""
"Patterns such as this are said to be using match ergonomics, originally "
"introduced in [RFC 2005](https://github.com/rust-lang/rfcs/pull/2005)."
msgstr ""

#: src/rust-2024/match-ergonomics.md:30
msgid ""
"Under match ergonomics, as we incrementally match a pattern against a "
"scrutinee, we keep track of the default binding mode.  This mode can be one "
"of `move`, `ref mut`, or `ref`, and it starts as `move`.  When we reach a "
"binding, unless an explicit binding mode is provided, the default binding "
"mode is used to decide the binding's type."
msgstr ""

#: src/rust-2024/match-ergonomics.md:32
msgid ""
"For example, here we provide an explicit binding mode, causing `x` to be "
"bound by reference:"
msgstr ""

#: src/rust-2024/match-ergonomics.md:35 src/rust-2024/match-ergonomics.md:41
msgid "// &()\n"
msgstr ""

#: src/rust-2024/match-ergonomics.md:38
msgid "By contrast:"
msgstr ""

#: src/rust-2024/match-ergonomics.md:44
msgid ""
"Here, in the pattern, we pass the outer shared reference in the scrutinee.  "
"This causes the default binding mode to switch from `move` to `ref`.  Since "
"there is no explicit binding mode specified, the `ref` binding mode is used "
"when binding `x`."
msgstr ""

#: src/rust-2024/match-ergonomics.md:48
msgid "`mut` restriction"
msgstr ""

#: src/rust-2024/match-ergonomics.md:50 src/rust-2024/match-ergonomics.md:86
msgid "In Rust 2021 and earlier editions, we allow this oddity:"
msgstr ""

#: src/rust-2024/match-ergonomics.md:53 src/rust-2024/match-ergonomics.md:65
msgid "// x: &(), mut y: ()\n"
msgstr ""

#: src/rust-2024/match-ergonomics.md:56
msgid ""
"Here, because we pass the shared reference in the pattern, the default "
"binding mode switches to `ref`.  But then, in these editions, writing `mut` "
"on the binding resets the default binding mode to `move`."
msgstr ""

#: src/rust-2024/match-ergonomics.md:58
msgid ""
"This can be surprising as it's not intuitive that mutability should affect "
"the type."
msgstr ""

#: src/rust-2024/match-ergonomics.md:60
msgid ""
"To leave space to fix this, in Rust 2024 it's an error to write `mut` on a "
"binding when the default binding mode is not `move`.  That is, `mut` can "
"only be written on a binding when the pattern (leading up to that binding) "
"is fully explicit."
msgstr ""

#: src/rust-2024/match-ergonomics.md:62 src/rust-2024/match-ergonomics.md:96
msgid "In Rust 2024, we can write the above example as:"
msgstr ""

#: src/rust-2024/match-ergonomics.md:68
msgid "`ref` / `ref mut` restriction"
msgstr ""

#: src/rust-2024/match-ergonomics.md:70
msgid "In Rust 2021 and earlier editions, we allow:"
msgstr ""

#: src/rust-2024/match-ergonomics.md:76
msgid ""
"Here, the `ref` explicit binding mode is redundant, as by passing the shared "
"reference (i.e. not mentioning it in the pattern), the binding mode switches "
"to `ref`."
msgstr ""

#: src/rust-2024/match-ergonomics.md:78
msgid ""
"To leave space for other language possibilities, we are disallowing explicit "
"binding modes where they are redundant in Rust 2024.  We can rewrite the "
"above example as simply:"
msgstr ""

#: src/rust-2024/match-ergonomics.md:84
msgid "Reference patterns restriction"
msgstr ""

#: src/rust-2024/match-ergonomics.md:89
msgid "// x: (), y: &&()\n"
msgstr ""

#: src/rust-2024/match-ergonomics.md:92
msgid ""
"Here, the `&` in the pattern both matches against the reference on `&()` and "
"resets the default binding mode to `move`.  This can be surprising because "
"the single `&` in the pattern causes a larger than expected change in the "
"type by removing both layers of references."
msgstr ""

#: src/rust-2024/match-ergonomics.md:94
msgid ""
"To leave space to fix this, in Rust 2024 it's an error to write `&` or "
"`&mut` in the pattern when the default binding mode is not `move`.  That is, "
"`&` or `&mut` can only be written when the pattern (leading up to that "
"point) is fully explicit."
msgstr ""

#: src/rust-2024/match-ergonomics.md:104
msgid ""
"The [`rust_2024_incompatible_pat`](../../rustc/lints/listing/allowed-by-"
"default.html#rust-2024-incompatible-pat) lint flags patterns that are not "
"allowed in Rust 2024.  This lint is part of the `rust-2024-compatibility` "
"lint group which is automatically applied when running `cargo fix --"
"edition`.  This lint will automatically convert affected patterns to fully "
"explicit patterns that work correctly in Rust 2024 and in all prior editions."
msgstr ""

#: src/rust-2024/match-ergonomics.md:112
msgid "For example, this will convert this..."
msgstr ""

#: src/rust-2024/match-ergonomics.md:120
msgid "...into this:"
msgstr ""

#: src/rust-2024/match-ergonomics.md:128
msgid ""
"Alternatively, you can manually enable the lint to find patterns that will "
"need to be migrated:"
msgstr ""

#: src/rust-2024/unsafe-extern.md:5
msgid ""
"[`extern` blocks](../../reference/items/external-blocks.html) must now be "
"marked with the `unsafe` keyword."
msgstr ""

#: src/rust-2024/unsafe-extern.md:11
msgid ""
"Rust 1.82 added the ability in all editions to mark [`extern` blocks](../../"
"reference/items/external-blocks.html) with the `unsafe` keyword.[^RFC3484] "
"Adding the `unsafe` keyword helps to emphasize that it is the responsibility "
"of the author of the `extern` block to ensure that the signatures are "
"correct. If the signatures are not correct, then it may result in undefined "
"behavior."
msgstr ""

#: src/rust-2024/unsafe-extern.md:13
msgid "The syntax for an unsafe `extern` block looks like this:"
msgstr ""

#: src/rust-2024/unsafe-extern.md:16 src/rust-2024/static-mut-references.md:270
msgid "\"C\""
msgstr ""

#: src/rust-2024/unsafe-extern.md:17
msgid "// sqrt (from libm) may be called with any `f64`\n"
msgstr ""

#: src/rust-2024/unsafe-extern.md:20
msgid ""
"// strlen (from libc) requires a valid pointer,\n"
"    // so we mark it as being an unsafe fn\n"
msgstr ""

#: src/rust-2024/unsafe-extern.md:24
msgid "// this function doesn't say safe or unsafe, so it defaults to unsafe\n"
msgstr ""

#: src/rust-2024/unsafe-extern.md:31
msgid ""
"In addition to being able to mark an `extern` block as `unsafe`, you can "
"also specify if individual items in the `extern` block are `safe` or "
"`unsafe`. Items marked as `safe` can be used without an `unsafe` block."
msgstr ""

#: src/rust-2024/unsafe-extern.md:33
msgid ""
"Starting with the 2024 Edition, it is now required to include the `unsafe` "
"keyword on an `extern` block. This is intended to make it very clear that "
"there are safety requirements that must be upheld by the extern definitions."
msgstr ""

#: src/rust-2024/unsafe-extern.md:35
msgid ""
"See [RFC 3484](https://github.com/rust-lang/rfcs/blob/master/text/3484-"
"unsafe-extern-blocks.md) for the original proposal."
msgstr ""

#: src/rust-2024/unsafe-extern.md:39
msgid ""
"The [`missing_unsafe_on_extern`](../../rustc/lints/listing/allowed-by-"
"default.html#missing-unsafe-on-extern) lint can update `extern` blocks to "
"add the `unsafe` keyword. The lint is part of the `rust-2024-compatibility` "
"lint group which is included in the automatic edition migration. In order to "
"migrate your code to be Rust 2024 Edition compatible, run:"
msgstr ""

#: src/rust-2024/unsafe-extern.md:45
msgid ""
"Just beware that this automatic migration will not be able to verify that "
"the signatures in the `extern` block are correct. It is still your "
"responsibility to manually review their definition."
msgstr ""

#: src/rust-2024/unsafe-extern.md:47
msgid ""
"Alternatively, you can manually enable the lint to find places where there "
"are `unsafe` blocks that need to be updated."
msgstr ""

#: src/rust-2024/unsafe-attributes.md:5
msgid "The following attributes must now be marked as `unsafe`:"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:6
msgid "[`export_name`](../../reference/abi.html#the-export_name-attribute)"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:7
msgid "[`link_section`](../../reference/abi.html#the-link_section-attribute)"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:8
msgid "[`no_mangle`](../../reference/abi.html#the-no_mangle-attribute)"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:16
msgid ""
"Rust 1.82 added the ability in all editions to mark certain attributes as "
"`unsafe` to indicate that they have soundness requirements that must be "
"upheld.[^RFC3325] The syntax for an unsafe attribute looks like this:"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:19
msgid "// SAFETY: there is no other global function of this name\n"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:24
msgid ""
"Marking the attribute with `unsafe` highlights that there are safety "
"requirements that must be upheld that the compiler cannot verify on its own."
msgstr ""

#: src/rust-2024/unsafe-attributes.md:26
msgid ""
"Starting with the 2024 Edition, it is now required to mark these attributes "
"as `unsafe`. The following section describes the safety requirements for "
"these attributes."
msgstr ""

#: src/rust-2024/unsafe-attributes.md:28
msgid ""
"See [RFC 3325](https://rust-lang.github.io/rfcs/3325-unsafe-attributes.html) "
"for the original proposal."
msgstr ""

#: src/rust-2024/unsafe-attributes.md:30
msgid "Safety requirements"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:32
msgid ""
"The [`no_mangle`](../../reference/abi.html#the-no_mangle-attribute), "
"[`export_name`](../../reference/abi.html#the-export_name-attribute), and "
"[`link_section`](../../reference/abi.html#the-link_section-attribute) "
"attributes influence the symbol names and linking behavior of items. Care "
"must be taken to ensure that these attributes are used correctly."
msgstr ""

#: src/rust-2024/unsafe-attributes.md:34
msgid ""
"Because the set of symbols across all linked libraries is a global "
"namespace, there can be issues if there is a symbol name collision between "
"libraries. Typically this isn't an issue for normally defined functions "
"because [symbol mangling](../../rustc/symbol-mangling/index.html) helps "
"ensure that the symbol name is unique. However, attributes like "
"`export_name` can upset that assumption of uniqueness."
msgstr ""

#: src/rust-2024/unsafe-attributes.md:36
msgid ""
"For example, in previous editions the following crashes on most Unix-like "
"platforms despite containing only safe code:"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:40
msgid "\"Hello, world!\""
msgstr ""

#: src/rust-2024/unsafe-attributes.md:43
msgid "\"malloc\""
msgstr ""

#: src/rust-2024/unsafe-attributes.md:47
msgid ""
"In the 2024 Edition, it is now required to mark these attributes as unsafe "
"to emphasize that it is required to ensure that the symbol is defined "
"correctly:"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:50
msgid ""
"// SAFETY: There should only be a single definition of the loop symbol.\n"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:51
msgid "\"loop\""
msgstr ""

#: src/rust-2024/unsafe-attributes.md:53
#: src/rust-2024/static-mut-references.md:161
#: src/rust-2024/static-mut-references.md:238
msgid "// ...\n"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:62
msgid ""
"The [`unsafe_attr_outside_unsafe`](../../rustc/lints/listing/allowed-by-"
"default.html#unsafe-attr-outside-unsafe) lint can update these attributes to "
"use the `unsafe(...)` format. The lint is part of the `rust-2024-"
"compatibility` lint group which is included in the automatic edition "
"migration. In order to migrate your code to be Rust 2024 Edition compatible, "
"run:"
msgstr ""

#: src/rust-2024/unsafe-attributes.md:68
msgid ""
"Just beware that this automatic migration will not be able to verify that "
"these attributes are being used correctly. It is still your responsibility "
"to manually review their usage."
msgstr ""

#: src/rust-2024/unsafe-attributes.md:70
msgid ""
"Alternatively, you can manually enable the lint to find places where these "
"attributes need to be updated."
msgstr ""

#: src/rust-2024/unsafe-op-in-unsafe-fn.md:1
msgid "unsafe_op_in_unsafe_fn warning"
msgstr ""

#: src/rust-2024/unsafe-op-in-unsafe-fn.md:5
msgid ""
"The [`unsafe_op_in_unsafe_fn`](../../rustc/lints/listing/allowed-by-"
"default.html#unsafe-op-in-unsafe-fn) lint now warns by default. This warning "
"detects calls to unsafe operations in unsafe functions without an explicit "
"unsafe block."
msgstr ""

#: src/rust-2024/unsafe-op-in-unsafe-fn.md:12
msgid ""
"The [`unsafe_op_in_unsafe_fn`](../../rustc/lints/listing/allowed-by-"
"default.html#unsafe-op-in-unsafe-fn) lint will fire if there are [unsafe "
"operations](../../reference/unsafety.html) in an unsafe function without an "
"explicit [`unsafe {}` block](../../reference/expressions/block-"
"expr.html#unsafe-blocks)."
msgstr ""

#: src/rust-2024/unsafe-op-in-unsafe-fn.md:17
msgid "// WARNING: requires unsafe block\n"
msgstr ""

#: src/rust-2024/unsafe-op-in-unsafe-fn.md:21
msgid "The solution is to wrap any unsafe operations in an `unsafe` block:"
msgstr ""

#: src/rust-2024/unsafe-op-in-unsafe-fn.md:30
msgid ""
"This change is intended to help protect against accidental use of unsafe "
"operations in an unsafe function. The `unsafe` function keyword was "
"performing two roles. One was to declare that _calling_ the function "
"requires unsafe, and that the caller is responsible to uphold additional "
"safety requirements. The other role was to allow the use of unsafe "
"operations inside of the function. This second role was determined to be too "
"risky without explicit `unsafe` blocks."
msgstr ""

#: src/rust-2024/unsafe-op-in-unsafe-fn.md:36
msgid ""
"More information and motivation may be found in [RFC #2585](https://rust-"
"lang.github.io/rfcs/2585-unsafe-block-in-unsafe-fn.html)."
msgstr ""

#: src/rust-2024/unsafe-op-in-unsafe-fn.md:44
msgid ""
"The [`unsafe_op_in_unsafe_fn`](../../rustc/lints/listing/allowed-by-"
"default.html#unsafe-op-in-unsafe-fn) lint is part of the `rust-2024-"
"compatibility` lint group. In order to migrate your code to be Rust 2024 "
"Edition compatible, run:"
msgstr ""

#: src/rust-2024/unsafe-op-in-unsafe-fn.md:51
msgid ""
"Alternatively, you can manually enable the lint to find places where unsafe "
"blocks need to be added, or switch it to `allow` to silence the lint "
"completely."
msgstr ""

#: src/rust-2024/static-mut-references.md:1
msgid "Disallow references to static mut"
msgstr ""

#: src/rust-2024/static-mut-references.md:5
msgid ""
"The [`static_mut_refs`](../../rustc/lints/listing/warn-by-"
"default.html#static-mut-refs) lint level is now `deny` by default. This "
"checks for taking a shared or mutable reference to a `static mut`."
msgstr ""

#: src/rust-2024/static-mut-references.md:12
msgid ""
"The [`static_mut_refs`](../../rustc/lints/listing/warn-by-"
"default.html#static-mut-refs) lint detects taking a reference to a [`static "
"mut`](../../reference/items/static-items.html#mutable-statics). In the 2024 "
"Edition, this lint is now `deny` by default to emphasize that you should "
"avoid making these references."
msgstr ""

#: src/rust-2024/static-mut-references.md:20
#: src/rust-2024/static-mut-references.md:21
#: src/rust-2024/static-mut-references.md:22
#: src/rust-2024/static-mut-references.md:35
#: src/rust-2024/static-mut-references.md:36
msgid "// ERROR: shared reference to mutable static\n"
msgstr ""

#: src/rust-2024/static-mut-references.md:26
msgid ""
"Merely taking such a reference in violation of Rust's mutability XOR "
"aliasing requirement has always been _instantaneous_ [undefined behavior]"
"(../../reference/behavior-considered-undefined.html), **even if the "
"reference is never read from or written to**.  Furthermore, upholding "
"mutability XOR aliasing for a `static mut` requires _reasoning about your "
"code globally_, which can be particularly difficult in the face of "
"reentrancy and/or multithreading."
msgstr ""

#: src/rust-2024/static-mut-references.md:28
msgid ""
"Note that there are some cases where implicit references are automatically "
"created without a visible `&` operator. For example, these situations will "
"also trigger the lint:"
msgstr ""

#: src/rust-2024/static-mut-references.md:35
msgid "\"{NUMS:?}\""
msgstr ""

#: src/rust-2024/static-mut-references.md:40
msgid "Alternatives"
msgstr ""

#: src/rust-2024/static-mut-references.md:42
msgid ""
"Wherever possible, it is **strongly recommended** to use instead an "
"_immutable_ `static` of a type that provides _interior mutability_ behind "
"some _locally-reasoned abstraction_ (which greatly reduces the complexity of "
"ensuring that Rust's mutability XOR aliasing requirement is upheld)."
msgstr ""

#: src/rust-2024/static-mut-references.md:44
msgid ""
"In situations where no locally-reasoned abstraction is possible and you are "
"therefore compelled still to reason globally about accesses to your `static` "
"variable, you must now use raw pointers such as can be obtained via the "
"[`&raw const` or `&raw mut` operators](../../reference/expressions/operator-"
"expr.html#raw-borrow-operators).  By first obtaining a raw pointer rather "
"than directly taking a reference, (the safety requirements of) accesses "
"through that pointer will be more familiar to `unsafe` developers and can be "
"deferred until/limited to smaller regions of code."
msgstr ""

#: src/rust-2024/static-mut-references.md:51
msgid ""
"Note that the following examples are just illustrations and are not intended "
"as full-fledged implementations. Do not copy these as-is. There are details "
"for your specific situation that may require alterations to fit your needs. "
"These are intended to help you see different ways to approach your problem."
msgstr ""

#: src/rust-2024/static-mut-references.md:53
msgid ""
"It is recommended to read the documentation for the specific types in the "
"standard library, the reference on [undefined behavior](../../reference/"
"behavior-considered-undefined.html), the [Rustonomicon](../../nomicon/"
"index.html), and if you are having questions to reach out on one of the Rust "
"forums such as the [Users Forum](https://users.rust-lang.org/)."
msgstr ""

#: src/rust-2024/static-mut-references.md:59
msgid "Don't use globals"
msgstr ""

#: src/rust-2024/static-mut-references.md:61
msgid ""
"This is probably something you already know, but if possible it is best to "
"avoid mutable global state. Of course this can be a little more awkward or "
"difficult at times, particularly if you need to pass a mutable reference "
"around between many functions."
msgstr ""

#: src/rust-2024/static-mut-references.md:63
msgid "Atomics"
msgstr ""

#: src/rust-2024/static-mut-references.md:65
msgid ""
"The [atomic types](../../std/sync/atomic/index.html) provide integers, "
"pointers, and booleans that can be used in a `static` (without `mut`)."
msgstr ""

#: src/rust-2024/static-mut-references.md:70
msgid ""
"// Change from this:\n"
"//   static mut COUNTER: u64 = 0;\n"
"// to this:\n"
msgstr ""

#: src/rust-2024/static-mut-references.md:77
msgid ""
"// Be sure to analyze your use case to determine the correct Ordering to "
"use.\n"
msgstr ""

#: src/rust-2024/static-mut-references.md:84
msgid "Mutex or RwLock"
msgstr ""

#: src/rust-2024/static-mut-references.md:86
msgid ""
"When your type is more complex than an atomic, consider using a [`Mutex`]"
"(../../std/sync/struct.Mutex.html) or [`RwLock`](../../std/sync/"
"struct.RwLock.html) to ensure proper access to the global value."
msgstr ""

#: src/rust-2024/static-mut-references.md:91
msgid ""
"// Change from this:\n"
"//     static mut QUEUE: VecDeque<String> = VecDeque::new();\n"
"// to this:\n"
msgstr ""

#: src/rust-2024/static-mut-references.md:98
msgid "\"abc\""
msgstr ""

#: src/rust-2024/static-mut-references.md:106
msgid "OnceLock or LazyLock"
msgstr ""

#: src/rust-2024/static-mut-references.md:108
msgid ""
"If you are using a `static mut` because you need to do some one-time "
"initialization that can't be `const`, you can instead reach for [`OnceLock`]"
"(../../std/sync/struct.OnceLock.html) or [`LazyLock`](../../std/sync/"
"struct.LazyLock.html) instead."
msgstr ""

#: src/rust-2024/static-mut-references.md:121
msgid ""
"// Instead of some temporary or uninitialized type like:\n"
"//     static mut STATE: Option<GlobalState> = None;\n"
"// use this instead:\n"
msgstr ""

#: src/rust-2024/static-mut-references.md:134
msgid ""
"[`OnceLock`](../../std/sync/struct.OnceLock.html) is similar to [`LazyLock`]"
"(../../std/sync/struct.LazyLock.html), but can be used if you need to pass "
"information into the constructor, which can work well with single "
"initialization points (like `main`), or if the inputs are available wherever "
"you access the global."
msgstr ""

#: src/rust-2024/static-mut-references.md:169
msgid "`no_std` one-time initialization"
msgstr ""

#: src/rust-2024/static-mut-references.md:171
msgid ""
"This example is similar to [`OnceLock`](../../std/sync/struct.OnceLock.html) "
"in that it provides one-time initialization of a global, but it does not "
"require `std` which is useful in a `no_std` context. Assuming your target "
"supports atomics, then you can use an atomic to check for the initialization "
"of the global. The pattern might look something like this:"
msgstr ""

#: src/rust-2024/static-mut-references.md:215
msgid ""
"// SAFETY: The reads and writes to STATE are guarded with the INITIALIZED "
"guard.\n"
msgstr ""

#: src/rust-2024/static-mut-references.md:221
msgid "\"already initialized, or concurrent initialization\""
msgstr ""

#: src/rust-2024/static-mut-references.md:227
msgid "\"not initialized\""
msgstr ""

#: src/rust-2024/static-mut-references.md:229
msgid ""
"// SAFETY: Mutable access is not possible after state has been initialized.\n"
msgstr ""

#: src/rust-2024/static-mut-references.md:244
msgid ""
"This example assumes you can put some default value in the static before it "
"is initialized (the const `default` constructor in this example). If that is "
"not possible, consider using either [`MaybeUninit`](../../core/mem/"
"union.MaybeUninit.html), or dynamic trait dispatch (with a dummy type that "
"implements a trait), or some other approach to have a default placeholder."
msgstr ""

#: src/rust-2024/static-mut-references.md:246
msgid ""
"There are community-provided crates that can provide similar one-time "
"initialization, such as the [`static-cell`](https://crates.io/crates/"
"static_cell) crate (which supports targets that do not have atomics by using "
"[`portable-atomic`](https://crates.io/crates/portable-atomic))."
msgstr ""

#: src/rust-2024/static-mut-references.md:252
msgid "Raw pointers"
msgstr ""

#: src/rust-2024/static-mut-references.md:254
msgid ""
"In some cases you can continue to use `static mut`, but avoid creating "
"references. For example, if you just need to pass [raw pointers](../../"
"reference/types/pointer.html#raw-pointers-const-and-mut) into a C library, "
"don't create an intermediate reference. Instead you can use [raw borrow "
"operators](../../reference/expressions/operator-expr.html#raw-borrow-"
"operators), like in the following example:"
msgstr ""

#: src/rust-2024/static-mut-references.md:276
msgid ""
"// Change from this:\n"
"        //     example_ffi(&mut STATE as *mut GlobalState);\n"
"        // to this:\n"
msgstr ""

#: src/rust-2024/static-mut-references.md:284
msgid ""
"Just beware that you still need to uphold the aliasing constraints around "
"mutable pointers. This may require some internal or external synchronization "
"or proofs about how it is used across threads, interrupt handlers, and "
"reentrancy."
msgstr ""

#: src/rust-2024/static-mut-references.md:289
msgid "`UnsafeCell` with `Sync`"
msgstr ""

#: src/rust-2024/static-mut-references.md:291
msgid ""
"[`UnsafeCell`](../../std/cell/struct.UnsafeCell.html) does not impl `Sync`, "
"so it cannot be used in a `static`. You can create your own wrapper around "
"[`UnsafeCell`](../../std/cell/struct.UnsafeCell.html) to add a `Sync` impl "
"so that it can be used in a `static` to implement interior mutability. This "
"approach can be useful if you have external locks or other guarantees that "
"uphold the safety invariants required for mutable pointers."
msgstr ""

#: src/rust-2024/static-mut-references.md:293
msgid ""
"Note that this is largely the same as the [raw pointers](#raw-pointers) "
"example. The wrapper helps to emphasize how you are using the type, and "
"focus on which safety requirements you should be careful of. But otherwise "
"they are roughly the same."
msgstr ""

#: src/rust-2024/static-mut-references.md:299
msgid "// A real example would disable interrupts.\n"
msgstr ""

#: src/rust-2024/static-mut-references.md:325
msgid ""
"// SAFETY: This value is only ever read in our interrupt handler,\n"
"            // and interrupts are disabled, and we only use this in one "
"thread.\n"
msgstr ""

#: src/rust-2024/static-mut-references.md:333
msgid ""
"The standard library has a nightly-only (unstable) variant of [`UnsafeCell`]"
"(../../std/cell/struct.UnsafeCell.html) called [`SyncUnsafeCell`](../../std/"
"cell/struct.SyncUnsafeCell.html). This example above shows a very simplified "
"version of the standard library type, but would be used roughly the same "
"way. It can provide even better isolation, so do check out its "
"implementation for more details."
msgstr ""

#: src/rust-2024/static-mut-references.md:335
msgid ""
"This example includes a fictional `with_interrupts_disabled` function which "
"is the type of thing you might see in an embedded environment. For example, "
"the [`critical-section`](https://crates.io/crates/critical-section) crate "
"provides a similar kind of functionality that could be used for an embedded "
"environment."
msgstr ""

#: src/rust-2024/static-mut-references.md:341
msgid "Safe references"
msgstr ""

#: src/rust-2024/static-mut-references.md:343
msgid ""
"In some cases it may be safe to create a reference of a `static mut`. The "
"whole point of the [`static_mut_refs`](../../rustc/lints/listing/warn-by-"
"default.html#static-mut-refs) lint is that this is very hard to do "
"correctly! However, that's not to say it is _impossible_. If you have a "
"situation where you can guarantee that the aliasing requirements are upheld, "
"such as guaranteeing the static is narrowly scoped (only used in a small "
"module or function), has some internal or external synchronization, accounts "
"for interrupt handlers and reentrancy, panic safety, drop handlers, etc., "
"then taking a reference may be fine."
msgstr ""

#: src/rust-2024/static-mut-references.md:345
msgid ""
"There are two approaches you can take for this. You can either allow the "
"[`static_mut_refs`](../../rustc/lints/listing/warn-by-default.html#static-"
"mut-refs) lint (preferably as narrowly as you can), or convert raw pointers "
"to a reference, as with `&mut *&raw mut MY_STATIC`."
msgstr ""

#: src/rust-2024/static-mut-references.md:349
msgid "Short-lived references"
msgstr ""

#: src/rust-2024/static-mut-references.md:351
msgid ""
"If you must create a reference to a `static mut`, then it is recommended to "
"minimize the scope of how long that reference exists. Avoid squirreling the "
"reference away somewhere, or keeping it alive through a large section of "
"code. Keeping it short-lived helps with auditing, and verifying that "
"exclusive access is maintained for the duration. Using pointers should be "
"your default unit, and only convert the pointer to a reference on demand "
"when absolutely required."
msgstr ""

#: src/rust-2024/static-mut-references.md:355
msgid ""
"There is no automatic migration to fix these references to `static mut`. To "
"avoid undefined behavior you must rewrite your code to use a different "
"approach as recommended in the [Alternatives](#alternatives) section."
msgstr ""

#: src/rust-2024/never-type-fallback.md:5
msgid ""
"Never type (`!`) to any type (\"never-to-any\") coercions fall back to never "
"type (`!`) rather than to unit type (`()`)."
msgstr ""

#: src/rust-2024/never-type-fallback.md:6
msgid ""
"The [`never_type_fallback_flowing_into_unsafe`](../../rustc/lints/listing/"
"warn-by-default.html#never-type-fallback-flowing-into-unsafe) lint is now "
"`deny` by default."
msgstr ""

#: src/rust-2024/never-type-fallback.md:12
msgid ""
"When the compiler sees a value of type `!` (never) in a [coercion site]"
"(../../reference/type-coercions.html#coercion-sites), it implicitly inserts "
"a coercion to allow the type checker to infer any type:"
msgstr ""

#: src/rust-2024/never-type-fallback.md:15
#: src/rust-2024/never-type-fallback.md:31
msgid "// This:\n"
msgstr ""

#: src/rust-2024/never-type-fallback.md:18
msgid "// ...is (essentially) turned by the compiler into:\n"
msgstr ""

#: src/rust-2024/never-type-fallback.md:21
msgid ""
"// ...where `absurd` is the following function\n"
"// (it's sound because `!` always marks unreachable code):\n"
msgstr ""

#: src/rust-2024/never-type-fallback.md:27
msgid "This can lead to compilation errors if the type cannot be inferred:"
msgstr ""

#: src/rust-2024/never-type-fallback.md:34
msgid "// ...gets turned into this:\n"
msgstr ""

#: src/rust-2024/never-type-fallback.md:36
msgid "//~ ERROR can't infer the type of `absurd`\n"
msgstr ""

#: src/rust-2024/never-type-fallback.md:39
msgid ""
"To prevent such errors, the compiler remembers where it inserted `absurd` "
"calls, and if it can't infer the type, it uses the fallback type instead:"
msgstr ""

#: src/rust-2024/never-type-fallback.md:44
msgid "/* An arbitrarily selected type! */"
msgstr ""

#: src/rust-2024/never-type-fallback.md:48
msgid "This is what is known as \"never type fallback\"."
msgstr ""

#: src/rust-2024/never-type-fallback.md:50
msgid ""
"Historically, the fallback type has been `()` (unit).  This caused `!` to "
"spontaneously coerce to `()` even when the compiler would not infer `()` "
"without the fallback.  That was confusing and has prevented the "
"stabilization of the `!` type."
msgstr ""

#: src/rust-2024/never-type-fallback.md:52
msgid ""
"In the 2024 edition, the fallback type is now `!`.  (We plan to make this "
"change across all editions at a later date.)  This makes things work more "
"intuitively.  Now when you pass `!` and there is no reason to coerce it to "
"something else, it is kept as `!`."
msgstr ""

#: src/rust-2024/never-type-fallback.md:54
msgid ""
"In some cases your code might depend on the fallback type being `()`, so "
"this can cause compilation errors or changes in behavior."
msgstr ""

#: src/rust-2024/never-type-fallback.md:58
msgid "`never_type_fallback_flowing_into_unsafe`"
msgstr ""

#: src/rust-2024/never-type-fallback.md:60
msgid ""
"The default level of the [`never_type_fallback_flowing_into_unsafe`](../../"
"rustc/lints/listing/warn-by-default.html#never-type-fallback-flowing-into-"
"unsafe) lint has been raised from `warn` to `deny` in the 2024 Edition. This "
"lint helps detect a particular interaction with the fallback to `!` and "
"`unsafe` code which may lead to undefined behavior. See the link for a "
"complete description."
msgstr ""

#: src/rust-2024/never-type-fallback.md:64
msgid ""
"There is no automatic fix, but there is automatic detection of code that "
"will be broken by the edition change.  While still on a previous edition you "
"will see warnings if your code will be broken."
msgstr ""

#: src/rust-2024/never-type-fallback.md:66
msgid ""
"The fix is to specify the type explicitly so that the fallback type is not "
"used.  Unfortunately, it might not be trivial to see which type needs to be "
"specified."
msgstr ""

#: src/rust-2024/never-type-fallback.md:68
msgid ""
"One of the most common patterns broken by this change is using `f()?;` where "
"`f` is generic over the `Ok`\\-part of the return type:"
msgstr ""

#: src/rust-2024/never-type-fallback.md:82
msgid ""
"You might think that, in this example, type `T` can't be inferred.  However, "
"due to the current desugaring of the `?` operator, it was inferred as `()`, "
"and it will now be inferred as `!`."
msgstr ""

#: src/rust-2024/never-type-fallback.md:84
msgid "To fix the issue you need to specify the `T` type explicitly:"
msgstr ""

#: src/rust-2024/never-type-fallback.md:92
#: src/rust-2024/never-type-fallback.md:148
msgid "// ...or:\n"
msgstr ""

#: src/rust-2024/never-type-fallback.md:99
msgid "Another relatively common case is panicking in a closure:"
msgstr ""

#: src/rust-2024/never-type-fallback.md:113
msgid ""
"Previously `!` from the `panic!` coerced to `()` which implements `Unit`.  "
"However now the `!` is kept as `!` so this code fails because `!` doesn't "
"implement `Unit`.  To fix this you can specify the return type of the "
"closure:"
msgstr ""

#: src/rust-2024/never-type-fallback.md:126
msgid ""
"A similar case to that of `f()?` can be seen when using a `!`\\-typed "
"expression in one branch and a function with an unconstrained return type in "
"the other:"
msgstr ""

#: src/rust-2024/never-type-fallback.md:137
msgid ""
"Previously `()` was inferred as the return type of `Default::default()` "
"because `!` from `return` was spuriously coerced to `()`.  Now, `!` will be "
"inferred instead causing this code to not compile because `!` does not "
"implement `Default`."
msgstr ""

#: src/rust-2024/never-type-fallback.md:139
msgid "Again, this can be fixed by specifying the type explicitly:"
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:1
msgid "Macro Fragment Specifiers"
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:5
msgid ""
"The `expr` [fragment specifier](../../reference/macros-by-"
"example.html#metavariables) now also supports `const` and `_` expressions."
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:6
msgid ""
"The `expr_2021` fragment specifier has been added for backwards "
"compatibility."
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:12
msgid ""
"As new syntax is added to Rust, existing `macro_rules` fragment specifiers "
"are sometimes not allowed to match on the new syntax in order to retain "
"backwards compatibility. Supporting the new syntax in the old fragment "
"specifiers is sometimes deferred until the next edition, which provides an "
"opportunity to update them."
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:14
msgid ""
"Indeed this happened with [`const` expressions](../../reference/expressions/"
"block-expr.html#const-blocks) added in 1.79 and [`_` expressions](../../"
"reference/expressions/underscore-expr.html) added in 1.59. In the 2021 "
"Edition and earlier, the `expr` fragment specifier does _not_ match those "
"expressions. This is because you may have a scenario like:"
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:18
msgid "\"first rule\""
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:19
msgid "\"second rule\""
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:27
msgid ""
"Here, in the 2021 Edition, the macro will match the _second_ rule. If "
"earlier editions had changed `expr` to match the newly introduced `const` "
"expressions, then it would match the _first_ rule, which would be a breaking "
"change."
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:29
msgid ""
"In the 2024 Edition, `expr` specifiers now also match `const` and `_` "
"expressions. To support the old behavior, the `expr_2021` fragment specifier "
"has been added which does _not_ match the new expressions."
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:36
msgid ""
"The [`edition_2024_expr_fragment_specifier`](../../rustc/lints/listing/"
"allowed-by-default.html#edition-2024-expr-fragment-specifier) lint will "
"change all uses of the `expr` specifier to `expr_2021` to ensure that the "
"behavior of existing macros does not change. The lint is part of the "
"`rust-2024-compatibility` lint group which is included in the automatic "
"edition migration. In order to migrate your code to be Rust 2024 Edition "
"compatible, run:"
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:42
msgid ""
"In _most_ cases, you will likely want to keep the `expr` specifier instead, "
"in order to support the new expressions. You will need to review your macro "
"to determine if there are other rules that would otherwise match with "
"`const` or `_` and determine if there is a conflict. If you want the new "
"behavior, just revert any changes made by the lint."
msgstr ""

#: src/rust-2024/macro-fragment-specifiers.md:44
msgid ""
"Alternatively, you can manually enable the lint to find macros where you may "
"need to update the `expr` specifier."
msgstr ""

#: src/rust-2024/missing-macro-fragment-specifiers.md:5
msgid ""
"The [`missing_fragment_specifier`](../../rustc/lints/listing/deny-by-"
"default.html#missing-fragment-specifier) lint is now a hard error."
msgstr ""

#: src/rust-2024/missing-macro-fragment-specifiers.md:11
msgid ""
"The [`missing_fragment_specifier`](../../rustc/lints/listing/deny-by-"
"default.html#missing-fragment-specifier) lint detects a situation when an "
"**unused** pattern in a `macro_rules!` macro definition has a meta-variable "
"(e.g. `$e`) that is not followed by a fragment specifier (e.g. `:expr`). "
"This is now a hard error in the 2024 Edition."
msgstr ""

#: src/rust-2024/missing-macro-fragment-specifiers.md:16
msgid "// ERROR: missing fragment specifier\n"
msgstr ""

#: src/rust-2024/missing-macro-fragment-specifiers.md:24
msgid ""
"Calling the macro with arguments that would match a rule with a missing "
"specifier (e.g., `foo!($name)`) is a hard error in all editions. However, "
"simply defining a macro with missing fragment specifiers is not, though we "
"did add a lint in Rust 1.17."
msgstr ""

#: src/rust-2024/missing-macro-fragment-specifiers.md:26
msgid ""
"We'd like to make this a hard error in all editions, but there would be too "
"much breakage right now. So we're starting by making this a hard error in "
"Rust 2024.[^future-incompat]"
msgstr ""

#: src/rust-2024/missing-macro-fragment-specifiers.md:28
msgid ""
"The lint is marked as a \"future-incompatible\" warning to indicate that it "
"may become a hard error in all editions in a future release. See [\\#40107]"
"(https://github.com/rust-lang/rust/issues/40107) for more information."
msgstr ""

#: src/rust-2024/missing-macro-fragment-specifiers.md:34
msgid ""
"To migrate your code to the 2024 Edition, remove the unused matcher rule "
"from the macro. The [`missing_fragment_specifier`](../../rustc/lints/listing/"
"deny-by-default.html#missing-fragment-specifier) lint is on by default in "
"all editions, and should alert you to macros with this issue."
msgstr ""

#: src/rust-2024/missing-macro-fragment-specifiers.md:36
msgid ""
"There is no automatic migration for this change. We expect that this style "
"of macro is extremely rare. The lint has been a future-incompatibility lint "
"since Rust 1.17, a deny-by-default lint since Rust 1.20, and since Rust "
"1.82, it has warned about dependencies that are using this pattern."
msgstr ""

#: src/rust-2024/gen-keyword.md:5
msgid ""
"`gen` is a [reserved keyword](../../reference/keywords.html#reserved-"
"keywords)."
msgstr ""

#: src/rust-2024/gen-keyword.md:11
msgid ""
"The `gen` keyword has been reserved as part of [RFC #3513](https://rust-"
"lang.github.io/rfcs/3513-gen-blocks.html) to introduce \"gen blocks\" in a "
"future release of Rust. `gen` blocks will provide a way to make it easier to "
"write certain kinds of iterators. Reserving the keyword now will make it "
"easier to stabilize `gen` blocks before the next edition."
msgstr ""

#: src/rust-2024/gen-keyword.md:17
msgid ""
"Introducing the `gen` keyword can cause a problem for any identifiers that "
"are already called `gen`. For example, any variable or function name called "
"`gen` would clash with the new keyword. To overcome this, Rust supports the "
"`r#` prefix for a [raw identifier](../../reference/identifiers.html#raw-"
"identifiers), which allows identifiers to overlap with keywords."
msgstr ""

#: src/rust-2024/gen-keyword.md:19
msgid ""
"The [`keyword_idents_2024`](../../rustc/lints/listing/allowed-by-"
"default.html#keyword-idents-2024) lint will automatically modify any "
"identifier named `gen` to be `r#gen` so that code continues to work on both "
"editions. This lint is part of the `rust-2024-compatibility` lint group, "
"which will automatically be applied when running `cargo fix --edition`. To "
"migrate your code to be Rust 2024 Edition compatible, run:"
msgstr ""

#: src/rust-2024/gen-keyword.md:29 src/rust-2024/gen-keyword.md:41
msgid "\"generating!\""
msgstr ""

#: src/rust-2024/gen-keyword.md:37 src/rust-2024/intoiterator-box-slice.md:67
#: src/rust-2024/newly-unsafe-functions.md:58
msgid "to be:"
msgstr ""

#: src/rust-2024/gen-keyword.md:49
msgid ""
"Alternatively, you can manually enable the lint to find places where `gen` "
"identifiers need to be modified to `r#gen`:"
msgstr ""

#: src/rust-2024/reserved-syntax.md:5
msgid ""
"Unprefixed guarded strings of the form `#\"foo\"#` are reserved for future "
"use."
msgstr ""

#: src/rust-2024/reserved-syntax.md:6
msgid "Two or more `#` characters are reserved for future use."
msgstr ""

#: src/rust-2024/reserved-syntax.md:10
msgid ""
"[RFC 3593](https://rust-lang.github.io/rfcs/3593-unprefixed-guarded-"
"strings.html) reserved syntax in the 2024 Edition for guarded string "
"literals that do not have a prefix to make room for possible future language "
"changes. The 2021 Edition [reserved syntax](../rust-2021/reserved-syntax.md) "
"for guarded strings with a prefix, such as `ident##\"foo\"##`. The 2024 "
"Edition extends that to also reserve strings without the `ident` prefix."
msgstr ""

#: src/rust-2024/reserved-syntax.md:12
msgid "There are two reserved syntaxes:"
msgstr ""

#: src/rust-2024/reserved-syntax.md:14
msgid ""
"One or more `#` characters immediately followed by a [string literal](../../"
"reference/tokens.html#string-literals)."
msgstr ""

#: src/rust-2024/reserved-syntax.md:15
msgid "Two or more `#` characters in a row (not separated by whitespace)."
msgstr ""

#: src/rust-2024/reserved-syntax.md:17
msgid ""
"This reservation is done across an edition boundary because of interactions "
"with tokenization and macros. For example, consider this macro:"
msgstr ""

#: src/rust-2024/reserved-syntax.md:21
msgid "\"one token\""
msgstr ""

#: src/rust-2024/reserved-syntax.md:22
msgid "\"three tokens\""
msgstr ""

#: src/rust-2024/reserved-syntax.md:26
msgid "r#\"foo\"#"
msgstr ""

#: src/rust-2024/reserved-syntax.md:31
msgid "Prior to the 2024 Edition, this produces:"
msgstr ""

#: src/rust-2024/reserved-syntax.md:40
msgid ""
"Starting in the 2024 Edition, the `#\"foo\"#` line and the `###` line now "
"generates a compile error because those forms are now reserved."
msgstr ""

#: src/rust-2024/reserved-syntax.md:48
msgid ""
"The [`rust_2024_guarded_string_incompatible_syntax`](../../rustc/lints/"
"listing/allowed-by-default.html#rust-2024-guarded-string-incompatible-"
"syntax) lint will identify any tokens that match the reserved syntax, and "
"will suggest a modification to insert spaces where necessary to ensure the "
"tokens continue to be parsed separately."
msgstr ""

#: src/rust-2024/reserved-syntax.md:50
msgid ""
"The lint is part of the `rust-2024-compatibility` lint group which is "
"included in the automatic edition migration. In order to migrate your code "
"to be Rust 2024 Edition compatible, run:"
msgstr ""

#: src/rust-2024/reserved-syntax.md:56
msgid ""
"Alternatively, you can manually enable the lint to find macro calls where "
"you may need to update the tokens:"
msgstr ""

#: src/rust-2024/standard-library.md:3
msgid ""
"The following chapters detail changes to the standard library in the 2024 "
"Edition."
msgstr ""

#: src/rust-2024/prelude.md:5
msgid ""
"The [`Future`](../../std/future/trait.Future.html) and [`IntoFuture`](../../"
"std/future/trait.IntoFuture.html) traits are now part of the prelude."
msgstr ""

#: src/rust-2024/prelude.md:13
msgid ""
"The [prelude of the standard library](../../std/prelude/index.html) is the "
"module containing everything that is automatically imported in every module. "
"It contains commonly used items such as `Option`, `Vec`, `drop`, and `Clone`."
msgstr ""

#: src/rust-2024/prelude.md:22
msgid ""
"However, adding a _trait_ to the prelude can break existing code in a subtle "
"way. For example, a call to `x.poll()` which comes from a `MyPoller` trait "
"might fail to compile if `std`'s `Future` is also imported, because the call "
"to `poll` is now ambiguous and could come from either trait."
msgstr ""

#: src/rust-2024/prelude.md:25
msgid ""
"As a solution, Rust 2024 will use a new prelude. It's identical to the "
"current one, except for the following changes:"
msgstr ""

#: src/rust-2024/prelude.md:28
msgid "Added:"
msgstr ""

#: src/rust-2024/prelude.md:29
msgid "[`std::future::Future`](../../std/future/trait.Future.html)"
msgstr ""

#: src/rust-2024/prelude.md:30
msgid "[`std::future::IntoFuture`](../../std/future/trait.IntoFuture.html)"
msgstr ""

#: src/rust-2024/prelude.md:40
msgid ""
"// This name is the same as the `poll` method on the `Future` trait from "
"`std`.\n"
msgstr ""

#: src/rust-2024/prelude.md:42
msgid "\"polling\""
msgstr ""

#: src/rust-2024/prelude.md:49
msgid ""
"// Pin<&mut async {}> implements both `std::future::Future` and `MyPoller`.\n"
"    // If both traits are in scope (as would be the case in Rust 2024),\n"
"    // then it becomes ambiguous which `poll` method to call\n"
msgstr ""

#: src/rust-2024/prelude.md:56
msgid ""
"We can fix this so that it works on all editions by using fully qualified "
"syntax:"
msgstr ""

#: src/rust-2024/prelude.md:65
msgid ""
"The [`rust_2024_prelude_collisions`](../../rustc/lints/listing/allowed-by-"
"default.html#rust-2024-prelude-collisions) lint will automatically modify "
"any ambiguous method calls to use fully qualified syntax. This lint is part "
"of the `rust-2024-compatibility` lint group, which will automatically be "
"applied when running `cargo fix --edition`. To migrate your code to be Rust "
"2024 Edition compatible, run:"
msgstr ""

#: src/rust-2024/prelude.md:71
msgid ""
"Alternatively, you can manually enable the lint to find places where these "
"qualifications need to be added:"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:5
msgid ""
"Boxed slices implement [`IntoIterator`](../../std/iter/"
"trait.IntoIterator.html) in _all_ editions."
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:6
msgid ""
"Calls to [`IntoIterator::into_iter`](../../std/iter/"
"trait.IntoIterator.html#tymethod.into_iter) are _hidden_ in editions prior "
"to 2024 when using method call syntax (i.e., `boxed_slice.into_iter()`). So, "
"`boxed_slice.into_iter()` still resolves to `(&(*boxed_slice)).into_iter()` "
"as it has before."
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:7
msgid ""
"`boxed_slice.into_iter()` changes meaning to call [`IntoIterator::into_iter`]"
"(../../std/iter/trait.IntoIterator.html#tymethod.into_iter) in Rust 2024."
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:14
msgid ""
"Until Rust 1.80, `IntoIterator` was not implemented for boxed slices. In "
"prior versions, if you called `.into_iter()` on a boxed slice, the method "
"call would automatically dereference from `Box<[T]>` to `&[T]`, and return "
"an iterator that yielded references of `&T`. For example, the following "
"worked in prior versions:"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:17
msgid "// Example of behavior in previous editions.\n"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:18
msgid "// Note: .into_iter() was required in versions older than 1.80\n"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:21
msgid "// x is of type &u32 in editions prior to 2024\n"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:25
msgid ""
"In Rust 1.80, implementations of `IntoIterator` were added for boxed slices. "
"This allows iterating over elements of the slice by-value instead of by-"
"reference:"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:28
msgid "// NEW as of 1.80, all editions\n"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:30
msgid ""
"// notice no need for calling .into_iter()\n"
"    // x is of type u32\n"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:35
msgid ""
"This example is allowed on all editions because previously this was an error "
"since `for` loops do not automatically dereference like the `.into_iter()` "
"method call does."
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:37
msgid ""
"However, this would normally be a breaking change because existing code that "
"manually called `.into_iter()` on a boxed slice would change from having an "
"iterator over references to an iterator over values. To resolve this "
"problem, method calls of `.into_iter()` on boxed slices have edition-"
"dependent behavior. In editions before 2024, it continues to return an "
"iterator over references, and starting in Edition 2024 it returns an "
"iterator over values."
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:40
msgid "// Example of changed behavior in Edition 2024\n"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:41
msgid "// Example of old code that still manually calls .into_iter()\n"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:44
msgid "// x is now type u32 in Edition 2024\n"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:50
msgid ""
"The [`boxed_slice_into_iter`](../../rustc/lints/listing/warn-by-"
"default.html#boxed-slice-into-iter) lint will automatically modify any calls "
"to `.into_iter()` on boxed slices to call `.iter()` instead to retain the "
"old behavior of yielding references. This lint is part of the `rust-2024-"
"compatibility` lint group, which will automatically be applied when running "
"`cargo fix --edition`. To migrate your code to be Rust 2024 Edition "
"compatible, run:"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:62
#: src/rust-2024/intoiterator-box-slice.md:73
msgid "// x is of type &u32\n"
msgstr ""

#: src/rust-2024/intoiterator-box-slice.md:78
msgid ""
"The [`boxed_slice_into_iter`](../../rustc/lints/listing/warn-by-"
"default.html#boxed-slice-into-iter) lint is defaulted to warn on all "
"editions, so unless you have manually silenced the lint, you should already "
"see it before you migrate."
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:1
msgid "Unsafe functions"
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:5
msgid ""
"The following functions are now marked [`unsafe`](../../reference/unsafe-"
"keyword.html#unsafe-functions-unsafe-fn):"
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:6
msgid "[`std::env::set_var`](../../std/env/fn.set_var.html)"
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:7
msgid "[`std::env::remove_var`](../../std/env/fn.remove_var.html)"
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:8
msgid ""
"[`std::os::unix::process::CommandExt::before_exec`](../../std/os/unix/"
"process/trait.CommandExt.html#method.before_exec)"
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:17
msgid ""
"Over time it has become evident that certain functions in the standard "
"library should have been marked as `unsafe`. However, adding `unsafe` to a "
"function can be a breaking change since it requires existing code to be "
"placed in an `unsafe` block. To avoid the breaking change, these functions "
"are marked as `unsafe` starting in the 2024 Edition, while not requiring "
"`unsafe` in previous editions."
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:19
msgid "`std::env::{set_var, remove_var}`"
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:21
msgid ""
"It can be unsound to call [`std::env::set_var`](../../std/env/"
"fn.set_var.html) or [`std::env::remove_var`](../../std/env/"
"fn.remove_var.html) in a multi-threaded program due to safety limitations of "
"the way the process environment is handled on some platforms. The standard "
"library originally defined these as safe functions, but it was later "
"determined that was not correct."
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:23
msgid ""
"It is important to ensure that these functions are not called when any other "
"thread might be running. See the [Safety](../../std/env/"
"fn.set_var.html#safety) section of the function documentation for more "
"details."
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:27
msgid "`std::os::unix::process::CommandExt::before_exec`"
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:29
msgid ""
"The [`std::os::unix::process::CommandExt::before_exec`](../../std/os/unix/"
"process/trait.CommandExt.html#method.before_exec) function is a unix-"
"specific function which provides a way to run a closure before calling "
"`exec`. This function was deprecated in the 1.37 release, and replaced with "
"[`pre_exec`](../../std/os/unix/process/"
"trait.CommandExt.html#tymethod.pre_exec) which does the same thing, but is "
"marked as `unsafe`."
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:31
msgid ""
"Even though `before_exec` is deprecated, it is now correctly marked as "
"`unsafe` starting in the 2024 Edition. This should help ensure that any "
"legacy code which has not already migrated to `pre_exec` to require an "
"`unsafe` block."
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:33
msgid ""
"There are very strict safety requirements for the `before_exec` closure to "
"satisfy. See the [Safety section](../../std/os/unix/process/"
"trait.CommandExt.html#notes-and-safety) for more details."
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:40
msgid ""
"To make your code compile in both the 2021 and 2024 editions, you will need "
"to make sure that these functions are called only from within `unsafe` "
"blocks."
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:42
msgid ""
"**⚠ Caution**: It is important that you manually inspect the calls to these "
"functions and possibly rewrite your code to satisfy the preconditions of "
"those functions. In particular, `set_var` and `remove_var` should not be "
"called if there might be multiple threads running. You may need to elect to "
"use a different mechanism other than environment variables to manage your "
"use case."
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:44
msgid ""
"The [`deprecated_safe_2024`](../../rustc/lints/listing/allowed-by-"
"default.html#deprecated-safe-2024) lint will automatically modify any use of "
"these functions to be wrapped in an `unsafe` block so that it can compile on "
"both editions. This lint is part of the `rust-2024-compatibility` lint "
"group, which will automatically be applied when running `cargo fix --"
"edition`. To migrate your code to be Rust 2024 Edition compatible, run:"
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:54
#: src/rust-2024/newly-unsafe-functions.md:63
msgid "\"FOO\""
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:54
#: src/rust-2024/newly-unsafe-functions.md:63
msgid "\"123\""
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:62
msgid ""
"// TODO: Audit that the environment access only happens in single-threaded "
"code.\n"
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:67
msgid ""
"Just beware that this automatic migration will not be able to verify that "
"these functions are being used correctly. It is still your responsibility to "
"manually review their usage."
msgstr ""

#: src/rust-2024/newly-unsafe-functions.md:69
msgid ""
"Alternatively, you can manually enable the lint to find places these "
"functions are called:"
msgstr ""

#: src/rust-2024/cargo.md:3
msgid "The following chapters detail changes to Cargo in the 2024 Edition."
msgstr ""

#: src/rust-2024/cargo-resolver.md:5
msgid ""
"`edition = \"2024\"` implies `resolver = \"3\"` in `Cargo.toml` which "
"enables a Rust-version aware dependency resolver."
msgstr ""

#: src/rust-2024/cargo-resolver.md:9
msgid ""
"Since Rust 1.84.0, Cargo has opt-in support for compatibility with "
"[`package.rust-version`](../../cargo/reference/rust-version.html) to be "
"considered when selecting dependency versions by setting "
"[`resolver.incompatible-rust-version = \"fallback\"`](../../cargo/reference/"
"config.html#resolverincompatible-rust-versions) in `.cargo/config.toml`."
msgstr ""

#: src/rust-2024/cargo-resolver.md:13
msgid ""
"Starting in Rust 2024, this will be the default. That is, writing `edition = "
"\"2024\"` in `Cargo.toml` will imply `resolver = \"3\"` which will imply "
"[`resolver.incompatible-rust-version = \"fallback\"`](../../cargo/reference/"
"config.html#resolverincompatible-rust-versions)."
msgstr ""

#: src/rust-2024/cargo-resolver.md:22
msgid ""
"For more details on how Rust-version aware dependency resolution works, see "
"[the Cargo book](../../cargo/reference/resolver.html#rust-version)."
msgstr ""

#: src/rust-2024/cargo-resolver.md:32
msgid ""
"There are no automated migration tools for updating for the new resolver."
msgstr ""

#: src/rust-2024/cargo-resolver.md:34
msgid ""
"We recommend projects [verify against the latest dependencies in CI](../../"
"cargo/guide/continuous-integration.html#verifying-latest-dependencies) to "
"catch bugs in dependencies as soon as possible."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:5
msgid ""
"Several table and key names in `Cargo.toml` have been removed where there "
"were previously two ways to specify the same thing."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:6
msgid "Removed `[project]`; use `[package]` instead."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:7
msgid "Removed `default_features`; use `default-features` instead."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:8
msgid "Removed `crate_type`; use `crate-type` instead."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:9
msgid "Removed `proc_macro`; use `proc-macro` instead."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:10
msgid "Removed `dev_dependencies`; use `dev-dependencies` instead."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:11
msgid "Removed `build_dependencies`; use `build-dependencies` instead."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:15
msgid ""
"Several table and keys names are no longer allowed in the 2024 Edition. "
"There were two ways to specify these tables or keys, and this helps ensure "
"there is only one way to specify them."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:18
msgid ""
"Some were due to a change in decisions over time, and some were inadvertent "
"implementation artifacts. In order to avoid confusion, and to enforce a "
"single style for specifying these tables and keys, only one variant is now "
"allowed."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:23
msgid ""
"```toml\n"
"[dev_dependencies]\n"
"rand = { version = \"0.8.5\", default_features = false }\n"
"```"
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:28
msgid "Should be changed to:"
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:30
msgid ""
"```toml\n"
"[dev-dependencies]\n"
"rand = { version = \"0.8.5\", default-features = false }\n"
"```"
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:35
msgid ""
"Notice that the underscores were changed to dashes for `dev_dependencies` "
"and `default_features`."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:39
msgid ""
"When using `cargo fix --edition`, Cargo will automatically update your "
"`Cargo.toml` file to use the preferred table and key names."
msgstr ""

#: src/rust-2024/cargo-table-key-names.md:41
msgid ""
"If you would prefer to update your `Cargo.toml` manually, be sure to go "
"through the list above and make sure only the new forms are used."
msgstr ""

#: src/rust-2024/cargo-inherited-default-features.md:5
msgid ""
"`default-features = false` is no longer allowed in an inherited workspace "
"dependency if the workspace dependency specifies `default-features = true` "
"(or does not specify `default-features`)."
msgstr ""

#: src/rust-2024/cargo-inherited-default-features.md:9
msgid ""
"[Workspace inheritance](../../cargo/reference/specifying-"
"dependencies.html#inheriting-a-dependency-from-a-workspace) allows you to "
"specify dependencies in one place (the workspace), and then to refer to "
"those workspace dependencies from within a package. There was an inadvertent "
"interaction with how `default-features` is specified that is no longer "
"allowed in the 2024 Edition."
msgstr ""

#: src/rust-2024/cargo-inherited-default-features.md:12
msgid ""
"Unless the workspace specifies `default-features = false`, it is no longer "
"allowed to specify `default-features = false` in an inherited package "
"dependency. For example, with a workspace that specifies:"
msgstr ""

#: src/rust-2024/cargo-inherited-default-features.md:15
msgid ""
"```toml\n"
"[workspace.dependencies]\n"
"regex = \"1.10.4\"\n"
"```"
msgstr ""

#: src/rust-2024/cargo-inherited-default-features.md:20
msgid "The following is now an error:"
msgstr ""

#: src/rust-2024/cargo-inherited-default-features.md:22
msgid ""
"```toml\n"
"[package]\n"
"name = \"foo\"\n"
"version = \"1.0.0\"\n"
"edition = \"2024\"\n"
"\n"
"[dependencies]\n"
"regex = { workspace = true, default-features = false }  # ERROR\n"
"```"
msgstr ""

#: src/rust-2024/cargo-inherited-default-features.md:32
msgid ""
"The reason for this change is to avoid confusion when specifying `default-"
"features = false` when the default feature is already enabled, since it has "
"no effect."
msgstr ""

#: src/rust-2024/cargo-inherited-default-features.md:34
msgid ""
"If you want the flexibility of deciding whether or not a dependency enables "
"the default-features of a dependency, be sure to set `default-features = "
"false` in the workspace definition. Just beware that if you build multiple "
"workspace members at the same time, the features will be unified so that if "
"one member sets `default-features = true` (which is the default if not "
"explicitly set), the default-features will be enabled for all members using "
"that dependency."
msgstr ""

#: src/rust-2024/cargo-inherited-default-features.md:39
msgid ""
"When using `cargo fix --edition`, Cargo will automatically update your "
"`Cargo.toml` file to remove `default-features = false` in this situation."
msgstr ""

#: src/rust-2024/cargo-inherited-default-features.md:41
msgid ""
"If you would prefer to update your `Cargo.toml` manually, check for any "
"warnings when running a build and remove the corresponding entries. Previous "
"editions should display something like:"
msgstr ""

#: src/rust-2024/rustdoc.md:3
msgid "The following chapters detail changes to Rustdoc in the 2024 Edition."
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:5
msgid ""
"[Doctests](../../rustdoc/write-documentation/documentation-tests.html) are "
"now combined into a single binary which should result in a significant "
"performance improvement."
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:9
msgid ""
"Prior the the 2024 Edition, rustdoc's \"test\" mode would compile each code "
"block in your documentation as a separate executable. Although this was "
"relatively simple to implement, it resulted in a significant performance "
"burden when there were a large number of documentation tests. Starting with "
"the 2024 Edition, rustdoc will attempt to combine documentation tests into a "
"single binary, significantly reducing the overhead for compiling doctests."
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:12
msgid ""
"/// Adds two numbers\n"
"///\n"
"/// ```\n"
"/// assert_eq!(add(1, 1), 2);\n"
"/// ```\n"
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:20
msgid ""
"/// Subtracts two numbers\n"
"///\n"
"/// ```\n"
"/// assert_eq!(subtract(2, 1), 1);\n"
"/// ```\n"
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:31
msgid ""
"In this example, the two doctests will now be compiled into a single "
"executable. Rustdoc will essentially place each example in a separate "
"function within a single binary. The tests still run in independent "
"processes as they did before, so any global state (like global statics) "
"should still continue to work correctly.[^implementation]"
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:33
msgid ""
"This change is only available in the 2024 Edition to avoid potential "
"incompatibilities with existing doctests which may not work in a combined "
"executable. However, these incompatibilities are expected to be extremely "
"rare."
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:38
msgid ""
"For more information on the details of how this work, see [\"Doctests - How "
"were they improved?\"](https://blog.guillaume-gomez.fr/articles/"
"2024-08-17+Doctests+-+How+were+they+improved%3F)."
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:40
msgid "`standalone_crate` tag"
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:42
msgid ""
"In some situations it is not possible for rustdoc to combine examples into a "
"single executable. Rustdoc will attempt to automatically detect if this is "
"not possible. For example, a test will not be combined with others if it:"
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:44
msgid ""
"Uses the [`compile_fail`](../../rustdoc/write-documentation/documentation-"
"tests.html#attributes) tag, which indicates that the example should fail to "
"compile."
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:45
msgid ""
"Uses an [`edition`](../../rustdoc/write-documentation/documentation-"
"tests.html#attributes) tag, which indicates the edition of the example."
"[^edition-tag]"
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:46
msgid ""
"Uses global attributes, like the [`global_allocator`](../../std/alloc/"
"trait.GlobalAlloc.html) attribute, which could potentially interfere with "
"other tests."
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:47
msgid "Defines any crate-wide attributes (like `#![feature(...)]`)."
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:48
msgid ""
"Defines a macro that uses `$crate`, because the `$crate` path will not work "
"correctly."
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:50
msgid ""
"However, rustdoc is not able to automatically determine _all_ situations "
"where an example cannot be combined with other examples. In these "
"situations, you can add the `standalone_crate` language tag to indicate that "
"the example should be built as a separate executable. For example:"
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:53
msgid ""
"//! ```\n"
"//! let location = std::panic::Location::caller();\n"
"//! assert_eq!(location.line(), 5);\n"
"//! ```\n"
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:59
msgid ""
"This is sensitive to the code structure of how the example is compiled and "
"won't work with the \"combined\" approach because the line numbers will "
"shift depending on how the doctests are combined. In these situations, you "
"can add the `standalone_crate` tag to force the example to be built "
"separately just as it was in previous editions. E.g.:"
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:62
msgid ""
"//! ```standalone_crate\n"
"//! let location = std::panic::Location::caller();\n"
"//! assert_eq!(location.line(), 5);\n"
"//! ```\n"
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:71
msgid ""
"Note that rustdoc will only combine tests if the entire crate is Edition "
"2024 or greater. Using the `edition2024` tag in older editions will not "
"result in those tests being combined."
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:75
msgid ""
"There is no automatic migration to determine which doctests need to be "
"annotated with the `standalone_crate` tag. It's very unlikely that any given "
"doctest will not work correctly when migrated. We suggest that you update "
"your crate to the 2024 Edition and then run your documentation tests and see "
"if any fail. If one does, you will need to analyze whether it can be "
"rewritten to be compatible with the combined approach, or alternatively, add "
"the `standalone_crate` tag to retain the previous behavior."
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:77
msgid "Some things to watch out for and avoid are:"
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:79
msgid ""
"Checking the values of [`std::panic::Location`](https://doc.rust-lang.org/"
"std/panic/struct.Location.html) or things that make use of `Location`. The "
"location of the code is now different since multiple tests are now located "
"in the same test crate."
msgstr ""

#: src/rust-2024/rustdoc-doctests.md:80
msgid ""
"Checking the value of [`std::any::type_name`](https://doc.rust-lang.org/std/"
"any/fn.type_name.html), which now has a different module path."
msgstr ""

#: src/rust-2024/rustdoc-nested-includes.md:5
msgid ""
"When a doctest is included with `include_str!`, if that doctest itself also "
"uses `include!`, `include_str!`, or `include_bytes!`, the path is resolved "
"relative to the Markdown file, rather than to the Rust source file."
msgstr ""

#: src/rust-2024/rustdoc-nested-includes.md:9
msgid ""
"Prior to the 2024 edition, adding documentation with `#[doc=include_str!"
"(\"path/file.md\")]` didn't carry span information into any doctests in that "
"file. As a result, if the Markdown file was in a different directory than "
"the source, any paths included had to be specified relative to the source "
"file."
msgstr ""

#: src/rust-2024/rustdoc-nested-includes.md:11
msgid "For example, consider a library crate with these files:"
msgstr ""

#: src/rust-2024/rustdoc-nested-includes.md:13
msgid "`Cargo.toml`"
msgstr ""

#: src/rust-2024/rustdoc-nested-includes.md:14
msgid "`README.md`"
msgstr ""

#: src/rust-2024/rustdoc-nested-includes.md:15
msgid "`src/`"
msgstr ""

#: src/rust-2024/rustdoc-nested-includes.md:16
msgid "`lib.rs`"
msgstr ""

#: src/rust-2024/rustdoc-nested-includes.md:17
msgid "`examples/`"
msgstr ""

#: src/rust-2024/rustdoc-nested-includes.md:18
msgid "`data.bin`"
msgstr ""

#: src/rust-2024/rustdoc-nested-includes.md:20
msgid "Let's say that `lib.rs` contains this:"
msgstr ""

#: src/rust-2024/rustdoc-nested-includes.md:23
msgid "\"../README.md\""
msgstr ""

#: src/rust-2024/rustdoc-nested-includes.md:26
msgid "And assume this `README.md` file:"
msgstr ""

#: src/rust-2024/rustdoc-nested-includes.md:35
msgid ""
"Prior to the 2024 edition, the path in `README.md` needed to be relative to "
"the `lib.rs` file. In 2024 and later, it is now relative to `README.md` "
"itself, so we would update `README.md` to:"
msgstr ""

#: src/rust-2024/rustdoc-nested-includes.md:45
msgid ""
"There is no automatic migration to convert the paths in affected doctests. "
"If one of your doctests is affected, you'll see an error like this after "
"migrating to the new edition when building your tests:"
msgstr ""

#: src/rust-2024/rustdoc-nested-includes.md:47
msgid ""
"````````````````````text\n"
"error: couldn't read `../examples/data.bin`: No such file or directory (os "
"error 2)\n"
" --> src/../README.md:2:24\n"
"  |\n"
"2 | let _ = include_bytes!(\"../examples/data.bin\");\n"
"  |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
"  = note: this error originates in the macro `include_bytes` (in Nightly "
"builds, run with -Z macro-backtrace for more info)\n"
"help: there is a file with the same name in a different directory\n"
"  |\n"
"2 | let _ = include_bytes!(\"examples/data.bin\");\n"
"  |                        ~~~~~~~~~~~~~~~~~~~\n"
"````````````````````"
msgstr ""

#: src/rust-2024/rustdoc-nested-includes.md:60
msgid ""
"To migrate your doctests to Rust 2024, update any affected paths to be "
"relative to the file containing the doctests."
msgstr ""

#: src/rust-2024/rustfmt.md:3
msgid "The following chapters detail changes to Rustfmt in the 2024 Edition."
msgstr ""

#: src/rust-2024/rustfmt-style-edition.md:5
msgid "User can now control which style edition to use with `rustfmt`."
msgstr ""

#: src/rust-2024/rustfmt-style-edition.md:9
msgid ""
"The default formatting produced by Rustfmt is governed by the rules in the "
"[Rust Style Guide](../../style-guide/index.html)."
msgstr ""

#: src/rust-2024/rustfmt-style-edition.md:12
msgid ""
"Additionally, Rustfmt has a formatting stability guarantee that aims to "
"avoid causing noisy formatting churn for users when updating a Rust "
"toolchain. This stability guarantee essentially means that a newer version "
"of Rustfmt cannot modify the _successfully formatted_ output that was "
"produced by a previous version of Rustfmt."
msgstr ""

#: src/rust-2024/rustfmt-style-edition.md:18
msgid ""
"The combination of those two constraints had historically locked both the "
"Style Guide and the default formatting behavior in Rustfmt. This impasse "
"caused various challenges, such as preventing the ability to iterate on "
"style improvements, and requiring Rustfmt to maintain legacy formatting "
"quirks that were obviated long ago (e.g. nested tuple access)."
msgstr ""

#: src/rust-2024/rustfmt-style-edition.md:24
msgid ""
"[RFC 3338](https://rust-lang.github.io/rfcs/3338-style-evolution.html) "
"resolved this impasse by establishing a mechanism for the Rust Style Guide "
"to be aligned to Rust's Edition model wherein the Style Guide could evolve "
"across Editions, and `rustfmt` would allow users to specify their desired "
"Edition of the Style Guide, referred to as the Style Edition."
msgstr ""

#: src/rust-2024/rustfmt-style-edition.md:29
msgid ""
"In the 2024 Edition, `rustfmt` now supports the ability for users to control "
"the Style Edition used for formatting. The 2024 Edition of the Style Guide "
"also includes enhancements to the Style Guide which are detailed elsewhere "
"in this Edition Guide."
msgstr ""

#: src/rust-2024/rustfmt-style-edition.md:33
msgid ""
"By default `rustfmt` will use the same Style Edition as the standard Rust "
"Edition used for parsing, but the Style Edition can also be overridden and "
"configured separately."
msgstr ""

#: src/rust-2024/rustfmt-style-edition.md:36
msgid "There are multiple ways to run `rustfmt` with the 2024 Style Edition:"
msgstr ""

#: src/rust-2024/rustfmt-style-edition.md:38
msgid "With a `Cargo.toml` file that has `edition` set to `2024`, run:"
msgstr ""

#: src/rust-2024/rustfmt-style-edition.md:44
msgid ""
"Or run `rustfmt` directly with `2024` for the edition to use the 2024 "
"edition for both parsing and the 2024 edition of the Style Guide:"
msgstr ""

#: src/rust-2024/rustfmt-style-edition.md:51
msgid ""
"The style edition can also be set in a `rustfmt.toml` configuration file:"
msgstr ""

#: src/rust-2024/rustfmt-style-edition.md:52
msgid ""
"```toml\n"
"style_edition = \"2024\"\n"
"```"
msgstr ""

#: src/rust-2024/rustfmt-style-edition.md:56
msgid "Which is then used when running `rustfmt` directly:"
msgstr ""

#: src/rust-2024/rustfmt-style-edition.md:61
msgid ""
"Alternatively, the style edition can be specified directly from `rustfmt` "
"options:"
msgstr ""

#: src/rust-2024/rustfmt-style-edition.md:72
msgid ""
"Running `cargo fmt` or `rustfmt` with the 2024 edition or style edition will "
"automatically migrate formatting over to the 2024 style edition formatting."
msgstr ""

#: src/rust-2024/rustfmt-style-edition.md:75
msgid ""
"Projects who have contributors that may utilize their editor's format-on-"
"save features are also strongly encouraged to add a `.rustfmt.toml` file to "
"their project that includes the corresponding `style_edition` utilized "
"within their project, or to encourage their users to ensure their local "
"editor format-on-save feature is configured to use that same `style_edition`."
msgstr ""

#: src/rust-2024/rustfmt-style-edition.md:81
msgid ""
"This is to ensure that the editor format-on-save output is consistent with "
"the output when `cargo fmt` is manually executed by the developer, or the "
"project's CI process (many editors will run `rustfmt` directly which by "
"default uses the 2015 edition, whereas `cargo fmt` uses the edition "
"specified in the `Cargo.toml` file)"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:5
msgid "Fixes to various formatting scenarios."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:9
msgid ""
"The 2024 style edition introduces several fixes to various formatting "
"scenarios."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:11
msgid ""
"Don't align unrelated trailing comments after items or at the end of blocks"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:17
msgid ""
"Previously rustfmt would assume that a comment on a line following an item "
"with a trailing comment should be indented to match the trailing comment. "
"This has been changed so that those comments are not indented."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:19
#: src/rust-2024/rustfmt-formatting-fixes.md:94
#: src/rust-2024/rustfmt-formatting-fixes.md:120
#: src/rust-2024/rustfmt-formatting-fixes.md:160
#: src/rust-2024/rustfmt-formatting-fixes.md:198
#: src/rust-2024/rustfmt-formatting-fixes.md:238
#: src/rust-2024/rustfmt-formatting-fixes.md:263
#: src/rust-2024/rustfmt-formatting-fixes.md:297
#: src/rust-2024/rustfmt-formatting-fixes.md:328
#: src/rust-2024/rustfmt-formatting-fixes.md:366
#: src/rust-2024/rustfmt-formatting-fixes.md:412
#: src/rust-2024/rustfmt-formatting-fixes.md:442
#: src/rust-2024/rustfmt-formatting-fixes.md:473
#: src/rust-2024/rustfmt-formatting-fixes.md:519
#: src/rust-2024/rustfmt-formatting-fixes.md:550
#: src/rust-2024/rustfmt-formatting-fixes.md:580
#: src/rust-2024/rustfmt-formatting-fixes.md:616
msgid "**Style edition 2021:**"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:22
msgid ""
"// Supports multicast\n"
"                                                 // Multicast using "
"broadcst. add.\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:25
#: src/rust-2024/rustfmt-formatting-fixes.md:50
msgid "// CREATE TABLE\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:26
#: src/rust-2024/rustfmt-formatting-fixes.md:51
msgid "// DROP TABLE\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:27
msgid ""
"// CREATE INDEX\n"
"                                   //const SQ_DRPIDX: u16 = 0x0011; // DROP "
"INDEX\n"
"                                   //const SQ_GRANT: u16 = 0x0012;  // "
"GRANT\n"
"                                   //const SQ_REVOKE: u16 = 0x0013; // "
"REVOKE\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:33
msgid ""
"// Donec consequat mi. Quisque vitae dolor. Integer lobortis. Maecenas id "
"nulla. Lorem.\n"
"                   // Id turpis. Nam posuere lectus vitae nibh. Etiam tortor "
"orci, sagittis\n"
"                   // malesuada, rhoncus quis, hendrerit eget, libero. "
"Quisque commodo nulla at\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:38
msgid ""
"// [-1.0, 1.0]\n"
"                                                                   // "
"TODO(emilio): It may make sense to make this range [.01, 10.0], to align\n"
"                                                                   // with "
"css-fonts-4's range of [1, 1000].\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:44
#: src/rust-2024/rustfmt-formatting-fixes.md:107
#: src/rust-2024/rustfmt-formatting-fixes.md:133
#: src/rust-2024/rustfmt-formatting-fixes.md:175
#: src/rust-2024/rustfmt-formatting-fixes.md:213
#: src/rust-2024/rustfmt-formatting-fixes.md:246
#: src/rust-2024/rustfmt-formatting-fixes.md:276
#: src/rust-2024/rustfmt-formatting-fixes.md:306
#: src/rust-2024/rustfmt-formatting-fixes.md:346
#: src/rust-2024/rustfmt-formatting-fixes.md:384
#: src/rust-2024/rustfmt-formatting-fixes.md:422
#: src/rust-2024/rustfmt-formatting-fixes.md:454
#: src/rust-2024/rustfmt-formatting-fixes.md:488
#: src/rust-2024/rustfmt-formatting-fixes.md:531
#: src/rust-2024/rustfmt-formatting-fixes.md:560
#: src/rust-2024/rustfmt-formatting-fixes.md:594
#: src/rust-2024/rustfmt-formatting-fixes.md:628
msgid "**Style edition 2024:**"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:47
msgid ""
"// Supports multicast\n"
"// Multicast using broadcst. add.\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:52
msgid ""
"// CREATE INDEX\n"
"//const SQ_DRPIDX: u16 = 0x0011; // DROP INDEX\n"
"//const SQ_GRANT: u16 = 0x0012;  // GRANT\n"
"//const SQ_REVOKE: u16 = 0x0013; // REVOKE\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:58
msgid ""
"// Donec consequat mi. Quisque vitae dolor. Integer lobortis. Maecenas id "
"nulla. Lorem.\n"
"    // Id turpis. Nam posuere lectus vitae nibh. Etiam tortor orci, "
"sagittis\n"
"    // malesuada, rhoncus quis, hendrerit eget, libero. Quisque commodo "
"nulla at\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:63
msgid ""
"// [-1.0, 1.0]\n"
"    // TODO(emilio): It may make sense to make this range [.01, 10.0], to "
"align\n"
"    // with css-fonts-4's range of [1, 1000].\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:69
msgid "Don't indent strings in comments"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:79
msgid ""
"Previously rustfmt would incorrectly attempt to format strings in comments."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:81
#: src/rust-2024/rustfmt-formatting-fixes.md:508
msgid "**Original:**"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:85
msgid ""
"/*   let s = String::from(\n"
"        \"\n"
"hello\n"
"world\n"
"\",\n"
"    ); */"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:98
msgid ""
"/*   let s = String::from(\n"
"            \"\n"
"    hello\n"
"    world\n"
"    \",\n"
"        ); */"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:109
msgid "No change from original."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:111
msgid "Long strings don't prevent formatting expressions"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:118
msgid ""
"In some situations, long strings would previously prevent the expression "
"from being formatted."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:124
#: src/rust-2024/rustfmt-formatting-fixes.md:138
msgid ""
"\"Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia "
"deserunt mollit anim id est laborum.\""
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:127
#: src/rust-2024/rustfmt-formatting-fixes.md:146
msgid "\"long_long_long_long_long_long_long_lo_long_long_long_long_long_long__long_long_long_long_long_long_\""
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:128
#: src/rust-2024/rustfmt-formatting-fixes.md:147
msgid "\"long_long_long_long_long_long_long_long_long_long_lo_long_long_lolong_long_long_lo_long_long_lolong_long_long_lo_long_long_lo\""
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:152
msgid "Fixed indentation of generics in impl blocks"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:158
msgid "Generics in `impl` items had excessive indentation."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:190
msgid "Use correct indentation when formatting a complex `fn`"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:196
msgid ""
"In some cases, a complex `fn` signature could end up with an unusual "
"indentation that is now fixed."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:230
msgid "Avoid extra space in nested tuple indexing expression"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:236
msgid ""
"Nested tuple indexing expressions would incorrectly include an extra space."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:254
msgid "End return/break/continue inside a block in a match with a semicolon"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:261
msgid ""
"A `return`, `break`, or `continue` inside a block in a match arm was "
"incorrectly missing a semicolon."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:271
#: src/rust-2024/rustfmt-formatting-fixes.md:284
msgid "\"\""
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:289
msgid "Long array and slice patterns are now wrapped"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:295
msgid "Long array and slice patterns were not getting wrapped properly."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:319
msgid "Format the last expression-statement as an expression"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:326
msgid ""
"The last statement in a block which is an expression is now formatted as an "
"expression."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:358
msgid "Same formatting between function and macro calls"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:364
msgid ""
"Some formatting is now the same in a macro invocation as it is in a function "
"call."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:404
msgid "Force block closures for closures with a single loop body"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:410
msgid "Closures with a single loop are now formatted as a block expression."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:417
#: src/rust-2024/rustfmt-formatting-fixes.md:428
msgid "\"iteration\""
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:434
msgid "Empty lines in where clauses are now removed"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:440
msgid "Empty lines in a `where` clause are now removed."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:465
msgid "Fixed formatting of a let-else statement with an attribute"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:471
msgid ""
"If a let-else statement had an attribute, then it would cause the `else` "
"clause to incorrectly wrap the `else` part separately."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:477
#: src/rust-2024/rustfmt-formatting-fixes.md:492
msgid "\"linux\""
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:483
#: src/rust-2024/rustfmt-formatting-fixes.md:495
msgid "// This is the same without an attribute.\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:500
msgid "Off-by-one error for wrapping enum variant doc comments"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:506
msgid ""
"When using the `wrap_comments` feature, the comments were being wrapped at a "
"column width off-by-one."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:512
#: src/rust-2024/rustfmt-formatting-fixes.md:535
msgid ""
"/// But here, this comment is 120 columns wide and the formatter wants to "
"split it up onto two separate lines still.\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:514
#: src/rust-2024/rustfmt-formatting-fixes.md:526
#: src/rust-2024/rustfmt-formatting-fixes.md:537
msgid ""
"/// This comment is 119 columns wide and works perfectly. Lorem ipsum. lorem "
"ipsum. lorem ipsum. lorem ipsum lorem.\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:523
msgid ""
"/// But here, this comment is 120 columns wide and the formatter wants to "
"split it up onto two separate lines\n"
"    /// still.\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:542
msgid "Off-by-one error for `format_macro_matchers`"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:548
msgid ""
"When using the `format_macro_matchers` feature, the matcher was being "
"wrapped at a column width off-by-one."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:572
msgid "Fixed failure with `=>` in comment after match `=>`"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:578
msgid ""
"In certain circumstances if a comment contained a `=>` after the `=>` in a "
"match expression, this would cause a failure to format correctly."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:586
#: src/rust-2024/rustfmt-formatting-fixes.md:600
msgid "// comment with =>\n"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:588
#: src/rust-2024/rustfmt-formatting-fixes.md:602
msgid "\"A\""
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:608
msgid "Multiple inner attributes in a match expression indented incorrectly"
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:614
msgid ""
"Multiple inner attributes in a match expression were being indented "
"incorrectly."
msgstr ""

#: src/rust-2024/rustfmt-formatting-fixes.md:642
#: src/rust-2024/rustfmt-raw-identifier-sorting.md:34
#: src/rust-2024/rustfmt-version-sorting.md:39
msgid ""
"The change can be applied automatically by running `cargo fmt` or `rustfmt` "
"with the 2024 Edition. See the [Style edition](rustfmt-style-edition.md) "
"chapter for more information on migrating and how style editions work."
msgstr ""

#: src/rust-2024/rustfmt-raw-identifier-sorting.md:5
msgid ""
"`rustfmt` now properly sorts [raw identifiers](../../reference/"
"identifiers.html#raw-identifiers)."
msgstr ""

#: src/rust-2024/rustfmt-raw-identifier-sorting.md:11
#: src/rust-2024/rustfmt-version-sorting.md:9
msgid ""
"The [Rust Style Guide](../../style-guide/index.html) includes [rules for "
"sorting](../../style-guide/index.html#sorting) that `rustfmt` applies in "
"various contexts, such as on imports."
msgstr ""

#: src/rust-2024/rustfmt-raw-identifier-sorting.md:13
msgid ""
"Prior to the 2024 Edition, when sorting rustfmt would use the leading `r#` "
"token instead of the ident which led to unwanted results. For example:"
msgstr ""

#: src/rust-2024/rustfmt-raw-identifier-sorting.md:21
#: src/rust-2024/rustfmt-version-sorting.md:27
msgid "In the 2024 Edition, `rustfmt` now produces:"
msgstr ""

#: src/rust-2024/rustfmt-version-sorting.md:5
msgid "`rustfmt` utilizes a new sorting algorithm."
msgstr ""

#: src/rust-2024/rustfmt-version-sorting.md:11
msgid ""
"Previous versions of the Style Guide and Rustfmt generally used an "
"\"ASCIIbetical\" based approach. In the 2024 Edition this is changed to use "
"a version-sort like algorithm that compares Unicode characters "
"lexicographically and provides better results in ASCII digit comparisons."
msgstr ""

#: src/rust-2024/rustfmt-version-sorting.md:13
msgid "For example with a given (unsorted) input:"
msgstr ""

#: src/rust-2024/rustfmt-version-sorting.md:20
msgid "In the prior Editions, `rustfmt` would have produced:"
msgstr ""
