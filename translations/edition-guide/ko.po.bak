msgstr "Rust 에디션 가이드"

msgstr "소개"

msgstr "에디션이란 무엇인가요?"

msgstr "새 프로젝트 생성하기"

msgstr "기존 프로젝트를 새 에디션으로 전환하기"

msgstr "고급 마이그레이션"

msgstr "Rust 2015"

msgstr "Rust 2018"

msgstr "경로 및 모듈 시스템 변경사항"

msgstr "익명 트레이트 함수 매개변수 사용 중단"

msgstr "새로운 키워드"

msgstr "추론 변수에 대한 원시 포인터의 메서드 디스패치"

msgstr "Cargo 변경사항"

msgstr "Rust 2021"

msgstr "프렐루드에 추가된 항목"

msgstr "기본 Cargo 기능 해결자"

msgstr "배열을 위한 IntoIterator"

msgstr "클로저에서의 분리된 캡처"

msgstr "Panic 매크로 일관성"

msgstr "예약된 구문"

msgstr "원시 라이프타임"

msgstr "오류로 승격된 경고"

msgstr "매크로 규칙에서의 OR 패턴"

msgstr "C 문자열 리터럴"

msgstr "Rust 2024"

msgstr "언어"

msgstr "RPIT 라이프타임 캡처 규칙"

msgstr "`if let` 임시 스코프"

msgstr "꼬리 표현식 임시 스코프"

msgstr "매치 인체공학 예약"

msgstr "안전하지 않은 `extern` 블록"

msgstr "안전하지 않은 속성"

msgstr "`unsafe_op_in_unsafe_fn` 경고"

msgstr "`static mut`에 대한 참조 금지"

msgstr "Never 타입 폴백 변경"

msgstr "매크로 프래그먼트 지정자"

msgstr "누락된 매크로 프래그먼트 지정자"

msgstr "`gen` 키워드"

msgstr "표준 라이브러리"

msgstr "프렐루드 변경사항"

msgstr "`Box<[T]>`에 대한 `IntoIterator` 추가"

msgstr "새로 안전하지 않은 함수"

msgstr "Cargo"

msgstr "Cargo: Rust 버전 인식 해결자"

msgstr "Cargo: 테이블 및 키 이름 일관성"

msgstr "Cargo: 사용되지 않는 상속된 기본 기능 거부"

msgstr "Rustdoc"

msgstr "Rustdoc 통합 테스트"

msgstr "Rustdoc 중첩 `include!` 변경"

msgstr "Rustfmt"

msgstr "Rustfmt: 스타일 에디션"

msgstr "Rustfmt: 포매팅 수정"

msgstr "Rustfmt: 원시 식별자 정렬"

msgstr "Rustfmt: 버전 정렬"

msgstr "Rust 에디션 가이드에 오신 것을 환영합니다! "에디션"은 하위 호환성을 깨뜨릴 수 있는 변경 사항을 언어에 도입하는 Rust의 방식입니다."

msgstr "이 가이드에서는 다음에 대해 설명합니다."

msgstr "에디션이란 무엇인가"

msgstr "각 에디션에 포함된 변경 사항"

msgstr "한 에디션에서 다른 에디션으로 코드를 마이그레이션하는 방법"

msgstr "에디션이란 무엇인가요?"

msgstr "2015년 5월, [Rust 1.0 릴리스](https://blog.rust-lang.org/2015/05/15/Rust-1.0.html)는 "[정체 없는 안정성](https://blog.rust-lang.org/2014/10/30/Stability.html)"을 핵심 Rust 원칙으로 확립했습니다. 그 이후로 Rust는 중요한 규칙을 약속했습니다. 기능이 [안정 버전을 통해 릴리스되면](https://doc.rust-lang.org/book/appendix-07-nightly-rust.html) 기여자는 향후 모든 릴리스에서 해당 기능을 계속 지원할 것입니다."

msgstr "그러나 언어에 하위 호환되지 않는 변경을 하는 것이 유용할 때가 있습니다. 일반적인 예는 새 키워드를 도입하는 것입니다. 예를 들어, 초기 버전의 Rust에는 `async` 및 `await` 키워드가 없었습니다."

msgstr "만약 Rust가 갑자기 이러한 새 키워드를 도입했다면 일부 코드가 깨졌을 것입니다. `let async = 1;`은 더 이상 작동하지 않을 것입니다."

msgstr "Rust는 이 문제를 해결하기 위해 **에디션**을 사용합니다. 하위 호환되지 않는 변경 사항이 있을 때, 다음 에디션으로 푸시됩니다. 에디션은 옵트인이므로, 기존 크레이트는 명시적으로 새 에디션으로 마이그레이션하지 않는 한 변경 사항을 사용하지 않습니다. 예를 들어, 최신 버전의 Rust는 2018 에디션 이상을 선택하지 않는 한 `async`를 키워드로 취급하지 않습니다."

msgstr "각 크레이트는 [`Cargo.toml` 파일 내에서](https://doc.rust-lang.org/cargo/reference/manifest.html#the-edition-field) 에디션을 선택합니다. Cargo로 새 크레이트를 만들 때, 자동으로 최신 안정 에디션을 선택합니다."

msgstr "에디션은 생태계를 분할하지 않습니다"

msgstr "에디션을 만들 때 가장 중요한 규칙이 하나 있습니다. 한 에디션의 크레이트는 다른 에디션으로 컴파일된 크레이트와 **반드시** 원활하게 상호 운용되어야 합니다."

msgstr "즉, 각 크레이트는 독립적으로 새 에디션으로 마이그레이션할 시기를 결정할 수 있습니다. 이 결정은 '비공개'이며 생태계의 다른 크레이트에 영향을 미치지 않습니다."

msgstr "Rust의 경우, 이러한 필수 호환성은 에디션에 포함될 수 있는 변경 종류에 몇 가지 제한을 의미합니다. 결과적으로, 새로운 Rust 에디션에서 발견되는 변경 사항은 '피상적인' 경향이 있습니다. 에디션에 관계없이 모든 Rust 코드는 궁극적으로 컴파일러 내에서 동일한 내부 표현으로 컴파일됩니다."

msgstr "에디션 마이그레이션은 쉽고 대부분 자동화됩니다"

msgstr "Rust는 새 에디션으로의 업그레이드를 쉬운 프로세스로 만드는 것을 목표로 합니다. 새 에디션이 출시되면 크레이트 작성자는 [`cargo` 내의 자동 마이그레이션 도구](https://doc.rust-lang.org/cargo/commands/cargo-fix.html)를 사용하여 마이그레이션할 수 있습니다. 그러면 Cargo는 새 버전과 호환되도록 코드에 사소한 변경을 합니다."

msgstr "예를 들어, Rust 2018로 마이그레이션할 때 `async`라는 이름의 모든 것은 이제 동등한 [원시 식별자 구문](https://doc.rust-lang.org/rust-by-example/compatibility/raw_identifiers.html)인 `r#async`를 사용합니다."

msgstr "Cargo의 자동 마이그레이션은 완벽하지 않습니다. 수동 변경이 필요한 예외적인 경우가 여전히 있을 수 있습니다. 코드의 정확성이나 성능에 영향을 줄 수 있는 의미 체계 변경을 피하는 것을 목표로 합니다."

msgstr "이 가이드에서 다루는 내용"

msgstr "도구 외에도 이 Rust 에디션 가이드는 각 에디션의 일부인 변경 사항도 다룹니다. 각 변경 사항을 설명하고 가능한 경우 추가 세부 정보에 대한 링크를 제공합니다. 또한 크레이트 작성자가 알아야 할 예외적인 경우나 까다로운 세부 정보도 다룹니다."

msgstr "크레이트 작성자는 다음을 찾아야 합니다."

msgstr "에디션 개요"

msgstr "특정 에디션에 대한 마이그레이션 가이드"

msgstr "자동화된 도구가 작동하지 않을 때를 위한 빠른 문제 해결 참조."

msgstr "Cargo로 생성된 새 프로젝트는 기본적으로 최신 에디션을 사용하도록 구성됩니다."

msgstr "```console
$ cargo new foo
    Creating binary (application) `foo` package
note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
$ cat foo/Cargo.toml
[package]
name = "foo"
version = "0.1.0"
edition = "2024"

[dependencies]
```"

msgstr "`edition = "2024"` 설정은 패키지가 Rust 2024 에디션을 사용하여 빌드되도록 구성합니다. 추가 구성이 필요하지 않습니다!"

msgstr "`cargo new`의 `--edition <YEAR>` 옵션을 사용하여 특정 에디션을 사용하는 프로젝트를 만들 수 있습니다. 예를 들어, Rust 2018 에디션을 사용하는 새 프로젝트를 만드는 것은 다음과 같이 할 수 있습니다."

msgstr "```console
$ cargo new --edition 2018 foo
    Creating binary (application) `foo` package
note: see more `Cargo.toml` keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
$ cat foo/Cargo.toml
[package]
name = "foo"
version = "0.1.0"
edition = "2018"

[dependencies]
```"

msgstr "실수로 에디션에 유효하지 않은 연도를 사용하는 것에 대해 걱정하지 마십시오. `cargo new` 호출은 유효하지 않은 에디션 연도 값을 허용하지 않습니다."

msgstr "`Cargo.toml` 파일을 편집하여 `edition` 키의 값을 변경할 수 있습니다. 예를 들어, 패키지가 Rust 2015 에디션을 사용하여 빌드되도록 하려면 다음 예와 같이 키를 설정합니다."

msgstr "```toml
[package]
name = "foo"
version = "0.1.0"
edition = "2015"

[dependencies]
```"

msgstr "Rust에는 프로젝트를 한 에디션에서 다음 에디션으로 자동으로 전환하는 도구가 포함되어 있습니다. 소스 코드를 다음 에디션과 호환되도록 업데이트합니다. 간단히 말해, 다음 에디션으로 업데이트하는 단계는 다음과 같습니다."

msgstr "`cargo update`를 실행하여 종속성을 최신 버전으로 업데이트하십시오."

msgstr "`cargo fix --edition` 실행"

msgstr "`Cargo.toml`을 편집하고 `edition` 필드를 다음 에디션으로 설정합니다(예: `edition = "2024"`)."

msgstr "`cargo build` 또는 `cargo test`를 실행하여 수정 사항이 작동하는지 확인합니다."

msgstr "`cargo fmt`를 실행하여 프로젝트를 다시 포맷합니다."

msgstr "다음 섹션에서는 이러한 단계의 세부 정보와 그 과정에서 발생할 수 있는 몇 가지 문제에 대해 자세히 설명합니다."

msgstr "새 에디션으로의 마이그레이션이 가능한 한 순조로운 경험이 되도록 하는 것이 저희의 의도입니다. 최신 에디션으로 업그레이드하기 어려운 경우 버그로 간주합니다. 이 프로세스에 문제가 발생하면 [버그 보고서를 제출](https://github.com/rust-lang/rust/issues/new/choose)해 주십시오. 감사합니다!"

msgstr "마이그레이션 시작"

msgstr "예를 들어, 2015 에디션에서 2018 에디션으로 전환하는 것을 살펴보겠습니다. 2021과 같은 다른 에디션으로 전환할 때도 단계는 기본적으로 동일합니다."

msgstr "`src/lib.rs`에 이 코드가 있는 크레이트가 있다고 상상해 보십시오."

msgstr "이 코드는 익명 매개변수인 `i32`를 사용합니다. 이것은 [Rust 2018에서 지원되지 않으므로](../rust-2018/trait-system/no-anon-params.md) 컴파일에 실패합니다. 이 코드를 최신 상태로 만들어 봅시다!"

msgstr "종속성 업데이트"

msgstr "시작하기 전에 종속성을 업데이트하는 것이 좋습니다. 일부 종속성, 특히 일부 proc-매크로 또는 빌드 타임 코드 생성을 수행하는 종속성은 최신 에디션과 호환성 문제가 있을 수 있습니다. 마지막으로 업데이트한 이후에 이러한 문제를 해결할 수 있는 새 릴리스가 만들어졌을 수 있습니다. 다음을 실행하십시오."

msgstr "업데이트 후 테스트를 실행하여 모든 것이 작동하는지 확인하는 것이 좋습니다. `git`과 같은 소스 제어 도구를 사용하는 경우 커밋의 논리적 분리를 유지하기 위해 이러한 변경 사항을 별도로 커밋할 수 있습니다."

msgstr "새 에디션과 호환되도록 코드 업데이트"

msgstr "코드가 새 에디션과 호환되지 않는 기능을 사용할 수도 있고 사용하지 않을 수도 있습니다. 다음 에디션으로의 전환을 돕기 위해 Cargo에는 소스 코드를 자동으로 업데이트하는 [`cargo fix`](../../cargo/commands/cargo-fix.html) 하위 명령이 포함되어 있습니다. 시작하려면 실행해 봅시다."

msgstr "이렇게 하면 코드를 확인하고 가능한 모든 문제를 자동으로 수정합니다. `src/lib.rs`를 다시 살펴보겠습니다."

msgstr "코드를 다시 작성하여 `i32` 값에 대한 매개변수 이름을 도입했습니다. 이 경우 이름이 없었기 때문에 `cargo fix`는 사용되지 않는 변수에 대한 관례인 `_`로 바꿉니다."

msgstr "`cargo fix`가 항상 코드를 자동으로 수정할 수 있는 것은 아닙니다. `cargo fix`가 무언가를 수정할 수 없는 경우 수정할 수 없다는 경고를 콘솔에 인쇄합니다. 이러한 경고 중 하나가 표시되면 코드를 수동으로 업데이트해야 합니다. 마이그레이션 프로세스 작업에 대한 자세한 내용은 [고급 마이그레이션 전략](advanced-migrations.md) 장을 참조하고 필요한 변경 사항을 설명하는 이 가이드의 장을 읽으십시오. 문제가 있는 경우 [사용자 포럼](https://users.rust-lang.org/)에서 도움을 요청하십시오."

msgstr "새 기능을 사용하기 위해 새 에디션 활성화"

msgstr "일부 새로운 기능을 사용하려면 새 에디션을 명시적으로 선택해야 합니다. 계속할 준비가 되면 `Cargo.toml`을 변경하여 새 `edition` 키/값 쌍을 추가하십시오. 예를 들어:"

msgstr "```toml
[package]
name = "foo"
version = "0.1.0"
edition = "2018"
```"

msgstr "`edition` 키가 없으면 Cargo는 기본적으로 Rust 2015를 사용합니다. 하지만 이 경우 `2018`을 선택했으므로 코드가 Rust 2018로 컴파일됩니다!"

msgstr "새 에디션에서 코드 테스트"

msgstr "다음 단계는 새 에디션에서 프로젝트를 테스트하는 것입니다. `cargo test`를 실행하는 것과 같이 프로젝트 테스트를 실행하여 모든 것이 여전히 작동하는지 확인하십시오. 새 경고가 발행되면 컴파일러에서 제공하는 제안을 적용하기 위해 `cargo fix`를 다시 실행( `--edition` 플래그 없이)하는 것을 고려할 수 있습니다."

msgstr "이 시점에서 여전히 일부 수동 변경이 필요할 수 있습니다. 예를 들어, 자동 마이그레이션은 doctest를 업데이트하지 않으며 빌드 타임 코드 생성 또는 매크로는 수동 업데이트가 필요할 수 있습니다. 자세한 내용은 [고급 마이그레이션 장](advanced-migrations.md)을 참조하십시오."

msgstr "축하합니다! 이제 코드가 Rust 2015와 Rust 2018 모두에서 유효합니다!"

msgstr "rustfmt로 다시 포맷하기"

msgstr "프로젝트 내에서 포맷을 자동으로 유지하기 위해 [rustfmt](https://github.com/rust-lang/rustfmt)를 사용하는 경우 새 에디션의 새 포맷 규칙을 사용하여 다시 포맷하는 것을 고려해야 합니다."

msgstr "다시 포맷하기 전에 `git`과 같은 소스 제어 도구를 사용하는 경우 이 단계를 수행하기 전에 지금까지 변경한 모든 내용을 커밋하는 것이 좋습니다. 포맷 변경 사항을 별도의 커밋에 넣는 것이 유용할 수 있습니다. 그러면 어떤 변경 사항이 단지 포맷인지 다른 코드 변경 사항인지 확인할 수 있고 `git blame`에서 포맷 변경 사항을 무시할 수도 있습니다."

msgstr "자세한 내용은 [스타일 에디션 장](../rust-2024/rustfmt-style-edition.md)을 참조하십시오."

msgstr "불안정한 에디션으로 마이그레이션"

msgstr "에디션이 출시된 후 다음 에디션까지는 대략 3년의 기간이 있습니다. 그 기간 동안 다음 에디션에 새로운 기능이 추가될 수 있으며, 이는 [nightly 채널](../../book/appendix-07-nightly-rust.html)에서만 사용할 수 있습니다. 안정화되기 전에 이러한 새로운 기능을 테스트하는 데 도움을 주고 싶다면 nightly 채널을 사용하여 사용해 볼 수 있습니다."

msgstr "단계는 안정 채널과 거의 유사합니다."

msgstr "최신 nightly 설치: `rustup update nightly`."

msgstr "`cargo +nightly fix --edition` 실행."

msgstr "`Cargo.toml`을 편집하고 맨 위에( `[package]` 위) `cargo-features = ["edition20xx"]`를 배치하고 edition 필드를 `edition = "20xx"`로 변경합니다. 여기서 `20xx`는 업그레이드하는 에디션입니다."

msgstr "`cargo +nightly check`를 실행하여 새 에디션에서 작동하는지 확인합니다."

msgstr "**⚠ 주의**: 다음 에디션에 구현된 기능에는 `cargo fix`로 구현된 자동 마이그레이션이 없을 수 있으며 기능 자체가 완료되지 않았을 수 있습니다. 가능하면 이 가이드에는 상태에 대한 자세한 정보와 함께 nightly에 구현된 기능에 대한 정보가 포함되어야 합니다. 에디션이 안정화되기 몇 달 전에 모든 새로운 기능이 완전히 구현되어야 하며 [Rust 블로그](https://blog.rust-lang.org/)에서 테스트 요청을 발표할 것입니다."

msgstr "고급 마이그레이션 전략"

msgstr "마이그레이션 작동 방식"

msgstr "[`cargo fix --edition`](../../cargo/commands/cargo-fix.html)은 다음 에디션에서 컴파일되지 않을 수 있는 코드를 감지하는 특수 [lints](../../rustc/lints/index.html)가 활성화된 상태에서 프로젝트에서 [`cargo check`](../../cargo/commands/cargo-check.html)와 동등한 것을 실행하여 작동합니다. 이러한 린트에는 현재 및 다음 에디션 모두에서 호환되도록 코드를 수정하는 방법에 대한 지침이 포함되어 있습니다. `cargo fix`는 이러한 변경 사항을 소스 코드에 적용한 다음 `cargo check`를 다시 실행하여 수정 사항이 작동하는지 확인합니다. 수정 사항이 실패하면 변경 사항을 되돌리고 경고를 표시합니다."

msgstr "코드를 현재 및 다음 에디션 모두와 동시에 호환되도록 변경하면 코드를 점진적으로 마이그레이션하기가 더 쉬워집니다. 자동화된 마이그레이션이 완전히 성공하지 못하거나 수동 도움이 필요한 경우 `Cargo.toml`을 다음 에디션을 사용하도록 변경하기 전에 원래 에디션에 머무르면서 반복할 수 있습니다."

msgstr "`cargo fix --edition`이 적용하는 린트는 [린트 그룹](../../rustc/lints/groups.html)의 일부입니다. 예를 들어, 2018에서 2021로 마이그레이션할 때 Cargo는 `rust-2021-compatibility` 린트 그룹을 사용하여 코드를 수정합니다. 마이그레이션에 도움이 되는 개별 린트 사용에 대한 팁은 아래 [부분 마이그레이션](#partial-migration-with-broken-code) 섹션을 확인하십시오."

msgstr "`cargo fix`는 `cargo check`를 여러 번 실행할 수 있습니다. 예를 들어, 한 세트의 수정 사항을 적용한 후 추가 수정이 필요한 새 경고가 트리거될 수 있습니다. Cargo는 새 경고가 생성되지 않을 때까지 이 작업을 반복합니다."

msgstr "여러 구성 마이그레이션"

msgstr "`cargo fix`는 한 번에 하나의 구성으로만 작동할 수 있습니다. [Cargo 기능](../../cargo/reference/features.html) 또는 [조건부 컴파일](../../reference/conditional-compilation.html)을 사용하는 경우 다른 플래그로 `cargo fix`를 여러 번 실행해야 할 수 있습니다."

msgstr "예를 들어, `#[cfg]` 속성을 사용하여 다른 플랫폼에 대해 다른 코드를 포함하는 코드가 있는 경우 다른 대상에 대해 수정하기 위해 `--target` 옵션으로 `cargo fix`를 실행해야 할 수 있습니다. 교차 컴파일을 사용할 수 없는 경우 시스템 간에 코드를 이동해야 할 수 있습니다."

msgstr "마찬가지로, `#[cfg(feature = "my-optional-thing")]`과 같이 Cargo 기능에 조건이 있는 경우 `--all-features` 플래그를 사용하여 `cargo fix`가 해당 기능 게이트 뒤의 모든 코드를 마이그레이션하도록 허용하는 것이 좋습니다. 기능 코드를 개별적으로 마이그레이션하려면 `--features` 플래그를 사용하여 한 번에 하나씩 마이그레이션할 수 있습니다."

msgstr "대규모 프로젝트 또는 작업 공간 마이그레이션"

msgstr "문제가 발생하면 대규모 프로젝트를 점진적으로 마이그레이션하여 프로세스를 더 쉽게 만들 수 있습니다."

msgstr "[Cargo 작업 공간](../../cargo/reference/workspaces.html)에서 각 패키지는 자체 에디션을 정의하므로 프로세스는 자연스럽게 한 번에 하나의 패키지를 마이그레이션하는 것을 포함합니다."

msgstr "[Cargo 패키지](../../cargo/reference/manifest.html#the-package-section) 내에서 전체 패키지를 한 번에 마이그레이션하거나 개별 [Cargo 대상](../../cargo/reference/cargo-targets.html)을 한 번에 하나씩 마이그레이션할 수 있습니다. 예를 들어, 여러 바이너리, 테스트 및 예제가 있는 경우 `cargo fix --edition`과 함께 특정 대상 선택 플래그를 사용하여 해당 대상 하나만 마이그레이션할 수 있습니다. 기본적으로 `cargo fix`는 `--all-targets`를 사용합니다."

msgstr "더 고급 사례의 경우 `Cargo.toml`에서 각 개별 대상에 대한 에디션을 다음과 같이 지정할 수 있습니다."

msgstr "```toml
[[bin]]
name = "my-binary"
edition = "2018"
```"

msgstr "이것은 일반적으로 필요하지 않지만 대상이 많고 모두 함께 마이그레이션하는 데 어려움이 있는 경우 옵션입니다."

msgstr "손상된 코드로 부분 마이그레이션"

msgstr "때때로 컴파일러에서 제안한 수정 사항이 작동하지 않을 수 있습니다. 이런 일이 발생하면 Cargo는 무슨 일이 일어났는지와 오류가 무엇인지 나타내는 경고를 보고합니다. 그러나 기본적으로 변경 사항을 자동으로 되돌립니다. 코드를 손상된 상태로 유지하고 문제를 수동으로 해결하는 것이 도움이 될 수 있습니다. 일부 수정 사항은 정확했을 수 있으며 손상된 수정 사항은 _대부분_ 정확하지만 약간의 조정만 필요할 수 있습니다."

msgstr "이 상황에서는 `cargo fix`와 함께 `--broken-code` 옵션을 사용하여 Cargo에 변경 사항을 되돌리지 않도록 지시하십시오. 그런 다음 수동으로 오류를 검사하고 수정하는 데 필요한 사항을 조사할 수 있습니다."

msgstr "프로젝트를 점진적으로 마이그레이션하는 또 다른 옵션은 개별 수정 사항을 한 번에 하나씩 별도로 적용하는 것입니다. 개별 린트를 경고로 추가한 다음 `cargo fix`(`--edition` 플래그 없이)를 실행하거나 편집기 또는 IDE가 "빠른 수정"을 지원하는 경우 해당 제안을 적용하여 이 작업을 수행할 수 있습니다."

msgstr "예를 들어, 2018 에디션은 [`keyword-idents`](../../rustc/lints/listing/allowed-by-default.html#keyword-idents) 린트를 사용하여 충돌하는 키워드를 수정합니다. 각 크레이트의 맨 위에(예: `src/lib.rs` 또는 `src/main.rs`의 맨 위) `#![warn(keyword_idents)]`를 추가할 수 있습니다. 그런 다음 `cargo fix`를 실행하면 해당 린트에 대한 제안만 적용됩니다."

msgstr "[린트 그룹](../../rustc/lints/groups.html) 페이지에서 각 에디션에 대해 활성화된 린트 목록을 보거나 `rustc -Whelp` 명령을 실행할 수 있습니다."

msgstr "매크로 마이그레이션"

msgstr "일부 매크로는 다음 에디션을 위해 수정하기 위해 수동 작업이 필요할 수 있습니다. 예를 들어, `cargo fix --edition`은 다음 에디션에서 작동하지 않는 구문을 생성하는 매크로를 자동으로 수정하지 못할 수 있습니다."

msgstr "이것은 [proc 매크로](../../reference/procedural-macros.html)와 `macro_rules` 스타일 매크로 모두에 문제가 될 수 있습니다. `macro_rules` 매크로는 동일한 크레이트 내에서 매크로가 사용되는 경우 때때로 자동으로 업데이트될 수 있지만, 그렇지 않은 경우도 여러 있습니다. 일반적으로 Proc 매크로는 자동으로 수정할 수 없습니다."

msgstr ""it is {}""

msgstr "이 매크로가 2015 크레이트에 정의된 경우 매크로 위생(아래에서 설명)으로 인해 다른 에디션의 크레이트에서 사용할 수 있습니다. 2015년에는 `dyn`이 일반 식별자이며 제한 없이 사용할 수 있습니다."

msgstr "그러나 2018년에는 `dyn`이 더 이상 유효한 식별자가 아닙니다. `cargo fix --edition`을 사용하여 2018로 마이그레이션할 때 Cargo는 경고나 오류를 전혀 표시하지 않습니다. 그러나 `foo`는 어떤 크레이트에서 호출해도 작동하지 않습니다."

msgstr "매크로가 있는 경우 매크로의 구문을 완전히 다루는 테스트가 있는지 확인하는 것이 좋습니다. 또한 여러 에디션의 크레이트에서 매크로를 가져와 사용하여 모든 곳에서 올바르게 작동하는지 확인하는 것이 좋습니다. 문제가 발생하면 이 가이드의 장을 읽고 모든 에디션에서 작동하도록 코드를 변경하는 방법을 이해해야 합니다."

msgstr "매크로 위생"

msgstr "매크로는 매크로 내의 토큰이 어떤 에디션에서 왔는지 표시되는 "에디션 위생"이라는 시스템을 사용합니다. 이를 통해 외부 매크로를 호출하는 에디션에 대해 걱정할 필요 없이 다양한 에디션의 크레이트에서 호출할 수 있습니다."

msgstr "`dyn`을 식별자로 사용하는 `macro_rules` 매크로를 정의하는 위의 예를 자세히 살펴보겠습니다. 해당 매크로가 2015 에디션을 사용하는 크레이트에 정의된 경우 `dyn`이 키워드이고 일반적으로 구문 오류가 발생하는 2018 크레이트에서 호출되더라도 해당 매크로는 잘 작동합니다. `let dyn = 1;` 토큰은 2015년산으로 표시되며 컴파일러는 해당 코드가 확장되는 모든 곳에서 이를 기억합니다. 파서는 토큰의 에디션을 보고 해석 방법을 알 수 있습니다."

msgstr "문제는 정의된 크레이트에서 에디션을 2018로 변경할 때 발생합니다. 이제 해당 토큰은 2018 에디션으로 태그가 지정되며 구문 분석에 실패합니다. 그러나 크레이트에서 매크로를 호출한 적이 없기 때문에 `cargo fix --edition`은 매크로를 검사하고 수정할 기회가 없었습니다."

msgstr "문서 테스트"

msgstr "현재 `cargo fix`는 [문서 테스트](https://doc.rust-lang.org/rustdoc/write-documentation/documentation-tests.html)를 업데이트할 수 없습니다. `Cargo.toml`에서 에디션을 업데이트한 후 `cargo test`를 실행하여 모든 것이 여전히 통과하는지 확인해야 합니다. 문서 테스트가 새 에디션에서 지원되지 않는 구문을 사용하는 경우 수동으로 업데이트해야 합니다."

msgstr "드문 경우지만 각 테스트에 대해 에디션을 수동으로 설정할 수 있습니다. 예를 들어, 삼중 백틱에 [`edition2018` 주석](https://doc.rust-lang.org/rustdoc/documentation-tests.html#attributes)을 사용하여 `rustdoc`에 사용할 에디션을 알릴 수 있습니다."

msgstr "생성된 코드"

msgstr "자동 수정이 적용될 수 없는 또 다른 영역은 컴파일 타임에 Rust 코드를 생성하는 빌드 스크립트가 있는 경우입니다(예는 [코드 생성](https://doc.rust-lang.org/cargo/reference/build-script-examples.html#code-generation) 참조). 이 상황에서 다음 에디션에서 작동하지 않는 코드가 생기면 호환되는 코드를 생성하도록 빌드 스크립트를 수동으로 변경해야 합니다."

msgstr "비-Cargo 프로젝트 마이그레이션"

msgstr "프로젝트가 빌드 시스템으로 Cargo를 사용하지 않는 경우에도 자동화된 린트를 사용하여 다음 에디션으로 마이그레이션하는 데 도움을 받을 수 있습니다. 적절한 [린트 그룹](https://doc.rust-lang.org/rustc/lints/groups.html)을 활성화하여 위에서 설명한 대로 마이그레이션 린트를 활성화할 수 있습니다. 예를 들어, `#![warn(rust_2021_compatibility)]` 속성 또는 `-Wrust-2021-compatibility` 또는 `--force-warns=rust-2021-compatibility` [CLI 플래그](https://doc.rust-lang.org/rustc/lints/levels.html#via-compiler-flag)를 사용할 수 있습니다."

msgstr "다음 단계는 해당 린트를 코드에 적용하는 것입니다. 여기에는 몇 가지 옵션이 있습니다."

msgstr "경고를 수동으로 읽고 컴파일러에서 권장하는 제안을 적용합니다."

msgstr "제안을 자동으로 적용하는 것을 지원하는 편집기나 IDE를 사용하십시오. 예를 들어, [Rust Analyzer 확장](https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer)이 포함된 [Visual Studio Code](https://code.visualstudio.com/)는 "빠른 수정" 링크를 사용하여 제안을 자동으로 적용하는 기능이 있습니다. 다른 많은 편집기와 IDE에도 유사한 기능이 있습니다."

msgstr "[`rustfix`](https://crates.io/crates/rustfix) 라이브러리를 사용하여 마이그레이션 도구를 작성하십시오. 이것은 Cargo가 내부적으로 컴파일러에서 [JSON 메시지](https://doc.rust-lang.org/rustc/json.html)를 가져와 소스 코드를 수정하는 데 사용하는 라이브러리입니다. 라이브러리 사용 방법에 대한 예는 [`examples` 디렉토리](https://github.com/rust-lang/cargo/tree/master/crates/rustfix/examples)를 확인하십시오."

msgstr "새 에디션에서 관용적인 코드 작성"

msgstr "에디션은 새로운 기능을 추가하고 오래된 기능을 제거하는 것만이 아닙니다. 모든 프로그래밍 언어에서 관용구는 시간이 지남에 따라 변하며 Rust도 예외는 아닙니다. 이전 코드는 계속 컴파일되지만 오늘날에는 다른 관용구로 작성될 수 있습니다."

msgstr "예를 들어, Rust 2015에서는 외부 크레이트를 다음과 같이 `extern crate`로 나열해야 합니다."

msgstr "// src/lib.rs
"

msgstr "Rust 2018에서는 [더 이상 포함할 필요가 없습니다](../rust-2018/path-changes.md#no-more-extern-crate)."

msgstr "`cargo fix`에는 이러한 관용구 중 일부를 새 구문으로 자동 전환하는 `--edition-idioms` 옵션이 있습니다."

msgstr "**경고**: 현재 _"관용구 린트"_에는 몇 가지 문제가 있는 것으로 알려져 있습니다. 컴파일에 실패할 수 있는 잘못된 제안을 할 수 있습니다. 현재 린트는 다음과 같습니다."

msgstr "2018 에디션:"

msgstr "[`unused-extern-crates`](../../rustc/lints/listing/allowed-by-default.html#unused-extern-crates)"

msgstr "[`explicit-outlives-requirements`](../../rustc/lints/listing/allowed-by-default.html#explicit-outlives-requirements)"

msgstr "2021 에디션에는 관용구 린트가 없습니다."

msgstr "다음 지침은 몇 가지 컴파일러/Cargo 버그를 해결하려는 용감한 사람들에게만 권장됩니다! 문제가 발생하면 [위에서 설명한](#partial-migration-with-broken-code) `--broken-code` 옵션을 사용하여 가능한 한 많은 진전을 이룬 다음 나머지 문제를 수동으로 해결할 수 있습니다."

msgstr "이제 Cargo에 코드 스니펫을 수정하도록 지시할 수 있습니다."

msgstr "그런 다음 `src/lib.rs`의 `extern crate rand;` 줄이 제거됩니다."

msgstr "이제 더 관용적이 되었고 코드를 수동으로 수정할 필요가 없었습니다!"

msgstr "Rust 2015의 주제는 "안정성"입니다. 1.0 릴리스와 함께 시작되었으며 "기본 에디션"입니다. 에디션 시스템은 2017년 후반에 고안되었지만 Rust 1.0은 2015년 5월에 출시되었습니다. 따라서 2015는 하위 호환성을 위해 특정 에디션을 지정하지 않을 때 얻는 에디션입니다."

msgstr ""안정성"은 Rust 2015의 주제입니다. 왜냐하면 1.0은 Rust 개발에 큰 변화를 가져왔기 때문입니다. Rust 1.0 이전에는 Rust가 매일 바뀌었습니다. 이로 인해 Rust로 대규모 소프트웨어를 작성하기가 매우 어려웠고 배우기도 어려웠습니다. Rust 1.0 및 Rust 2015 릴리스를 통해 우리는 하위 호환성을 약속하여 사람들이 프로젝트를 구축할 수 있는 견고한 기반을 보장했습니다."

msgstr "기본 에디션이므로 코드를 Rust 2015로 포팅할 방법이 없습니다. 그냥 _그렇습니다_. 2015에서 _벗어나_ 전환하게 되지만 실제로 2015로 _전환_하지는 않습니다. 따라서 그것에 대해 더 이상 할 말이 없습니다!"

msgstr "정보"

msgstr "RFC"

msgstr "[\#2052](https://rust-lang.github.io/rfcs/2052-epochs.html), 에디션 시스템도 제안함"

msgstr "릴리스 버전"

msgstr "[1.31.0](https://blog.rust-lang.org/2018/12/06/Rust-1.31-and-rust-2018.html)"

msgstr "에디션 시스템은 Rust 2018 릴리스를 위해 만들어졌습니다. Rust 2018 에디션 릴리스는 _생산성_이라는 주제를 중심으로 조정된 여러 다른 기능과 동시에 이루어졌습니다. 이러한 기능의 대부분은 하위 호환이 가능하며 이제 모든 에디션에서 사용할 수 있습니다. 그러나 이러한 변경 사항 중 일부는 에디션 메커니즘이 필요했습니다(가장 주목할 만한 것은 [모듈 시스템 변경](path-changes.md)입니다)."

msgstr "![최소 Rust 버전: 1.31](https://img.shields.io/badge/Minimum%20Rust%20Version-1.31-brightgreen.svg)"

msgstr "요약"

msgstr "`use` 선언의 경로는 이제 다른 경로와 동일하게 작동합니다."

msgstr "`::`로 시작하는 경로는 이제 외부 크레이트가 뒤따라야 합니다."

msgstr "`pub(in path)` 가시성 한정자의 경로는 이제 `crate`, `self` 또는 `super`로 시작해야 합니다."

msgstr "동기"

msgstr "모듈 시스템은 종종 Rust를 처음 접하는 사람들에게 가장 어려운 것 중 하나입니다. 물론 모든 사람이 마스터하는 데 시간이 걸리는 자신만의 것이 있지만, 많은 사람들에게 혼란스러운 근본적인 원인이 있습니다. 모듈 시스템을 정의하는 간단하고 일관된 규칙이 있지만 그 결과는 일관성이 없고 직관에 반하며 신비롭게 느껴질 수 있습니다."

msgstr "따라서 2018 에디션의 Rust는 몇 가지 새로운 모듈 시스템 기능을 도입하지만, 결국 모듈 시스템을 _단순화_하여 무슨 일이 일어나고 있는지 더 명확하게 만듭니다."

msgstr "간단한 요약은 다음과 같습니다."

msgstr "`extern crate`는 99%의 경우에 더 이상 필요하지 않습니다."

msgstr "`crate` 키워드는 현재 크레이트를 나타냅니다."

msgstr "경로는 하위 모듈 내에서도 크레이트 이름으로 시작할 수 있습니다."

msgstr "`::`로 시작하는 경로는 외부 크레이트를 참조해야 합니다."

msgstr "`foo.rs`와 `foo/` 하위 디렉토리가 공존할 수 있습니다. 하위 모듈을 하위 디렉토리에 배치할 때 `mod.rs`는 더 이상 필요하지 않습니다."

msgstr "`use` 선언의 경로는 다른 경로와 동일하게 작동합니다."

msgstr "이렇게 말하면 임의의 새로운 규칙처럼 보일 수 있지만, 이제 정신 모델이 전반적으로 크게 단순화되었습니다. 자세한 내용은 계속 읽어보십시오!"

msgstr "자세한 내용"

msgstr "각 새로운 기능에 대해 차례로 이야기해 봅시다."

msgstr "`extern crate` 더 이상 없음"

msgstr "이것은 매우 간단합니다. 더 이상 프로젝트에 크레이트를 가져오기 위해 `extern crate`를 작성할 필요가 없습니다. 이전:"

msgstr "// Rust 2015
"

msgstr "이후:"

msgstr "// Rust 2018
"

msgstr "이제 프로젝트에 새 크레이트를 추가하려면 `Cargo.toml`에 추가하면 두 번째 단계가 없습니다. Cargo를 사용하지 않는 경우 이미 `--extern` 플래그를 전달하여 `rustc`에 외부 크레이트의 위치를 제공해야 했으므로 거기서 하던 일을 계속하면 됩니다."

msgstr "예외"

msgstr "이 규칙에는 한 가지 예외가 있는데, 바로 "sysroot" 크레이트입니다. 이것들은 Rust 자체와 함께 배포되는 크레이트입니다."

msgstr "일반적으로 이것들은 매우 특수한 상황에서만 필요합니다. 1.41부터 `rustc`는 `extern crate`와 유사한 방식으로 주어진 크레이트 이름을 자동으로 추가하는 `--extern=CRATE_NAME` 플래그를 허용합니다. 빌드 도구는 이를 사용하여 sysroot 크레이트를 크레이트의 프렐루드에 주입할 수 있습니다. Cargo는 `proc_macro` 크레이트에 사용하지만 이를 표현하는 일반적인 방법이 없습니다."

msgstr "sysroot 크레이트를 명시적으로 가져와야 하는 몇 가지 예는 다음과 같습니다."

msgstr "[`std`](../../std/index.html): 일반적으로 이것은 필요하지 않습니다. 왜냐하면 `std`는 크레이트가 [`#![no_std]`](../../reference/names/preludes.html#the-no_std-attribute)로 표시되지 않는 한 자동으로 가져오기 때문입니다."

msgstr "[`core`](../../core/index.html): 일반적으로 이것은 필요하지 않습니다. 왜냐하면 `core`는 크레이트가 [`#![no_core]`](https://github.com/rust-lang/rust/issues/29639)로 표시되지 않는 한 자동으로 가져오기 때문입니다. 예를 들어, 표준 라이브러리 자체에서 사용하는 일부 내부 크레이트에는 이것이 필요합니다."

msgstr "[`proc_macro`](../../proc_macro/index.html): 1.42부터 proc-macro 크레이트인 경우 Cargo에서 자동으로 가져옵니다. 이전 릴리스를 지원하거나 `rustc`에 적절한 `--extern` 플래그를 전달하지 않는 다른 빌드 도구를 사용하는 경우 `extern crate proc_macro;`가 필요합니다."

msgstr "[`alloc`](../../alloc/index.html): `alloc` 크레이트의 항목은 일반적으로 `std` 크레이트의 재내보내기를 통해 액세스됩니다. 할당을 지원하는 `no_std` 크레이트로 작업하는 경우 `alloc`을 명시적으로 가져와야 할 수 있습니다."

msgstr "[`test`](../../test/index.html): 이것은 [nightly 채널](https://doc.rust-lang.org/book/appendix-07-nightly-rust.html)에서만 사용할 수 있으며 일반적으로 불안정한 벤치마크 지원에만 사용됩니다."

msgstr "매크로"

msgstr "`extern crate`의 또 다른 용도는 매크로를 가져오는 것이었습니다. 더 이상 필요하지 않습니다. 매크로는 다른 항목과 마찬가지로 `use`로 가져올 수 있습니다. 예를 들어, 다음과 같은 `extern crate` 사용:"

msgstr "다음과 같이 변경할 수 있습니다."

msgstr "크레이트 이름 바꾸기"

msgstr "다음과 같이 `as`를 사용하여 크레이트 이름을 바꾸고 있었다면:"

msgstr "`extern crate` 줄을 자체적으로 제거하는 것은 작동하지 않습니다. 다음과 같이 해야 합니다."

msgstr "이 변경은 `f`를 사용하는 모든 모듈에서 발생해야 합니다."

msgstr "`crate` 키워드는 현재 크레이트를 나타냅니다."

msgstr "`use` 선언 및 기타 코드에서 `crate::` 접두사를 사용하여 현재 크레이트의 루트를 참조할 수 있습니다. 예를 들어, `crate::foo::bar`는 동일한 크레이트의 다른 곳에서 항상 `foo` 모듈 내의 `bar` 이름을 참조합니다."

msgstr "이전에는 접두사 `::`가 크레이트 루트 또는 외부 크레이트를 참조했지만 이제는 명확하게 외부 크레이트를 참조합니다. 예를 들어, `::foo::bar`는 항상 외부 크레이트 `foo` 내의 `bar` 이름을 참조합니다."

msgstr "외부 크레이트 경로"

msgstr "이전에는 `use` 가져오기 없이 모듈에서 외부 크레이트를 사용하려면 경로에 선행 `::`가 필요했습니다."

msgstr "// 이것은 크레이트 루트에서 작동합니다
"

msgstr "// 그러나 하위 모듈에서는 `use`로 가져오지 않으면 선행 ::가 필요합니다
"

msgstr "이제 외부 크레이트 이름은 하위 모듈을 포함하여 전체 크레이트의 범위에 있습니다."

msgstr "// 크레이트는 하위 모듈에서도 직접 참조할 수 있습니다
"

msgstr "외부 크레이트와 이름이 같은 로컬 모듈이나 항목이 있는 경우 해당 이름으로 시작하는 경로는 로컬 모듈이나 항목을 참조하는 것으로 간주됩니다. 외부 크레이트를 명시적으로 참조하려면 `::name` 형식을 사용하십시오."

msgstr "`mod.rs` 더 이상 없음"

msgstr "Rust 2015에서 하위 모듈이 있는 경우:"

msgstr "// 이 `mod` 선언은 `foo` 모듈을
// `foo.rs` 또는 `foo/mod.rs`에서 찾습니다.
"

msgstr "`foo.rs` 또는 `foo/mod.rs`에 있을 수 있습니다. 자체 하위 모듈이 있는 경우 _반드시_ `foo/mod.rs`여야 합니다. 따라서 `foo`의 `bar` 하위 모듈은 `foo/bar.rs`에 있습니다."

msgstr "Rust 2018에서는 하위 모듈이 있는 모듈의 이름이 `mod.rs`여야 한다는 제한이 해제되었습니다. `foo.rs`는 그냥 `foo.rs`일 수 있으며 하위 모듈은 여전히 `foo/bar.rs`입니다. 이렇게 하면 특수 이름이 제거되고 편집기에서 여러 파일을 열어두면 `mod.rs`라는 이름의 여러 탭 대신 이름을 명확하게 볼 수 있습니다."

msgstr "`use` 경로"

msgstr "![최소 Rust 버전: 1.32](https://img.shields.io/badge/Minimum%20Rust%20Version-1.32-brightgreen.svg)"

msgstr "Rust 2018은 Rust 2015에 비해 경로 처리를 단순화하고 통합합니다. Rust 2015에서는 `use` 선언의 경로가 다른 곳과 다르게 작동합니다. 특히 `use` 선언의 경로는 항상 크레이트 루트에서 시작하는 반면 다른 코드의 경로는 암시적으로 현재 범위에서 시작했습니다. 이러한 차이점은 최상위 모듈에 영향을 미치지 않았으므로 하위 모듈이 있는 충분히 큰 프로젝트에서 작업할 때까지 모든 것이 간단해 보였습니다."

msgstr "Rust 2018에서는 `use` 선언 및 기타 코드의 경로가 최상위 모듈과 모든 하위 모듈에서 동일하게 작동합니다. 현재 범위의 상대 경로, 외부 크레이트 이름으로 시작하는 경로 또는 `::`, `crate`, `super` 또는 `self`로 시작하는 경로를 사용할 수 있습니다."

msgstr "다음과 같이 보이는 코드:"

msgstr "`extern crate` 줄을 삭제할 수 있다는 점을 제외하고 Rust 2018에서도 똑같이 보일 것입니다."

msgstr "동일한 코드는 하위 모듈에서도 완전히 수정되지 않은 상태로 작동합니다."

msgstr "이렇게 하면 프로젝트에서 코드를 쉽게 이동할 수 있고 다중 모듈 프로젝트에 추가적인 복잡성을 도입하는 것을 방지할 수 있습니다."

msgstr "[트레이트 함수 매개변수](https://doc.rust-lang.org/stable/reference/items/traits.html#parameter-patterns)는 함수에 본문이 있을 때 모든 반박할 수 없는 패턴을 사용할 수 있습니다."

msgstr "세부 정보"

msgstr "RFC [\#1685](https://github.com/rust-lang/rfcs/pull/1685)에 따라 트레이트 메서드 선언의 매개변수는 더 이상 익명으로 허용되지 않습니다."

msgstr "예를 들어, 2015 에디션에서는 이것이 허용되었습니다."

msgstr "2018 에디션에서는 모든 매개변수에 인수 이름이 지정되어야 합니다(단지 `_`인 경우에도)."

msgstr "![최소 Rust 버전: 1.27](https://img.shields.io/badge/Minimum%20Rust%20Version-1.27-brightgreen.svg)"

msgstr "`dyn`은 [엄격한 키워드](https://doc.rust-lang.org/reference/keywords.html#strict-keywords)이며, 2015년에는 [약한 키워드](https://doc.rust-lang.org/reference/keywords.html#weak-keywords)입니다."

msgstr "`async` 및 `await`는 [엄격한 키워드](https://doc.rust-lang.org/reference/keywords.html#strict-keywords)입니다."

msgstr "`try`는 [예약된 키워드](https://doc.rust-lang.org/reference/keywords.html#reserved-keywords)입니다."

msgstr "트레이트 객체를 위한 `dyn Trait`"

msgstr "`dyn Trait` 기능은 트레이트 객체를 사용하기 위한 새로운 구문입니다. 간단히 말해서:"

msgstr "`Box<Trait>`는 `Box<dyn Trait>`가 됩니다."

msgstr "`&Trait` 및 `&mut Trait`는 `&dyn Trait` 및 `&mut dyn Trait`가 됩니다."

msgstr "등등. 코드에서:"

msgstr "// 이전
"

msgstr "// 새로운
"

msgstr "그게 다입니다!"

msgstr "왜?"

msgstr "트레이트 객체에 트레이트 이름만 사용하는 것은 잘못된 결정으로 판명되었습니다. 현재 구문은 베테랑에게도 종종 모호하고 혼란스러우며, 대안보다 더 자주 사용되지 않고, 때로는 더 느리며, 대안을 사용할 수 있을 때 전혀 사용할 수 없는 기능을 선호합니다."

msgstr "또한 `impl Trait`가 등장하면서 "`impl Trait` 대 `dyn Trait`"는 "`impl Trait` 대 `Trait`"보다 훨씬 대칭적이므로 조금 더 좋습니다. `impl Trait`는 [여기](https://doc.rust-lang.org/rust-by-example/trait/impl_trait.html)에서 설명합니다."

msgstr "따라서 새 에디션에서는 트레이트 객체가 필요한 경우 `Trait` 대신 `dyn Trait`를 선호해야 합니다."

msgstr "`async` 및 `await`"

msgstr "이러한 키워드는 Rust의 async-await 기능을 구현하기 위해 예약되었으며, 궁극적으로 [1.39.0에서 안정 버전으로 출시되었습니다](https://blog.rust-lang.org/2019/11/07/Async-await-stable.html)."

msgstr "`try` 키워드"

msgstr "`try` 키워드는 `try` 블록에서 사용하기 위해 예약되었으며, (이 글을 쓰는 시점에는) 안정화되지 않았습니다([추적 문제](https://github.com/rust-lang/rust/issues/31436))."

msgstr "[`tyvar_behind_raw_pointer`](https://github.com/rust-lang/rust/issues/46906) 린트는 이제 하드 오류입니다."

msgstr "자세한 내용은 Rust 문제 [\#46906](https://github.com/rust-lang/rust/issues/46906)을 참조하십시오."

msgstr "`Cargo.toml` 매니페스트에 대상 정의가 있는 경우 더 이상 다른 대상의 자동 검색을 자동으로 비활성화하지 않습니다."

msgstr "`path` 필드가 설정되지 않은 대상에 대해 `src/{target_name}.rs` 형식의 대상 경로는 더 이상 유추되지 않습니다."

msgstr "현재 디렉토리에 대한 `cargo install`은 더 이상 허용되지 않으며, 현재 패키지를 설치하려면 `cargo install --path .`를 지정해야 합니다."

msgstr "[\#3085](https://github.com/rust-lang/rfcs/pull/3085)"

msgstr "1.56.0"

msgstr "Rust 2021 에디션에는 언어에 새로운 기능과 일관성을 더하고 향후 확장을 위한 공간을 여는 몇 가지 변경 사항이 포함되어 있습니다. 다음 장에서는 각 변경 사항의 세부 정보를 자세히 살펴보고 기존 코드를 마이그레이션하는 방법에 대한 지침을 포함합니다."

msgstr "`TryInto`, `TryFrom` 및 `FromIterator` 트레이트는 이제 프렐루드의 일부입니다."

msgstr "이로 인해 트레이트 메서드 호출이 모호해져 일부 코드가 컴파일되지 않을 수 있습니다."

msgstr "표준 라이브러리의 [프렐루드](https://doc.rust-lang.org/stable/std/prelude/index.html)는 모든 모듈에서 자동으로 가져오는 모든 것을 포함하는 모듈입니다. `Option`, `Vec`, `drop` 및 `Clone`과 같이 일반적으로 사용되는 항목을 포함합니다."

msgstr "Rust 컴파일러는 프렐루드에 추가된 항목이 기존 코드를 깨뜨리지 않도록 하기 위해 프렐루드의 항목보다 수동으로 가져온 항목을 우선시합니다. 예를 들어, `pub struct Option;`을 포함하는 `example`이라는 크레이트나 모듈이 있는 경우 `use example::*;`은 `Option`이 표준 라이브러리의 것이 아니라 `example`의 것을 명확하게 참조하도록 합니다."

msgstr "그러나 프렐루드에 _트레이트_를 추가하면 미묘한 방식으로 기존 코드가 깨질 수 있습니다. 예를 들어, `MyTryInto` 트레이트에서 오는 `x.try_into()` 호출은 `std`의 `TryInto`도 가져온 경우 컴파일에 실패할 수 있습니다. `try_into` 호출이 이제 모호하고 어느 트레이트에서든 올 수 있기 때문입니다. 이것이 우리가 아직 `TryInto`를 프렐루드에 추가하지 않은 이유입니다. 이런 식으로 깨질 코드가 많기 때문입니다."

msgstr "해결책으로 Rust 2021은 새로운 프렐루드를 사용합니다. 세 가지 새로운 추가 사항을 제외하고는 현재 것과 동일합니다."

msgstr "[`std::convert::TryInto`](https://doc.rust-lang.org/stable/std/convert/trait.TryInto.html)"

msgstr "[`std::convert::TryFrom`](https://doc.rust-lang.org/stable/std/convert/trait.TryFrom.html)"

msgstr "[`std::iter::FromIterator`](https://doc.rust-lang.org/stable/std/iter/trait.FromIterator.html)"

msgstr "추적 문제는 [여기](https://github.com/rust-lang/rust/issues/85684)에서 찾을 수 있습니다."

msgstr "마이그레이션"

msgstr "2021 에디션의 일부로 Rust 2018 코드베이스를 Rust 2021로 자동 마이그레이션하는 데 도움이 되도록 마이그레이션 린트인 `rust_2021_prelude_collisions`가 추가되었습니다."

msgstr "코드를 Rust 2021 에디션과 호환되도록 마이그레이션하려면 다음을 실행하십시오."

msgstr "린트는 새 프렐루드 트레이트 중 하나에 정의된 메서드와 이름이 같은 함수나 메서드가 호출되는 경우를 감지합니다. 경우에 따라 이전에 호출했던 것과 동일한 함수를 계속 호출하도록 호출을 다양한 방식으로 다시 작성할 수 있습니다."

msgstr "코드를 수동으로 마이그레이션하거나 `cargo fix`가 수행하는 작업을 더 잘 이해하고 싶다면 아래에 마이그레이션이 필요한 상황과 필요하지 않은 경우의 반대 예를 간략하게 설명했습니다."

msgstr "마이그레이션 필요"

msgstr "충돌하는 트레이트 메서드"

msgstr "범위에 있는 두 트레이트의 메서드 이름이 같으면 어떤 트레이트 메서드를 사용해야 할지 모호합니다. 예를 들어:"

msgstr "// 이 이름은 `std`의 `FromIterator` 트레이트에 있는 `from_iter` 메서드와 같습니다.  
"

msgstr "// Vec<T>는 `std::iter::FromIterator`와 `MyTrait`를 모두 구현합니다