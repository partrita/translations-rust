<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>타입 레이아웃 - The Rust Reference</title>


        <!-- Custom HTML head -->

        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/reference";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/type-layout.md`;
                    } else {
                        canonical_href = `${base}/${lang}/type-layout.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/reference-bb0bdaf8.css">
        <link rel="stylesheet" href="theme/language-picker-00e4db94.css">


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-de0d1ba3.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-f44ceee2.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>
                        <a href="https://github.com/rust-lang/reference/edit/master/src/type-layout.md" title="Suggest an edit" aria-label="Suggest an edit" rel="edit">
                            <span class=fa-svg id="git-edit-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M421.7 220.3l-11.3 11.3-22.6 22.6-205 205c-6.6 6.6-14.8 11.5-23.8 14.1L30.8 511c-8.4 2.5-17.5 .2-23.7-6.1S-1.5 489.7 1 481.2L38.7 353.1c2.6-9 7.5-17.2 14.1-23.8l205-205 22.6-22.6 11.3-11.3 33.9 33.9 62.1 62.1 33.9 33.9zM96 353.9l-9.3 9.3c-.9 .9-1.6 2.1-2 3.4l-25.3 86 86-25.3c1.3-.4 2.5-1.1 3.4-2l9.3-9.3H112c-8.8 0-16-7.2-16-16V353.9zM453.3 19.3l39.4 39.4c25 25 25 65.5 0 90.5l-14.5 14.5-22.6 22.6-11.3 11.3-33.9-33.9-62.1-62.1L314.3 67.7l11.3-11.3 22.6-22.6 14.5-14.5c25-25 65.5-25 90.5 0z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <div class="rule" id="r-layout"><a class="rule-link" href="#r-layout" title="layout"><span>[layout]</span></a>
</div>

<h1 id="타입-레이아웃"><a class="header" href="#타입-레이아웃">타입 레이아웃</a></h1>
<div class="rule" id="r-layout.intro"><a class="rule-link" href="#r-layout.intro" title="layout.intro"><span>[layout<wbr>.intro]</span></a>
</div>

<p>타입의 레이아웃은 크기, 정렬, 그리고 필드들의 상대적 오프셋을 의미합니다. 열거형의 경우, 판별자(discriminant)가 어떻게 배치되고 해석되는지 또한 타입 레이아웃의 일부입니다.</p>
<div class="rule" id="r-layout.guarantees"><a class="rule-link" href="#r-layout.guarantees" title="layout.guarantees"><span>[layout<wbr>.guarantees]</span></a>
</div>

<p>타입 레이아웃은 컴파일할 때마다 변경될 수 있습니다. 정확히 어떻게 수행되는지 문서화하려고 시도하는 대신, 우리는 현재 보장되는 내용만을 문서화합니다.</p>
<p>동일한 레이아웃을 가진 타입이라도 함수 경계를 넘어 전달되는 방식은 다를 수 있다는 점에 유의하십시오. 타입의 함수 호출 ABI 호환성에 대해서는 <a href="../core/primitive.fn.html#abi-compatibility">여기</a> 를 참조하십시오.</p>
<div class="rule" id="r-layout.properties"><a class="rule-link" href="#r-layout.properties" title="layout.properties"><span>[layout<wbr>.properties]</span></a>
</div>

<h2 id="size-and-alignment"><a class="header" href="#size-and-alignment">Size and alignment</a></h2>
<p>모든 값은 정렬과 크기를 가집니다.</p>
<div class="rule" id="r-layout.properties.align"><a class="rule-link" href="#r-layout.properties.align" title="layout.properties.align"><span>[layout<wbr>.properties<wbr>.align]</span></a>
</div>

<p>값의 <em>정렬(alignment)</em> 은 해당 값을 저장하기에 유효한 주소가 무엇인지 지정합니다. 정렬이 <code>n</code> 인 값은 반드시 n의 배수인 주소에만 저장되어야 합니다. 예를 들어, 정렬이 2인 값은 짝수 주소에 저장되어야 하며, 정렬이 1인 값은 아무 주소에나 저장될 수 있습니다. 정렬은 바이트 단위로 측정되며, 최소 1이어야 하고 항상 2의 거듭제곱이어야 합니다. 값의 정렬은 <a href="../core/mem/fn.align_of_val.html"><code>align_of_val</code></a> 함수로 확인할 수 있습니다.</p>
<div class="rule" id="r-layout.properties.size"><a class="rule-link" href="#r-layout.properties.size" title="layout.properties.size"><span>[layout<wbr>.properties<wbr>.size]</span></a>
</div>

<p>값의 <em>크기(size)</em> 는 해당 아이템 타입을 가진 배열에서 연속된 요소 사이의 바이트 단위 오프셋이며, 정렬 패딩을 포함합니다. 값의 크기는 항상 정렬의 배수입니다. 일부 타입은 크기가 0일 수 있음에 유의하십시오; 0은 모든 정렬의 배수로 간주됩니다(예를 들어, 일부 플랫폼에서 <code>[u16; 0]</code> 타입은 크기가 0이고 정렬이 2입니다). 값의 크기는 <a href="../core/mem/fn.size_of_val.html"><code>size_of_val</code></a> 함수로 확인할 수 있습니다.</p>
<div class="rule" id="r-layout.properties.sized"><a class="rule-link" href="#r-layout.properties.sized" title="layout.properties.sized"><span>[layout<wbr>.properties<wbr>.sized]</span></a>
</div>

<p>모든 값이 동일한 크기와 정렬을 가지며 컴파일 타임에 둘 다 알려진 타입은 <a href="../core/marker/trait.Sized.html"><code>Sized</code></a> 트레잇을 구현하고, <a href="../core/mem/fn.size_of.html"><code>size_of</code></a> 및 <a href="../core/mem/fn.align_of.html"><code>align_of</code></a> 함수로 확인할 수 있습니다. <a href="../core/marker/trait.Sized.html"><code>Sized</code></a> 가 아닌 타입은 <a href="dynamically-sized-types.html">동적 크기 타입</a> 으로 알려져 있습니다. <code>Sized</code> 타입의 모든 값은 동일한 크기와 정렬을 공유하므로, 이러한 공유된 값을 각각 해당 타입의 크기와 타입의 정렬이라고 부릅니다.</p>
<div class="rule" id="r-layout.primitive"><a class="rule-link" href="#r-layout.primitive" title="layout.primitive"><span>[layout<wbr>.primitive]</span></a>
</div>

<h2 id="primitive-data-layout"><a class="header" href="#primitive-data-layout">Primitive data layout</a></h2>
<div class="rule" id="r-layout.primitive.size"><a class="rule-link" href="#r-layout.primitive.size" title="layout.primitive.size"><span>[layout<wbr>.primitive<wbr>.size]</span></a>
</div>

<p>대부분의 기본 타입들의 크기는 이 표에 주어져 있습니다.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>유형</th><th><code>size_of::&lt;Type&gt;()</code></th></tr>
</thead>
<tbody>
<tr><td><code>bool</code></td><td>1</td></tr>
<tr><td><code>u8</code> / <code>i8</code></td><td>1</td></tr>
<tr><td><code>u16</code> / <code>i16</code></td><td>2</td></tr>
<tr><td><code>u32</code> / <code>i32</code></td><td>4</td></tr>
<tr><td><code>u64</code> / <code>i64</code></td><td>8</td></tr>
<tr><td><code>u128</code> / <code>i128</code></td><td>16</td></tr>
<tr><td><code>usize</code> / <code>isize</code></td><td>아래 참조</td></tr>
<tr><td><code>f32</code></td><td>4</td></tr>
<tr><td><code>f64</code></td><td>8</td></tr>
<tr><td><code>char</code></td><td>4</td></tr>
</tbody>
</table>
</div>
<div class="rule" id="r-layout.primitive.size-int"><a class="rule-link" href="#r-layout.primitive.size-int" title="layout.primitive.size-int"><span>[layout<wbr>.primitive<wbr>.size-int]</span></a>
</div>

<p><code>usize</code> 와 <code>isize</code> 는 대상 플랫폼의 모든 주소를 포함할 수 있을 만큼 큰 크기를 가집니다. 예를 들어, 32비트 대상에서는 4바이트이고, 64비트 대상에서는 8바이트입니다.</p>
<div class="rule" id="r-layout.primitive.align"><a class="rule-link" href="#r-layout.primitive.align" title="layout.primitive.align"><span>[layout<wbr>.primitive<wbr>.align]</span></a>
</div>

<p>기본 타입의 정렬은 플랫폼에 따라 다릅니다. 대부분의 경우 정렬은 크기와 같지만, 더 작을 수도 있습니다. 특히 <code>i128</code> 과 <code>u128</code> 은 크기가 16임에도 불구하고 종종 4 또는 8 바이트로 정렬되며, 많은 32비트 플랫폼에서 <code>i64</code>, <code>u64</code>, <code>f64</code> 는 8이 아닌 4 바이트로만 정렬됩니다.</p>
<div class="rule" id="r-layout.pointer"><a class="rule-link" href="#r-layout.pointer" title="layout.pointer"><span>[layout<wbr>.pointer]</span></a>
</div>

<h2 id="pointers-and-references-layout"><a class="header" href="#pointers-and-references-layout">Pointers and references layout</a></h2>
<div class="rule" id="r-layout.pointer.intro"><a class="rule-link" href="#r-layout.pointer.intro" title="layout.pointer.intro"><span>[layout<wbr>.pointer<wbr>.intro]</span></a>
</div>

<p>포인터와 참조는 동일한 레이아웃을 가집니다. 포인터나 참조의 가변성은 레이아웃을 변경하지 않습니다.</p>
<div class="rule" id="r-layout.pointer.thin"><a class="rule-link" href="#r-layout.pointer.thin" title="layout.pointer.thin"><span>[layout<wbr>.pointer<wbr>.thin]</span></a>
</div>

<p>크기가 있는 타입에 대한 포인터는 <code>usize</code> 와 동일한 크기와 정렬을 가집니다.</p>
<div class="rule" id="r-layout.pointer.unsized"><a class="rule-link" href="#r-layout.pointer.unsized" title="layout.pointer.unsized"><span>[layout<wbr>.pointer<wbr>.unsized]</span></a>
</div>

<p>크기가 없는 타입(unsized types)에 대한 포인터는 크기를 가집니다. 크기와 정렬은 적어도 포인터의 크기 및 정렬과 동일함이 보장됩니다.</p>
<div class="alert alert-note">
<blockquote>
<p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>

<p>Though you should not rely on this, all pointers to <abbr title="Dynamically Sized Types">DSTs</abbr> are currently twice the size of the size of <code>usize</code> and have the same alignment.</p>
</blockquote>
</div>

<div class="rule" id="r-layout.array"><a class="rule-link" href="#r-layout.array" title="layout.array"><span>[layout<wbr>.array]</span></a>
</div>

<h2 id="array-layout"><a class="header" href="#array-layout">Array layout</a></h2>
<p><code>[T; N]</code> 배열은 <code>size_of::&lt;T&gt;() * N</code> 의 크기를 가지며 <code>T</code> 와 동일한 정렬을 가집니다. 배열은 0부터 시작하는 <code>nth</code> 요소가 배열 시작점으로부터 <code>n * size_of::&lt;T&gt;()</code> 바이트만큼 오프셋되도록 배치됩니다.</p>
<div class="rule" id="r-layout.slice"><a class="rule-link" href="#r-layout.slice" title="layout.slice"><span>[layout<wbr>.slice]</span></a>
</div>

<h2 id="slice-layout"><a class="header" href="#slice-layout">Slice layout</a></h2>
<p>슬라이스는 자신이 슬라이싱하는 배열 섹션과 동일한 레이아웃을 가집니다.</p>
<div class="alert alert-note">
<blockquote>
<p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>

<p>This is about the raw <code>[T]</code> type, not pointers (<code>&amp;[T]</code>, <code>Box&lt;[T]&gt;</code>, etc.) to slices.</p>
</blockquote>
</div>

<div class="rule" id="r-layout.str"><a class="rule-link" href="#r-layout.str" title="layout.str"><span>[layout<wbr>.str]</span></a>
</div>

<h2 id="str-레이아웃"><a class="header" href="#str-레이아웃"><code>str</code> 레이아웃</a></h2>
<p>String slices are a UTF-8 representation of characters that have the same layout as slices of type <code>[u8]</code>. A reference <code>&amp;str</code> has the same layout as a reference <code>&amp;[u8]</code>.</p>
<div class="rule" id="r-layout.tuple"><a class="rule-link" href="#r-layout.tuple" title="layout.tuple"><span>[layout<wbr>.tuple]</span></a>
</div>

<h2 id="tuple-layout"><a class="header" href="#tuple-layout">Tuple layout</a></h2>
<div class="rule" id="r-layout.tuple.def"><a class="rule-link" href="#r-layout.tuple.def" title="layout.tuple.def"><span>[layout<wbr>.tuple<wbr>.def]</span></a>
</div>

<p>튜플은 <a href="#the-rust-representation"><code>Rust</code> 표현</a> 에 따라 배치됩니다.</p>
<div class="rule" id="r-layout.tuple.unit"><a class="rule-link" href="#r-layout.tuple.unit" title="layout.tuple.unit"><span>[layout<wbr>.tuple<wbr>.unit]</span></a>
</div>

<p>이에 대한 예외는 유닛 튜플(<code>()</code>)로, 크기가 0이고 정렬이 1인 0크기 타입(zero-sized type)으로 보장됩니다.</p>
<div class="rule" id="r-layout.trait-object"><a class="rule-link" href="#r-layout.trait-object" title="layout.trait-object"><span>[layout<wbr>.trait-object]</span></a>
</div>

<h2 id="trait-object-layout"><a class="header" href="#trait-object-layout">Trait object layout</a></h2>
<p>트레잇 객체는 해당 트레잇 객체가 나타내는 값과 동일한 레이아웃을 가집니다.</p>
<div class="alert alert-note">
<blockquote>
<p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>

<p>This is about the raw trait object types, not pointers (<code>&amp;dyn Trait</code>, <code>Box&lt;dyn Trait&gt;</code>, etc.) to trait objects.</p>
</blockquote>
</div>

<div class="rule" id="r-layout.closure"><a class="rule-link" href="#r-layout.closure" title="layout.closure"><span>[layout<wbr>.closure]</span></a>
</div>

<h2 id="closure-layout"><a class="header" href="#closure-layout">Closure layout</a></h2>
<p>클로저는 레이아웃 보장이 없습니다.</p>
<div class="rule" id="r-layout.repr"><a class="rule-link" href="#r-layout.repr" title="layout.repr"><span>[layout<wbr>.repr]</span></a>
</div>

<h2 id="표현-representations"><a class="header" href="#표현-representations">표현 (Representations)</a></h2>
<div class="rule" id="r-layout.repr.intro"><a class="rule-link" href="#r-layout.repr.intro" title="layout.repr.intro"><span>[layout<wbr>.repr<wbr>.intro]</span></a>
</div>

<p>모든 사용자 정의 복합 타입(<code>struct</code>, <code>enum</code>, <code>union</code>)은 해당 타입의 레이아웃이 무엇인지 지정하는 <em>표현(representation)</em> 을 가집니다.</p>
<div class="rule" id="r-layout.repr.kinds"><a class="rule-link" href="#r-layout.repr.kinds" title="layout.repr.kinds"><span>[layout<wbr>.repr<wbr>.kinds]</span></a>
</div>

<p>타입에 대해 가능한 표현은 다음과 같습니다:</p>
<ul>
<li><a href="#the-rust-representation"><code>Rust</code></a> (기본값)</li>
<li><a href="#the-c-representation"><code>C</code></a></li>
<li><a href="#primitive-representations">기본 표현(primitive representations)</a></li>
<li><a href="#the-transparent-representation"><code>transparent</code></a></li>
</ul>
<div class="rule" id="r-layout.repr.attribute"><a class="rule-link" href="#r-layout.repr.attribute" title="layout.repr.attribute"><span>[layout<wbr>.repr<wbr>.attribute]</span></a>
</div>

<p>타입의 표현은 <code>repr</code> 속성을 적용하여 변경할 수 있습니다. 다음 예시는 <code>C</code> 표현을 가진 구조체를 보여줍니다.</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct ThreeInts {
    first: i16,
    second: i8,
    third: i32
}
<span class="boring">}</span></code></pre>
<div class="rule" id="r-layout.repr.align-packed"><a class="rule-link" href="#r-layout.repr.align-packed" title="layout.repr.align-packed"><span>[layout<wbr>.repr<wbr>.align-packed]</span></a>
</div>

<p>정렬은 각각 <code>align</code> 과 <code>packed</code> 수정자를 사용하여 높이거나 낮출 수 있습니다. 이들은 속성에 지정된 표현을 변경합니다. 지정된 표현이 없으면 기본 표현이 변경됩니다.</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 기본 표현, 정렬이 2로 낮아짐.
#[repr(packed(2))]
struct PackedStruct {
    first: i16,
    second: i8,
    third: i32
}

// C 표현, 정렬이 8로 높아짐
#[repr(C, align(8))]
struct AlignedStruct {
    first: i16,
    second: i8,
    third: i32
}
<span class="boring">}</span></code></pre>
<div class="alert alert-note">
<blockquote>
<p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>

<p>As a consequence of the representation being an attribute on the item, the representation does not depend on generic parameters. Any two types with the same name have the same representation. For example, <code>Foo&lt;Bar&gt;</code> and <code>Foo&lt;Baz&gt;</code> both have the same representation.</p>
</blockquote>
</div>

<div class="rule" id="r-layout.repr.inter-field"><a class="rule-link" href="#r-layout.repr.inter-field" title="layout.repr.inter-field"><span>[layout<wbr>.repr<wbr>.inter-field]</span></a>
</div>

<p>타입의 표현은 필드 간의 패딩을 변경할 수 있지만, 필드 자체의 레이아웃은 변경하지 않습니다. 예를 들어, <code>Rust</code> 표현을 가진 <code>Inner</code> 구조체를 포함하는 <code>C</code> 표현의 구조체는 <code>Inner</code> 의 레이아웃을 변경하지 않습니다.</p>
<p><a id="the-default-representation"></a></p>
<div class="rule" id="r-layout.repr.rust"><a class="rule-link" href="#r-layout.repr.rust" title="layout.repr.rust"><span>[layout<wbr>.repr<wbr>.rust]</span></a>
</div>

<h3 id="the-rust-representation"><a class="header" href="#the-rust-representation">The <code>Rust</code> representation</a></h3>
<div class="rule" id="r-layout.repr.rust.intro"><a class="rule-link" href="#r-layout.repr.rust.intro" title="layout.repr.rust.intro"><span>[layout<wbr>.repr<wbr>.rust<wbr>.intro]</span></a>
</div>

<p><code>Rust</code> 표현은 <code>repr</code> 속성이 없는 명목적 타입의 기본 표현입니다. <code>repr</code> 속성을 통해 이 표현을 명시적으로 사용하는 것은 속성을 완전히 생략하는 것과 동일함이 보장됩니다.</p>
<div class="rule" id="r-layout.repr.rust.layout"><a class="rule-link" href="#r-layout.repr.rust.layout" title="layout.repr.rust.layout"><span>[layout<wbr>.repr<wbr>.rust<wbr>.layout]</span></a>
</div>

<p>이 표현이 제공하는 유일한 데이터 레이아웃 보장은 안전성(soundness)을 위해 필요한 것들뿐입니다. 그 보장들은 다음과 같습니다:</p>
<ol>
<li>필드들이 올바르게 정렬됩니다.</li>
<li>필드들이 겹치지 않습니다.</li>
<li>타입의 정렬은 최소한 그 필드들의 최대 정렬 이상입니다.</li>
</ol>
<div class="rule" id="r-layout.repr.rust.alignment"><a class="rule-link" href="#r-layout.repr.rust.alignment" title="layout.repr.rust.alignment"><span>[layout<wbr>.repr<wbr>.rust<wbr>.alignment]</span></a>
</div>

<p>형식적으로, 첫 번째 보장은 모든 필드의 오프셋이 해당 필드의 정렬로 나누어떨어진다는 것을 의미합니다.</p>
<div class="rule" id="r-layout.repr.rust.field-storage"><a class="rule-link" href="#r-layout.repr.rust.field-storage" title="layout.repr.rust.field-storage"><span>[layout<wbr>.repr<wbr>.rust<wbr>.field-storage]</span></a>
</div>

<p>두 번째 보장은 필드들이 순서대로 정렬될 때, 어떤 필드의 오프셋 더하기 크기가 다음 필드의 오프셋보다 작거나 같도록 정렬될 수 있음을 의미합니다. 이 순서는 타입 선언에 필드가 지정된 순서와 동일할 필요는 없습니다.</p>
<p>두 번째 보장이 필드들이 서로 다른 주소를 갖는다는 것을 의미하지는 않음에 유의하십시오. 크기가 0인 타입은 동일한 구조체 내의 다른 필드와 같은 주소를 가질 수 있습니다.</p>
<div class="rule" id="r-layout.repr.rust.unspecified"><a class="rule-link" href="#r-layout.repr.rust.unspecified" title="layout.repr.rust.unspecified"><span>[layout<wbr>.repr<wbr>.rust<wbr>.unspecified]</span></a>
</div>

<p>이 표현이 제공하는 데이터 레이아웃에 대한 다른 보장은 없습니다.</p>
<div class="rule" id="r-layout.repr.c"><a class="rule-link" href="#r-layout.repr.c" title="layout.repr.c"><span>[layout<wbr>.repr<wbr>.c]</span></a>
</div>

<h3 id="the-c-representation"><a class="header" href="#the-c-representation">The <code>C</code> representation</a></h3>
<div class="rule" id="r-layout.repr.c.intro"><a class="rule-link" href="#r-layout.repr.c.intro" title="layout.repr.c.intro"><span>[layout<wbr>.repr<wbr>.c<wbr>.intro]</span></a>
</div>

<p><code>C</code> 표현은 이중 목적으로 설계되었습니다. 첫 번째 목적은 C 언어와 상호 운용 가능한 타입을 생성하는 것입니다. 두 번째 목적은 값을 다른 타입으로 재해석하는 것과 같이 데이터 레이아웃에 의존하는 연산을 안전하게 수행할 수 있는 타입을 생성하는 것입니다.</p>
<p>이러한 이중 목적 때문에, C 프로그래밍 언어와의 인터페이스에는 유용하지 않은 타입을 생성하는 것도 가능합니다.</p>
<div class="rule" id="r-layout.repr.c.constraint"><a class="rule-link" href="#r-layout.repr.c.constraint" title="layout.repr.c.constraint"><span>[layout<wbr>.repr<wbr>.c<wbr>.constraint]</span></a>
</div>

<p>이 표현은 구조체, 공용체, 열거형에 적용될 수 있습니다. 예외는 <a href="items/enumerations.html#zero-variant-enums">변형이 없는 열거형</a> 으로, 이에 대해 <code>C</code> 표현을 사용하는 것은 오류입니다.</p>
<div class="rule" id="r-layout.repr.c.struct"><a class="rule-link" href="#r-layout.repr.c.struct" title="layout.repr.c.struct"><span>[layout<wbr>.repr<wbr>.c<wbr>.struct]</span></a>
</div>

<h4 id="reprc-구조체"><a class="header" href="#reprc-구조체"><code>#[repr(C)]</code> 구조체</a></h4>
<div class="rule" id="r-layout.repr.c.struct.align"><a class="rule-link" href="#r-layout.repr.c.struct.align" title="layout.repr.c.struct.align"><span>[layout<wbr>.repr<wbr>.c<wbr>.struct<wbr>.align]</span></a>
</div>

<p>구조체의 정렬은 그 안에 있는 가장 크게 정렬된 필드의 정렬입니다.</p>
<div class="rule" id="r-layout.repr.c.struct.size-field-offset"><a class="rule-link" href="#r-layout.repr.c.struct.size-field-offset" title="layout.repr.c.struct.size-field-offset"><span>[layout<wbr>.repr<wbr>.c<wbr>.struct<wbr>.size-field-offset]</span></a>
</div>

<p>필드의 크기와 오프셋은 다음 알고리즘에 의해 결정됩니다.</p>
<p>현재 오프셋 0바이트로 시작합니다.</p>
<p>구조체의 선언 순서대로 각 필드에 대해, 먼저 필드의 크기와 정렬을 결정합니다. 현재 오프셋이 필드의 정렬의 배수가 아니라면, 필드 정렬의 배수가 될 때까지 현재 오프셋에 패딩 바이트를 추가합니다. 해당 필드의 오프셋은 현재 오프셋 값이 됩니다. 그런 다음 현재 오프셋을 필드의 크기만큼 증가시킵니다.</p>
<p>마지막으로, 구조체의 크기는 현재 오프셋을 구조체의 정렬의 가장 가까운 배수로 올림한 값입니다.</p>
<p>다음은 의사코드로 설명된 이 알고리즘입니다.</p>
<!-- ignore: pseudocode -->
<pre><code class="language-rust ignore">/// 다음 주소가 `alignment` 에 맞춰 정렬되도록 하기 위해
/// `offset` 뒤에 필요한 패딩의 양을 반환합니다.
fn padding_needed_for(offset: usize, alignment: usize) -&gt; usize {
    let misalignment = offset % alignment;
    if misalignment &gt; 0 {
        // `alignment` 의 다음 배수로 올림
        alignment - misalignment
    } else {
        // 이미 `alignment` 의 배수임
        0
    }
}

struct.alignment = struct.fields().map(|field| field.alignment).max();

let current_offset = 0;

for field in struct.fields_in_declaration_order() {
    // 현재 오프셋을 증가시켜 이 필드의 정렬의 배수가 되도록 합니다.
    // 첫 번째 필드의 경우, 이는 항상 0이 됩니다.
    // 건너뛴 바이트를 패딩 바이트라고 합니다.
    current_offset += padding_needed_for(current_offset, field.alignment);

    struct[field].offset = current_offset;

    current_offset += field.size;
}

struct.size = current_offset + padding_needed_for(current_offset, struct.alignment);</code></pre>
<div class="alert alert-warning">
<blockquote>
<p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Warning</p>

<p>This pseudocode uses a naive algorithm that ignores overflow issues for the sake of clarity. To perform memory layout computations in actual code, use <a href="../core/alloc/layout/struct.Layout.html"><code>Layout</code></a>.</p>
</blockquote>
</div>

<div class="alert alert-note">
<blockquote>
<p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>

<p>This algorithm can produce zero-sized structs. In C, an empty struct declaration like <code>struct Foo { }</code> is illegal. However, both gcc and clang support options to enable such structs, and assign them size zero. C++, in contrast, gives empty structs a size of 1, unless they are inherited from or they are fields that have the <code>[[no_unique_address]]</code> attribute, in which case they do not increase the overall size of the struct.</p>
</blockquote>
</div>

<div class="rule" id="r-layout.repr.c.union"><a class="rule-link" href="#r-layout.repr.c.union" title="layout.repr.c.union"><span>[layout<wbr>.repr<wbr>.c<wbr>.union]</span></a>
</div>

<h4 id="reprc-공용체"><a class="header" href="#reprc-공용체"><code>#[repr(C)]</code> 공용체</a></h4>
<div class="rule" id="r-layout.repr.c.union.intro"><a class="rule-link" href="#r-layout.repr.c.union.intro" title="layout.repr.c.union.intro"><span>[layout<wbr>.repr<wbr>.c<wbr>.union<wbr>.intro]</span></a>
</div>

<p><code>#[repr(C)]</code> 로 선언된 공용체는 대상 플랫폼의 C 언어에서 동등한 C 공용체 선언과 동일한 크기와 정렬을 가집니다.</p>
<div class="rule" id="r-layout.repr.c.union.size-align"><a class="rule-link" href="#r-layout.repr.c.union.size-align" title="layout.repr.c.union.size-align"><span>[layout<wbr>.repr<wbr>.c<wbr>.union<wbr>.size-align]</span></a>
</div>

<p>The union will have a size of the maximum size of all of its fields rounded to its alignment, and an alignment of the maximum alignment of all of its fields. These maximums may come from different fields. Each field lives at byte offset 0 from the beginning of the union.</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
union Union {
    f1: u16,
    f2: [u8; 4],
}

assert_eq!(std::mem::size_of::&lt;Union&gt;(), 4);  // f2에서 옴
assert_eq!(std::mem::align_of::&lt;Union&gt;(), 2); // f1에서 옴

assert_eq!(std::mem::offset_of!(Union, f1), 0);
assert_eq!(std::mem::offset_of!(Union, f2), 0);

#[repr(C)]
union SizeRoundedUp {
   a: u32,
   b: [u16; 3],
}

assert_eq!(std::mem::size_of::&lt;SizeRoundedUp&gt;(), 8);  // b에서 크기 6,
                                                      // a의 정렬에 따라
                                                      // 8로 올림.
assert_eq!(std::mem::align_of::&lt;SizeRoundedUp&gt;(), 4); // a에서 옴

assert_eq!(std::mem::offset_of!(SizeRoundedUp, a), 0);
assert_eq!(std::mem::offset_of!(SizeRoundedUp, b), 0);
<span class="boring">}</span></code></pre>
<div class="rule" id="r-layout.repr.c.enum"><a class="rule-link" href="#r-layout.repr.c.enum" title="layout.repr.c.enum"><span>[layout<wbr>.repr<wbr>.c<wbr>.enum]</span></a>
</div>

<h4 id="reprc-필드-없는-열거형"><a class="header" href="#reprc-필드-없는-열거형"><code>#[repr(C)]</code> 필드 없는 열거형</a></h4>
<p><a href="items/enumerations.html#field-less-enum">필드 없는 열거형</a> 의 경우, <code>C</code> 표현은 대상 플랫폼의 C ABI에 대한 기본 <code>enum</code> 크기 및 정렬과 동일한 크기 및 정렬을 가집니다.</p>
<div class="alert alert-note">
<blockquote>
<p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>

<p>The enum representation in C is implementation defined, so this is really a “best guess”. In particular, this may be incorrect when the C code of interest is compiled with certain flags.</p>
</blockquote>
</div>

<div class="alert alert-warning">
<blockquote>
<p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M6.457 1.047c.659-1.234 2.427-1.234 3.086 0l6.082 11.378A1.75 1.75 0 0 1 14.082 15H1.918a1.75 1.75 0 0 1-1.543-2.575Zm1.763.707a.25.25 0 0 0-.44 0L1.698 13.132a.25.25 0 0 0 .22.368h12.164a.25.25 0 0 0 .22-.368Zm.53 3.996v2.5a.75.75 0 0 1-1.5 0v-2.5a.75.75 0 0 1 1.5 0ZM9 11a1 1 0 1 1-2 0 1 1 0 0 1 2 0Z"></path></svg>Warning</p>

<p>There are crucial differences between an <code>enum</code> in the C language and Rust’s <a href="items/enumerations.html#field-less-enum">field-less enums</a> with this representation. An <code>enum</code> in C is mostly a <code>typedef</code> plus some named constants; in other words, an object of an <code>enum</code> type can hold any integer value. For example, this is often used for bitflags in <code>C</code>. In contrast, Rust’s <a href="items/enumerations.html#field-less-enum">field-less enums</a> can only legally hold the discriminant values, everything else is <a href="behavior-considered-undefined.html">undefined behavior</a>. Therefore, using a field-less enum in FFI to model a C <code>enum</code> is often wrong.</p>
</blockquote>
</div>

<div class="rule" id="r-layout.repr.c.adt"><a class="rule-link" href="#r-layout.repr.c.adt" title="layout.repr.c.adt"><span>[layout<wbr>.repr<wbr>.c<wbr>.adt]</span></a>
</div>

<h4 id="reprc-필드-있는-열거형"><a class="header" href="#reprc-필드-있는-열거형"><code>#[repr(C)]</code> 필드 있는 열거형</a></h4>
<div class="rule" id="r-layout.repr.c.adt.intro"><a class="rule-link" href="#r-layout.repr.c.adt.intro" title="layout.repr.c.adt.intro"><span>[layout<wbr>.repr<wbr>.c<wbr>.adt<wbr>.intro]</span></a>
</div>

<p>필드가 있는 <code>repr(C)</code> 열거형의 표현은 두 개의 필드를 가진 <code>repr(C)</code> 구조체이며, C에서는 “태그된 공용체(tagged union)“라고도 불립니다:</p>
<div class="rule" id="r-layout.repr.c.adt.tag"><a class="rule-link" href="#r-layout.repr.c.adt.tag" title="layout.repr.c.adt.tag"><span>[layout<wbr>.repr<wbr>.c<wbr>.adt<wbr>.tag]</span></a>
</div>

<ul>
<li>모든 필드가 제거된 열거형의 <code>repr(C)</code> 버전 (“태그”)</li>
</ul>
<div class="rule" id="r-layout.repr.c.adt.fields"><a class="rule-link" href="#r-layout.repr.c.adt.fields" title="layout.repr.c.adt.fields"><span>[layout<wbr>.repr<wbr>.c<wbr>.adt<wbr>.fields]</span></a>
</div>

<ul>
<li>필드를 가진 각 변형의 필드들을 위한 <code>repr(C)</code> 구조체들의 <code>repr(C)</code> 공용체 (“페이로드”)</li>
</ul>
<div class="alert alert-note">
<blockquote>
<p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>

<p>Due to the representation of <code>repr(C)</code> structs and unions, if a variant has a single field there is no difference between putting that field directly in the union or wrapping it in a struct; any system which wishes to manipulate such an <code>enum</code>’s representation may therefore use whichever form is more convenient or consistent for them.</p>
</blockquote>
</div>

<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 Enum은 다음 구조체와 동일한 표현을 가집니다 ...
#[repr(C)]
enum MyEnum {
    A(u32),
    B(f32, u64),
    C { x: u32, y: u8 },
    D,
 }

// ... 이 구조체와.
#[repr(C)]
struct MyEnumRepr {
    tag: MyEnumDiscriminant,
    payload: MyEnumFields,
}

// 이것은 판별자 열거형입니다.
#[repr(C)]
enum MyEnumDiscriminant { A, B, C, D }

// 이것은 변형 공용체입니다.
#[repr(C)]
union MyEnumFields {
    A: MyAFields,
    B: MyBFields,
    C: MyCFields,
    D: MyDFields,
}

#[repr(C)]
#[derive(Copy, Clone)]
struct MyAFields(u32);

#[repr(C)]
#[derive(Copy, Clone)]
struct MyBFields(f32, u64);

#[repr(C)]
#[derive(Copy, Clone)]
struct MyCFields { x: u32, y: u8 }

// 이 구조체는 생략될 수 있으며(0크기 타입임), C/C++ 헤더에 있어야 합니다.
#[repr(C)]
#[derive(Copy, Clone)]
struct MyDFields;
<span class="boring">}</span></code></pre>
<div class="rule" id="r-layout.repr.primitive"><a class="rule-link" href="#r-layout.repr.primitive" title="layout.repr.primitive"><span>[layout<wbr>.repr<wbr>.primitive]</span></a>
</div>

<h3 id="기본-표현-primitive-representations"><a class="header" href="#기본-표현-primitive-representations">기본 표현 (Primitive representations)</a></h3>
<div class="rule" id="r-layout.repr.primitive.intro"><a class="rule-link" href="#r-layout.repr.primitive.intro" title="layout.repr.primitive.intro"><span>[layout<wbr>.repr<wbr>.primitive<wbr>.intro]</span></a>
</div>

<p><em>기본 표현</em> 은 기본 정수 타입과 동일한 이름을 가진 표현입니다. 즉: <code>u8</code>, <code>u16</code>, <code>u32</code>, <code>u64</code>, <code>u128</code>, <code>usize</code>, <code>i8</code>, <code>i16</code>, <code>i32</code>, <code>i64</code>, <code>i128</code>, <code>isize</code> 입니다.</p>
<div class="rule" id="r-layout.repr.primitive.constraint"><a class="rule-link" href="#r-layout.repr.primitive.constraint" title="layout.repr.primitive.constraint"><span>[layout<wbr>.repr<wbr>.primitive<wbr>.constraint]</span></a>
</div>

<p>기본 표현은 열거형에만 적용될 수 있으며 열거형에 필드가 있는지 없는지에 따라 다르게 동작합니다. <a href="items/enumerations.html#zero-variant-enums">변형이 없는 열거형</a> 이 기본 표현을 갖는 것은 오류입니다. 두 개의 기본 표현을 결합하는 것은 오류입니다.</p>
<div class="rule" id="r-layout.repr.primitive.enum"><a class="rule-link" href="#r-layout.repr.primitive.enum" title="layout.repr.primitive.enum"><span>[layout<wbr>.repr<wbr>.primitive<wbr>.enum]</span></a>
</div>

<h4 id="primitive-representation-of-field-less-enums"><a class="header" href="#primitive-representation-of-field-less-enums">Primitive representation of field-less enums</a></h4>
<p><a href="items/enumerations.html#field-less-enum">필드 없는 열거형</a> 의 경우, 기본 표현은 크기와 정렬을 동일한 이름의 기본 타입과 같게 설정합니다. 예를 들어, <code>u8</code> 표현을 가진 필드 없는 열거형은 0에서 255(포함) 사이의 판별자만 가질 수 있습니다.</p>
<div class="rule" id="r-layout.repr.primitive.adt"><a class="rule-link" href="#r-layout.repr.primitive.adt" title="layout.repr.primitive.adt"><span>[layout<wbr>.repr<wbr>.primitive<wbr>.adt]</span></a>
</div>

<h4 id="primitive-representation-of-enums-with-fields"><a class="header" href="#primitive-representation-of-enums-with-fields">Primitive representation of enums with fields</a></h4>
<p>기본 표현 열거형의 표현은 <code>repr(C)</code> 공용체입니다</p>
<div class="alert alert-note">
<blockquote>
<p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>

<p>This representation is unchanged if the tag is given its own member in the union, should that make manipulation more clear for you (although to follow the C++ standard the tag member should be wrapped in a <code>struct</code>).</p>
</blockquote>
</div>

<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 이 열거형은 다음 공용체와 동일한 표현을 가집니다 ...
#[repr(u8)]
enum MyEnum {
    A(u32),
    B(f32, u64),
    C { x: u32, y: u8 },
    D,
 }

// ... 이 공용체와.
#[repr(C)]
union MyEnumRepr {
    A: MyVariantA,
    B: MyVariantB,
    C: MyVariantC,
    D: MyVariantD,
}

// 이것은 판별자 열거형입니다.
#[repr(u8)]
#[derive(Copy, Clone)]
enum MyEnumDiscriminant { A, B, C, D }

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantA(MyEnumDiscriminant, u32);

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantB(MyEnumDiscriminant, f32, u64);

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantC { tag: MyEnumDiscriminant, x: u32, y: u8 }

#[repr(C)]
#[derive(Clone, Copy)]
struct MyVariantD(MyEnumDiscriminant);
<span class="boring">}</span></code></pre>
<div class="rule" id="r-layout.repr.primitive-c"><a class="rule-link" href="#r-layout.repr.primitive-c" title="layout.repr.primitive-c"><span>[layout<wbr>.repr<wbr>.primitive-c]</span></a>
</div>

<h4 id="필드가-있는-열거형의-기본-표현과-reprc-결합하기"><a class="header" href="#필드가-있는-열거형의-기본-표현과-reprc-결합하기">필드가 있는 열거형의 기본 표현과 <code>#[repr(C)]</code> 결합하기</a></h4>
<p>필드가 있는 열거형의 경우, <code>repr(C)</code> 와 기본 표현을 결합하는 것도 가능합니다(예: <code>repr(C, u8)</code>). 이는 판별자 열거형의 표현을 선택된 기본 타입으로 변경함으로써 <a href="#reprc-enums-with-fields"><code>repr(C)</code></a> 를 수정합니다. 따라서 <code>u8</code> 표현을 선택했다면, 판별자 열거형은 1바이트의 크기와 정렬을 갖게 됩니다.</p>
<p><a href="#reprc-enums-with-fields">앞서</a> 나온 예시의 판별자 열거형은 다음과 같이 됩니다:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C, u8)] // `u8` 이 추가됨
enum MyEnum {
    A(u32),
    B(f32, u64),
    C { x: u32, y: u8 },
    D,
 }

// ...

#[repr(u8)] // 따라서 여기서 `C` 대신 `u8` 이 사용됨
enum MyEnumDiscriminant { A, B, C, D }

// ...
<span class="boring">}</span></code></pre>
<p>예를 들어, <code>repr(C, u8)</code> 열거형은 257개의 고유한 판별자(“태그”)를 가질 수 없는 반면, <code>repr(C)</code> 속성만 있는 동일한 열거형은 문제없이 컴파일됩니다.</p>
<p><code>repr(C)</code> 에 더해 기본 표현을 사용하면 <code>repr(C)</code> 형태로부터 열거형의 크기가 변경될 수 있습니다:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
enum EnumC {
    Variant0(u8),
    Variant1,
}

#[repr(C, u8)]
enum Enum8 {
    Variant0(u8),
    Variant1,
}

#[repr(C, u16)]
enum Enum16 {
    Variant0(u8),
    Variant1,
}

// The size of the C representation is platform dependent
assert_eq!(std::mem::size_of::&lt;EnumC&gt;(), 8);
// 판별자를 위한 1바이트와 Enum8::Variant0의 값을 위한 1바이트
assert_eq!(std::mem::size_of::&lt;Enum8&gt;(), 2);
// 판별자를 위한 2바이트와 Enum16::Variant0의 값을 위한 1바이트
// 더하기 1바이트의 패딩.
assert_eq!(std::mem::size_of::&lt;Enum16&gt;(), 4);
<span class="boring">}</span></code></pre>
<div class="rule" id="r-layout.repr.alignment"><a class="rule-link" href="#r-layout.repr.alignment" title="layout.repr.alignment"><span>[layout<wbr>.repr<wbr>.alignment]</span></a>
</div>

<h3 id="정렬-수정자"><a class="header" href="#정렬-수정자">정렬 수정자</a></h3>
<div class="rule" id="r-layout.repr.alignment.intro"><a class="rule-link" href="#r-layout.repr.alignment.intro" title="layout.repr.alignment.intro"><span>[layout<wbr>.repr<wbr>.alignment<wbr>.intro]</span></a>
</div>

<p><code>align</code> 과 <code>packed</code> 수정자는 각각 <code>struct</code> 와 <code>union</code> 의 정렬을 높이거나 낮출 때 사용할 수 있습니다. <code>packed</code> 는 필드 사이의 패딩을 변경할 수도 있습니다(단, 필드 내부의 패딩은 변경하지 않습니다). <code>align</code> 과 <code>packed</code> 는 그 자체로는 구조체 레이아웃이나 열거형 변형 레이아웃의 필드 순서에 대한 보장을 제공하지 않지만, 그러한 보장을 제공하는 표현(예: <code>C</code>)과 결합될 수 있습니다.</p>
<div class="rule" id="r-layout.repr.alignment.constraint-alignment"><a class="rule-link" href="#r-layout.repr.alignment.constraint-alignment" title="layout.repr.alignment.constraint-alignment"><span>[layout<wbr>.repr<wbr>.alignment<wbr>.constraint-alignment]</span></a>
</div>

<p>The alignment is specified as an integer parameter in the form of <code>#[repr(align(x))]</code> or <code>#[repr(packed(x))]</code>. The alignment value must be a power of two from 1 up to 2<sup>29</sup>. For <code>packed</code>, if no value is given, as in <code>#[repr(packed)]</code>, then the value is 1.</p>
<div class="rule" id="r-layout.repr.alignment.align"><a class="rule-link" href="#r-layout.repr.alignment.align" title="layout.repr.alignment.align"><span>[layout<wbr>.repr<wbr>.alignment<wbr>.align]</span></a>
</div>

<p><code>align</code> 의 경우, 지정된 정렬이 <code>align</code> 수정자가 없을 때의 타입 정렬보다 작으면 정렬은 영향을 받지 않습니다.</p>
<div class="rule" id="r-layout.repr.alignment.packed"><a class="rule-link" href="#r-layout.repr.alignment.packed" title="layout.repr.alignment.packed"><span>[layout<wbr>.repr<wbr>.alignment<wbr>.packed]</span></a>
</div>

<p><code>packed</code> 의 경우, 지정된 정렬이 <code>packed</code> 수정자가 없을 때의 타입 정렬보다 크면 정렬과 레이아웃은 영향을 받지 않습니다.</p>
<div class="rule" id="r-layout.repr.alignment.packed-fields"><a class="rule-link" href="#r-layout.repr.alignment.packed-fields" title="layout.repr.alignment.packed-fields"><span>[layout<wbr>.repr<wbr>.alignment<wbr>.packed-fields]</span></a>
</div>

<p>필드 배치를 위한 각 필드의 정렬은 지정된 정렬과 필드 타입의 정렬 중 더 작은 값입니다.</p>
<div class="rule" id="r-layout.repr.alignment.packed-padding"><a class="rule-link" href="#r-layout.repr.alignment.packed-padding" title="layout.repr.alignment.packed-padding"><span>[layout<wbr>.repr<wbr>.alignment<wbr>.packed-padding]</span></a>
</div>

<p>필드 간 패딩은 각 필드의 (변경되었을 수 있는) 정렬을 충족하기 위해 필요한 최소한의 양으로 보장됩니다(단, <code>packed</code> 자체는 필드 순서에 대한 어떤 보장도 제공하지 않음에 유의하십시오). 이 규칙의 중요한 결과는 <code>#[repr(packed(1))]</code>(또는 <code>#[repr(packed)]</code>)을 가진 타입은 필드 간 패딩이 없다는 것입니다.</p>
<div class="rule" id="r-layout.repr.alignment.constraint-exclusive"><a class="rule-link" href="#r-layout.repr.alignment.constraint-exclusive" title="layout.repr.alignment.constraint-exclusive"><span>[layout<wbr>.repr<wbr>.alignment<wbr>.constraint-exclusive]</span></a>
</div>

<p><code>align</code> 과 <code>packed</code> 수정자는 동일한 타입에 적용될 수 없으며, <code>packed</code> 타입은 전이적으로 다른 <code>align</code> 된 타입을 포함할 수 없습니다. <code>align</code> 과 <code>packed</code> 는 <a href="#the-rust-representation"><code>Rust</code></a> 및 <a href="#the-c-representation"><code>C</code></a> 표현에만 적용될 수 있습니다.</p>
<div class="rule" id="r-layout.repr.alignment.enum"><a class="rule-link" href="#r-layout.repr.alignment.enum" title="layout.repr.alignment.enum"><span>[layout<wbr>.repr<wbr>.alignment<wbr>.enum]</span></a>
</div>

<p><code>align</code> 수정자는 <code>enum</code> 에도 적용될 수 있습니다. 이 경우, <code>enum</code> 의 정렬에 미치는 효과는 <code>enum</code> 이 동일한 <code>align</code> 수정자를 가진 뉴타입 <code>struct</code> 로 감싸진 경우와 동일합니다.</p>
<div class="alert alert-note">
<blockquote>
<p class="alert-title"><svg viewbox="0 0 16 16" width="18" height="18"><path d="M0 8a8 8 0 1 1 16 0A8 8 0 0 1 0 8Zm8-6.5a6.5 6.5 0 1 0 0 13 6.5 6.5 0 0 0 0-13ZM6.5 7.75A.75.75 0 0 1 7.25 7h1a.75.75 0 0 1 .75.75v2.75h.25a.75.75 0 0 1 0 1.5h-2a.75.75 0 0 1 0-1.5h.25v-2h-.25a.75.75 0 0 1-.75-.75ZM8 6a1 1 0 1 1 0-2 1 1 0 0 1 0 2Z"></path></svg>Note</p>

<p>References to unaligned fields are not allowed because it is <a href="behavior-considered-undefined.html">undefined behavior</a>. When fields are unaligned due to an alignment modifier, consider the following options for using references and dereferences:</p>
<pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(packed)]
struct Packed {
    f1: u8,
    f2: u16,
}
let mut e = Packed { f1: 1, f2: 2 };
// 필드에 대한 참조를 생성하는 대신, 값을 로컬 변수로 복사하십시오.
let x = e.f2;
// 또는 참조를 생성하는 `println!` 과 같은 상황에서는 중괄호를 사용하여
// 값의 복사본으로 변경하십시오.
println!("{}", {e.f2});
// 포인터가 필요한 경우, 포인터를 직접 역참조하는 대신
// 읽기 및 쓰기에 정렬되지 않은 메서드를 사용하십시오.
let ptr: *const u16 = &amp;raw const e.f2;
let value = unsafe { ptr.read_unaligned() };
let mut_ptr: *mut u16 = &amp;raw mut e.f2;
unsafe { mut_ptr.write_unaligned(3) }
<span class="boring">}</span></code></pre>
</blockquote>
</div>

<div class="rule" id="r-layout.repr.transparent"><a class="rule-link" href="#r-layout.repr.transparent" title="layout.repr.transparent"><span>[layout<wbr>.repr<wbr>.transparent]</span></a>
</div>

<h3 id="the-transparent-representation"><a class="header" href="#the-transparent-representation">The <code>transparent</code> representation</a></h3>
<div class="rule" id="r-layout.repr.transparent.constraint-field"><a class="rule-link" href="#r-layout.repr.transparent.constraint-field" title="layout.repr.transparent.constraint-field"><span>[layout<wbr>.repr<wbr>.transparent<wbr>.constraint-field]</span></a>
</div>

<p><code>transparent</code> 표현은 다음을 가진 <a href="items/structs.html"><code>struct</code></a> 또는 단일 변형 <a href="items/enumerations.html"><code>enum</code></a> 에서만 사용될 수 있습니다:</p>
<ul>
<li>크기가 0이고 정렬이 1인 임의 개수의 필드 (예: <a href="special-types-and-traits.html#phantomdatat"><code>PhantomData&lt;T&gt;</code></a>), 그리고</li>
<li>최대 하나의 다른 필드.</li>
</ul>
<div class="rule" id="r-layout.repr.transparent.layout-abi"><a class="rule-link" href="#r-layout.repr.transparent.layout-abi" title="layout.repr.transparent.layout-abi"><span>[layout<wbr>.repr<wbr>.transparent<wbr>.layout-abi]</span></a>
</div>

<p>이 표현을 가진 구조체와 열거형은 크기가 0이 아니고 정렬이 1이 아닌 유일한 필드(존재하는 경우)와 동일한 레이아웃 및 ABI를 가지며, 그렇지 않으면 유닛과 동일합니다.</p>
<p>이는 <code>C</code> 표현과는 다릅니다. <code>C</code> 표현을 가진 구조체는 항상 <code>C</code> <code>struct</code> 의 ABI를 갖는 반면, 예를 들어 기본(primitive) 필드를 가진 <code>transparent</code> 표현의 구조체는 해당 기본 필드의 ABI를 갖기 때문입니다.</p>
<div class="rule" id="r-layout.repr.transparent.constraint-exclusive"><a class="rule-link" href="#r-layout.repr.transparent.constraint-exclusive" title="layout.repr.transparent.constraint-exclusive"><span>[layout<wbr>.repr<wbr>.transparent<wbr>.constraint-exclusive]</span></a>
</div>

<p>이 표현은 타입 레이아웃을 다른 타입에 위임하므로, 다른 어떤 표현과도 함께 사용될 수 없습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="dynamically-sized-types.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                            </a>

                            <a rel="next prefetch" href="interior-mutability.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="dynamically-sized-types.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M41.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.3 256 246.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z"/></svg></span>
                    </a>

                    <a rel="next prefetch" href="interior-mutability.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 320 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M278.6 233.4c12.5 12.5 12.5 32.8 0 45.3l-160 160c-12.5 12.5-32.8 12.5-45.3 0s-12.5-32.8 0-45.3L210.7 256 73.4 118.6c-12.5-12.5-12.5-32.8 0-45.3s32.8-12.5 45.3 0l160 160z"/></svg></span>
                    </a>
            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/reference-da60281b.js"></script>
        <script src="theme/language-picker-0917ae23.js"></script>



    </div>
    </body>
</html>
