<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>불안정한 기능 - The Cargo Book</title>


        <!-- Custom HTML head -->
        <style>
            dd {
                margin-bottom: 1em;
            }
        </style>
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/cargo";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/reference/unstable.md`;
                    } else {
                        canonical_href = `${base}/${lang}/reference/unstable.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/cargo.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cargo Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/cargo/edit/master/src/doc/src/reference/unstable.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="불안정한-기능"><a class="header" href="#불안정한-기능">불안정한 기능</a></h1>
<p>실험적인 Cargo 기능은 <a href="../../book/appendix-07-nightly-rust.html">나이틀리 채널</a>에서만 사용할 수 있습니다. 이러한 기능이 요구 사항을 충족하는지, 문제나 이슈가 있는지 확인하기 위해 실험해 보는 것을 권장합니다. 기능에 대한 자세한 정보는 아래 링크된 추적 이슈(tracking issues)를 확인하고, 향후 업데이트를 받고 싶다면 GitHub 구독 버튼을 클릭하세요.</p>
<p>일정 기간이 지난 후 주요 우려 사항이 없다면 해당 기능은 <a href="https://doc.crates.io/contrib/process/unstable.html#stabilization">안정화</a>될 수 있으며, 현재 나이틀리 릴리스가 안정 채널에 도달하면(6주에서 12주 소요) 안정 버전에서 사용할 수 있게 됩니다.</p>
<p>기능이 작동하는 방식에 따라 불안정한 기능을 활성화하는 세 가지 방법이 있습니다:</p>
<ul>
<li>
<p><code>Cargo.toml</code>의 새로운 문법은 <code>Cargo.toml</code> 상단, 모든 테이블 앞에 <code>cargo-features</code> 키가 필요합니다. 예를 들어:</p>
<pre><code class="language-toml"># 활성화할 새로운 Cargo.toml 기능을 지정합니다.
cargo-features = ["test-dummy-unstable"]

[package]
name = "my-package"
version = "0.1.0"
im-a-teapot = true  # 이것은 test-dummy-unstable에 의해 활성화된 새로운 옵션입니다.
</code></pre>
</li>
<li>
<p>새로운 명령줄 플래그, 옵션 및 하위 명령어를 사용하려면 <code>-Z unstable-options</code> CLI 옵션도 함께 포함해야 합니다. 예를 들어, 새로운 <code>--artifact-dir</code> 옵션은 나이틀리에서만 사용할 수 있습니다:</p>
<p><code>cargo +nightly build --artifact-dir=out -Z unstable-options</code></p>
</li>
<li>
<p><code>-Z</code> 명령줄 플래그는 인터페이스가 없거나 아직 설계되지 않은 새로운 기능, 또는 Cargo의 여러 부분에 영향을 미치는 더 복잡한 기능을 활성화하는 데 사용됩니다. 예를 들어, <a href="#mtime-on-use">mtime-on-use</a> 기능은 다음을 통해 활성화할 수 있습니다:</p>
<p><code>cargo +nightly build -Z mtime-on-use</code></p>
<p>사용 가능한 플래그 목록을 보려면 <code>cargo -Z help</code>를 실행하세요.</p>
<p><code>-Z</code> 플래그로 구성할 수 있는 모든 것은 cargo <a href="config.html">설정 파일</a> (<code>.cargo/config.toml</code>)의 <code>unstable</code> 테이블에서도 설정할 수 있습니다. 예를 들어:</p>
<pre><code class="language-toml">[unstable]
mtime-on-use = true
build-std = ["core", "alloc"]
</code></pre>
</li>
</ul>
<p>아래 설명된 각 새로운 기능은 사용 방법을 설명해야 합니다.</p>
<p><em>최신 나이틀리에 대해서는 이 페이지의 <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html">나이틀리 버전</a>을 참조하세요.</em></p>
<h2 id="불안정한-기능-목록"><a class="header" href="#불안정한-기능-목록">불안정한 기능 목록</a></h2>
<ul>
<li>불안정 기능 전용 기능
<ul>
<li><a href="#allow-features">-Z allow-features</a> — 사용되는 불안정한 기능을 제한하는 방법을 제공합니다.</li>
</ul>
</li>
<li>빌드 스크립트 및 링킹
<ul>
<li><a href="#metabuild">Metabuild</a> — 선언적 빌드 스크립트를 제공합니다.</li>
<li><a href="#multiple-build-scripts">Multiple Build Scripts</a> — Allows use of multiple build scripts.</li>
<li><a href="#any-build-script-metadata">Any Build Script Metadata</a> — Allow any build script to specify env vars via <code>cargo::metadata=key=value</code></li>
</ul>
</li>
<li>리졸버 및 기능
<ul>
<li><a href="#no-index-update">no-index-update</a> — Cargo가 인덱스 캐시를 업데이트하지 않도록 합니다.</li>
<li><a href="#avoid-dev-deps">avoid-dev-deps</a> — 의존성 해결 중에 리졸버가 개발 의존성(dev-dependencies)을 포함하지 않도록 합니다.</li>
<li><a href="#minimal-versions">minimal-versions</a> — 리졸버가 가장 높은 버전 대신 호환되는 가장 낮은 버전을 사용하도록 강제합니다.</li>
<li><a href="#direct-minimal-versions">direct-minimal-versions</a> — 리졸버가 가장 높은 버전 대신 호환되는 가장 낮은 버전을 사용하도록 강제합니다.</li>
<li><a href="#public-dependency">public-dependency</a> — 의존성을 공개 또는 비공개로 분류할 수 있게 합니다.</li>
<li><a href="#msrv-policy">msrv-policy</a> — MSRV를 인식하는 리졸버 및 버전 선택</li>
<li><a href="#precise-pre-release">precise-pre-release</a> — <code>update --precise</code>로 프리릴리스 버전을 선택할 수 있게 합니다.</li>
<li><a href="#sbom">sbom</a> — 컴파일된 결과물에 대한 SBOM 전구체 파일을 생성합니다.</li>
<li><a href="#update-breaking">update-breaking</a> — <code>update --breaking</code>으로 중단되는 변경이 포함된 버전으로 업그레이드할 수 있게 합니다.</li>
<li><a href="#feature-unification">feature-unification</a> — 워크스페이스에서 새로운 기능 통합 모드를 활성화합니다.</li>
<li>[lockfile-publish-time] — Limit resolver to packages older than the specified time</li>
</ul>
</li>
<li>출력 동작
<ul>
<li><a href="#artifact-dir">artifact-dir</a> — 결과물이 복사될 디렉토리를 추가합니다.</li>
<li><a href="#build-dir-new-layout">build-dir-new-layout</a> — Enables the new build-dir filesystem layout</li>
<li><a href="#different-binary-name">Different binary name</a> — 빌드된 바이너리에 크레이트 이름과 별개의 이름을 할당합니다.</li>
<li><a href="#root-dir">root-dir</a> — 경로가 출력될 기준이 되는 루트 디렉토리를 제어합니다.</li>
</ul>
</li>
<li>컴파일 동작
<ul>
<li><a href="#mtime-on-use">mtime-on-use</a> — 의존성이 사용될 때마다 최종 수정 시간을 업데이트하여, 사용되지 않는 결과물을 삭제하는 메커니즘을 제공합니다.</li>
<li><a href="#build-std">build-std</a> — 사전 빌드된 바이너리를 사용하는 대신 표준 라이브러리를 빌드합니다.</li>
<li><a href="#build-std-features">build-std-features</a> — 표준 라이브러리와 함께 사용할 기능을 설정합니다.</li>
<li><a href="#binary-dep-depinfo">binary-dep-depinfo</a> — dep-info 파일이 바이너리 의존성을 추적하게 합니다.</li>
<li><a href="#checksum-freshness">checksum-freshness</a> — 이 옵션이 전달되면, 크레이트 재빌드 여부를 결정할 때 파일의 mtime 대신 파일 체크섬을 사용합니다.</li>
<li><a href="#panic-abort-tests">panic-abort-tests</a> — “abort” 패닉 전략으로 테스트를 실행할 수 있게 합니다.</li>
<li><a href="#host-config">host-config</a> — 호스트 빌드 타겟에 대해 <code>[target]</code>과 유사한 설정 구성을 허용합니다.</li>
<li><a href="#no-embed-metadata">no-embed-metadata</a> — Passes <code>-Zembed-metadata=no</code> to the compiler, which avoid embedding metadata into rlib and dylib artifacts, to save disk space.</li>
<li><a href="#target-applies-to-host">target-applies-to-host</a> — 특정 플래그가 호스트 빌드 타겟에 전달될지 여부를 변경합니다.</li>
<li><a href="#gc">gc</a> — 전역 캐시 가비지 컬렉션.</li>
<li><a href="#open-namespaces">open-namespaces</a> — 여러 패키지가 동일한 API 네임스페이스에 참여할 수 있게 합니다.</li>
<li><a href="#panic-immediate-abort">panic-immediate-abort</a> — Passes <code>-Cpanic=immediate-abort</code> to the compiler.</li>
<li><a href="#compile-time-deps">compile-time-deps</a> — Perma-unstable feature for rust-analyzer</li>
<li><a href="#fine-grain-locking">fine-grain-locking</a> — Use fine grain locking instead of locking the entire build cache</li>
</ul>
</li>
<li>rustdoc
<ul>
<li><a href="#rustdoc-map">rustdoc-map</a> — 문서가 <a href="https://docs.rs/">docs.rs</a>와 같은 외부 사이트로 링크될 수 있도록 매핑을 제공합니다.</li>
<li><a href="#scrape-examples">scrape-examples</a> — 문서 내에 예제를 보여줍니다.</li>
<li><a href="#output-format-for-rustdoc">output-format</a> — 문서를 실험적인 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustdoc_json_types/">JSON 형식</a>으로도 출력할 수 있게 합니다.</li>
<li><a href="#rustdoc-depinfo">rustdoc-depinfo</a> — Use dep-info files in rustdoc rebuild detection.</li>
<li><a href="#rustdoc-mergeable-info">rustdoc-mergeable-info</a> — Use rustdoc mergeable cross-crate-info files.</li>
</ul>
</li>
<li><code>Cargo.toml</code> 확장
<ul>
<li><a href="#profile-rustflags-option">Profile <code>rustflags</code> 옵션</a> — rustc에 직접 전달됩니다.</li>
<li><a href="#profile-hint-mostly-unused-option">Profile <code>hint-mostly-unused</code> option</a> — Hint that a dependency is mostly unused, to optimize compilation time.</li>
<li><a href="#codegen-backend">codegen-backend</a> — rustc에서 사용할 코드 생성 백엔드를 선택합니다.</li>
<li><a href="#per-package-target">per-package-target</a> — 각 개별 패키지에 사용할 <code>--target</code>을 설정합니다.</li>
<li><a href="#artifact-dependencies">결과물 의존성(artifact dependencies)</a> — 빌드 결과물을 다른 빌드 결과물에 포함할 수 있게 하고, 다른 타겟에 대해 빌드할 수 있게 합니다.</li>
<li><a href="#profile-trim-paths-option">Profile <code>trim-paths</code> 옵션</a> — 빌드 출력에서 파일 경로의 정리(sanitization)를 제어합니다.</li>
<li><a href="#lintscargo"><code>[lints.cargo]</code></a> — Cargo에 대한 린트를 설정할 수 있게 합니다.</li>
<li><a href="#path-bases">path bases</a> — 경로 의존성을 위한 이름이 지정된 기본 디렉토리입니다.</li>
<li><a href="#unstable-editions"><code>unstable-editions</code></a> — Allows use of editions that are not yet stable.</li>
</ul>
</li>
<li>정보 및 메타데이터
<ul>
<li><a href="#unit-graph">unit-graph</a> — Cargo의 내부 그래프 구조에 대한 JSON을 출력합니다.</li>
<li><a href="#rustc---print"><code>cargo rustc --print</code></a> — <code>--print</code>와 함께 rustc를 호출하여 rustc의 정보를 표시합니다.</li>
<li><a href="#build-analysis">Build analysis</a> — Record and persist detailed build metrics across runs, with new commands to query past builds.</li>
<li><a href="#rustc-unicode"><code>rustc-unicode</code></a> — Enables <code>rustc</code>’s unicode error format in Cargo’s error messages</li>
</ul>
</li>
<li>설정
<ul>
<li><a href="#cargo-config"><code>cargo config</code></a> — 설정 파일을 확인하기 위한 새로운 하위 명령어를 추가합니다.</li>
</ul>
</li>
<li>레지스트리
<ul>
<li><a href="#publish-timeout">publish-timeout</a> — 크레이트 업로드와 인덱스에서 사용 가능해지는 사이의 타임아웃을 제어합니다.</li>
<li><a href="#asymmetric-token">asymmetric-token</a> — 비대칭 암호화(<code>cargo:paseto</code> 제공자)를 사용한 인증 토큰 지원을 추가합니다.</li>
</ul>
</li>
<li>기타
<ul>
<li><a href="#gitoxide">gitoxide</a> — 일련의 작업에 대해 <code>git2</code> 대신 <code>gitoxide</code>를 사용합니다.</li>
<li><a href="#script">script</a> — 단일 파일 <code>.rs</code> 패키지에 대한 지원을 활성화합니다.</li>
<li><a href="#lockfile-path">lockfile-path</a> — 기본 경로인 <code>&lt;workspace_root&gt;/Cargo.lock</code> 이외의 잠금 파일 경로를 지정할 수 있게 합니다.</li>
<li><a href="#native-completions">native-completions</a> — Cargo 셸 완성을 네이티브 완성으로 이동합니다.</li>
<li><a href="#warnings">warnings</a> — 경고 동작을 제어합니다. 경고를 허용하거나 거부하는 옵션이 있습니다.</li>
<li><a href="#package-message-format">Package message format</a> — Message format for <code>cargo package</code>.</li>
<li><a href="#fix-edition"><code>fix-edition</code></a> — A permanently unstable edition migration helper.</li>
<li><a href="https://github.com/crate-ci/cargo-plumbing">Plumbing subcommands</a> — Low, level commands that act as APIs for Cargo, like <code>cargo metadata</code></li>
</ul>
</li>
</ul>
<h2 id="allow-features"><a class="header" href="#allow-features">allow-features</a></h2>
<p>이 영구적으로 불안정한(permanently-unstable) 플래그는 나열된 일련의 불안정한 기능들만 사용할 수 있게 합니다. 구체적으로, <code>-Zallow-features=foo,bar</code>를 전달하면 <code>cargo</code>에 <code>-Zfoo</code>와 <code>-Zbar</code>는 계속 전달할 수 있지만, <code>-Zbaz</code>는 전달할 수 없게 됩니다. 빈 문자열(<code>-Zallow-features=</code>)을 전달하여 모든 불안정한 기능을 허용하지 않을 수도 있습니다.</p>
<p><code>-Zallow-features</code>는 또한 <code>Cargo.toml</code>의 <code>cargo-features</code> 항목에 전달될 수 있는 불안정한 기능을 제한합니다. 예를 들어, 다음을 허용하고 싶다면</p>
<pre><code class="language-toml">cargo-features = ["test-dummy-unstable"]
</code></pre>
<p>여기서 <code>test-dummy-unstable</code>이 불안정한 기능인 경우, 해당 기능은 <code>-Zallow-features=</code>에 의해 허용되지 않으며, <code>-Zallow-features=test-dummy-unstable</code>을 사용해야 허용됩니다.</p>
<p>Cargo의 <code>-Zallow-features</code>에 전달된 기능 목록은 Cargo가 호출하는 모든 Rust 도구(<code>rustc</code>나 <code>rustdoc</code> 등)에도 전달됩니다. 따라서 <code>cargo -Zallow-features=</code>를 실행하면 불안정한 Cargo 기능이나 Rust 기능을 모두 사용할 수 없습니다.</p>
<h2 id="no-index-update"><a class="header" href="#no-index-update">no-index-update</a></h2>
<ul>
<li>원본 이슈: <a href="https://github.com/rust-lang/cargo/issues/3479">#3479</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/7404">#7404</a></li>
</ul>
<p><code>-Z no-index-update</code> 플래그는 Cargo가 레지스트리 인덱스 업데이트를 시도하지 않도록 합니다. 이것은 Crater와 같이 많은 Cargo 명령을 내리는 도구를 위한 것이며, 매번 인덱스를 업데이트하는 네트워크 지연 시간을 피하고 싶을 때 사용합니다.</p>
<h2 id="mtime-on-use"><a class="header" href="#mtime-on-use">mtime-on-use</a></h2>
<ul>
<li>원본 이슈: <a href="https://github.com/rust-lang/cargo/pull/6477">#6477</a></li>
<li>캐시 사용 메타 추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/7150">#7150</a></li>
</ul>
<p><code>-Z mtime-on-use</code> 플래그는 사용된 파일의 mtime을 Cargo가 업데이트하도록 하여 cargo-sweep와 같은 도구가 어떤 파일이 오래되었는지 더 쉽게 감지할 수 있도록 하는 실험입니다. 많은 워크플로에서 이 설정은 Cargo의 <em>모든</em> 호출에 적용되어야 합니다. 이를 보다 실용적으로 만들기 위해 <code>.cargo/config.toml</code>에서 <code>unstable.mtime_on_use</code> 플래그를 설정하거나 해당 환경 변수를 설정하면 nightly Cargo의 모든 호출에 <code>-Z mtime-on-use</code>가 적용됩니다. (이 설정 플래그는 stable에서는 무시됩니다.)</p>
<h2 id="avoid-dev-deps"><a class="header" href="#avoid-dev-deps">avoid-dev-deps</a></h2>
<ul>
<li>원본 이슈: <a href="https://github.com/rust-lang/cargo/issues/4988">#4988</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/5133">#5133</a></li>
</ul>
<p><code>cargo install</code>이나 <code>cargo build</code>와 같은 명령을 실행할 때, 현재 Cargo는 사용되지 않더라도 개발 의존성(dev-dependencies)을 다운로드해야 합니다. <code>-Z avoid-dev-deps</code> 플래그를 사용하면 필요하지 않은 경우 개발 의존성 다운로드를 피할 수 있습니다. 개발 의존성을 건너뛰면 <code>Cargo.lock</code> 파일이 생성되지 않습니다.</p>
<h2 id="minimal-versions"><a class="header" href="#minimal-versions">minimal-versions</a></h2>
<ul>
<li>원본 이슈: <a href="https://github.com/rust-lang/cargo/issues/4100">#4100</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/5657">#5657</a></li>
</ul>
<blockquote>
<p>참고: 이 기능을 사용하는 것은 권장되지 않습니다. 모든 전이적(transitive) 의존성에 대해 최소 버전을 강제하기 때문에, 모든 외부 의존성이 적절한 하위 버전 범위를 선언하지는 않으므로 유용성이 제한적입니다. 향후 직접적인 의존성에 대해서만 최소 버전을 강제하도록 변경될 예정입니다.</p>
</blockquote>
<p><code>Cargo.lock</code> 파일이 생성될 때, <code>-Z minimal-versions</code> 플래그는 요구 사항을 충족하는 가장 높은 버전 대신 가장 낮은 SemVer 버전으로 의존성을 해결합니다.</p>
<p>이 플래그의 의도된 사용 사례는 지속적 통합(CI) 중에 Cargo.toml에 지정된 버전이 실제로 사용 중인 최소 버전을 올바르게 반영하고 있는지 확인하는 것입니다. 즉, Cargo.toml에 <code>foo = "1.0.0"</code>이라고 되어 있을 때 실수로 <code>foo 1.5.0</code>에서만 추가된 기능에 의존하고 있지는 않은지 확인하는 것입니다.</p>
<h2 id="direct-minimal-versions"><a class="header" href="#direct-minimal-versions">direct-minimal-versions</a></h2>
<ul>
<li>원본 이슈: <a href="https://github.com/rust-lang/cargo/issues/4100">#4100</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/5657">#5657</a></li>
</ul>
<p><code>Cargo.lock</code> 파일이 생성될 때, <code>-Z direct-minimal-versions</code> 플래그는 직접적인 의존성에 대해서만 요구 사항을 충족하는 가장 높은 버전 대신 가장 낮은 SemVer 버전으로 의존성을 해결합니다.</p>
<p>이 플래그의 의도된 사용 사례는 지속적 통합(CI) 중에 Cargo.toml에 지정된 버전이 실제로 사용 중인 최소 버전을 올바르게 반영하고 있는지 확인하는 것입니다. 즉, Cargo.toml에 <code>foo = "1.0.0"</code>이라고 되어 있을 때 실수로 <code>foo 1.5.0</code>에서만 추가된 기능에 의존하고 있지는 않은지 확인하는 것입니다.</p>
<p>간접적인 의존성은 최소 버전 검증에 의해 차단되지 않도록 정상적으로 해결됩니다.</p>
<h2 id="artifact-dir"><a class="header" href="#artifact-dir">artifact-dir</a></h2>
<ul>
<li>원본 이슈: <a href="https://github.com/rust-lang/cargo/issues/4875">#4875</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/6790">#6790</a></li>
</ul>
<p>이 기능을 사용하면 결과물이 빌드된 후 복사될 디렉토리를 지정할 수 있습니다. 일반적으로 결과물은 <code>target/release</code>나 <code>target/debug</code> 디렉토리에만 기록됩니다. 그러나 JSON 출력을 파싱해야 하므로 정확한 파일 이름을 결정하는 것이 까다로울 수 있습니다. <code>--artifact-dir</code> 플래그를 사용하면 예측 가능한 방식으로 결과물에 접근하기가 더 쉬워집니다. 결과물은 복사되는 것이므로 원본은 여전히 <code>target</code> 디렉토리에 남아 있음에 유의하세요. 예시:</p>
<pre><code class="language-sh">cargo +nightly build --artifact-dir=out -Z unstable-options
</code></pre>
<p>이는 <code>.cargo/config.toml</code> 파일에서도 지정할 수 있습니다.</p>
<pre><code class="language-toml">[build]
artifact-dir = "out"
</code></pre>
<h2 id="root-dir"><a class="header" href="#root-dir">root-dir</a></h2>
<ul>
<li>원본 이슈: <a href="https://github.com/rust-lang/cargo/issues/9887">#9887</a></li>
<li>추적 이슈: 없음 (현재 안정화 계획 없음)</li>
</ul>
<p><code>-Zroot-dir</code> 플래그는 경로가 출력되는 기준이 되는 루트 디렉토리를 설정합니다. 이는 진단 정보와 <code>file!()</code> 매크로에 의해 출력되는 경로 모두에 영향을 미칩니다.</p>
<h2 id="metabuild"><a class="header" href="#metabuild">Metabuild</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/rust/issues/49803">rust-lang/rust#49803</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/blob/master/text/2196-metabuild.md">#2196</a></li>
</ul>
<p>Metabuild는 선언적 빌드 스크립트를 가질 수 있는 기능입니다. <code>build.rs</code> 스크립트를 작성하는 대신, <code>Cargo.toml</code>의 <code>metabuild</code> 키에 빌드 의존성 목록을 지정합니다. 각 빌드 의존성을 순서대로 실행하는 빌드 스크립트가 자동으로 생성됩니다. Metabuild 패키지는 <code>Cargo.toml</code>에서 메타데이터를 읽어 동작을 지정할 수 있습니다.</p>
<p><code>Cargo.toml</code> 상단에 <code>cargo-features</code>를 포함하고, <code>package</code>에 <code>metabuild</code> 키를 추가하며, <code>build-dependencies</code>에 의존성을 나열하고, metabuild 패키지가 요구하는 메타데이터를 <code>package.metadata</code> 아래에 추가하세요. 예시:</p>
<pre><code class="language-toml">[package]
name = "my-package"
version = "0.1.0"
metabuild = ["foo", "bar"]

[build-dependencies]
foo = "1.0"
bar = "1.0"

[package.metadata.foo]
extra-info = "qwerty"
</code></pre>
<p>Metabuild 패키지는 일반적인 <code>build.rs</code> 스크립트가 수행하는 것과 동일한 작업을 수행하는 <code>metabuild</code>라는 이름의 공개 함수를 가지고 있어야 합니다.</p>
<h2 id="multiple-build-scripts"><a class="header" href="#multiple-build-scripts">Multiple Build Scripts</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/14903">#14903</a></li>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/15630">#15630</a></li>
</ul>
<p>Multiple Build Scripts feature allows you to have multiple build scripts in your package.</p>
<p>Include <code>cargo-features</code> at the top of <code>Cargo.toml</code> and add <code>multiple-build-scripts</code> to enable feature. Add the paths of the build scripts as an array in <code>package.build</code>. For example:</p>
<pre><code class="language-toml">cargo-features = ["multiple-build-scripts"]

[package]
name = "mypackage"
version = "0.0.1"
build = ["foo.rs", "bar.rs"]
</code></pre>
<p><strong>Accessing Output Directories</strong>:  Output directory of each build script can be accessed by using <code>&lt;script-name&gt;_OUT_DIR</code> where the <code>&lt;script-name&gt;</code> is the file-stem of the build script, exactly as-is. For example, <code>bar_OUT_DIR</code> for script at <code>foo/bar.rs</code>. (Only set during compilation, can be accessed via <code>env!</code> macro)</p>
<h2 id="any-build-script-metadata"><a class="header" href="#any-build-script-metadata">Any Build Script Metadata</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/3544">#14903</a></li>
</ul>
<p>Allow any build script to specify env vars via <code>cargo::metadata=key=value</code></p>
<p>Depedant build scripts can access these key/value pair by reading the <code>CARGO_DEP_&lt;dep&gt;_&lt;key&gt;</code> env variable at runtime. For build scripts of crates with a <code>links</code>, both <code>DEP_&lt;links&gt;_&lt;key&gt;</code> and <code>CARGO_DEP_&lt;dep&gt;_&lt;key&gt;</code> will be set.</p>
<p>Note that <code>dep</code> and <code>key</code> in <code>CARGO_DEP_&lt;dep&gt;_&lt;key&gt;</code> are uppercased and hyphens (<code>-</code>) replaced with underscores (<code>_</code>).</p>
<h2 id="public-dependency"><a class="header" href="#public-dependency">public-dependency</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/rust/issues/44663">#44663</a></li>
</ul>
<p>‘public-dependency’ 기능을 사용하면 의존성을 ‘공개(public)’ 또는 ’비공개(private)’로 표시할 수 있습니다. 이 기능이 활성화되면, <a href="../../rustc/lints/listing/warn-by-default.html#exported-private-dependencies">exported_private_dependencies</a> 린트가 제대로 작동할 수 있도록 rustc에 추가 정보가 전달됩니다.</p>
<p>이 기능을 활성화하려면, <code>-Zpublic-dependency</code>를 사용하거나</p>
<pre><code class="language-sh">cargo +nightly run -Zpublic-dependency
</code></pre>
<p>또는 예를 들어 <code>[unstable]</code> 표를 사용할 수 있습니다.</p>
<pre><code class="language-toml"># .cargo/config.toml
[unstable]
public-dependency = true
</code></pre>
<p><code>public-dependency</code>는 <code>cargo-features</code>에서도 활성화할 수 있었으나, <strong>현재는 권장되지 않으며(deprecated) 곧 제거될 예정</strong>입니다.</p>
<pre><code class="language-toml">cargo-features = ["public-dependency"]

[dependencies]
my_dep = { version = "1.2.3", public = true }
private_dep = "2.0.0" # 기본적으로 '비공개(private)'가 됩니다
</code></pre>
<p>문서 업데이트:</p>
<ul>
<li>워크스페이스의 “The <code>dependencies</code> table” 섹션에 대해, <code>workspace.dependencies</code>에서 지원되지 않는 필드로 <code>public</code>을 포함하세요.</li>
</ul>
<h2 id="msrv-policy"><a class="header" href="#msrv-policy">msrv-policy</a></h2>
<ul>
<li><a href="https://rust-lang.github.io/rfcs/3537-msrv-resolver.html">RFC: MSRV-aware Resolver</a></li>
<li><a href="https://github.com/rust-lang/cargo/issues/9930">#9930</a> (MSRV 인식 리졸버)</li>
</ul>
<p><a href="https://github.com/rust-lang/rfcs/pull/2495">RFC 2495</a>에 따른 MSRV 인식 Cargo 기능을 위한 포괄적 불안정 기능입니다.</p>
<h3 id="msrv-인식-cargo-add"><a class="header" href="#msrv-인식-cargo-add">MSRV 인식 cargo add</a></h3>
<p>이는 1.79 버전에서 <a href="https://github.com/rust-lang/cargo/pull/13608">#13608</a>을 통해 안정화되었습니다.</p>
<h3 id="msrv-인식-리졸버"><a class="header" href="#msrv-인식-리졸버">MSRV 인식 리졸버</a></h3>
<p>이는 1.84 버전에서 <a href="https://github.com/rust-lang/cargo/pull/14639">#14639</a>을 통해 안정화되었습니다.</p>
<h3 id="incompatible_toolchain-오류를-린트로-변환"><a class="header" href="#incompatible_toolchain-오류를-린트로-변환"><code>incompatible_toolchain</code> 오류를 린트로 변환</a></h3>
<p>미구현</p>
<h3 id="cargo-add-cargo-update를-위한---update-rust-version-플래그"><a class="header" href="#cargo-add-cargo-update를-위한---update-rust-version-플래그"><code>cargo add</code>, <code>cargo update</code>를 위한 <code>--update-rust-version</code> 플래그</a></h3>
<p>미구현</p>
<h3 id="packagerust-version--toolchain"><a class="header" href="#packagerust-version--toolchain"><code>package.rust-version = "toolchain"</code></a></h3>
<p>미구현</p>
<h3 id="packagerust-version--toolchain을-설정하도록-cargo-new-템플릿을-업데이트합니다"><a class="header" href="#packagerust-version--toolchain을-설정하도록-cargo-new-템플릿을-업데이트합니다"><code>package.rust-version = "toolchain"</code>을 설정하도록 <code>cargo new</code> 템플릿을 업데이트합니다.</a></h3>
<p>미구현</p>
<h2 id="precise-pre-release"><a class="header" href="#precise-pre-release">precise-pre-release</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/13290">#13290</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/3493">#3493</a></li>
</ul>
<p><code>precise-pre-release</code> 기능을 사용하면 프로젝트의 <code>Cargo.toml</code>에 프리릴리스가 지정되어 있지 않더라도 <code>update --precise</code>를 통해 프리릴리스 버전을 선택할 수 있습니다.</p>
<p>예를 들어 다음과 같은 <code>Cargo.toml</code>이 있다고 가정해 봅시다.</p>
<pre><code class="language-toml">[dependencies]
my-dependency = "0.1.1"
</code></pre>
<p><code>update -Zunstable-options my-dependency --precise 0.1.2-pre.0</code>를 사용하여 <code>my-dependency</code>를 프리릴리스 버전으로 업데이트할 수 있습니다. 이는 <code>0.1.2-pre.0</code>이 <code>0.1.1</code>과 호환되는 것으로 간주되기 때문입니다. 같은 방식으로 <code>0.1.1</code>에서 <code>0.2.0-pre.0</code>으로 업그레이드하는 것은 불가능합니다.</p>
<h2 id="sbom"><a class="header" href="#sbom">sbom</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/pull/13709">#13709</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/3553">#3553</a></li>
</ul>
<p><code>sbom</code> 빌드 설정을 사용하면 각 컴파일된 결과물과 함께 이른바 SBOM 전구체(pre-cursor) 파일을 생성할 수 있습니다. 소프트웨어 자재 명세서(SBOM) 도구는 이러한 생성된 파일을 통합하여, 다른 방식으로는 얻기 어렵거나 불가능한 Cargo 빌드 과정의 중요한 정보를 수집할 수 있습니다.</p>
<p>이 기능을 활성화하려면 <code>.cargo/config.toml</code>에서 <code>sbom</code> 필드를 설정하거나</p>
<pre><code class="language-toml">[unstable]
sbom = true

[build]
sbom = true
</code></pre>
<p>또는 <code>CARGO_BUILD_SBOM</code> 환경 변수를 <code>true</code>로 설정하세요. 이 기능은 <code>-Z sbom</code> 플래그를 통해 사용할 수 있습니다.</p>
<p>생성된 출력 파일은 JSON 형식이며 <code>&lt;artifact&gt;.cargo-sbom.json</code> 명명 규칙을 따릅니다. JSON 파일에는 의존성, 타겟, 기능 및 사용된 <code>rustc</code> 컴파일러에 대한 정보가 포함되어 있습니다.</p>
<p>SBOM 전구체 파일은 타겟 또는 결과물 디렉토리로 상향(uplifted)되는 모든 실행 가능 및 링크 가능 출력물에 대해 생성됩니다.</p>
<h3 id="cargo가-크레이트를-위해-설정하는-환경-변수"><a class="header" href="#cargo가-크레이트를-위해-설정하는-환경-변수">Cargo가 크레이트를 위해 설정하는 환경 변수</a></h3>
<ul>
<li><code>CARGO_SBOM_PATH</code> – 플랫폼 PATH 구분자로 구분된 생성된 SBOM 전구체 파일 목록입니다. 이 목록은 <code>std::env::split_paths</code>로 분리할 수 있습니다.</li>
</ul>
<h3 id="sbom-전구체-스키마"><a class="header" href="#sbom-전구체-스키마">SBOM 전구체 스키마</a></h3>
<pre><code class="language-json5">{
  // Schema version.
  "version": 1,
  // Index into the crates array for the root crate.
  "root": 0,
  // Array of all crates. There may be duplicates of the same crate if that
  // crate is compiled differently (different opt-level, features, etc).
  "crates": [
    {
      // Fully qualified package ID specification
      "id": "path+file:///sample-package#0.1.0",
      // List of target kinds: bin, lib, rlib, dylib, cdylib, staticlib, proc-macro, example, test, bench, custom-build
      "kind": ["bin"],
      // Enabled feature flags.
      "features": [],
      // Dependencies for this crate.
      "dependencies": [
        {
          // Index in to the crates array.
          "index": 1,
          // Dependency kind: 
          // Normal: A dependency linked to the artifact produced by this crate.
          // Build: A compile-time dependency used to build this crate (build-script or proc-macro).
          "kind": "normal"
        },
        {
          // A crate can depend on another crate with both normal and build edges.
          "index": 1,
          "kind": "build"
        }
      ]
    },
    {
      "id": "registry+https://github.com/rust-lang/crates.io-index#zerocopy@0.8.16",
      "kind": ["bin"],
      "features": [],
      "dependencies": []
    }
  ],
  // Information about rustc used to perform the compilation.
  "rustc": {
    // Compiler version
    "version": "1.86.0-nightly",
    // Compiler wrapper
    "wrapper": null,
    // Compiler workspace wrapper
    "workspace_wrapper": null,
    // Commit hash for rustc
    "commit_hash": "bef3c3b01f690de16738b1c9f36470fbfc6ac623",
    // Host target triple
    "host": "x86_64-pc-windows-msvc",
    // Verbose version string: `rustc -vV`
    "verbose_version": "rustc 1.86.0-nightly (bef3c3b01 2025-02-04)\nbinary: rustc\ncommit-hash: bef3c3b01f690de16738b1c9f36470fbfc6ac623\ncommit-date: 2025-02-04\nhost: x86_64-pc-windows-msvc\nrelease: 1.86.0-nightly\nLLVM version: 19.1.7\n"
  }
}
</code></pre>
<h2 id="update-breaking"><a class="header" href="#update-breaking">update-breaking</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/12425">#12425</a></li>
</ul>
<p><code>--breaking</code> 플래그를 사용하여 <code>Cargo.toml</code>의 의존성 버전 요구 사항을 SemVer와 호환되지 않는 버전으로 업그레이드할 수 있게 합니다.</p>
<p>이는 다음과 같은 경우의 의존성에만 적용됩니다</p>
<ul>
<li>패키지가 워크스페이스 멤버의 의존성인 경우</li>
<li>의존성 이름이 변경되지 않은 경우</li>
<li>SemVer와 호환되지 않는 버전을 사용할 수 있는 경우</li>
<li>“SemVer 연산자“가 사용된 경우 (기본값인 <code>^</code>)</li>
</ul>
<p>사용자는 명령줄에 패키지를 지정하여 업그레이드할 패키지를 더 제한할 수 있습니다.</p>
<p>예시:</p>
<pre><code class="language-console">$ cargo +nightly -Zunstable-options update --breaking
$ cargo +nightly -Zunstable-options update --breaking clap
</code></pre>
<p><em>이는 <a href="https://github.com/killercup/cargo-edit/">cargo-upgrade</a>와 유사한 역할을 하기 위한 것입니다.</em></p>
<h2 id="build-std"><a class="header" href="#build-std">build-std</a></h2>
<ul>
<li>추적 저장소: <a href="https://github.com/rust-lang/wg-cargo-std-aware">https://github.com/rust-lang/wg-cargo-std-aware</a></li>
</ul>
<p><code>build-std</code> 기능을 사용하면 Cargo가 크레이트 그래프 컴파일의 일부로 표준 라이브러리 자체를 컴파일할 수 있습니다. 이 기능은 역사적으로 “std-aware Cargo“라고도 알려져 왔습니다. 이 기능은 아직 개발 초기 단계에 있으며, Cargo에 추가될 수 있는 거대한 기능이기도 합니다. 오늘날 존재하는 최소한의 형태조차도 문서화하기에는 매우 방대한 기능이므로, 최신 상태를 유지하고 싶다면 <a href="https://github.com/rust-lang/wg-cargo-std-aware">추적 저장소</a>와 관련 이슈들을 팔로우하는 것이 좋습니다.</p>
<p>오늘날 구현된 기능은 <code>-Z build-std</code>라는 플래그 뒤에 있습니다. 이 플래그는 메인 빌드 자체와 동일한 프로파일을 사용하여 소스 코드로부터 표준 라이브러리를 컴파일하도록 Cargo에 지시합니다. 이 기능이 작동하려면 표준 라이브러리의 소스 코드가 있어야 하며, 현재로서는 <code>rust-src</code> rustup 컴포넌트를 추가하는 것이 유일하게 지원되는 방법입니다.</p>
<pre><code class="language-console">$ rustup component add rust-src --toolchain nightly
</code></pre>
<p>사용법은 다음과 같습니다.</p>
<pre><code class="language-console">$ cargo new foo
$ cd foo
$ cargo +nightly run -Z build-std --target x86_64-unknown-linux-gnu
   Compiling core v0.0.0 (...)
   ...
   Compiling foo v0.1.0 (...)
    Finished dev [unoptimized + debuginfo] target(s) in 21.00s
     Running `target/x86_64-unknown-linux-gnu/debug/foo`
Hello, world!
</code></pre>
<p>여기서는 디버그 어설션이 포함된 디버그 모드로 표준 라이브러리를 재컴파일했으며(<code>src/main.rs</code>가 컴파일되는 방식과 동일), 마지막에 모든 것이 함께 링크되었습니다.</p>
<p><code>-Z build-std</code>를 사용하면 안정적인 크레이트인 <code>core</code>, <code>std</code>, <code>alloc</code>, <code>proc_macro</code>가 암시적으로 컴파일됩니다. <code>cargo test</code>를 사용하는 경우 <code>test</code> 크레이트도 컴파일됩니다. 이러한 크레이트 중 일부를 지원하지 않는 환경에서 작업하는 경우 <code>-Zbuild-std</code>에 인수를 전달할 수도 있습니다.</p>
<pre><code class="language-console">$ cargo +nightly build -Z build-std=core,alloc
</code></pre>
<p>여기에 입력할 값은 빌드할 표준 라이브러리 크레이트의 쉼표로 구분된 목록입니다.</p>
<h3 id="요구-사항"><a class="header" href="#요구-사항">요구 사항</a></h3>
<p>요약하자면, 현재 <code>-Z build-std</code>를 사용하기 위한 요구 사항은 다음과 같습니다.</p>
<ul>
<li><code>rustup component add rust-src</code>를 통해 libstd의 소스 코드를 설치해야 합니다.</li>
<li>nightly Cargo와 nightly rustc를 모두 사용해야 합니다.</li>
<li>모든 <code>cargo</code> 호출 시 <code>-Z build-std</code> 플래그를 전달해야 합니다.</li>
</ul>
<h3 id="버그-보고-및-지원"><a class="header" href="#버그-보고-및-지원">버그 보고 및 지원</a></h3>
<p><code>-Z build-std</code> 기능은 아직 개발 초기 단계에 있습니다! 이 기능은 Cargo에서 매우 긴 역사를 가지고 있으며 범위도 매우 넓지만, 이제 막 시작된 단계입니다. 버그를 보고하고 싶으시다면 다음 중 한 곳에 보고해 주세요.</p>
<ul>
<li>Cargo — <a href="https://github.com/rust-lang/cargo/issues/new">https://github.com/rust-lang/cargo/issues/new</a> — 구현 버그용</li>
<li>추적 저장소 — <a href="https://github.com/rust-lang/wg-cargo-std-aware/issues/new">https://github.com/rust-lang/wg-cargo-std-aware/issues/new</a> — 큰 규모의 설계 관련 질문용</li>
</ul>
<p>또한 아직 구현되지 않은 기능을 보고 싶거나 무언가 원하는 대로 작동하지 않는 경우, 추적 저장소의 <a href="https://github.com/rust-lang/wg-cargo-std-aware/issues">이슈 트래커</a>를 자유롭게 확인해 보세요. 거기에 없다면 새 이슈를 등록해 주세요!</p>
<h2 id="build-std-features"><a class="header" href="#build-std-features">build-std-features</a></h2>
<ul>
<li>추적 저장소: <a href="https://github.com/rust-lang/wg-cargo-std-aware">https://github.com/rust-lang/wg-cargo-std-aware</a></li>
</ul>
<p>이 플래그는 <code>-Zbuild-std</code> 기능 플래그의 자매격입니다. 표준 라이브러리를 빌드할 때 표준 라이브러리 자체에 활성화할 기능을 설정합니다. 현재 기본적으로 활성화되는 기능은 <code>backtrace</code>와 <code>panic-unwind</code>입니다. 이 플래그는 쉼표로 구분된 목록을 받으며, 제공될 경우 기본 활성화 기능 목록을 덮어씁니다.</p>
<h2 id="binary-dep-depinfo"><a class="header" href="#binary-dep-depinfo">binary-dep-depinfo</a></h2>
<ul>
<li>rustc 추적 이슈: <a href="https://github.com/rust-lang/rust/issues/63012">#63012</a></li>
</ul>
<p><code>-Z binary-dep-depinfo</code> 플래그는 Cargo가 동일한 플래그를 <code>rustc</code>에 전달하도록 하여, <code>rustc</code>가 “.d” 확장자를 가진 “dep info” 파일에 모든 바이너리 의존성의 경로를 포함하게 합니다. 그 후 Cargo는 이 정보를 사용하여 변경 사항을 감지합니다(바이너리 의존성이 변경되면 크레이트가 다시 빌드됩니다). 주요 사용 사례는 컴파일러 자체를 빌드할 때로, 표준 라이브러리에 대한 암시적인 의존성이 있어 그렇지 않으면 변경 감지가 되지 않는 경우를 대비한 것입니다.</p>
<h2 id="checksum-freshness"><a class="header" href="#checksum-freshness">checksum-freshness</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/14136">#14136</a></li>
</ul>
<p><code>-Z checksum-freshness</code> 플래그는 Cargo의 핑거프린트(fingerprint)에서 파일 mtime 대신 파일 체크섬 값을 사용하도록 대체합니다. 이는 mtime 구현이 부실한 시스템이나 CI/CD 환경에서 유용합니다. 체크섬 알고리즘은 Cargo 버전에 따라 예고 없이 변경될 수 있습니다. 핑거프린트는 Cargo가 크레이트 재빌드 필요 여부를 결정하는 데 사용됩니다.</p>
<p>당분간은 <code>checksum-freshness</code>가 활성화되어 있더라도 빌드 스크립트에서 사용되는 파일들은 계속해서 mtime을 사용합니다. 이는 장기적인 해결책으로 의도된 것은 아닙니다.</p>
<h2 id="panic-abort-tests"><a class="header" href="#panic-abort-tests">panic-abort-tests</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/rust/issues/67650">#67650</a></li>
<li>원본 풀 리퀘스트: <a href="https://github.com/rust-lang/cargo/pull/7460">#7460</a></li>
</ul>
<p><code>-Z panic-abort-tests</code> 플래그는 테스트 하네스(test harness) 크레이트를 <code>-Cpanic=abort</code>로 컴파일하는 nightly 지원을 활성화합니다. 이 플래그가 없으면 Cargo는 테스트와 그 모든 의존성을 <code>-Cpanic=unwind</code>로 컴파일하는데, 이는 <code>test</code> 크레이트가 작동하는 유일한 방법이기 때문입니다. 하지만 <a href="https://github.com/rust-lang/rust/pull/64158">rust-lang/rust#64158</a>부터 <code>test</code> 크레이트는 프로세스당 하나의 테스트(test-per-process) 방식으로 <code>-C panic=abort</code>를 지원하며, 이는 크레이트 그래프를 여러 번 컴파일하는 것을 피하는 데 도움이 될 수 있습니다.</p>
<p>현재 이 기능이 Cargo에서 어떻게 안정화될지는 불분명하지만, 어떤 방식으로든 안정화되기를 원합니다!</p>
<h2 id="target-applies-to-host"><a class="header" href="#target-applies-to-host">target-applies-to-host</a></h2>
<ul>
<li>원본 풀 리퀘스트: <a href="https://github.com/rust-lang/cargo/pull/9322">#9322</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/9453">#9453</a></li>
</ul>
<p>역사적으로, 환경 변수 및 <a href="config.html#target"><code>[target]</code></a>의 <code>linker</code> 및 <code>rustflags</code> 설정 옵션이 빌드 스크립트, 플러그인 및 항상 호스트 플랫폼용으로 빌드되는 기타 결과물에 대해 적용되는지 여부에 관한 Cargo의 동작은 다소 일관되지 않았습니다. <code>--target</code>이 전달되지 <em>않으면</em>, Cargo는 다른 모든 컴파일 결과물과 동일한 <code>linker</code> 및 <code>rustflags</code>를 빌드 스크립트에 적용합니다. 그러나 <code>--target</code>이 전달_되면_, Cargo는 <a href="config.html#targettriplelinker"><code>[target.&lt;host triple&gt;]</code></a>의 <code>linker</code>는 적용하지만, 어떤 <code>rustflags</code> 설정도 가져오지 않습니다. 이러한 이중적인 동작은 혼란스러울 뿐만 아니라, 호스트 트리플과 <a href="../appendix/glossary.html#target" title="&quot;target&quot; (용어집)">타겟 트리플</a>이 우연히 같더라도 빌드 호스트에서 실행될 결과물을 다르게 설정해야 하는 빌드를 올바르게 구성하는 것을 어렵게 만듭니다.</p>
<p><code>-Ztarget-applies-to-host</code>는 Cargo 설정 파일에서 최상위 <code>target-applies-to-host</code> 설정을 활성화하여 사용자가 이러한 속성들에 대해 다르고 (더 일관된) 동작을 선택할 수 있게 합니다. 설정 파일에서 <code>target-applies-to-host</code>가 설정되지 않았거나 <code>true</code>로 설정된 경우 기존 Cargo 동작이 유지됩니다 (단, 해당 기본값을 변경하는 <code>-Zhost-config</code>를 참고하세요). <code>false</code>로 설정되면, Cargo에 <code>--target</code> 전달 여부와 관계없이 호스트 결과물에 대해 <code>[target.&lt;host triple&gt;]</code>, <code>RUSTFLAGS</code> 또는 <code>[build]</code>의 어떤 옵션도 적용되지 않습니다. 호스트에서 실행될 결과물을 사용자 정의하려면 <code>[host]</code> (<a href="#host-config"><code>host-config</code></a>)를 사용하세요.</p>
<p>향후에는 더 합리적이고 일관된 기본 동작을 제공하기 위해 <code>target-applies-to-host</code>의 기본값이 <code>false</code>가 될 수 있습니다.</p>
<pre><code class="language-toml"># config.toml
target-applies-to-host = false
</code></pre>
<pre><code class="language-console">cargo +nightly -Ztarget-applies-to-host build --target x86_64-unknown-linux-gnu
</code></pre>
<h2 id="host-config"><a class="header" href="#host-config">host-config</a></h2>
<ul>
<li>원본 풀 리퀘스트: <a href="https://github.com/rust-lang/cargo/pull/9322">#9322</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/9452">#9452</a></li>
</ul>
<p>설정 파일의 <code>host</code> 키는 교차 컴파일 시 타겟 시스템 대신 호스트 시스템에서 실행되어야 하는 빌드 스크립트와 같은 호스트 빌드 타겟에 플래그를 전달하는 데 사용할 수 있습니다. 일반적인 테이블과 호스트 아키텍처별 테이블을 모두 지원합니다. 일치하는 호스트 아키텍처 테이블은 일반 호스트 테이블보다 우선순위를 가집니다.</p>
<p>이 기능은 <code>-Zhost-config</code> 및 <code>-Ztarget-applies-to-host</code> 명령줄 옵션이 설정되어 있어야 하며, Cargo 설정 파일에 <code>target-applies-to-host = false</code>가 설정되어 있어야 합니다.</p>
<pre><code class="language-toml"># config.toml
[host]
linker = "/path/to/host/linker"
[host.x86_64-unknown-linux-gnu]
linker = "/path/to/host/arch/linker"
rustflags = ["-Clink-arg=--verbose"]
[target.x86_64-unknown-linux-gnu]
linker = "/path/to/target/linker"
</code></pre>
<p>위의 일반 <code>host</code> 테이블은 <code>x86_64-unknown-linux-gnu</code> 호스트에서 빌드할 때 <code>host.x86_64-unknown-linux-gnu</code> 테이블이 우선하므로 완전히 무시됩니다.</p>
<p><code>-Zhost-config</code>를 설정하면 <code>target-applies-to-host</code>의 기본값이 <code>true</code>에서 <code>false</code>로 변경됩니다.</p>
<pre><code class="language-console">cargo +nightly -Ztarget-applies-to-host -Zhost-config build --target x86_64-unknown-linux-gnu
</code></pre>
<h2 id="unit-graph"><a class="header" href="#unit-graph">unit-graph</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/8002">#8002</a></li>
</ul>
<p><code>--unit-graph</code> 플래그는 Cargo의 내부 유닛 그래프를 나타내는 JSON 객체를 표준 출력으로 내보내기 위해 모든 빌드 명령 (<code>build</code>, <code>check</code>, <code>run</code>, <code>test</code>, <code>bench</code>, <code>doc</code> 등)에 전달될 수 있습니다. 실제로 빌드되는 것은 없으며, 명령은 출력 후 즉시 반환됩니다. 각 “유닛“은 컴파일러의 한 번의 실행에 해당합니다. 이러한 객체에는 각 유닛이 의존하는 유닛 정보도 포함됩니다.</p>
<pre><code>cargo +nightly build --unit-graph -Z unstable-options
</code></pre>
<p>이 구조는 Cargo가 바라보는 의존성 관계에 대한 더 완전한 뷰를 제공합니다. 특히 “features” 필드는 의존성이 서로 다른 기능으로 여러 번 빌드될 수 있는 새로운 기능 리졸버를 지원합니다. <code>cargo metadata</code>는 기본적으로 서로 다른 의존성 종류 간의 기능 관계를 나타낼 수 없으며, 이제 기능은 어떤 명령이 실행되고 어떤 패키지와 타겟이 선택되었는지에 따라 달라집니다. 또한 빌드 스크립트나 테스트와 같은 패키지 내부 의존성에 대한 세부 정보도 제공할 수 있습니다.</p>
<p>다음은 JSON 구조에 대한 설명입니다.</p>
<pre><code class="language-javascript">{
  /* JSON 출력 구조의 버전입니다. 하위 호환되지 않는 변경이 이루어지면,
     이 값이 증가합니다.
  */
  "version": 1,
  /* 모든 빌드 유닛의 배열. */
  "units": [
    {
      /* 패키지를 나타내는 불투명 문자열.
         패키지에 대한 정보는 `cargo metadata`에서 얻을 수 있습니다.
      */
      "pkg_id": "my-package 0.1.0 (path+file:///path/to/my-package)",
      /* Cargo 타겟. 이 필드에 대한 자세한 정보는 `cargo metadata` 문서를
         참조하세요.
         https://doc.rust-lang.org/cargo/commands/cargo-metadata.html
      */
      "target": {
        "kind": ["lib"],
        "crate_types": ["lib"],
        "name": "my_package",
        "src_path": "/path/to/my-package/src/lib.rs",
        "edition": "2018",
        "test": true,
        "doctest": true
      },
      /* 이 유닛에 대한 프로파일 설정입니다.
         이 값들은 매니페스트에 정의된 프로파일과 일치하지 않을 수 있습니다.
         유닛은 수정된 프로파일 설정을 사용할 수 있습니다. 예를 들어, 테스트를 위해
         "panic" 설정을 강제로 "unwind"로 재정의할 수 있습니다.
      */
      "profile": {
        /* 이 설정들이 파생된 프로파일 이름입니다. */
        "name": "dev",
        /* 문자열 형태의 최적화 수준. */
        "opt_level": "0",
        /* 문자열 형태의 LTO 설정. */
        "lto": "false",
        /* 정수 형태의 코드 생성 유닛 수.
           컴파일러 기본값을 사용해야 하는 경우 `null`입니다.
        */
        "codegen_units": null,
        /* 정수 형태의 디버그 정보 레벨.
           컴파일러 기본값(0)을 사용해야 하는 경우 `null`입니다.
        */
        "debuginfo": 2,
        /* 디버그 어설션 활성화 여부. */
        "debug_assertions": true,
        /* 오버플로 체크 활성화 여부. */
        "overflow_checks": true,
        /* rpath 활성화 여부. */
        "rpath": false,
        /* 증분(incremental) 컴파일 활성화 여부. */
        "incremental": true,
        /* 패닉 전략, "unwind" 또는 "abort". */
        "panic": "unwind"
      },
      /* 이 타겟이 어떤 플랫폼을 위해 빌드되는지 나타냅니다.
         `null` 값은 호스트를 위한 것임을 나타냅니다.
         그렇지 않으면 타겟 트리플 문자열(예: "x86_64-unknown-linux-gnu")입니다.
      */
      "platform": null,
      /* 이 유닛의 "모드(mode)"입니다. 유효한 값:

         * "test" --- 테스트용으로 `rustc`를 사용하여 빌드합니다.
         * "build" --- `rustc`를 사용하여 빌드합니다.
         * "check" --- "check" 모드에서 `rustc`를 사용하여 빌드합니다.
         * "doc" --- `rustdoc`을 사용하여 빌드합니다.
         * "doctest" --- `rustdoc`을 사용하여 테스트합니다.
         * "run-custom-build" --- 빌드 스크립트의 실행을 나타냅니다.
      */
      "mode": "build",
      /* 이 유닛에서 활성화된 기능의 문자열 배열입니다. */
      "features": ["somefeat"],
      /* 이것이 표준 라이브러리 유닛인지 여부이며,
         불안정한 build-std 기능의 일부입니다.
         설정되지 않은 경우 `false`로 처리합니다.
      */
      "is_std": false,
      /* 이 유닛의 의존성 배열입니다. */
      "dependencies": [
        {
          /* 의존성에 대한 "units" 배열에서의 인덱스입니다. */
          "index": 1,
          /* 이 의존성이 참조될 이름입니다. */
          "extern_crate_name": "unicode_xid",
          /* 이 의존성이 "공개(public)"인지 여부이며,
             불안정한 public-dependency 기능의 일부입니다.
             설정되지 않은 경우, public-dependency 기능이 활성화되지 않습니다.
          */
          "public": false,
          /* 이 의존성이 프렐류드(prelude)에 주입되는지 여부이며,
             현재 build-std 기능에서 사용됩니다.
             설정되지 않은 경우 `false`로 처리합니다.
          */
          "noprelude": false
        }
      ]
    },
    // ...
  ],
  /* 의존성 그래프의 "루트(roots)"인 "units" 배열 인덱스의 배열입니다.
  */
  "roots": [0],
}
</code></pre>
<h2 id="프로파일-rustflags-옵션"><a class="header" href="#프로파일-rustflags-옵션">프로파일 <code>rustflags</code> 옵션</a></h2>
<ul>
<li>원본 이슈: <a href="https://github.com/rust-lang/cargo/issues/7878">rust-lang/cargo#7878</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/10271">rust-lang/cargo#10271</a></li>
</ul>
<p>이 기능은 <code>[profile]</code> 섹션에서 rustc에 직접 전달할 플래그를 지정할 수 있는 새로운 옵션을 제공합니다. 다음과 같이 활성화할 수 있습니다:</p>
<pre><code class="language-toml">cargo-features = ["profile-rustflags"]

[package]
# ...

[profile.release]
rustflags = [ "-C", "..." ]
</code></pre>
<p>Cargo 설정의 프로파일에서 이를 설정하려면, <code>-Z profile-rustflags</code> 또는 <code>[unstable]</code> 테이블을 사용하여 활성화해야 합니다. 예를 들어,</p>
<pre><code class="language-toml"># .cargo/config.toml
[unstable]
profile-rustflags = true

[profile.release]
rustflags = [ "-C", "..." ]
</code></pre>
<h2 id="profile-hint-mostly-unused-option"><a class="header" href="#profile-hint-mostly-unused-option">Profile <code>hint-mostly-unused</code> option</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15644">#15644</a></li>
</ul>
<p>This feature provides a new option in the <code>[profile]</code> section to enable the rustc <code>hint-mostly-unused</code> option. This is primarily useful to enable for specific dependencies:</p>
<pre><code class="language-toml">[profile.dev.package.huge-mostly-unused-dependency]
hint-mostly-unused = true
</code></pre>
<p>To enable this feature, pass <code>-Zprofile-hint-mostly-unused</code>. However, since this option is a hint, using it without passing <code>-Zprofile-hint-mostly-unused</code> will only warn and ignore the profile option. Versions of Cargo prior to the introduction of this feature will give an “unused manifest key” warning, but will otherwise function without erroring. This allows using the hint in a crate’s <code>Cargo.toml</code> without mandating the use of a newer Cargo to build it.</p>
<p>A crate can also provide this hint automatically for crates that depend on it, using the <code>[hints]</code> table (which will likewise be ignored by older Cargo):</p>
<pre><code class="language-toml">[hints]
mostly-unused = true
</code></pre>
<p>This will cause the crate to default to hint-mostly-unused, unless overridden via <code>profile</code>, which takes precedence, and which can only be specified in the top-level crate being built.</p>
<h2 id="rustdoc-map"><a class="header" href="#rustdoc-map">rustdoc-map</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/8296">#8296</a></li>
</ul>
<p>이 기능은 <code>rustdoc</code>에 전달되는 설정값을 추가하여, 의존성의 문서가 로컬에 생성되지 않았을 때 다른 곳에서 호스팅되는 의존성 문서로 링크를 생성할 수 있게 합니다. 먼저, <code>.cargo/config</code>에 다음을 추가하세요:</p>
<pre><code class="language-toml">[doc.extern-map.registries]
crates-io = "https://docs.rs/"
</code></pre>
<p>그 다음, 문서를 빌드할 때 다음 플래그를 사용하여 의존성 링크가 <a href="https://docs.rs/">docs.rs</a>로 연결되도록 하세요:</p>
<pre><code>cargo +nightly doc --no-deps -Zrustdoc-map
</code></pre>
<p><code>registries</code> 테이블은 레지스트리 이름과 링크할 URL의 매핑을 포함합니다. URL에는 <code>{pkg_name}</code>과 <code>{version}</code> 마커를 사용할 수 있으며, 이는 해당 값으로 대체됩니다. 둘 다 지정되지 않은 경우, Cargo는 기본적으로 URL 끝에 <code>{pkg_name}/{version}/</code>을 추가합니다.</p>
<p>표준 라이브러리 링크를 리다이렉션하는 또 다른 설정이 있습니다. 기본적으로 rustdoc은 <a href="https://doc.rust-lang.org/nightly/">https://doc.rust-lang.org/nightly/</a>로 링크를 생성합니다. 이 동작을 변경하려면 <code>doc.extern-map.std</code> 설정을 사용하세요:</p>
<pre><code class="language-toml">[doc.extern-map]
std = "local"
</code></pre>
<p><code>"local"</code> 값은 <code>rustc</code> sysroot에 있는 문서를 링크한다는 뜻입니다. rustup을 사용하고 있다면 <code>rustup component add rust-docs</code>로 이 문서를 설치할 수 있습니다.</p>
<p>기본값은 <code>"remote"</code>입니다.</p>
<p>이 값은 또한 사용자 정의 위치를 위한 URL을 가질 수도 있습니다.</p>
<h2 id="per-package-target"><a class="header" href="#per-package-target">per-package-target</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/pull/9406">#9406</a></li>
<li>원본 풀 리퀘스트: <a href="https://github.com/rust-lang/cargo/pull/9030">#9030</a></li>
<li>원본 이슈: <a href="https://github.com/rust-lang/cargo/pull/7004">#7004</a></li>
</ul>
<p><code>per-package-target</code> 기능은 매니페스트에 <code>package.default-target</code>과 <code>package.forced-target</code> 두 개의 키를 추가합니다. 첫 번째는 패키지가 기본적으로 (즉, <code>--target</code> 인수가 전달되지 않았을 때) 특정 타겟을 위해 컴파일되게 합니다. 두 번째는 패키지가 항상 해당 타겟을 위해 컴파일되게 합니다.</p>
<p>예시:</p>
<pre><code class="language-toml">[package]
forced-target = "wasm32-unknown-unknown"
</code></pre>
<p>이 예시에서 크레이트는 항상 <code>wasm32-unknown-unknown</code>을 위해 빌드됩니다. 예를 들어, 호스트(또는 명령줄에서 제공된) 타겟에서 실행되는 메인 프로그램의 플러그인으로 사용될 것이기 때문입니다.</p>
<h2 id="artifact-dependencies"><a class="header" href="#artifact-dependencies">artifact-dependencies</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/pull/9096">#9096</a></li>
<li>원본 풀 리퀘스트: <a href="https://github.com/rust-lang/cargo/pull/9992">#9992</a></li>
</ul>
<p>아티팩트(Artifact) 의존성은 Cargo 패키지가 <code>bin</code>, <code>cdylib</code>, <code>staticlib</code> 크레이트에 의존하고, 해당 크레이트에 의해 빌드된 결과물을 컴파일 타임에 사용할 수 있게 합니다.</p>
<p>이 기능을 활성화하려면 <code>-Z bindeps</code>와 함께 <code>cargo</code>를 실행하세요.</p>
<h3 id="artifact-dependencies-의존성-선언"><a class="header" href="#artifact-dependencies-의존성-선언">artifact-dependencies: 의존성 선언</a></h3>
<p>아티팩트 의존성은 <code>Cargo.toml</code>의 의존성 선언에 다음 키들을 추가합니다:</p>
<ul>
<li>
<p><code>artifact</code> — 빌드할 <a href="cargo-targets.html">Cargo 타겟</a>을 지정합니다. 보통 이 필드가 없으면 Cargo는 의존성에서 <code>[lib]</code> 타겟만 빌드합니다. 이 필드를 사용하면 어떤 타겟을 빌드할지 지정할 수 있으며, 빌드 시점에 바이너리로 사용할 수 있게 됩니다.</p>
<ul>
<li><code>"bin"</code> — 컴파일된 실행 바이너리들로, 의존성 매니페스트의 모든 <code>[[bin]]</code> 섹션에 해당합니다.</li>
<li><code>"bin:&lt;bin-name&gt;"</code> — 컴파일된 실행 바이너리로, 주어진 <code>&lt;bin-name&gt;</code>으로 지정된 특정 바이너리 타겟에 해당합니다.</li>
<li><code>"cdylib"</code> — C 호환 동적 라이브러리로, 의존성 매니페스트에서 <code>crate-type = ["cdylib"]</code>인 <code>[lib]</code> 섹션에 해당합니다.</li>
<li><code>"staticlib"</code> — C 호환 정적 라이브러리로, 의존성 매니페스트에서 <code>crate-type = ["staticlib"]</code>인 <code>[lib]</code> 섹션에 해당합니다.
<code>artifact</code> 값은 문자열일 수 있으며, 여러 타겟을 지정하기 위해 문자열 배열일 수도 있습니다.</li>
</ul>
<p>예시:</p>
<pre><code class="language-toml">[dependencies]
bar = { version = "1.0", artifact = "staticlib" }
zoo = { version = "1.0", artifact = ["bin:cat", "bin:dog"]}
</code></pre>
</li>
<li>
<p><code>lib</code> — 의존성의 라이브러리를 일반적인 Rust <code>lib</code> 의존성으로도 빌드할지 여부를 나타내는 불리언(Boolean) 값입니다. 이 필드는 <code>artifact</code>가 지정된 경우에만 지정할 수 있습니다.</p>
<p><code>artifact</code>가 지정된 경우 이 필드의 기본값은 <code>false</code>입니다. 이 값을 <code>true</code>로 설정하면, 의존성을 선언한 패키지가 빌드되는 플랫폼 타겟에 대해 의존성의 <code>[lib]</code> 타겟도 함께 빌드됩니다. 이를 통해 패키지는 아티팩트 의존성뿐만 아니라 일반 의존성처럼 Rust 코드에서 해당 의존성을 사용할 수 있게 됩니다.</p>
<p>예시:</p>
<pre><code class="language-toml">[dependencies]
bar = { version = "1.0", artifact = "bin", lib = true }
</code></pre>
</li>
<li>
<p><code>target</code> — 의존성을 빌드할 플랫폼 타겟입니다. 이 필드는 <code>artifact</code>가 지정된 경우에만 지정할 수 있습니다.</p>
<p>이 필드를 지정하지 않았을 때의 기본값은 의존성 종류에 따라 다릅니다. 빌드 의존성(build dependencies)의 경우, 호스트 타겟을 위해 빌드됩니다. 그 외 모든 의존성의 경우, 의존성을 선언한 패키지가 빌드되는 타겟과 동일한 타겟을 위해 빌드됩니다.</p>
<p>빌드 의존성의 경우, <code>"target"</code>이라는 특별한 값을 가질 수도 있는데, 이는 패키지가 빌드되는 것과 동일한 타겟으로 의존성을 빌드하라는 의미입니다.</p>
<pre><code class="language-toml">[build-dependencies]
bar = { version = "1.0", artifact = "cdylib", target = "wasm32-unknown-unknown"}
same-target = { version = "1.0", artifact = "bin", target = "target" }
</code></pre>
</li>
</ul>
<h3 id="artifact-dependencies-환경-변수"><a class="header" href="#artifact-dependencies-환경-변수">artifact-dependencies: 환경 변수</a></h3>
<p>아티팩트 의존성을 빌드한 후, Cargo는 해당 아티팩트에 접근하는 데 사용할 수 있는 다음과 같은 환경 변수를 제공합니다:</p>
<ul>
<li>
<p><code>CARGO_&lt;ARTIFACT-TYPE&gt;_DIR_&lt;DEP&gt;</code> — 의존성에서 생성된 모든 아티팩트를 포함하는 디렉토리입니다.</p>
<p><code>&lt;ARTIFACT-TYPE&gt;</code>은 의존성에 지정된 <code>artifact</code>(<code>CDYLIB</code>, <code>STATICLIB</code>, <code>BIN</code>과 같이 대문자화됨)이며, <code>&lt;DEP&gt;</code>은 의존성의 이름입니다. 다른 Cargo 환경 변수와 마찬가지로, 의존성 이름은 대문자로 변환되고 대시는 밑줄로 대체됩니다.</p>
<p>매니페스트에서 의존성 이름을 변경한 경우, <code>&lt;DEP&gt;</code>는 원래 패키지 이름이 아니라 사용자가 지정한 이름에 해당합니다.</p>
</li>
<li>
<p><code>CARGO_&lt;ARTIFACT-TYPE&gt;_FILE_&lt;DEP&gt;_&lt;NAME&gt;</code> — 아티팩트의 전체 경로입니다.</p>
<p><code>&lt;ARTIFACT-TYPE&gt;</code>은 위와 같이 대문자로 변환된 의존성의 <code>artifact</code>이며, <code>&lt;DEP&gt;</code>는 위와 같이 변환된 의존성 이름, 그리고 <code>&lt;NAME&gt;</code>은 의존성에서 제공하는 아티팩트의 이름입니다.</p>
<p><code>&lt;NAME&gt;</code>은 아티팩트를 제공하는 크레이트에 지정된 <code>name</code>(지정되지 않은 경우 크레이트 이름)에서 어떠한 방식으로도 변경되지 않는다는 점에 유의하세요. 예를 들어, 소문자이거나 대시를 포함할 수 있습니다.</p>
<p>편의를 위해, 아티팩트 이름이 원래 패키지 이름과 일치하는 경우 Cargo는 <code>_&lt;NAME&gt;</code> 접미사가 생략된 변수의 복사본을 추가로 제공합니다. 예를 들어, <code>cmake</code> 크레이트가 <code>cmake</code>라는 이름의 바이너리를 제공하면 Cargo는 <code>CARGO_BIN_FILE_CMAKE</code>와 <code>CARGO_BIN_FILE_CMAKE_cmake</code>를 모두 제공합니다.</p>
</li>
</ul>
<p>각 의존성 종류별로, 이러한 변수들은 해당 의존성에 접근할 수 있는 빌드 프로세스의 동일한 부분에 제공됩니다:</p>
<ul>
<li>빌드 의존성(build-dependencies)의 경우, 이러한 변수들은 <code>build.rs</code> 스크립트에 제공되며, <a href="https://doc.rust-lang.org/std/env/fn.var_os.html"><code>std::env::var_os</code></a>를 사용하여 접근할 수 있습니다. (모든 OS 파일 경로와 마찬가지로, 이들은 유효한 UTF-8일 수도 있고 아닐 수도 있습니다.)</li>
<li>일반 의존성(normal dependencies)의 경우, 이러한 변수들은 크레이트 컴파일 중에 제공되며, <a href="https://doc.rust-lang.org/std/macro.env.html"><code>env!</code></a> 매크로를 사용하여 접근할 수 있습니다.</li>
<li>개발 의존성(dev-dependencies)의 경우, 이러한 변수들은 예제, 테스트, 벤치마크 컴파일 중에 제공되며, <a href="https://doc.rust-lang.org/std/macro.env.html"><code>env!</code></a> 매크로를 사용하여 접근할 수 있습니다.</li>
</ul>
<h3 id="artifact-dependencies-예제"><a class="header" href="#artifact-dependencies-예제">artifact-dependencies: 예제</a></h3>
<h4 id="예제-빌드-스크립트에서-바이너리-실행-파일-사용"><a class="header" href="#예제-빌드-스크립트에서-바이너리-실행-파일-사용">예제: 빌드 스크립트에서 바이너리 실행 파일 사용</a></h4>
<p><code>Cargo.toml</code> 파일에서 빌드 스크립트가 사용할 수 있도록 바이너리 의존성을 지정할 수 있습니다:</p>
<pre><code class="language-toml">[build-dependencies]
some-build-tool = { version = "1.0", artifact = "bin" }
</code></pre>
<p>그 다음 빌드 스크립트 내부에서, 해당 바이너리를 빌드 시점에 실행할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let build_tool = std::env::var_os("CARGO_BIN_FILE_SOME_BUILD_TOOL").unwrap();
    let status = std::process::Command::new(build_tool)
        .arg("do-stuff")
        .status()
        .unwrap();
    if !status.success() {
        eprintln!("failed!");
        std::process::exit(1);
    }
}</code></pre></pre>
<h4 id="예제-빌드-스크립트에서-cdylib-아티팩트-사용"><a class="header" href="#예제-빌드-스크립트에서-cdylib-아티팩트-사용">예제: 빌드 스크립트에서 <em>cdylib</em> 아티팩트 사용</a></h4>
<p>아티팩트를 사용하는 패키지의 <code>Cargo.toml</code>에서, 특정 빌드 타겟을 위해 <code>bar</code> 라이브러리를 <code>cdylib</code>로 빌드합니다…</p>
<pre><code class="language-toml">[build-dependencies]
bar = { artifact = "cdylib", version = "1.0", target = "wasm32-unknown-unknown" }
</code></pre>
<p>…그리고 <code>build.rs</code>에 있는 빌드 스크립트입니다.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    wasm::run_file(std::env::var("CARGO_CDYLIB_FILE_BAR").unwrap());
}</code></pre></pre>
<h4 id="예제-바이너리에서-바이너리-아티팩트-및-해당-라이브러리-사용"><a class="header" href="#예제-바이너리에서-바이너리-아티팩트-및-해당-라이브러리-사용">예제: 바이너리에서 <em>바이너리</em> 아티팩트 및 해당 라이브러리 사용</a></h4>
<p>아티팩트를 사용하는 패키지의 <code>Cargo.toml</code>에서, <code>bar</code> 바이너리를 아티팩트로 포함하기 위해 빌드하면서 라이브러리로도 사용할 수 있게 합니다…</p>
<pre><code class="language-toml">[dependencies]
bar = { artifact = "bin", version = "1.0", lib = true }
</code></pre>
<p>…그리고 <code>main.rs</code>를 사용하는 실행 파일입니다.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    bar::init();
    command::run(env!("CARGO_BIN_FILE_BAR"));
}</code></pre></pre>
<h2 id="publish-timeout"><a class="header" href="#publish-timeout">publish-timeout</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/11222">11222</a></li>
</ul>
<p>설정 파일의 <code>publish.timeout</code> 키는 <code>cargo publish</code>가 패키지를 레지스트리에 게시한 후 로컬 인덱스에서 사용 가능해질 때까지 대기하는 시간을 제어하는 데 사용할 수 있습니다.</p>
<p><code>0</code>의 타임아웃은 어떠한 검사도 발생하지 않도록 합니다. 현재 기본값은 <code>60</code>초입니다.</p>
<p>이 기능은 <code>-Zpublish-timeout</code> 명령줄 옵션이 설정되어 있어야 합니다.</p>
<pre><code class="language-toml"># config.toml
[publish]
timeout = 300  # in seconds
</code></pre>
<h2 id="asymmetric-token"><a class="header" href="#asymmetric-token">asymmetric-token</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/10519">10519</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/3231">#3231</a></li>
</ul>
<p>The <code>-Z asymmetric-token</code> flag enables the <code>cargo:paseto</code> credential provider which allows Cargo to authenticate to registries without sending secrets over the network.</p>
<p><a href="config.html"><code>config.toml</code></a> 및 <code>credentials.toml</code> 파일에는 <code>private-key</code>라는 필드가 있으며, 이는 <a href="https://github.com/paseto-standard/paserk/blob/master/types/secret.md"><code>PASERK</code>의 비밀 하위 집합</a> 형식의 비공개 키로, 비대칭 토큰에 서명하는 데 사용됩니다.</p>
<p>키 쌍은 <code>cargo login --generate-keypair</code>를 사용하여 생성할 수 있으며, 이는 다음 작업을 수행합니다:</p>
<ul>
<li>현재 권장되는 방식으로 공개/비공개 키 쌍을 생성합니다.</li>
<li>비공개 키를 <code>credentials.toml</code>에 저장합니다.</li>
<li>공개 키를 <a href="https://github.com/paseto-standard/paserk/blob/master/types/public.md">PASERK public</a> 형식으로 출력합니다.</li>
</ul>
<p><code>private-key</code>는 <code>credentials.toml</code>에 저장하는 것을 권장합니다. <code>config.toml</code>에서도 지원되는데, 이는 주로 관련 환경 변수를 사용하여 설정할 수 있도록 하기 위함이며, 이는 CI 환경에서 키를 제공하는 권장되는 방식입니다. 이 설정 방식은 비밀 토큰을 설정하기 위한 <code>token</code> 필드에 적용되는 방식과 동일합니다.</p>
<p><code>private-key-subject</code>라는 선택적 필드도 있으며, 이는 레지스트리가 선택하는 문자열입니다. 이 문자열은 비대칭 토큰의 일부로 포함되며 비밀이 아니어야 합니다. 이는 “중앙 CA 서버가 이 작업을 승인했다는 암호화 증명“과 같은 드문 사용 사례를 위한 것입니다. Cargo는 이를 공백이 없는 인쇄 가능한 ASCII로 요구합니다. 비 ASCII 데이터가 필요한 레지스트리는 base64 인코딩을 해야 합니다.</p>
<p>두 필드 모두 <code>cargo login --registry=name --private-key --private-key-subject="subject"</code>를 사용하여 설정할 수 있으며, 이 경우 키 값을 입력하라는 메시지가 표시됩니다.</p>
<p>레지스트리에는 <code>private-key</code> 또는 <code>token</code> 중 하나만 설정할 수 있습니다.</p>
<p>모든 PASETO에는 ISO 8601 형식의 현재 시간인 <code>iat</code>가 포함됩니다. Cargo는 적절한 경우 다음을 포함합니다:</p>
<ul>
<li><code>sub</code> 레지스트리가 선택하는 선택적인 비밀이 아닌 문자열로, 모든 요청에서 클레임으로 포함될 것으로 예상됩니다. 이 값은 <code>config.toml</code> 파일의 <code>private-key-subject</code>가 됩니다.</li>
<li><code>mutation</code>이 있는 경우, 이 요청이 변경 작업임을 나타내며(없으면 읽기 전용 작업), <code>publish</code>, <code>yank</code>, <code>unyank</code> 중 하나의 문자열이어야 합니다.
<ul>
<li><code>name</code> 이 요청과 관련된 크레이트의 이름입니다.</li>
<li><code>vers</code> 이 요청과 관련된 크레이트의 버전 문자열입니다.</li>
<li><code>cksum</code> 64자리의 소문자 16진수 문자열로 표현된 크레이트 내용의 SHA256 해시입니다. <code>mutation</code>이 <code>publish</code>인 경우에만 존재해야 합니다.</li>
</ul>
</li>
<li><code>challenge</code> 이번 세션에서 이 서버의 401/403 응답으로부터 받은 챌린지 문자열입니다. 챌린지를 발행하는 레지스트리는 어떤 챌린지가 발행/사용되었는지 추적해야 하며, 동일한 유효 기간 내에 주어진 챌린지를 두 번 이상 수락해서는 안 됩니다(지금껏 발행된 모든 챌린지를 추적할 필요는 없습니다).</li>
</ul>
<p>“푸터(footer)”(서명의 일부임)는 UTF-8 형식의 JSON 문자열이며 다음을 포함합니다:</p>
<ul>
<li><code>url</code> Cargo가 config.json 파일을 가져온 RFC 3986 준수 URL입니다.
<ul>
<li>HTTP 인덱스를 사용하는 레지스트리인 경우, 이는 모든 인덱스 쿼리의 기준이 되는 베이스 URL입니다.</li>
<li>GIT 인덱스를 사용하는 레지스트리인 경우, Cargo가 인덱스를 클론하는 데 사용한 URL입니다.</li>
</ul>
</li>
<li><code>kid</code> <a href="https://github.com/paseto-standard/paserk/blob/master/operations/ID.md">PASERK IDs</a> 표준을 사용하여 요청 서명에 사용된 비공개 키의 식별자입니다.</li>
</ul>
<p>PASETO에는 서명된 메시지가 포함되어 있으므로 서버는 서명을 확인하기 위해 요청에서 정확한 문자열을 재구성할 필요가 없습니다. 서버는 PASETO의 문자열에 대해 서명이 유효한지, 그리고 그 문자열의 내용이 요청과 일치하는지 확인해야 합니다. 요청에 대해 클레임이 예상되지만 PASETO에 누락된 경우 해당 요청은 거부되어야 합니다.</p>
<h2 id="cargo-config"><a class="header" href="#cargo-config"><code>cargo config</code></a></h2>
<ul>
<li>원본 이슈: <a href="https://github.com/rust-lang/cargo/issues/2362">#2362</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/9301">#9301</a></li>
</ul>
<p><code>cargo config</code> 하위 명령어는 Cargo가 로드하는 설정 파일들을 표시하는 방법을 제공합니다. 현재는 표시할 선택적 설정값을 인수로 받을 수 있는 <code>get</code> 하위 명령어를 포함하고 있습니다.</p>
<pre><code class="language-console">cargo +nightly -Zunstable-options config get build.rustflags
</code></pre>
<p>설정값이 포함되지 않으면 모든 설정값을 표시합니다. 사용 가능한 더 많은 옵션은 <code>--help</code> 출력을 참조하세요.</p>
<h2 id="rustc---print"><a class="header" href="#rustc---print">rustc <code>--print</code></a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/9357">#9357</a></li>
</ul>
<p><code>cargo rustc --print=VAL</code>은 <code>rustc</code>로부터 정보를 추출하기 위해 <code>--print</code> 플래그를 <code>rustc</code>에 전달합니다. 이는 해당 <a href="https://doc.rust-lang.org/rustc/command-line-arguments.html#--print-print-compiler-information"><code>--print</code></a> 플래그와 함께 <code>rustc</code>를 실행한 후 컴파일 없이 즉시 종료됩니다. 이를 Cargo 플래그로 노출함으로써 Cargo가 현재 설정을 기반으로 올바른 타겟과 RUSTFLAGS를 주입할 수 있게 합니다.</p>
<p>주요 사용 사례는 <code>cargo rustc --print=cfg</code>를 실행하여 적절한 타겟에 대한 설정값을 얻고, 다른 RUSTFLAGS의 영향을 받는 정보를 확인하는 것입니다.</p>
<h2 id="다른-바이너리-이름"><a class="header" href="#다른-바이너리-이름">다른 바이너리 이름</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/9778">#9778</a></li>
<li>PR: <a href="https://github.com/rust-lang/cargo/pull/9627">#9627</a></li>
</ul>
<p><code>different-binary-name</code> 기능은 크레이트 이름에 적용되는 제한을 따르지 않고 바이너리의 파일 이름을 설정할 수 있게 해줍니다. 예를 들어, 크레이트 이름은 <code>영숫자</code> 문자나 <code>-</code> 또는 <code>_</code>만 사용해야 하며 비어 있을 수 없습니다.</p>
<p><code>filename</code> 매개변수는 바이너리 확장자를 포함해서는 <strong>안 됩니다</strong>. <code>cargo</code>가 적절한 확장자를 파악하여 바이너리에 직접 사용합니다.</p>
<p><code>filename</code> 매개변수는 매니페스트의 <code>[[bin]]</code> 섹션에서만 사용할 수 있습니다.</p>
<pre><code class="language-toml">cargo-features = ["different-binary-name"]

[package]
name =  "foo"
version = "0.0.1"

[[bin]]
name = "foo"
filename = "007bar"
path = "src/main.rs"
</code></pre>
<h2 id="scrape-examples"><a class="header" href="#scrape-examples">scrape-examples</a></h2>
<ul>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/3123">#3123</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/9910">#9910</a></li>
</ul>
<p><code>-Z rustdoc-scrape-examples</code> 플래그는 Rustdoc에게 현재 워크스페이스의 크레이트에서 함수 호출을 검색하도록 지시합니다. 이러한 호출 위치(call-sites)는 문서에 포함됩니다. 다음과 같이 플래그를 사용할 수 있습니다:</p>
<pre><code>cargo doc -Z unstable-options -Z rustdoc-scrape-examples
</code></pre>
<p>기본적으로 Cargo는 문서화되는 패키지의 예제 타겟에서 예제를 수집합니다. 다음과 같이 <code>doc-scrape-examples</code> 플래그를 사용하여 개별 타겟의 수집 여부를 활성화하거나 비활성화할 수 있습니다:</p>
<pre><code class="language-toml"># 라이브러리에서 예제 수집 활성화
[lib]
doc-scrape-examples = true

# 예제 타겟에서 예제 수집 비활성화
[[example]]
name = "my-example"
doc-scrape-examples = false
</code></pre>
<p><strong>테스트 관련 참고:</strong> 테스트 타겟에서 <code>doc-scrape-examples</code>를 활성화하는 것은 현재 아무런 효과가 없습니다. 테스트에서 예제를 수집하는 기능은 현재 개발 중입니다.</p>
<p><strong>개발 의존성 관련 참고:</strong> 라이브러리를 문서화할 때는 일반적으로 크레이트의 개발 의존성이 필요하지 않습니다. 그러나 예제 타겟은 개발 의존성을 필요로 합니다. 하위 호환성을 위해 <code>-Z rustdoc-scrape-examples</code>는 <code>cargo doc</code>에 개발 의존성 요구 사항을 도입하지 <em>않습니다</em>. 따라서 다음 조건에서는 예제 타겟에서 예제가 수집되지 <em>않습니다</em>:</p>
<ol>
<li>문서화 중인 타겟 중 어느 것도 개발 의존성을 필요로 하지 않으며, 그리고</li>
<li>문서화 중인 타겟을 가진 크레이트 중 적어도 하나가 개발 의존성을 가지고 있으며, 그리고</li>
<li>모든 <code>[[example]]</code> 타겟에 대해 <code>doc-scrape-examples</code> 매개변수가 설정되지 않았거나 false인 경우.</li>
</ol>
<p>예제 타겟에서 예제가 수집되기를 원한다면, 위 조건 중 하나를 충족하지 않아야 합니다. 예를 들어, 하나의 예제 타겟에 대해 <code>doc-scrape-examples</code>를 true로 설정할 수 있으며, 이는 <code>cargo doc</code>을 위해 개발 의존성이 빌드되는 것을 허용한다는 신호를 Cargo에 보냅니다.</p>
<h2 id="rustdoc용-출력-형식output-format"><a class="header" href="#rustdoc용-출력-형식output-format">rustdoc용 출력 형식(output-format)</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/13283">#13283</a></li>
</ul>
<p>이 플래그는 <code>cargo rustdoc</code>의 출력 형식을 결정합니다. <code>html</code> 또는 <code>json</code>을 허용하며, 도구들이 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustdoc_json_types/">rustdoc의 실험적인 JSON 형식</a>을 활용할 수 있는 방법을 제공합니다.</p>
<p>다음과 같이 플래그를 사용할 수 있습니다:</p>
<pre><code>cargo rustdoc -Z unstable-options --output-format json
</code></pre>
<h2 id="코드-생성-백엔드codegen-backend"><a class="header" href="#코드-생성-백엔드codegen-backend">코드 생성 백엔드(codegen-backend)</a></h2>
<p><code>codegen-backend</code> 기능을 사용하면 프로파일을 통해 rustc에서 사용하는 코드 생성 백엔드를 선택할 수 있습니다.</p>
<p>예시:</p>
<pre><code class="language-toml">[package]
name = "foo"

[dependencies]
serde = "1.0.117"

[profile.dev.package.foo]
codegen-backend = "cranelift"
</code></pre>
<p>Cargo 설정의 프로파일에서 이를 설정하려면, <code>-Z codegen-backend</code> 또는 <code>[unstable]</code> 테이블을 사용하여 활성화해야 합니다. 예를 들어,</p>
<pre><code class="language-toml"># .cargo/config.toml
[unstable]
codegen-backend = true

[profile.dev.package.foo]
codegen-backend = "cranelift"
</code></pre>
<h2 id="gitoxide"><a class="header" href="#gitoxide">gitoxide</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/11813">#11813</a></li>
</ul>
<p>‘gitoxide’ 불안정 기능을 사용하면, 모든 또는 지정된 Git 작업이 <code>git2</code> 대신 <code>gitoxide</code> 크레이트에 의해 수행됩니다.</p>
<p><code>-Zgitoxide</code>는 현재 구현된 모든 기능을 활성화하지만, <code>-Zgitoxide=operation[,operationN]</code> 구문을 사용하여 <code>gitoxide</code>로 실행할 개별 Git 작업을 선택할 수 있습니다.</p>
<p>유효한 작업은 다음과 같습니다:</p>
<ul>
<li><code>fetch</code> - 모든 페치(fetch) 작업이 <code>gitoxide</code>로 수행되며, 여기에는 git 의존성뿐만 아니라 크레이트 인덱스도 포함됩니다.</li>
<li><code>checkout</code> <em>(계획됨)</em> - 필터 및 서브모듈 지원을 포함하여 작업 트리를 체크아웃합니다.</li>
</ul>
<h2 id="git"><a class="header" href="#git">git</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/13285">#13285</a></li>
</ul>
<p>‘git’ 불안정 기능을 사용하면, <code>gitoxide</code>와 <code>git2</code> 모두 크레이트 인덱스와 git 의존성의 얕은 페치(shallow fetch)를 수행합니다.</p>
<p><code>-Zgit</code>이 현재 구현된 모든 기능을 활성화하는 반면, <code>-Zgit=operation[,operationN]</code> 문법을 사용하여 언제 얕은 페치(shallow fetch)를 수행할지 개별적으로 선택할 수 있습니다.</p>
<p>유효한 작업은 다음과 같습니다:</p>
<ul>
<li><code>shallow-index</code> - 인덱스의 얕은 클론(shallow clone)을 수행합니다.</li>
<li><code>shallow-deps</code> - git 의존성의 얕은 클론(shallow clone)을 수행합니다.</li>
</ul>
<p><strong>얕은 클론(shallow clones)에 대한 세부 사항</strong></p>
<ul>
<li>얕은 클론을 활성화하려면, git 의존성을 가져오는 경우 <code>-Zgit=shallow-deps</code>를 추가하고 레지스트리 인덱스를 가져오는 경우 <code>-Zgit=shallow-index</code>를 추가하세요.</li>
<li>얕은 클론(shallow-cloned) 및 얕은 체크아웃(shallow-checked-out)된 git 저장소는 <code>-shallow</code> 접미사가 붙은 자체 디렉토리에 위치합니다. 즉,
<ul>
<li><code>~/.cargo/registry/index/*-shallow</code></li>
<li><code>~/.cargo/git/db/*-shallow</code></li>
<li><code>~/.cargo/git/checkouts/*-shallow</code></li>
</ul>
</li>
<li>불안정한 기능이 켜져 있으면 git 저장소를 가져오거나 클론할 때 항상 얕은 페치(shallow fetch)를 수행합니다. 이는 모든 곳에서 <code>git fetch --depth 1</code>을 수행하는 것과 거의 같습니다.</li>
<li><code>Cargo.lock</code>이 있거나 <code>{ rev = "…" }</code>로 커밋을 지정하더라도, gitoxide와 libgit2는 기존 저장소의 얕은 페치 상태를 해제(unshallowing)하지 않고 얕은 페치를 수행할 만큼 똑똑합니다.</li>
</ul>
<h2 id="script"><a class="header" href="#script">script</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/12207">#12207</a></li>
</ul>
<p>Cargo는 다음과 같이 <code>.rs</code> 파일을 직접 실행할 수 있습니다:</p>
<pre><code class="language-console">$ cargo +nightly -Zscript file.rs
</code></pre>
<p>여기서 <code>file.rs</code>는 다음과 같이 간단할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {}</code></pre></pre>
<p>사용자는 선택적으로 다음과 같이 모듈 레벨 주석의 <code>cargo</code> 코드 펜스 안에 매니페스트를 지정할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust">#!/usr/bin/env -S cargo +nightly -Zscript
---cargo
[dependencies]
clap = { version = "4.2", features = ["derive"] }
---

use clap::Parser;

#[derive(Parser, Debug)]
#[clap(version)]
struct Args {
    #[clap(short, long, help = "Path to config")]
    config: Option&lt;std::path::PathBuf&gt;,
}

fn main() {
    let args = Args::parse();
    println!("{:?}", args);
}</code></pre></pre>
<h3 id="단일-파일-패키지"><a class="header" href="#단일-파일-패키지">단일 파일 패키지</a></h3>
<p>기존의 다중 파일 패키지(다른 <code>.rs</code> 파일들과 함께 있는 <code>Cargo.toml</code> 파일) 외에, 임베디드 매니페스트를 포함할 수 있는 단일 파일 패키지 개념을 추가합니다. 단일 파일 <code>.rs</code> 패키지를 다른 <code>.rs</code> 파일과 구별하기 위한 필수적인 표시법은 없습니다.</p>
<p>단일 파일 패키지는 <code>cargo test --manifest-path foo.rs</code>와 같이 <code>--manifest-path</code>를 통해 선택할 수 있습니다. <code>Cargo.toml</code>과 달리, 이러한 파일은 자동으로 감지되지 않습니다.</p>
<p>단일 파일 패키지는 임베디드 매니페스트를 포함할 수 있습니다. 임베디드 매니페스트는 파일 상단의 정보 문자열(infostring) 시작 부분에 <code>cargo</code>가 있는 마크다운 코드 펜스인 Rust “프론트매터(frontmatter)” 내에 <code>TOML</code>을 사용하여 저장됩니다.</p>
<p>추론 / 기본값으로 설정된 매니페스트 필드:</p>
<ul>
<li><code>package.name = &lt;슬러그화된 파일 이름 줄기&gt;</code></li>
<li>Rust 업그레이드 시 스크립트가 중단될 수 있는 위험을 감수하고, 항상 임베디드 매니페스트를 추가해야 하는 번거로움을 피하기 위해 <code>package.edition = &lt;현재 버전&gt;</code>을 사용합니다.
<ul>
<li>이 사항을 알리기 위해 <code>edition</code>이 지정되지 않은 경우 경고를 표시합니다.</li>
</ul>
</li>
</ul>
<p>허용되지 않는 매니페스트 필드:</p>
<ul>
<li><code>[workspace]</code>, <code>[lib]</code>, <code>[[bin]]</code>, <code>[[example]]</code>, <code>[[test]]</code>, <code>[[bench]]</code></li>
<li><code>package.workspace</code>, <code>package.build</code>, <code>package.links</code>, <code>package.autolib</code>, <code>package.autobins</code>, <code>package.autoexamples</code>, <code>package.autotests</code>, <code>package.autobenches</code></li>
</ul>
<p>단일 파일 패키지의 기본 <code>CARGO_TARGET_DIR</code>은 <code>$CARGO_HOME/target/&lt;hash&gt;</code>에 위치합니다:</p>
<ul>
<li>동일한 디렉토리에 여러 단일 파일 패키지가 있을 때 발생하는 충돌 방지</li>
<li>단일 파일 패키지의 상위 디렉토리가 읽기 전용일 때 발생하는 문제 방지</li>
<li>사용자 디렉토리가 복잡해지는 것 방지</li>
</ul>
<p>단일 파일 패키지의 잠금 파일(lockfile)은 <code>CARGO_TARGET_DIR</code>에 위치하게 됩니다. 향후 워크스페이스가 지원되면 사용자가 영구적인 잠금 파일을 가질 수 있게 될 것입니다.</p>
<h3 id="매니페스트-명령어manifest-commands"><a class="header" href="#매니페스트-명령어manifest-commands">매니페스트 명령어(Manifest-commands)</a></h3>
<p>하위 명령어 없이 <code>foo/Cargo.toml</code>이나 <code>foo.rs</code>와 같은 단일 파일 패키지처럼 매니페스트를 <code>cargo</code> 명령에 직접 전달할 수 있습니다. 이는 주로 <code>#!</code> 라인에 넣기 위한 용도입니다.</p>
<p><code>cargo &lt;subcommand&gt;</code>를 해석하는 우선순위는 다음과 같습니다:</p>
<ol>
<li>내장(Built-in) XOR 단일 파일 패키지</li>
<li>별칭(Aliases)</li>
<li>외부 하위 명령어</li>
</ol>
<p>매개변수가 다음 중 하나를 포함하면 매니페스트 명령어로 식별됩니다:</p>
<ul>
<li>경로 구분자</li>
<li><code>.rs</code> 확장자</li>
<li>파일 이름이 <code>Cargo.toml</code>인 경우</li>
</ul>
<p><code>cargo run --manifest-path &lt;path&gt;</code>와 <code>cargo &lt;path&gt;</code>의 차이점</p>
<ul>
<li><code>cargo &lt;path&gt;</code>는 현재 디렉토리가 아닌 <code>&lt;path&gt;</code>에 대한 설정으로 실행됩니다. <code>cargo install --path &lt;path&gt;</code>와 더 비슷합니다.</li>
<li><code>cargo &lt;path&gt;</code>는 일반적인 기본값보다 낮은 상세 수준으로 실행됩니다. 정상적인 출력을 얻으려면 <code>-v</code>를 전달하세요.</li>
</ul>
<p>When running a package with an embedded manifest, <a href="https://doc.rust-lang.org/std/os/unix/process/trait.CommandExt.html#tymethod.arg0"><code>arg0</code></a> will be the scripts path. To get the executable’s path, see <a href="https://doc.rust-lang.org/std/env/fn.current_exe.html"><code>current_exe</code></a>.</p>
<h3 id="문서-업데이트"><a class="header" href="#문서-업데이트">문서 업데이트</a></h3>
<h2 id="프로파일-trim-paths-옵션"><a class="header" href="#프로파일-trim-paths-옵션">프로파일 <code>trim-paths</code> 옵션</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/12137">rust-lang/cargo#12137</a></li>
<li>rustc 추적 이슈: <a href="https://github.com/rust-lang/rust/issues/111540">rust-lang/rust#111540</a></li>
</ul>
<p>이는 생성된 바이너리에서 경로가 정제(sanitize)되는 방식을 제어하는 새로운 프로파일 설정을 추가합니다. 다음과 같이 활성화할 수 있습니다:</p>
<pre><code class="language-toml">cargo-features = ["trim-paths"]

[package]
# ...

[profile.release]
trim-paths = ["diagnostics", "object"]
</code></pre>
<p>Cargo 설정의 프로파일에서 이를 설정하려면, <code>-Z trim-paths</code> 또는 <code>[unstable]</code> 테이블을 사용하여 활성화해야 합니다. 예를 들어,</p>
<pre><code class="language-toml"># .cargo/config.toml
[unstable]
trim-paths = true

[profile.release]
trim-paths = ["diagnostics", "object"]
</code></pre>
<h3 id="문서-업데이트-1"><a class="header" href="#문서-업데이트-1">문서 업데이트</a></h3>
<h4 id="trim-paths"><a class="header" href="#trim-paths">trim-paths</a></h4>
<p><em>새로운 <a href="./profiles.html#profile-settings">“프로파일 설정” 항목</a>으로</em></p>
<p><code>trim-paths</code>는 빌드 출력에서 파일 경로의 정제(sanitization)를 활성화하고 제어하는 프로파일 설정입니다. 다음과 같은 값들을 가질 수 있습니다:</p>
<ul>
<li><code>"none"</code> 및 <code>false</code> — 경로 정제를 비활성화합니다.</li>
<li><code>"macro"</code> — <code>std::file!()</code> 매크로 확장 시 경로를 정제합니다. 이곳이 임베디드 패닉 메시지의 경로가 나오는 곳입니다.</li>
<li><code>"diagnostics"</code> — 출력된 컴파일러 진단 정보의 경로를 정제합니다.</li>
<li><code>"object"</code> — 컴파일된 실행 파일 또는 라이브러리의 경로를 정제합니다.</li>
<li><code>"all"</code> 및 <code>true</code> — 가능한 모든 위치의 경로를 정제합니다.</li>
</ul>
<p><code>"macro"</code>, <code>"diagnostics"</code>, <code>"object"</code>의 조합으로 이루어진 배열을 받을 수도 있습니다.</p>
<p><code>dev</code> 프로파일의 경우 기본값은 <code>none</code>이며, <code>release</code> 프로파일의 경우 <code>object</code>입니다. <code>Cargo.toml</code>에 이 옵션을 지정하여 수동으로 재정의할 수 있습니다:</p>
<pre><code class="language-toml">[profile.dev]
trim-paths = "all"

[profile.release]
trim-paths = ["object", "diagnostics"]
</code></pre>
<p>기본 <code>release</code> 프로파일 설정(<code>object</code>)은 생성된 실행 파일이나 라이브러리 파일의 경로만 정제합니다. 패닉 메시지와 같은 매크로의 경로에는 항상 영향을 미치며, 디버그 정보의 경우 바이너리에 함께 임베드되는 경우(Linux 및 windows-gnu와 같은 ELF 바이너리가 있는 플랫폼의 기본값)에만 영향을 미치고 별도의 파일에 있는 경우(Windows MSVC 및 macOS의 기본값)에는 건드리지 않습니다. 그러나 이러한 별도 파일의 경로는 정제됩니다.</p>
<p><code>trim-paths</code>가 <code>none</code> 또는 <code>false</code>가 아니면, 선택된 범위에 나타나는 다음 경로들이 정제됩니다:</p>
<ol>
<li>표준 및 코어 라이브러리(sysroot)의 소스 파일 경로는 <code>/rustc/[rustc commit hash]</code>로 시작하게 됩니다. 예: <code>/home/username/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs</code> -&gt; <code>/rustc/fe72845f7bb6a77b9e671e6a4f32fe714962cec4/library/core/src/result.rs</code></li>
<li>현재 패키지의 경로는 현재 워크스페이스 루트를 기준으로 제거됩니다. 예: <code>/home/username/crate/src/lib.rs</code> -&gt; <code>src/lib.rs</code>.</li>
<li>의존성 패키지의 경로는 <code>[패키지 이름]-[버전]</code>으로 대체됩니다. 예: <code>/home/username/deps/foo/src/lib.rs</code> -&gt; <code>foo-0.1.0/src/lib.rs</code></li>
</ol>
<p>표준 및 코어 라이브러리 소스 파일의 경로가 정제 범위에 포함되지 않은 경우, 출력되는 경로는 <code>rust-src</code> 컴포넌트의 존재 여부에 따라 달라집니다. 컴포넌트가 있으면 일부 경로는 파일 시스템의 소스 파일 복사본을 가리키고, 없으면 (정제 대상으로 선택되었을 때와 마찬가지로) <code>/rustc/[rustc commit hash]/library/...</code>로 표시됩니다. 다른 모든 소스 파일의 경로는 영향을 받지 않습니다.</p>
<p>이는 문자열과 같이 소스 코드에 하드코딩된 경로에는 영향을 주지 않습니다.</p>
<h4 id="환경-변수"><a class="header" href="#환경-변수">환경 변수</a></h4>
<p><em><a href="./environment-variables.html#environment-variables-cargo-sets-for-crates">“Cargo가 빌드 스크립트를 위해 설정하는 환경 변수”</a>의 새 항목으로</em></p>
<ul>
<li><code>CARGO_TRIM_PATHS</code> — <code>trim-paths</code> 프로파일 옵션의 값입니다. <code>false</code>, <code>"none"</code>, 빈 배열은 <code>none</code>으로 변환됩니다. <code>true</code>와 <code>"all"</code>은 <code>all</code>이 됩니다. 비어 있지 않은 배열의 값들은 쉼표로 구분된 목록으로 결합됩니다. 빌드 스크립트가 (컴파일러 호출 등을 통해) 빌드 결과물에 절대 경로를 도입하는 경우, 사용자는 다양한 유형의 결과물에서 이를 정제하도록 요청할 수 있습니다. 정제가 필요한 일반적인 경로로는 <code>OUT_DIR</code>, <code>CARGO_MANIFEST_DIR</code>, <code>CARGO_MANIFEST_PATH</code> 등이 있으며, 헤더 디렉토리와 같이 빌드 스크립트에 의해 도입된 다른 경로들도 포함됩니다.</li>
</ul>
<h2 id="gc"><a class="header" href="#gc">gc</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/12633">#12633</a></li>
</ul>
<p>The <code>-Zgc</code> flag is used to enable certain features related to garbage-collection of cargo’s global cache within the cargo home directory.</p>
<h4 id="자동-gc-설정"><a class="header" href="#자동-gc-설정">자동 GC 설정</a></h4>
<p>The <code>-Zgc</code> flag will enable Cargo to read extra configuration options related to garbage collection. The settings available are:</p>
<pre><code class="language-toml"># Example config.toml file.

# Sub-table for defining specific settings for cleaning the global cache.
[cache.global-clean]
# Anything older than this duration will be deleted in the source cache.
max-src-age = "1 month"
# Anything older than this duration will be deleted in the compressed crate cache.
max-crate-age = "3 months"
# Any index older than this duration will be deleted from the index cache.
max-index-age = "3 months"
# Any git checkout older than this duration will be deleted from the checkout cache.
max-git-co-age = "1 month"
# Any git clone older than this duration will be deleted from the git cache.
max-git-db-age = "3 months"
</code></pre>
<p>Note that the <a href="config.html#cacheauto-clean-frequency"><code>cache.auto-clean-frequency</code></a> option was stabilized in Rust 1.88.</p>
<h3 id="cargo-clean을-사용한-수동-가비지-컬렉션"><a class="header" href="#cargo-clean을-사용한-수동-가비지-컬렉션"><code>cargo clean</code>을 사용한 수동 가비지 컬렉션</a></h3>
<p>Manual deletion can be done with the <code>cargo clean gc -Zgc</code> command. Deletion of cache contents can be performed by passing one of the cache options:</p>
<ul>
<li><code>--max-src-age=DURATION</code> — 지정된 기간 동안 사용되지 않은 소스 캐시 파일을 삭제합니다.</li>
<li><code>--max-crate-age=DURATION</code> — 지정된 기간 동안 사용되지 않은 크레이트 캐시 파일을 삭제합니다.</li>
<li><code>--max-index-age=DURATION</code> — 지정된 기간 동안 사용되지 않은 레지스트리 인덱스(해당 <code>.crate</code> 및 <code>src</code> 파일 포함)를 삭제합니다.</li>
<li><code>--max-git-co-age=DURATION</code> — 지정된 기간 동안 사용되지 않은 Git 의존성 체크아웃을 삭제합니다.</li>
<li><code>--max-git-db-age=DURATION</code> — 지정된 기간 동안 사용되지 않은 Git 의존성 복제본을 삭제합니다.</li>
<li><code>--max-download-age=DURATION</code> — 지정된 기간 동안 사용되지 않은 모든 다운로드 캐시 데이터를 삭제합니다.</li>
<li><code>--max-src-size=SIZE</code> — 캐시가 지정된 크기 이하가 될 때까지 가장 오래된 소스 캐시 파일을 삭제합니다.</li>
<li><code>--max-crate-size=SIZE</code> — 캐시가 지정된 크기 이하가 될 때까지 가장 오래된 크레이트 캐시 파일을 삭제합니다.</li>
<li><code>--max-git-size=SIZE</code> — 캐시가 지정된 크기 이하가 될 때까지 가장 오래된 Git 의존성 캐시를 삭제합니다.</li>
<li><code>--max-download-size=SIZE</code> — 캐시가 지정된 크기 이하가 될 때까지 가장 오래된 다운로드 캐시 데이터를 삭제합니다.</li>
</ul>
<p>DURATION은 “N seconds/minutes/days/weeks/months” 형식으로 지정하며, N은 정수입니다.</p>
<p>SIZE는 “N <em>suffix</em>” 형식으로 지정하며, _suffix_는 B, kB, MB, GB, kiB, MiB, GiB 중 하나이고 N은 정수 또는 부동 소수점 숫자입니다. 접미사가 지정되지 않으면 바이트 단위 숫자로 간주됩니다.</p>
<pre><code class="language-sh">cargo clean gc -Zgc
cargo clean gc -Zgc --max-download-age=1week
cargo clean gc -Zgc --max-git-size=0 --max-download-size=100MB
</code></pre>
<h2 id="open-namespaces"><a class="header" href="#open-namespaces">open-namespaces</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/13576">#13576</a></li>
</ul>
<p>여러 패키지가 동일한 API 네임스페이스에 참여할 수 있게 합니다.</p>
<p>다음과 같이 활성화할 수 있습니다:</p>
<pre><code class="language-toml">cargo-features = ["open-namespaces"]

[package]
# ...
</code></pre>
<h2 id="panic-immediate-abort"><a class="header" href="#panic-immediate-abort">panic-immediate-abort</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/16042">#16042</a></li>
<li>Upstream Tracking Issue: <a href="https://github.com/rust-lang/rust/issues/147286">rust-lang/rust#147286</a></li>
</ul>
<p>Extends the <code>panic</code> profile setting to support the <a href="../../rustc/codegen-options/index.html#panic"><code>immediate-abort</code></a> panic strategy. This can be enabled like so:</p>
<pre><code class="language-toml"># Cargo.toml
cargo-features = ["panic-immediate-abort"]

[package]
# ...

[profile.release]
panic = "immediate-abort"
</code></pre>
<p>To set this in a profile in Cargo configuration, you need to use either <code>-Z panic-immediate-abort</code> CLI flag or the <code>[unstable]</code> table to enable it. For example,</p>
<pre><code class="language-toml"># .cargo/config.toml
[unstable]
panic-immediate-abort = true

[profile.release]
panic = "immediate-abort"
</code></pre>
<h2 id="fine-grain-locking"><a class="header" href="#fine-grain-locking">fine-grain-locking</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/4282">#4282</a></li>
</ul>
<p>Use fine grain locking instead of locking the entire build cache.</p>
<p>Note: Fine grain locking implicitly enables <a href="#build-dir-new-layout">build-dir-new-layout</a> as fine grain locking builds on that directory reoganization.</p>
<h2 id="lintscargo"><a class="header" href="#lintscargo"><code>[lints.cargo]</code></a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/12235">#12235</a></li>
</ul>
<p><code>-Zcargo-lints</code>가 사용될 때 Cargo 자체에서 내보내는 린트를 설정하는 데 사용할 수 있는 Cargo용 새로운 <code>lints</code> 도구 테이블입니다.</p>
<pre><code class="language-toml">[lints.cargo]
implicit-features = "warn"
</code></pre>
<p>이는 <a href="https://rust-lang.github.io/rfcs/2906-cargo-workspace-deduplicate.html">RFC 2906 <code>workspace-deduplicate</code></a>와 함께 작동합니다:</p>
<pre><code class="language-toml">[workspace.lints.cargo]
implicit-features = "warn"

[lints]
workspace = true
</code></pre>
<h2 id="경로-베이스-path-bases"><a class="header" href="#경로-베이스-path-bases">경로 베이스 (Path Bases)</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/14355">#14355</a></li>
</ul>
<p><code>path</code> 의존성은 <a href="config.html">설정</a>이나 <a href="#built-in-path-bases">내장 경로 베이스</a> 중 하나에 있는 <code>[path-bases]</code> 테이블의 경로 베이스 이름을 <code>base</code> 키로 설정하여 베이스를 지정할 수 있습니다. 해당 경로 베이스의 값은 <code>path</code> 값 앞에 추가되어(필요한 경우 경로 구분자와 함께), Cargo가 의존성을 찾을 실제 위치를 생성합니다.</p>
<p>예를 들어, <code>Cargo.toml</code>에 다음이 포함되어 있다면:</p>
<pre><code class="language-toml">cargo-features = ["path-bases"]

[dependencies]
foo = { base = "dev", path = "foo" }
</code></pre>
<p>설정에 다음과 같은 <code>[path-bases]</code> 테이블이 있다고 가정해 봅시다:</p>
<pre><code class="language-toml">[path-bases]
dev = "/home/user/dev/rust/libraries/"
</code></pre>
<p>이것은 <code>/home/user/dev/rust/libraries/foo</code>에 위치한 <code>path</code> 의존성 <code>foo</code>를 생성합니다.</p>
<p>경로 베이스는 절대 경로이거나 상대 경로일 수 있습니다. 상대 경로 베이스는 해당 경로 베이스를 선언한 설정 파일의 부모 디렉토리를 기준으로 합니다.</p>
<p>경로 베이스의 이름은 <a href="https://doc.rust-lang.org/std/primitive.char.html#method.is_alphanumeric">영문자 및 숫자</a> 또는 <code>-</code>, <code>_</code>만 사용해야 하며, <a href="https://doc.rust-lang.org/std/primitive.char.html#method.is_alphabetic">영문자</a>로 시작해야 하고 비어 있어서는 안 됩니다.</p>
<p>의존성에서 사용된 경로 베이스의 이름이 설정에도 없고 내장 경로 베이스 중 하나도 아닌 경우, Cargo는 오류를 발생시킵니다.</p>
<h4 id="내장-경로-베이스"><a class="header" href="#내장-경로-베이스">내장 경로 베이스</a></h4>
<p>Cargo는 <code>[path-bases]</code> 테이블에 지정할 필요 없이 사용할 수 있는 암시적 경로 베이스를 제공합니다.</p>
<ul>
<li><code>workspace</code> - 프로젝트가 <a href="workspaces.html">워크스페이스 또는 워크스페이스 구성원</a>인 경우, 이 경로 베이스는 워크스페이스의 루트 <code>Cargo.toml</code>이 있는 부모 디렉토리로 정의됩니다.</li>
</ul>
<p>내장 경로 베이스 이름이 설정에서도 선언된 경우, Cargo는 설정에 있는 값을 우선적으로 사용합니다. 이를 통해 Cargo는 기존 사용이 내장 이름을 가릴 수 있으므로 호환성 문제 없이 새로운 내장 경로 베이스를 추가할 수 있습니다.</p>
<h2 id="lockfile-path"><a class="header" href="#lockfile-path">lockfile-path</a></h2>
<ul>
<li>원래 이슈: <a href="https://github.com/rust-lang/cargo/issues/5707">#5707</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/14421">#14421</a></li>
</ul>
<p>The <code>-Zlockfile-path</code> flag enables the <code>resolver.lockfile-path</code> configuration option, which allows you to specify the path of the lockfile <code>Cargo.lock</code>.</p>
<p>By default, lockfile is written into <code>&lt;workspace_root&gt;/Cargo.lock</code>. However, when sources are stored in read-only directory, most of the cargo commands would fail when trying to write a lockfile. This configuration makes it easier to work with readonly sources.</p>
<p>Note, that currently path must end with <code>Cargo.lock</code>. If you want to use this feature in multiple projects, lockfiles should be stored in different directories.</p>
<h3 id="문서-업데이트-2"><a class="header" href="#문서-업데이트-2">문서 업데이트</a></h3>
<p><em>as a new <code>resolver.lockfile-path</code> entry in config.md</em></p>
<h4 id="resolverlockfile-path"><a class="header" href="#resolverlockfile-path"><code>resolver.lockfile-path</code></a></h4>
<ul>
<li>타입: 문자열 (경로)</li>
<li>Default: <code>&lt;workspace_root&gt;/Cargo.lock</code></li>
<li>Environment: <code>CARGO_RESOLVER_LOCKFILE_PATH</code></li>
</ul>
<p>Specifies the path to the lockfile. By default, the lockfile is written to <code>&lt;workspace_root&gt;/Cargo.lock</code>. This option is useful when working with read-only source directories.</p>
<p>The path must end with <code>Cargo.lock</code>.</p>
<h2 id="native-completions"><a class="header" href="#native-completions">native-completions</a></h2>
<ul>
<li>원래 이슈: <a href="https://github.com/rust-lang/cargo/issues/6645">#6645</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/14520">#14520</a></li>
</ul>
<p>이 기능은 수동으로 작성된 자동 완성 스크립트를 Rust 네이티브로 옮겨, 새로운 자동 완성을 추가, 확장 및 테스트하기 쉽게 만듭니다. 이 기능은 나이틀리 채널에서 추가적인 <code>-Z</code> 옵션 없이 활성화됩니다.</p>
<p>피드백을 기다리는 주요 영역</p>
<ul>
<li>탈출 문자(escaping)나 따옴표 처리가 올바르지 않은 인수들</li>
<li>정보의 부정확성</li>
<li>명령줄 파싱 버그</li>
<li>자동 완성이 제안되지 않는 인수들</li>
<li>알려진 이슈로 인해 문제가 발생하는 경우</li>
</ul>
<p>피드백은 다음과 같이 분류될 수 있습니다:</p>
<ul>
<li>보고되는 자동 완성 후보들
<ul>
<li>알려진 이슈: <a href="https://github.com/rust-lang/cargo/issues/14520">#14520</a>, <a href="https://github.com/rust-lang/cargo/labels/A-completions"><code>A-completions</code></a></li>
<li><a href="https://github.com/rust-lang/cargo/issues/new">이슈 보고</a> 또는 <a href="https://github.com/rust-lang/cargo/issues/14520">동작 논의</a></li>
</ul>
</li>
<li>셸 통합, 명령줄 파싱, 자동 완성 필터링
<ul>
<li>알려진 이슈: <a href="https://github.com/clap-rs/clap/issues/3166">clap#3166</a>, <a href="https://github.com/clap-rs/clap/labels/A-completion">clap’s <code>A-completions</code></a></li>
<li><a href="https://github.com/clap-rs/clap/issues/new/choose">이슈 보고</a> 또는 <a href="https://github.com/clap-rs/clap/discussions/new/choose">동작 논의</a></li>
</ul>
</li>
</ul>
<p>확실하지 않은 경우 <a href="https://github.com/rust-lang/cargo/issues/14520">#14520</a>이나 <a href="https://rust-lang.zulipchat.com/#narrow/stream/246057-t-cargo">zulip</a>에서 논의할 수 있습니다.</p>
<h3 id="native-completions-기능-사용-방법"><a class="header" href="#native-completions-기능-사용-방법">native-completions 기능 사용 방법:</a></h3>
<ul>
<li>
<p>bash: Add <code>source &lt;(CARGO_COMPLETE=bash cargo +nightly)</code> to <code>~/.local/share/bash-completion/completions/cargo</code>.</p>
</li>
<li>
<p>zsh: Add <code>source &lt;(CARGO_COMPLETE=zsh cargo +nightly)</code> to your <code>.zshrc</code>.</p>
</li>
<li>
<p>fish: <code>$XDG_CONFIG_HOME/fish/completions/cargo.fish</code>에 <code>source (CARGO_COMPLETE=fish cargo +nightly | psub)</code>를 추가하세요.</p>
</li>
<li>
<p>elvish: <code>$XDG_CONFIG_HOME/elvish/rc.elv</code>에 <code>eval (E:CARGO_COMPLETE=elvish cargo +nightly | slurp)</code>를 추가하세요.</p>
</li>
<li>
<p>powershell: <code>$PROFILE</code>에 <code>CARGO_COMPLETE=powershell cargo +nightly | Invoke-Expression</code>을 추가하세요.</p>
</li>
</ul>
<h2 id="warnings"><a class="header" href="#warnings">warnings</a></h2>
<ul>
<li>원래 이슈: <a href="https://github.com/rust-lang/cargo/issues/8424">#8424</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/14802">#14802</a></li>
</ul>
<p><code>-Z warnings</code> 기능은 Cargo가 경고를 처리하는 방식을 제어하는 <code>build.warnings</code> 설정 옵션을 활성화합니다. <code>-Z warnings</code> 불안정 플래그가 활성화되지 않으면 <code>build.warnings</code> 설정은 무시됩니다.</p>
<p>이 설정은 현재 rustc 경고에만 적용됩니다. 향후 추가적인 경고(Cargo 린트나 Cargo 경고 등)에 대해서도 적용될 수 있습니다.</p>
<h3 id="buildwarnings"><a class="header" href="#buildwarnings"><code>build.warnings</code></a></h3>
<ul>
<li>타입: 문자열</li>
<li>기본값: <code>warn</code></li>
<li>환경 변수: <code>CARGO_BUILD_WARNINGS</code></li>
</ul>
<p>Cargo가 경고를 처리하는 방식을 제어합니다. 허용되는 값은 다음과 같습니다:</p>
<ul>
<li><code>warn</code>: 경고가 경고로 출력됩니다 (기본값).</li>
<li><code>allow</code>: 경고가 숨겨집니다.</li>
<li><code>deny</code>: 경고가 발생하면 작업이 끝날 때 오류가 발생하며 프로세스가 실패 종료 코드로 종료됩니다.</li>
</ul>
<h2 id="기능-통합-feature-unification"><a class="header" href="#기능-통합-feature-unification">기능 통합 (feature unification)</a></h2>
<ul>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/blob/master/text/3692-feature-unification.md">#3692</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/14774">#14774</a></li>
</ul>
<p><code>-Z feature-unification</code>은 워크스페이스 전반에서 기능이 통합되는 방식을 제어하는 <code>resolver.feature-unification</code> 설정 옵션을 활성화합니다. <code>-Z feature-unification</code> 불안정 플래그가 활성화되지 않으면 <code>resolver.feature-unification</code> 설정은 무시됩니다.</p>
<h3 id="resolverfeature-unification"><a class="header" href="#resolverfeature-unification"><code>resolver.feature-unification</code></a></h3>
<ul>
<li>타입: 문자열</li>
<li>기본값: <code>"selected"</code></li>
<li>환경 변수: <code>CARGO_RESOLVER_FEATURE_UNIFICATION</code></li>
</ul>
<p>어떤 패키지가 <a href="../reference/features.html#feature-unification">기능 통합</a>에 참여할지 지정합니다.</p>
<ul>
<li><code>selected</code>: 현재 빌드를 위해 지정된 모든 패키지의 의존성 기능을 병합합니다.</li>
<li><code>workspace</code>: 현재 빌드를 위해 지정된 패키지에 관계없이, 모든 워크스페이스 구성원의 의존성 기능을 병합합니다.</li>
<li><code>package</code>: Dependency features are considered on a package-by-package basis, preferring duplicate builds of dependencies when different sets of features are activated by the packages.</li>
</ul>
<h2 id="lockfile-publish-time"><a class="header" href="#lockfile-publish-time">lockfile-publish-time</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/5221">#5221</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/16271">#16271</a></li>
</ul>
<p>With <code>cargo generate-lockfile -Zunstable-options --publish-time &lt;time&gt;</code>, package resolution will not consider any package newer than the specified time.</p>
<h2 id="package-message-format"><a class="header" href="#package-message-format">Package message format</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/11666">#11666</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15353">#15353</a></li>
</ul>
<p>The <code>--message-format</code> flag in <code>cargo package</code> controls the output message format. Currently, it only works with the <code>--list</code> flag and affects the file listing format, Requires <code>-Zunstable-options</code>. See <a href="../commands/cargo-package.html#option-cargo-package---message-format"><code>cargo package --message-format</code></a> for more information.</p>
<h2 id="rustdoc-depinfo"><a class="header" href="#rustdoc-depinfo">rustdoc depinfo</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/12266">#12266</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15370">#15370</a></li>
</ul>
<p>The <code>-Z rustdoc-depinfo</code> flag leverages rustdoc’s dep-info files to determine whether documentations are required to re-generate. This can be combined with <code>-Z checksum-freshness</code> to detect checksum changes rather than file mtime.</p>
<h2 id="no-embed-metadata"><a class="header" href="#no-embed-metadata">no-embed-metadata</a></h2>
<ul>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/15378">#15378</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15495">#15495</a></li>
</ul>
<p>The default behavior of Rust is to embed crate metadata into <code>rlib</code> and <code>dylib</code> artifacts. Since Cargo also passes <code>--emit=metadata</code> to these intermediate artifacts to enable pipelined compilation, this means that a lot of metadata ends up being duplicated on disk, which wastes disk space in the target directory.</p>
<p>This feature tells Cargo to pass the <code>-Zembed-metadata=no</code> flag to the compiler, which instructs it not to embed metadata within rlib and dylib artifacts. In this case, the metadata will only be stored in <code>.rmeta</code> files.</p>
<pre><code class="language-console">cargo +nightly -Zno-embed-metadata build
</code></pre>
<h2 id="unstable-editions"><a class="header" href="#unstable-editions"><code>unstable-editions</code></a></h2>
<p>The <code>unstable-editions</code> value in the <code>cargo-features</code> list allows a <code>Cargo.toml</code> manifest to specify an edition that is not yet stable.</p>
<pre><code class="language-toml">cargo-features = ["unstable-editions"]

[package]
name = "my-package"
edition = "future"
</code></pre>
<p>When new editions are introduced, the <code>unstable-editions</code> feature is required until the edition is stabilized.</p>
<p>The special “future” edition is a home for new features that are under development, and is permanently unstable. The “future” edition also has no new behavior by itself. Each change in the future edition requires an opt-in such as a <code>#![feature(...)]</code> attribute.</p>
<h2 id="fix-edition"><a class="header" href="#fix-edition"><code>fix-edition</code></a></h2>
<p><code>-Zfix-edition</code> is a permanently unstable flag to assist with testing edition migrations, particularly with the use of crater. It only works with the <code>cargo fix</code> subcommand. It takes two different forms:</p>
<ul>
<li><code>-Zfix-edition=start=$INITIAL</code> — This form checks if the current edition is equal to the given number. If not, it exits with success (because we want to ignore older editions). If it is, then it runs the equivalent of <code>cargo check</code>. This is intended to be used with crater’s “start” toolchain to set a baseline for the “before” toolchain.</li>
<li><code>-Zfix-edition=end=$INITIAL,$NEXT</code> — This form checks if the current edition is equal to the given <code>$INITIAL</code> value. If not, it exits with success. If it is, then it performs an edition migration to the edition specified in <code>$NEXT</code>. Afterwards, it will modify <code>Cargo.toml</code> to add the appropriate <code>cargo-features = ["unstable-edition"]</code>, update the <code>edition</code> field, and run the equivalent of <code>cargo check</code> to verify that the migration works on the new edition.</li>
</ul>
<p>예를 들어 다음과 같습니다.</p>
<pre><code class="language-console">cargo +nightly fix -Zfix-edition=end=2024,future
</code></pre>
<h2 id="section-timings"><a class="header" href="#section-timings">section-timings</a></h2>
<ul>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/15780">#15780</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15817">#15817</a></li>
</ul>
<p>This feature can be used to extend the output of <code>cargo build --timings</code>. It will tell rustc to produce timings of individual compilation sections, which will be then displayed in the timings HTML/JSON output.</p>
<pre><code class="language-console">cargo +nightly -Zsection-timings build --timings
</code></pre>
<h2 id="build-analysis"><a class="header" href="#build-analysis">Build analysis</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/rust-project-goals/pull/332">rust-lang/rust-project-goals#332</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15844">#15844</a></li>
</ul>
<p>The <code>-Zbuild-analysis</code> feature records and persists detailed build metrics on disk, with new commands to query past builds.</p>
<p>When enabled, Cargo writes build logs in JSONL format to the <code>$CARGO_HOME/log/</code> directory Each cargo invocation produces a log file named with a unique session ID. These logs contain timing information, rebuild reasons, and other build metadata that can be analyzed with the <code>cargo report</code> subcommands.</p>
<p>To enable build analysis, add the following <a href="config.html">Cargo configuration</a>:</p>
<pre><code class="language-toml"># Example config.toml file.

[unstable]
build-analysis = true

# Enable the build metric collection
[build.analysis]
enabled = true
</code></pre>
<p>Setting it on a stable toolchain only emits an unknown config warning, so it’s safe to keep enabled in your Cargo configuration.</p>
<h3 id="cargo-report-commands"><a class="header" href="#cargo-report-commands"><code>cargo report</code> commands</a></h3>
<p>The following commands are available under <code>-Zbuild-analysis</code>:</p>
<ul>
<li><code>cargo report sessions</code> — Lists previous build sessions. Use this to find session IDs for other report commands.</li>
<li><code>cargo report timings</code> — Generates an HTML timing report from a previous session, similar to <code>cargo build --timings</code> but without rebuilding.</li>
<li><code>cargo report rebuilds</code> — Reports why crates were rebuilt, helping diagnose unexpected recompilations.</li>
</ul>
<h2 id="build-dir-new-layout"><a class="header" href="#build-dir-new-layout">build-dir-new-layout</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15010">#15010</a></li>
</ul>
<p>Enables the new build-dir filesystem layout. This layout change unblocks work towards caching and locking improvements.</p>
<h2 id="compile-time-deps"><a class="header" href="#compile-time-deps">compile-time-deps</a></h2>
<p>This permanently-unstable flag to only build proc-macros and build scripts (and their required dependencies), as well as run the build scripts.</p>
<p>It is intended for use by tools like rust-analyzer and will never be stabilized.</p>
<p>예시:</p>
<pre><code class="language-console">cargo +nightly build --compile-time-deps -Z unstable-options
cargo +nightly check --compile-time-deps --all-targets -Z unstable-options
</code></pre>
<h1 id="rustc-unicode"><a class="header" href="#rustc-unicode"><code>rustc-unicode</code></a></h1>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/rust/issues/148607">rust#148607</a></li>
</ul>
<p>Enable <code>rustc</code>’s unicode error format in Cargo’s error messages</p>
<h2 id="rustdoc-mergeable-info"><a class="header" href="#rustdoc-mergeable-info">rustdoc mergeable info</a></h2>
<ul>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/16309">#16309</a></li>
<li>Tracking issue: <a href="https://github.com/rust-lang/cargo/issues/16306">#16306</a></li>
<li>Tracking rustc issue: <a href="https://github.com/rust-lang/rust/issues/130676">rust-lang/rust#130676</a></li>
</ul>
<p>The <code>-Z rustdoc-mergeable-info</code> leverage rustdoc’s mergeable crate info, so that <code>cargo doc</code> can merge cross-crate information (like the search index, source files index, etc.) from separate output directories, and run <code>rustdoc</code> in parallel.</p>
<h1 id="안정화-및-제거된-기능"><a class="header" href="#안정화-및-제거된-기능">안정화 및 제거된 기능</a></h1>
<h2 id="컴파일-진행-상황"><a class="header" href="#컴파일-진행-상황">컴파일 진행 상황</a></h2>
<p>compile-progress 기능은 1.30 릴리스에서 안정화되었습니다. 이제 진행률 표시줄(Progress bars)이 기본적으로 활성화됩니다. 이 기능을 제어하는 방법에 대한 자세한 내용은 <a href="config.html#termprogresswhen"><code>term.progress</code></a>를 참조하세요.</p>
<h2 id="에디션-edition"><a class="header" href="#에디션-edition">에디션 (Edition)</a></h2>
<p><code>Cargo.toml</code>에서 <code>edition</code>을 지정하는 기능은 1.31 릴리스에서 안정화되었습니다. 이 필드를 지정하는 방법에 대한 자세한 내용은 <a href="manifest.html#the-edition-field">edition 필드</a>를 참조하세요.</p>
<h2 id="rename-dependency"><a class="header" href="#rename-dependency">rename-dependency</a></h2>
<p><code>Cargo.toml</code>에서 이름을 바꾼 의존성을 지정하는 기능은 1.31 릴리스에서 안정화되었습니다. 의존성 이름 변경에 대한 자세한 내용은 <a href="specifying-dependencies.html#renaming-dependencies-in-cargotoml">의존성 이름 바꾸기</a>를 참조하세요.</p>
<h2 id="대체-레지스트리"><a class="header" href="#대체-레지스트리">대체 레지스트리</a></h2>
<p>대체 레지스트리에 대한 지원은 1.34 릴리스에서 안정화되었습니다. 대체 레지스트리에 대한 자세한 내용은 <a href="registries.html">레지스트리 장</a>을 참조하세요.</p>
<h2 id="오프라인-모드"><a class="header" href="#오프라인-모드">오프라인 모드</a></h2>
<p>offline 기능은 1.36 릴리스에서 안정화되었습니다. 오프라인 모드 사용에 대한 자세한 내용은 <a href="../commands/cargo.html#option-cargo---offline"><code>--offline</code> 플래그</a>를 참조하세요.</p>
<h2 id="publish-lockfile"><a class="header" href="#publish-lockfile">publish-lockfile</a></h2>
<p><code>publish-lockfile</code> 기능은 1.37 릴리스에서 제거되었습니다. 패키지에 바이너리 타겟이 포함된 경우 패키지를 게시할 때 <code>Cargo.lock</code> 파일이 항상 포함됩니다. <code>cargo install</code>에서 <code>Cargo.lock</code> 파일을 사용하려면 <code>--locked</code> 플래그가 필요합니다. 자세한 내용은 <a href="../commands/cargo-package.html"><code>cargo package</code></a>와 <a href="../commands/cargo-install.html"><code>cargo install</code></a>을 참조하세요.</p>
<h2 id="default-run"><a class="header" href="#default-run">default-run</a></h2>
<p><code>default-run</code> 기능은 1.37 릴리스에서 안정화되었습니다. 실행할 기본 타겟을 지정하는 방법에 대한 자세한 내용은 <a href="manifest.html#the-default-run-field"><code>default-run</code> 필드</a>를 참조하세요.</p>
<h2 id="cache-messages"><a class="header" href="#cache-messages">cache-messages</a></h2>
<p>컴파일러 메시지 캐싱은 1.40 릴리스에서 안정화되었습니다. 컴파일러 경고는 이제 기본적으로 캐시되며, Cargo를 다시 실행할 때 자동으로 다시 표시됩니다.</p>
<h2 id="install-upgrade"><a class="header" href="#install-upgrade">install-upgrade</a></h2>
<p><code>install-upgrade</code> 기능은 1.41 릴리스에서 안정화되었습니다. 이제 <a href="../commands/cargo-install.html"><code>cargo install</code></a>은 패키지가 오래된 것으로 보이면 자동으로 업그레이드합니다. 자세한 내용은 <a href="../commands/cargo-install.html"><code>cargo install</code></a> 문서를 참조하세요.</p>
<h2 id="프로파일-재정의-profile-overrides"><a class="header" href="#프로파일-재정의-profile-overrides">프로파일 재정의 (Profile Overrides)</a></h2>
<p>프로파일 재정의 기능은 1.41 릴리스에서 안정화되었습니다. 재정의 사용에 대한 자세한 내용은 <a href="profiles.html#overrides">프로파일 재정의</a>를 참조하세요.</p>
<h2 id="설정-프로파일-config-profiles"><a class="header" href="#설정-프로파일-config-profiles">설정 프로파일 (Config Profiles)</a></h2>
<p>Cargo 설정 파일 및 환경 변수에서 프로파일을 지정하는 기능은 1.43 릴리스에서 안정화되었습니다. 설정 파일에서 <a href="profiles.html">프로파일</a>을 지정하는 방법에 대한 자세한 내용은 <a href="config.html#profile">설정 <code>[profile]</code> 테이블</a>을 참조하세요.</p>
<h2 id="crate-versions"><a class="header" href="#crate-versions">crate-versions</a></h2>
<p><code>-Z crate-versions</code> 플래그는 1.47 릴리스에서 안정화되었습니다. 이제 크레이트 버전이 <a href="../commands/cargo-doc.html"><code>cargo doc</code></a> 문서 사이드바에 자동으로 포함됩니다.</p>
<h2 id="기능"><a class="header" href="#기능">기능</a></h2>
<p><code>-Z features</code> 플래그는 1.51 릴리스에서 안정화되었습니다. 새로운 기능 리졸버 사용에 대한 자세한 내용은 <a href="features.html#feature-resolver-version-2">기능 리졸버 버전 2</a>를 참조하세요.</p>
<h2 id="package-features"><a class="header" href="#package-features">package-features</a></h2>
<p><code>-Z package-features</code> 플래그는 1.51 릴리스에서 안정화되었습니다. 기능 CLI 옵션 사용에 대한 자세한 내용은 <a href="features.html#resolver-version-2-command-line-flags">리졸버 버전 2 명령줄 플래그</a>를 참조하세요.</p>
<h2 id="리졸버-resolver"><a class="header" href="#리졸버-resolver">리졸버 (Resolver)</a></h2>
<p><code>Cargo.toml</code>의 <code>resolver</code> 기능은 1.51 릴리스에서 안정화되었습니다. 리졸버 지정에 대한 자세한 내용은 <a href="resolver.html#resolver-versions">리졸버 버전</a>을 참조하세요.</p>
<h2 id="extra-link-arg"><a class="header" href="#extra-link-arg">extra-link-arg</a></h2>
<p>빌드 스크립트에서 추가 링커 인수를 지정하는 <code>extra-link-arg</code> 기능은 1.56 릴리스에서 안정화되었습니다. 추가 링커 인수를 지정하는 방법에 대한 자세한 내용은 <a href="build-scripts.html#outputs-of-the-build-script">빌드 스크립트 문서</a>를 참조하세요.</p>
<h2 id="configurable-env"><a class="header" href="#configurable-env">configurable-env</a></h2>
<p>Cargo 설정에서 환경 변수를 지정하는 <code>configurable-env</code> 기능은 1.56 릴리스에서 안정화되었습니다. 환경 변수 설정에 대한 자세한 내용은 <a href="config.html#env">설정 문서</a>를 참조하세요.</p>
<h2 id="rust-version"><a class="header" href="#rust-version">rust-version</a></h2>
<p><code>Cargo.toml</code>의 <code>rust-version</code> 필드는 1.56 릴리스에서 안정화되었습니다. <code>rust-version</code> 필드 사용 및 <code>--ignore-rust-version</code> 옵션에 대한 자세한 내용은 <a href="manifest.html#the-rust-version-field">rust-version 필드</a>를 참조하세요.</p>
<h2 id="patch-in-config"><a class="header" href="#patch-in-config">patch-in-config</a></h2>
<p><code>-Z patch-in-config</code> 플래그와 그에 대응하는 Cargo 설정 파일의 <code>[patch]</code> 섹션 지원은 1.56 릴리스에서 안정화되었습니다. 자세한 내용은 <a href="config.html#patch">patch 필드</a>를 참조하세요.</p>
<h2 id="2021-에디션"><a class="header" href="#2021-에디션">2021 에디션</a></h2>
<p>2021 에디션은 1.56 릴리스에서 안정화되었습니다. 에디션 설정에 대한 자세한 내용은 <a href="manifest.html#the-edition-field"><code>edition</code> 필드</a>를 참조하세요. 기존 프로젝트를 마이그레이션하는 방법에 대한 자세한 내용은 <a href="../commands/cargo-fix.html"><code>cargo fix --edition</code></a> 및 <a href="../../edition-guide/index.html">에디션 가이드</a>를 참조하세요.</p>
<h2 id="사용자-정의-이름-프로파일"><a class="header" href="#사용자-정의-이름-프로파일">사용자 정의 이름 프로파일</a></h2>
<p>사용자 정의 이름 프로파일은 1.57 릴리스에서 안정화되었습니다. 자세한 내용은 <a href="profiles.html#custom-profiles">프로파일 장</a>을 참조하세요.</p>
<h2 id="프로파일-strip-옵션"><a class="header" href="#프로파일-strip-옵션">프로파일 strip 옵션</a></h2>
<p>프로파일 <code>strip</code> 옵션은 1.59 릴리스에서 안정화되었습니다. 자세한 내용은 <a href="profiles.html#strip">프로파일 장</a>을 참조하세요.</p>
<h2 id="미래-비호환성-보고서"><a class="header" href="#미래-비호환성-보고서">미래 비호환성 보고서</a></h2>
<p>미래 비호환성 보고서(future-incompat report) 생성 지원은 1.59 릴리스에서 안정화되었습니다. 자세한 내용은 <a href="future-incompat-report.html">미래 비호환성 보고서 장</a>을 참조하세요.</p>
<h2 id="네임스페이스가-지정된-기능-namespaced-features"><a class="header" href="#네임스페이스가-지정된-기능-namespaced-features">네임스페이스가 지정된 기능 (Namespaced features)</a></h2>
<p>네임스페이스가 지정된 기능은 1.60 릴리스에서 안정화되었습니다. 자세한 내용은 <a href="features.html#optional-dependencies">기능 장</a>을 참조하세요.</p>
<h2 id="약한-의존성-기능-weak-dependency-features"><a class="header" href="#약한-의존성-기능-weak-dependency-features">약한 의존성 기능 (Weak dependency features)</a></h2>
<p>약한 의존성 기능은 1.60 릴리스에서 안정화되었습니다. 자세한 내용은 <a href="features.html#dependency-features">기능 장</a>을 참조하세요.</p>
<h2 id="timings"><a class="header" href="#timings">timings</a></h2>
<p>The <code>-Ztimings</code> option has been stabilized as <code>--timings</code> in the 1.60 release. The timings output format option (e.g., the <code>--timings=html</code> and the machine-readable <code>--timings=json</code> output) has been removed in 1.94.0-nightly.</p>
<h2 id="config-cli"><a class="header" href="#config-cli">config-cli</a></h2>
<p><code>--config</code> CLI 옵션은 1.63 릴리스에서 안정화되었습니다. 자세한 내용은 <a href="config.html#command-line-overrides">설정 문서</a>를 참조하세요.</p>
<h2 id="multitarget"><a class="header" href="#multitarget">multitarget</a></h2>
<p><code>-Z multitarget</code> 옵션은 1.64 릴리스에서 안정화되었습니다. 기본 [타겟 플랫폼 트리플](../appendix/glossary.md#target “타겟” (용어집)) 설정에 대한 자세한 내용은 <a href="config.html#buildtarget"><code>build.target</code></a>을 참조하세요.</p>
<h2 id="crate-type"><a class="header" href="#crate-type">crate-type</a></h2>
<p><code>cargo rustc</code>를 위한 <code>--crate-type</code> 플래그는 1.64 릴리스에서 안정화되었습니다. 자세한 내용은 <a href="../commands/cargo-rustc.html"><code>cargo rustc</code> 문서</a>를 참조하세요.</p>
<h2 id="워크스페이스-상속-workspace-inheritance"><a class="header" href="#워크스페이스-상속-workspace-inheritance">워크스페이스 상속 (Workspace Inheritance)</a></h2>
<p>워크스페이스 상속 기능은 1.64 릴리스에서 안정화되었습니다. 자세한 내용은 <a href="workspaces.html#the-package-table">workspace.package</a>, <a href="workspaces.html#the-dependencies-table">workspace.dependencies</a>, 그리고 <a href="specifying-dependencies.html#inheriting-a-dependency-from-a-workspace">워크스페이스로부터 의존성 상속하기</a>를 참조하세요.</p>
<h2 id="terminal-width"><a class="header" href="#terminal-width">terminal-width</a></h2>
<p><code>-Z terminal-width</code> 옵션은 1.68 릴리스에서 안정화되었습니다. Cargo가 너비를 자동으로 감지할 수 있는 터미널에서 실행할 때 터미널 너비가 항상 컴파일러에 전달됩니다.</p>
<h2 id="sparse-registry"><a class="header" href="#sparse-registry">sparse-registry</a></h2>
<p>희소 레지스트리(Sparse registry) 지원은 1.68 릴리스에서 안정화되었습니다. 자세한 내용은 <a href="registries.html#registry-protocols">레지스트리 프로토콜</a>을 참조하세요.</p>
<h3 id="cargo-logout"><a class="header" href="#cargo-logout"><code>cargo logout</code></a></h3>
<p><a href="../commands/cargo-logout.html"><code>cargo logout</code></a> 명령어는 1.70 릴리스에서 안정화되었습니다.</p>
<h2 id="doctest-in-workspace"><a class="header" href="#doctest-in-workspace"><code>doctest-in-workspace</code></a></h2>
<p><code>cargo test</code>를 위한 <code>-Z doctest-in-workspace</code> 옵션은 1.72 릴리스에서 안정화되었으며 기본적으로 활성화되었습니다. 테스트 컴파일 및 실행을 위한 작업 디렉토리에 대한 자세한 내용은 <a href="../commands/cargo-test.html#working-directory-of-tests"><code>cargo test</code> 문서</a>를 참조하세요.</p>
<h2 id="keep-going"><a class="header" href="#keep-going">keep-going</a></h2>
<p><code>--keep-going</code> 옵션은 1.74 릴리스에서 안정화되었습니다. 자세한 내용은 <code>cargo build</code>의 <a href="../commands/cargo-build.html#option-cargo-build---keep-going"><code>--keep-going</code> 플래그</a>를 예시로 참조하세요.</p>
<h2 id="lints"><a class="header" href="#lints"><code>[lints]</code></a></h2>
<p><a href="manifest.html#the-lints-section"><code>[lints]</code></a> (<code>-Zlints</code>를 통해 활성화됨) 기능은 1.74 릴리스에서 안정화되었습니다.</p>
<h2 id="credential-process"><a class="header" href="#credential-process">credential-process</a></h2>
<p><code>-Z credential-process</code> 기능은 1.74 릴리스에서 안정화되었습니다.</p>
<p>자세한 내용은 <a href="registry-authentication.html">레지스트리 인증</a> 문서를 참조하세요.</p>
<h2 id="registry-auth"><a class="header" href="#registry-auth">registry-auth</a></h2>
<p><code>-Z registry-auth</code> 기능은 1.74 릴리스에서 안정화되었으며, <code>credential-provider</code>가 설정되어 있어야 한다는 추가 요구 사항이 있습니다.</p>
<p>자세한 내용은 <a href="registry-authentication.html">레지스트리 인증</a> 문서를 참조하세요.</p>
<h2 id="check-cfg"><a class="header" href="#check-cfg">check-cfg</a></h2>
<p><code>-Z check-cfg</code> 기능은 1.80 릴리스에서 기본 동작으로 설정됨에 따라 안정화되었습니다.</p>
<p>사용자 정의 cfg를 지정하는 방법에 대한 자세한 내용은 <a href="build-scripts.html#rustc-check-cfg">빌드 스크립트 문서</a>를 참조하세요.</p>
<h2 id="2024-에디션"><a class="header" href="#2024-에디션">2024 에디션</a></h2>
<p>2024 에디션은 1.85 릴리스에서 안정화되었습니다. 에디션 설정에 대한 자세한 내용은 <a href="manifest.html#the-edition-field"><code>edition</code> 필드</a>를 참조하세요. 기존 프로젝트를 마이그레이션하는 방법에 대한 자세한 내용은 <a href="../commands/cargo-fix.html"><code>cargo fix --edition</code></a> 및 <a href="../../edition-guide/index.html">에디션 가이드</a>를 참조하세요.</p>
<h2 id="자동-가비지-컬렉션"><a class="header" href="#자동-가비지-컬렉션">자동 가비지 컬렉션</a></h2>
<p>Support for automatically deleting old files was stabilized in Rust 1.88. More information can be found in the <a href="config.html#cache">config chapter</a>.</p>
<h2 id="doctest-xcompile"><a class="header" href="#doctest-xcompile">doctest-xcompile</a></h2>
<p>Doctest cross-compiling is now unconditionally enabled starting in Rust 1.89. Running doctests with <code>cargo test</code> will now honor the <code>--target</code> flag.</p>
<h2 id="package-workspace"><a class="header" href="#package-workspace">package-workspace</a></h2>
<p>Multi-package publishing has been stabilized in Rust 1.90.0.</p>
<h2 id="build-dir"><a class="header" href="#build-dir">build-dir</a></h2>
<p>Support for <code>build.build-dir</code> was stabilized in the 1.91 release. See the <a href="config.html#buildbuild-dir">config documentation</a> for information about changing the build-dir</p>
<h2 id="build-plan"><a class="header" href="#build-plan">Build-plan</a></h2>
<p>The <code>--build-plan</code> argument for the <code>build</code> command has been removed in 1.93.0-nightly. See <a href="https://github.com/rust-lang/cargo/issues/7614">https://github.com/rust-lang/cargo/issues/7614</a> for the reason for its removal.</p>
<h2 id="config-include"><a class="header" href="#config-include">config-include</a></h2>
<p>Support for including extra configuration files via the <code>include</code> config key has been stabilized in 1.93.0. See the <a href="config.html#include"><code>include</code> config documentation</a> for more.</p>
<h2 id="pubtime"><a class="header" href="#pubtime">pubtime</a></h2>
<p>The <code>pubtime</code> index field  has been stabilized in Rust 1.94.0.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../reference/lints.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../commands/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../reference/lints.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../commands/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
