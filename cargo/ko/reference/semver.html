<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>SemVer 호환성 - The Cargo Book</title>


        <!-- Custom HTML head -->
        <style>
            dd {
                margin-bottom: 1em;
            }
        </style>
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/cargo";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/reference/semver.md`;
                    } else {
                        canonical_href = `${base}/${lang}/reference/semver.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/cargo.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cargo Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/cargo/edit/master/src/doc/src/reference/semver.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="semver-호환성"><a class="header" href="#semver-호환성">SemVer 호환성</a></h1>
<p>이 장에서는 패키지의 새 릴리스에 대해 관례적으로 호환 가능하거나 호환되지 않는 SemVer 변경으로 간주되는 사항에 대한 세부 정보를 제공합니다. SemVer가 무엇인지, Cargo가 라이브러리의 호환성을 보장하기 위해 이를 어떻게 사용하는지에 대한 자세한 내용은 <a href="resolver.html#semver-compatibility">SemVer 호환성</a> 섹션을 참조하세요.</p>
<p>이것들은 _가이드라인_일 뿐이며, 모든 프로젝트가 따라야 하는 엄격한 규칙은 아닙니다. <a href="#change-categories">변경 카테고리</a> 섹션에서는 이 가이드가 변경의 수준과 심각성을 어떻게 분류하는지 설명합니다. 이 가이드의 대부분은 이전에 작동하던 것을 <code>cargo</code>와 <code>rustc</code>가 빌드하지 못하게 하는 변경 사항에 초점을 맞추고 있습니다. 거의 모든 변경 사항은 런타임 동작에 부정적인 영향을 미칠 수 있는 위험을 내포하고 있으며, 이러한 경우 일반적으로 프로젝트 유지 관리자가 SemVer 호환 가능 여부를 판단합니다.</p>
<h2 id="변경-카테고리"><a class="header" href="#변경-카테고리">변경 카테고리</a></h2>
<p>아래 나열된 모든 정책은 변경 수준에 따라 분류됩니다:</p>
<ul>
<li><strong>메이저 변경</strong>: 메이저 SemVer 범프가 필요한 변경입니다.</li>
<li><strong>마이너 변경</strong>: 마이너 SemVer 범프만 필요한 변경입니다.</li>
<li><strong>중단 가능성 있음(Possibly-breaking)</strong>: 일부 프로젝트에서는 메이저로 간주하고 다른 프로젝트에서는 마이너로 간주할 수 있는 변경입니다.</li>
</ul>
<p>“중단 가능성 있음(Possibly-breaking)” 카테고리는 업데이트 중에 중단될 _잠재력_이 있지만 반드시 중단을 일으키지는 않는 변경 사항을 다룹니다. 이러한 변경 사항의 영향은 신중하게 고려되어야 합니다. 정확한 성격은 변경 사항과 프로젝트 유지 관리자의 원칙에 따라 달라집니다.</p>
<p>일부 프로젝트는 마이너 변경 시 패치 번호만 올리기로 선택할 수 있습니다. SemVer 명세를 따르고 패치 릴리스에는 버그 수정만 적용할 것을 권장합니다. 그러나 버그 수정을 위해 “마이너 변경“으로 표시된 API 변경이 필요할 수 있으며, 이는 호환성에 영향을 미치지 않아야 합니다. 이 가이드는 각 개별 “마이너 변경“이 어떻게 처리되어야 하는지에 대해 입장을 취하지 않습니다. 마이너 변경과 패치 변경의 차이는 변경의 성격에 따른 관례이기 때문입니다.</p>
<p>일부 변경 사항은 빌드를 중단시킬 잠재적 위험이 있음에도 불구하고 “마이너“로 표시됩니다. 이는 잠재적 위험이 매우 낮고, 중단을 일으킬 가능성이 있는 코드가 관용적인 Rust로 작성되었을 가능성이 낮거나 사용이 명확하게 권장되지 않는 상황을 위한 것입니다.</p>
<p>이 가이드에서 사용하는 “메이저” 및 “마이너“라는 용어는 “1.0.0” 이상의 릴리스와 관련이 있다고 가정합니다. “0.y.z“로 시작하는 초기 개발 릴리스는 “y“의 변경을 메이저 릴리스로, “z“의 변경을 마이너 릴리스로 취급할 수 있습니다. “0.0.z” 릴리스는 항상 메이저 변경입니다. 이는 Cargo가 가장 왼쪽의 0이 아닌 구성 요소의 변경만 비호환으로 간주하는 관례를 사용하기 때문입니다.</p>
<ul>
<li>API 호환성
<ul>
<li>아이템
<ul>
<li><a href="#item-remove">메이저: 공개 아이템의 이름 변경/이동/제거</a></li>
<li><a href="#item-new">마이너: 새로운 공개 아이템 추가</a></li>
</ul>
</li>
<li>타입
<ul>
<li><a href="#type-layout">메이저: 잘 정의된 타입의 정렬, 레이아웃 또는 크기 변경</a></li>
</ul>
</li>
<li>구조체
<ul>
<li><a href="#struct-add-private-field-when-public">메이저: 현재 모든 필드가 공개인 상태에서 비공개 구조체 필드 추가</a></li>
<li><a href="#struct-add-public-field-when-no-private">메이저: 비공개 필드가 없을 때 공개 필드 추가</a></li>
<li><a href="#struct-private-fields-with-private">마이너: 적어도 하나 이상의 비공개 필드가 존재할 때 비공개 필드 추가 또는 제거</a></li>
<li><a href="#struct-tuple-normal-with-private">마이너: 모든 필드가 비공개인 튜플 구조체(적어도 하나의 필드 포함)에서 일반 구조체로의 전환, 또는 그 반대</a></li>
</ul>
</li>
<li>열거형
<ul>
<li><a href="#enum-variant-new">메이저: 새로운 열거형 변형 추가(<code>non_exhaustive</code> 없음)</a></li>
<li><a href="#enum-fields-new">메이저: 열거형 변형에 새 필드 추가</a></li>
</ul>
</li>
<li>트레이트
<ul>
<li><a href="#trait-new-item-no-default">메이저: 기본값이 없는 트레이트 아이템 추가</a></li>
<li><a href="#trait-item-signature">메이저: 트레이트 아이템 시그니처의 모든 변경</a></li>
<li><a href="#trait-new-default-item">중단 가능성 있음: 기본값이 있는 트레이트 아이템 추가</a></li>
<li><a href="#trait-object-safety">메이저: 트레이트를 객체 안전하지 않게 만드는 트레이트 아이템 추가</a></li>
<li><a href="#trait-new-parameter-no-default">메이저: 기본값 없이 타입 매개변수 추가</a></li>
<li><a href="#trait-new-parameter-default">마이너: 기본값이 있는 트레이트 타입 매개변수 추가</a></li>
</ul>
</li>
<li>구현(Implementations)
<ul>
<li><a href="#impl-item-new">중단 가능성 있음: 고유 아이템(inherent items) 추가</a></li>
</ul>
</li>
<li>제네릭(Generics)
<ul>
<li><a href="#generic-bounds-tighten">메이저: 제네릭 바운드 강화</a></li>
<li><a href="#generic-bounds-loosen">마이너: 제네릭 바운드 완화</a></li>
<li><a href="#generic-new-default">마이너: 기본값이 있는 타입 매개변수 추가</a></li>
<li><a href="#generic-generalize-identical">마이너: 타입을 제네릭을 사용하도록 일반화 (동일한 타입 사용)</a></li>
<li><a href="#generic-generalize-different">메이저: 타입을 제네릭을 사용하도록 일반화 (다른 타입이 될 수 있음)</a></li>
<li><a href="#generic-more-generic">마이너: 제네릭 타입을 더 일반적인 타입으로 변경</a></li>
<li><a href="#generic-rpit-capture">메이저: RPIT(Return Position Impl Trait)에서 더 많은 제네릭 매개변수 캡처</a></li>
</ul>
</li>
<li>함수
<ul>
<li><a href="#fn-change-arity">메이저: 함수 매개변수 추가/제거</a></li>
<li><a href="#fn-generic-new">중단 가능성 있음: 새로운 함수 타입 매개변수 도입</a></li>
<li><a href="#fn-generalize-compatible">마이너: 함수를 제네릭을 사용하도록 일반화 (원래 타입 지원)</a></li>
<li><a href="#fn-generalize-mismatch">메이저: 함수를 제네릭을 사용하도록 일반화할 때 타입 불일치 발생</a></li>
<li><a href="#fn-unsafe-safe">마이너: <code>unsafe</code> 함수를 안전(safe)하게 만들기</a></li>
</ul>
</li>
<li>속성(Attributes)
<ul>
<li><a href="#attr-no-std-to-std">메이저: <code>no_std</code> 지원에서 <code>std</code> 필수 요구로 전환</a></li>
<li><a href="#attr-adding-non-exhaustive">메이저: 비공개 필드가 없는 기존 열거형, 변형(variant) 또는 구조체에 <code>non_exhaustive</code> 추가</a></li>
</ul>
</li>
</ul>
</li>
<li>도구 및 환경 호환성
<ul>
<li><a href="#env-new-rust">중단 가능성 있음: 필요한 최소 Rust 버전 변경</a></li>
<li><a href="#env-change-requirements">중단 가능성 있음: 플랫폼 및 환경 요구 사항 변경</a></li>
<li><a href="#new-lints">마이너: 새로운 린트(lints) 도입</a></li>
<li>Cargo
<ul>
<li><a href="#cargo-feature-add">마이너: 새로운 Cargo 기능 추가</a></li>
<li><a href="#cargo-feature-remove">메이저: Cargo 기능 제거</a></li>
<li><a href="#cargo-feature-remove-another">메이저: 기능 또는 공개 아이템을 변경하는 경우 기능 목록에서 기능 제거</a></li>
<li><a href="#cargo-remove-opt-dep">중단 가능성 있음: 선택적 의존성 제거</a></li>
<li><a href="#cargo-change-dep-feature">마이너: 의존성 기능 변경</a></li>
<li><a href="#cargo-dep-add">마이너: 의존성 추가</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#application-compatibility">애플리케이션 호환성</a></li>
</ul>
<h2 id="api-호환성"><a class="header" href="#api-호환성">API 호환성</a></h2>
<p>아래의 모든 예제는 세 부분으로 구성됩니다: 원래 코드, 수정된 후의 코드, 그리고 다른 프로젝트에서 나타날 수 있는 코드 사용 예시입니다. 마이너 변경의 경우, 사용 예시는 수정 전과 후 버전 모두에서 성공적으로 빌드되어야 합니다.</p>
<h3 id="item-remove"><a class="header" href="#item-remove">메이저: 모든 공개 아이템의 이름 변경/이동/제거</a></h3>
<p>공개적으로 노출된 <a href="../../reference/items.html">아이템</a>이 없으면 해당 아이템을 사용하는 모든 코드가 컴파일에 실패합니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub fn foo() {}

///////////////////////////////////////////////////////////
// 변경 후
// ... 아이템이 제거됨

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
fn main() {
    updated_crate::foo(); // 에러: `foo` 함수를 찾을 수 없음
}</code></pre>
<p>여기에는 <a href="../../reference/conditional-compilation.html">조건부 컴파일</a>에 따라 어떤 아이템이나 동작을 사용할 수 있는지 변경할 수 있는 모든 종류의 <a href="../../reference/conditional-compilation.html#the-cfg-attribute"><code>cfg</code> 속성</a>을 추가하는 것이 포함됩니다.</p>
<p>완화 전략:</p>
<ul>
<li>제거할 아이템을 <a href="../../reference/attributes/diagnostics.html#the-deprecated-attribute">권장되지 않음(deprecated)</a>으로 표시한 후, 나중에 SemVer를 중단하는 릴리스에서 제거하세요.</li>
<li>이름이 변경된 아이템을 <a href="../../reference/attributes/diagnostics.html#the-deprecated-attribute">권장되지 않음(deprecated)</a>으로 표시하고, <a href="../../reference/items/use-declarations.html"><code>pub use</code></a> 아이템을 사용하여 이전 이름으로 다시 내보내기(re-export)하세요.</li>
</ul>
<h3 id="item-new"><a class="header" href="#item-new">마이너: 새로운 공개 아이템 추가</a></h3>
<p>새로운 공개 <a href="../../reference/items.html">아이템</a>을 추가하는 것은 마이너 변경입니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
// ... 아이템 없음

///////////////////////////////////////////////////////////
// 변경 후
pub fn foo() {}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
// `foo`는 이전에 존재하지 않았으므로 사용되지 않음.</code></pre>
<p>드문 경우지만 와일드카드(glob) 임포트로 인해 **중단되는 변경 사항(breaking change)**이 될 수 있습니다. 예를 들어, 새로운 트레이트를 추가하고, 어떤 프로젝트에서 해당 트레이트를 스코프로 가져오는 와일드카드 임포트를 사용하고 있으며, 새로운 트레이트가 구현된 타입과 충돌하는 연관 아이템을 도입하는 경우 모호함으로 인해 컴파일 오류가 발생할 수 있습니다. 예시:</p>
<pre><code class="language-rust ignore">// 중단되는 변경 예시

///////////////////////////////////////////////////////////
// 변경 전
// ... 트레이트 없음

///////////////////////////////////////////////////////////
// 변경 후
pub trait NewTrait {
    fn foo(&amp;self) {}
}

impl NewTrait for i32 {}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::*;

pub trait LocalTrait {
    fn foo(&amp;self) {}
}

impl LocalTrait for i32 {}

fn main() {
    123i32.foo(); // 에러: 스코프 내에 적용 가능한 아이템이 여러 개 있음
}</code></pre>
<p>관례적으로 와일드카드(glob) 임포트는 미래 호환성을 해치는 위험 요소로 알려져 있기 때문에 이는 메이저 변경으로 간주되지 않습니다. 외부 크레이트 아이템의 와일드카드 임포트는 피해야 합니다.</p>
<h3 id="type-layout"><a class="header" href="#type-layout">메이저: 잘 정의된 타입의 정렬, 레이아웃 또는 크기 변경</a></h3>
<p>이전에 잘 정의되었던 타입의 정렬, 레이아웃 또는 크기를 변경하는 것은 중단되는 변경(breaking change)입니다.</p>
<p>일반적으로 <a href="../../reference/type-layout.html#the-default-representation">기본 표현(the default representation)</a>을 사용하는 타입은 잘 정의된 정렬, 레이아웃 또는 크기를 갖지 않습니다. 컴파일러는 정렬, 레이아웃 또는 크기를 자유롭게 변경할 수 있으므로, 코드는 이에 대해 어떤 가정도 해서는 안 됩니다.</p>
<blockquote>
<p><strong>참고</strong>: 외부 크레이트가 잘 정의되지 않은 타입의 정렬, 레이아웃 또는 크기에 대해 가정을 하는 경우 중단될 가능성이 있습니다. 하지만 그러한 가정을 해서는 안 되기 때문에 이는 SemVer 중단 변경으로 간주되지 않습니다.</p>
</blockquote>
<p>중단 변경이 아닌 변경 사항의 몇 가지 예는 다음과 같습니다(이 가이드의 다른 규칙을 위반하지 않는다고 가정함):</p>
<ul>
<li>이 가이드의 다른 규칙을 따르는 방식으로 기본 표현 구조체, 공용체(union) 또는 열거형의 필드를 추가, 제거, 재정렬 또는 변경하는 것 (예를 들어, <code>non_exhaustive</code>를 사용하여 이러한 변경을 허용하거나 이미 비공개인 필드를 변경하는 경우). <a href="#struct-add-private-field-when-public">struct-add-private-field-when-public</a>, <a href="#struct-add-public-field-when-no-private">struct-add-public-field-when-no-private</a>, <a href="#struct-private-fields-with-private">struct-private-fields-with-private</a>, <a href="#enum-fields-new">enum-fields-new</a>를 참조하세요.</li>
<li>열거형이 <code>non_exhaustive</code>를 사용하는 경우 기본 표현 열거형에 변형(variant)을 추가하는 것. 이는 열거형의 정렬이나 크기를 변경할 수 있지만, 이들은 잘 정의되어 있지 않습니다. <a href="#enum-variant-new">enum-variant-new</a>를 참조하세요.</li>
<li>이 가이드의 다른 규칙을 따르며 <code>repr(C)</code> 구조체, 공용체 또는 열거형의 비공개 필드를 추가, 제거, 재정렬 또는 변경하는 것 (예를 들어, <code>non_exhaustive</code>를 사용하거나 다른 비공개 필드가 이미 존재할 때 비공개 필드를 추가하는 경우). <a href="#repr-c-private-change">repr-c-private-change</a>를 참조하세요.</li>
<li>열거형이 <code>non_exhaustive</code>를 사용하는 경우 <code>repr(C)</code> 열거형에 변형(variant)을 추가하는 것. <a href="#repr-c-enum-variant-new">repr-c-enum-variant-new</a>를 참조하세요.</li>
<li>기본 표현 구조체, 공용체 또는 열거형에 <code>repr(C)</code>를 추가하는 것. <a href="#repr-c-add">repr-c-add</a>를 참조하세요.</li>
<li>열거형에 <code>repr(&lt;int&gt;)</code> <a href="../../reference/type-layout.html#primitive-representations">원시 표현(primitive representation)</a>을 추가하는 것. <a href="#repr-int-enum-add">repr-int-enum-add</a>를 참조하세요.</li>
<li>기본 표현 구조체 또는 열거형에 <code>repr(transparent)</code>를 추가하는 것. <a href="#repr-transparent-add">repr-transparent-add</a>를 참조하세요.</li>
</ul>
<p><a href="../../reference/type-layout.html#representations"><code>repr</code> 속성</a>을 사용하는 타입은 어떤 방식으로든 정의된 정렬 및 레이아웃을 갖는다고 할 수 있으며, 코드가 이에 대해 가정을 할 수 있습니다. 해당 타입을 변경하면 이러한 가정이 깨질 수 있습니다.</p>
<p>어떤 경우에는 <code>repr</code> 속성이 있는 타입이라도 정렬, 레이아웃 또는 크기가 잘 정의되지 않을 수 있습니다. 이러한 경우 타입을 변경하는 것이 안전할 수 있지만 주의를 기울여야 합니다. 예를 들어, 공개 API가 타입의 정렬, 레이아웃 또는 크기를 완전히 정의하지 않는 경우, 정렬, 레이아웃 또는 크기 보장을 별도로 문서화하지 않은 비공개 필드가 있는 타입을 외부 크레이트가 신뢰해서는 안 됩니다.</p>
<p><em>비공개</em> 필드가 있는 타입이 잘 정의된 일반적인 예로는 <code>repr(transparent)</code>를 사용하고 단일 비공개 제네릭 타입 필드를 가지며, 문서에서 해당 제네릭 타입에 대해 투명하다는 것을 설명하는 타입이 있습니다. 예를 들어 <a href="../../std/cell/struct.UnsafeCell.html#memory-layout"><code>UnsafeCell</code></a>을 참조하세요.</p>
<p>중단되는 변경의 몇 가지 예는 다음과 같습니다.</p>
<ul>
<li>구조체 또는 공용체에 <code>repr(packed)</code>를 추가하는 것. <a href="#repr-packed-add">repr-packed-add</a>를 참조하세요.</li>
<li>구조체, 공용체 또는 열거형에 <code>repr(align)</code>을 추가하는 것. <a href="#repr-align-add">repr-align-add</a>를 참조하세요.</li>
<li>구조체 또는 공용체에서 <code>repr(packed)</code>를 제거하는 것. <a href="#repr-packed-remove">repr-packed-remove</a>를 참조하세요.</li>
<li>정렬이나 레이아웃이 변경되는 경우 <code>repr(packed(N))</code>의 N 값을 변경하는 것. <a href="#repr-packed-n-change">repr-packed-n-change</a>를 참조하세요.</li>
<li>정렬이 변경되는 경우 <code>repr(align(N))</code>의 N 값을 변경하는 것. <a href="#repr-align-n-change">repr-align-n-change</a>를 참조하세요.</li>
<li>구조체, 공용체 또는 열거형에서 <code>repr(align)</code>을 제거하는 것. <a href="#repr-align-remove">repr-align-remove</a>를 참조하세요.</li>
<li><code>repr(C)</code> 타입의 공개 필드 순서를 변경하는 것. <a href="#repr-c-shuffle">repr-c-shuffle</a>를 참조하세요.</li>
<li>구조체, 공용체 또는 열거형에서 <code>repr(C)</code>를 제거하는 것. <a href="#repr-c-remove">repr-c-remove</a>를 참조하세요.</li>
<li>열거형에서 <code>repr(&lt;int&gt;)</code>를 제거하는 것. <a href="#repr-int-enum-remove">repr-int-enum-remove</a>를 참조하세요.</li>
<li><code>repr(&lt;int&gt;)</code> 열거형의 원시 표현을 변경하는 것. <a href="#repr-int-enum-change">repr-int-enum-change</a>를 참조하세요.</li>
<li>구조체 또는 열거형에서 <code>repr(transparent)</code>를 제거하는 것. <a href="#repr-transparent-remove">repr-transparent-remove</a>를 참조하세요.</li>
</ul>
<h4 id="repr-c-private-change"><a class="header" href="#repr-c-private-change">마이너: <code>repr(C)</code> 비공개 필드 추가, 제거 또는 변경</a></h4>
<p>이 가이드의 다른 지침을 따르는 한, <code>repr(C)</code> 구조체, 공용체 또는 열거형의 비공개 필드를 추가, 제거 또는 변경하는 것은 일반적으로 안전합니다. (<a href="#struct-add-private-field-when-public">struct-add-private-field-when-public</a>, <a href="#struct-add-public-field-when-no-private">struct-add-public-field-when-no-private</a>, <a href="#struct-private-fields-with-private">struct-private-fields-with-private</a>, <a href="#enum-fields-new">enum-fields-new</a>를 참조하세요.)</p>
<p>예를 들어, 비공개 필드 추가는 다른 비공개 필드가 이미 존재하거나 <code>non_exhaustive</code>인 경우에만 가능합니다. 공개 필드는 비공개 필드가 있거나 <code>non_exhaustive</code>이며, 추가로 인해 다른 필드의 레이아웃이 변경되지 않는 경우에 추가될 수 있습니다.</p>
<p>However, this may change the size and alignment of the type. Care should be taken if the size or alignment changes. Code should not make assumptions about the size or alignment of types with private fields or <code>non_exhaustive</code> unless it has a documented size or alignment.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
#[derive(Default)]
#[repr(C)]
pub struct Example {
    pub f1: i32,
    f2: i32, // 비공개 필드
}

///////////////////////////////////////////////////////////
// 변경 후
#[derive(Default)]
#[repr(C)]
pub struct Example {
    pub f1: i32,
    f2: i32,
    f3: i32, // 새로운 필드
}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
fn main() {
    // 참고: 크기나 정렬은 문서화되지 않았으므로 사용자는 이에 대해 가정해서는 안 됩니다.
    let f = updated_crate::Example::default();
}</code></pre>
<h4 id="repr-c-enum-variant-new"><a class="header" href="#repr-c-enum-variant-new">마이너: <code>repr(C)</code> 열거형 변형(variant) 추가</a></h4>
<p>열거형이 <code>non_exhaustive</code>를 사용하는 경우, <code>repr(C)</code> 열거형에 변형(variant)을 추가하는 것은 일반적으로 안전합니다. 자세한 내용은 <a href="#enum-variant-new">enum-variant-new</a>를 참조하세요.</p>
<p>이는 타입의 크기와 정렬을 변경하기 때문에 중단되는 변경(breaking change)이 될 수 있습니다. 유사한 문제에 대해서는 <a href="#repr-c-private-change">repr-c-private-change</a>를 참조하세요.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(C)]
#[non_exhaustive]
pub enum Example {
    Variant1 { f1: i16 },
    Variant2 { f1: i32 },
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(C)]
#[non_exhaustive]
pub enum Example {
    Variant1 { f1: i16 },
    Variant2 { f1: i32 },
    Variant3 { f1: i64 }, // 추가됨
}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
fn main() {
    // 참고: 크기나 정렬은 명시되지 않았으므로 사용자는 이에 대해 가정해서는 안 됩니다. 예를 들어, 이로 인해 크기가 8바이트에서 16바이트로 늘어났습니다.
    let f = updated_crate::Example::Variant2 { f1: 123 };
}</code></pre>
<h4 id="repr-c-add"><a class="header" href="#repr-c-add">마이너: 기본 표현에 <code>repr(C)</code> 추가</a></h4>
<p><a href="../../reference/type-layout.html#the-default-representation">기본 표현(the default representation)</a>을 사용하는 구조체, 공용체 또는 열거형에 <code>repr(C)</code>를 추가하는 것은 안전합니다. 기본 표현을 사용하는 타입의 정렬, 레이아웃 또는 크기에 대해 사용자가 어떤 가정도 해서는 안 되기 때문에 이는 안전합니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Example {
    pub f1: i32,
    pub f2: i16,
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(C)] // 추가됨
pub struct Example {
    pub f1: i32,
    pub f2: i16,
}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
fn main() {
    let f = updated_crate::Example { f1: 123, f2: 456 };
}</code></pre>
<h4 id="repr-int-enum-add"><a class="header" href="#repr-int-enum-add">마이너: 열거형에 <code>repr(&lt;int&gt;)</code> 추가</a></h4>
<p><a href="../../reference/type-layout.html#the-default-representation">기본 표현(the default representation)</a>을 사용하는 열거형에 <code>repr(&lt;int&gt;)</code> <a href="../../reference/type-layout.html#primitive-representations">원시 표현(primitive representation)</a>을 추가하는 것은 안전합니다. 기본 표현을 사용하는 열거형의 정렬, 레이아웃 또는 크기에 대해 사용자가 어떤 가정도 해서는 안 되기 때문에 이는 안전합니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
pub enum E {
    Variant1,
    Variant2(i32),
    Variant3 { f1: f64 },
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(i32)] // 추가됨
pub enum E {
    Variant1,
    Variant2(i32),
    Variant3 { f1: f64 },
}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
fn main() {
    let x = updated_crate::E::Variant3 { f1: 1.23 };
}</code></pre>
<h4 id="repr-transparent-add"><a class="header" href="#repr-transparent-add">마이너: 기본 표현 구조체 또는 열거형에 <code>repr(transparent)</code> 추가</a></h4>
<p><a href="../../reference/type-layout.html#the-default-representation">기본 표현(the default representation)</a>을 사용하는 구조체 또는 열거형에 <code>repr(transparent)</code>를 추가하는 것은 안전합니다. 기본 표현을 사용하는 구조체 또는 열거형의 정렬, 레이아웃 또는 크기에 대해 사용자가 어떤 가정도 해서는 안 되기 때문에 이는 안전합니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
#[derive(Default)]
pub struct Example&lt;T&gt;(T);

///////////////////////////////////////////////////////////
// 변경 후
#[derive(Default)]
#[repr(transparent)] // 추가됨
pub struct Example&lt;T&gt;(T);

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
fn main() {
    let x = updated_crate::Example::&lt;i32&gt;::default();
}</code></pre>
<h4 id="repr-packed-add"><a class="header" href="#repr-packed-add">메이저: 구조체 또는 공용체에 <code>repr(packed)</code> 추가</a></h4>
<p>구조체 또는 공용체에 <code>repr(packed)</code>를 추가하는 것은 중단되는 변경(breaking change)입니다. 타입을 <code>repr(packed)</code>로 만들면 필드에 대한 참조를 가져오는 것이 무효화되거나, 불연속 클로저 캡처(disjoint closure captures)의 잘림(truncation)이 발생하는 등 코드를 중단시킬 수 있는 변경이 발생합니다.</p>
<!-- TODO: If all fields are private, should this be safe to do? -->
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Example {
    pub f1: u8,
    pub f2: u16,
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(packed)] // 추가됨
pub struct Example {
    pub f1: u8,
    pub f2: u16,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
fn main() {
    let f = updated_crate::Example { f1: 1, f2: 2 };
    let x = &amp;f.f2; // 에러: packed 필드에 대한 참조가 정렬되지 않음
}</code></pre>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Example(pub i32, pub i32);

///////////////////////////////////////////////////////////
// 변경 후
#[repr(packed)]
pub struct Example(pub i32, pub i32);

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
fn main() {
    let mut f = updated_crate::Example(123, 456);
    let c = || {
        // repr(packed)가 없으면 클로저는 정확히 `&amp;f.0`을 캡처합니다.
        // repr(packed)가 있으면 클로저는 정의되지 않은 동작을 피하기 위해 `&amp;f`를 캡처합니다.
        let a = f.0;
    };
    f.1 = 789; // 에러: `f.1`이 대여 중이므로 값을 할당할 수 없음
    c();
}</code></pre>
<h4 id="repr-align-add"><a class="header" href="#repr-align-add">메이저: 구조체, 공용체 또는 열거형에 <code>repr(align)</code> 추가</a></h4>
<p>구조체, 공용체 또는 열거형에 <code>repr(align)</code>을 추가하는 것은 중단되는 변경(breaking change)입니다. 타입을 <code>repr(align)</code>으로 만들면 해당 타입을 <code>repr(packed)</code> 타입에서 사용하는 것이 중단됩니다. 이 두 조합은 허용되지 않기 때문입니다.</p>
<!-- TODO: This seems like it should be extraordinarily rare. Should there be any exceptions carved out for this? -->
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Aligned {
    pub a: i32,
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(align(8))] // 추가됨
pub struct Aligned {
    pub a: i32,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Aligned;

#[repr(packed)]
pub struct Packed { // 에러: packed 타입은 전이적으로 `#[repr(align)]` 타입을 포함할 수 없음
    f1: Aligned,
}

fn main() {
    let p = Packed {
        f1: Aligned { a: 123 },
    };
}</code></pre>
<h4 id="repr-packed-remove"><a class="header" href="#repr-packed-remove">메이저: 구조체 또는 공용체에서 <code>repr(packed)</code> 제거</a></h4>
<p>구조체 또는 공용체에서 <code>repr(packed)</code>를 제거하는 것은 중단되는 변경(breaking change)입니다. 이는 외부 크레이트가 의존하고 있는 정렬이나 레이아웃을 변경할 수 있습니다.</p>
<p>공개 필드가 있는 경우, <code>repr(packed)</code>를 제거하면 불연속 클로저 캡처(disjoint closure captures) 방식이 변경될 수 있습니다. 어떤 경우에는 <a href="../../edition-guide/rust-2021/disjoint-capture-in-closures.html">에디션 가이드</a>에 설명된 것과 유사하게 코드가 중단될 수 있습니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(C, packed)]
pub struct Packed {
    pub a: u8,
    pub b: u16,
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(C)] // packed 제거됨
pub struct Packed {
    pub a: u8,
    pub b: u16,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Packed;

fn main() {
    let p = Packed { a: 1, b: 2 };
    // 타입 크기에 대한 어떤 가정.
    // `packed`가 없으면 크기가 4이므로 실패함.
    const _: () = assert!(std::mem::size_of::&lt;Packed&gt;() == 3); // Error: assertion failed
}</code></pre>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(C, packed)]
pub struct Packed {
    pub a: *mut i32,
    pub b: i32,
}
unsafe impl Send for Packed {}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(C)] // packed 제거됨
pub struct Packed {
    pub a: *mut i32,
    pub b: i32,
}
unsafe impl Send for Packed {}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Packed;

fn main() {
    let mut x = 123;

    let p = Packed {
        a: &amp;mut x as *mut i32,
        b: 456,
    };

    // 구조체가 packed였을 때, 클로저는 Send인 `p`를 캡처합니다.
    // `packed`가 제거되면 Send가 아닌 `p.a`를 캡처하게 됩니다.
    std::thread::spawn(move || unsafe {
        *(p.a) += 1; // 에러: 스레드 간에 안전하게 보낼 수 없음
    });
}</code></pre>
<h4 id="repr-packed-n-change"><a class="header" href="#repr-packed-n-change">메이저: 정렬이나 레이아웃이 변경되는 경우 <code>repr(packed(N))</code>의 N 값 변경</a></h4>
<p>정렬이나 레이아웃이 변경되는 경우 <code>repr(packed(N))</code>의 N 값을 변경하는 것은 중단되는 변경(breaking change)입니다. 이는 외부 크레이트가 의존하고 있는 정렬이나 레이아웃을 변경할 수 있습니다.</p>
<p><code>N</code> 값이 공개 필드의 정렬보다 낮아지면, 해당 필드의 참조를 가져오려는 모든 코드가 중단됩니다.</p>
<p>현재 값이 이미 타입의 자연스러운 정렬(natural alignment)과 같은 상태에서 이를 높이는 경우와 같이, <code>N</code>에 대한 일부 변경은 정렬이나 레이아웃을 변경하지 않을 수도 있습니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(packed(4))]
pub struct Packed {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(packed(2))] // 2로 변경됨
pub struct Packed {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Packed;

fn main() {
    let p = Packed { a: 1, b: 2 };
    let x = &amp;p.b; // 에러: packed 필드에 대한 참조가 정렬되지 않음
}</code></pre>
<h4 id="repr-align-n-change"><a class="header" href="#repr-align-n-change">메이저: 정렬이 변경되는 경우 <code>repr(align(N))</code>의 N 값 변경</a></h4>
<p>정렬이 변경되는 경우 <code>repr(align(N))</code>의 <code>N</code> 값을 변경하는 것은 중단되는 변경(breaking change)입니다. 이는 외부 크레이트가 의존하고 있는 정렬을 변경할 수 있습니다.</p>
<p><a href="#type-layout">타입 레이아웃</a>에서 논의된 바와 같이 타입이 잘 정의되지 않은 경우(예: 비공개 필드가 있고 정렬이나 레이아웃이 문서화되지 않은 경우), 이러한 변경은 안전할 것입니다.</p>
<p>현재 값이 이미 타입의 자연스러운 정렬보다 작거나 같은 상태에서 이를 줄이는 경우와 같이, <code>N</code>에 대한 일부 변경은 정렬이나 레이아웃을 변경하지 않을 수도 있습니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(align(8))]
pub struct Packed {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(align(4))] // 4로 변경됨
pub struct Packed {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Packed;

fn main() {
    let p = Packed { a: 1, b: 2 };
    // 타입 크기에 대한 어떤 가정.
    // 정렬이 8에서 4로 변경됨.
    const _: () = assert!(std::mem::align_of::&lt;Packed&gt;() == 8); // Error: assertion failed
}</code></pre>
<h4 id="repr-align-remove"><a class="header" href="#repr-align-remove">메이저: 구조체, 공용체 또는 열거형에서 <code>repr(align)</code> 제거</a></h4>
<p>구조체, 공용체 또는 열거형의 레이아웃이 잘 정의되어 있는 경우, <code>repr(align)</code>을 제거하는 것은 중단되는 변경(breaking change)입니다. 이는 외부 크레이트가 의존하고 있는 정렬이나 레이아웃을 변경할 수 있습니다.</p>
<p><a href="#type-layout">타입 레이아웃</a>에서 논의된 바와 같이 타입이 잘 정의되지 않은 경우(예: 비공개 필드가 있고 정렬이 문서화되지 않은 경우), 이러한 변경은 안전할 것입니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(C, align(8))]
pub struct Packed {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(C)] // align 제거됨
pub struct Packed {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Packed;

fn main() {
    let p = Packed { a: 1, b: 2 };
    // 타입 크기에 대한 어떤 가정.
    // 정렬이 8에서 4로 변경됨.
    const _: () = assert!(std::mem::align_of::&lt;Packed&gt;() == 8); // Error: assertion failed
}</code></pre>
<h4 id="repr-c-shuffle"><a class="header" href="#repr-c-shuffle">메이저: <code>repr(C)</code> 타입의 공개 필드 순서 변경</a></h4>
<p><code>repr(C)</code> 타입의 공개 필드 순서를 변경하는 것은 중단되는 변경(breaking change)입니다. 외부 크레이트가 필드의 특정 순서에 의존하고 있을 수 있습니다.</p>
<pre><code class="language-rust ignore run-fail">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(C)]
pub struct SpecificLayout {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(C)]
pub struct SpecificLayout {
    pub b: u32, // 순서 변경됨
    pub a: u8,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::SpecificLayout;

unsafe extern "C" {
    // 이 C 함수는 C 헤더에 정의된 특정 레이아웃을 가정하고 있습니다.
    fn c_fn_get_b(x: &amp;SpecificLayout) -&gt; u32;
}

fn main() {
    let p = SpecificLayout { a: 1, b: 2 };
    unsafe { assert_eq!(c_fn_get_b(&amp;p), 2) } // 에러: 값이 2와 같지 않음
}

<span class="boring">mod cdep {
</span><span class="boring">    // 이는 보통 빌드 스크립트에서 포함되는 내용을 시뮬레이션합니다.
</span><span class="boring">    // 이 정의는 C 헤더에 있을 것입니다.
</span><span class="boring">    #[repr(C)]
</span><span class="boring">    pub struct SpecificLayout {
</span><span class="boring">        pub a: u8,
</span><span class="boring">        pub b: u32,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[no_mangle]
</span><span class="boring">    pub fn c_fn_get_b(x: &amp;SpecificLayout) -&gt; u32 {
</span><span class="boring">        x.b
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h4 id="repr-c-remove"><a class="header" href="#repr-c-remove">메이저: 구조체, 공용체 또는 열거형에서 <code>repr(C)</code> 제거</a></h4>
<p>구조체, 공용체 또는 열거형에서 <code>repr(C)</code>를 제거하는 것은 중단되는 변경(breaking change)입니다. 외부 크레이트가 해당 타입의 특정 레이아웃에 의존하고 있을 수 있습니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(C)]
pub struct SpecificLayout {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// 변경 후
// repr(C) 제거됨
pub struct SpecificLayout {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::SpecificLayout;

unsafe extern "C" {
    // 이 C 함수는 C 헤더에 정의된 특정 레이아웃을 가정하고 있습니다.
    fn c_fn_get_b(x: &amp;SpecificLayout) -&gt; u32; // 에러: FFI 안전하지 않음
}

fn main() {
    let p = SpecificLayout { a: 1, b: 2 };
    unsafe { assert_eq!(c_fn_get_b(&amp;p), 2) }
}

<span class="boring">mod cdep {
</span><span class="boring">    // 이는 보통 빌드 스크립트에서 포함되는 내용을 시뮬레이션합니다.
</span><span class="boring">    // 이 정의는 C 헤더에 있을 것입니다.
</span><span class="boring">    #[repr(C)]
</span><span class="boring">    pub struct SpecificLayout {
</span><span class="boring">        pub a: u8,
</span><span class="boring">        pub b: u32,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[no_mangle]
</span><span class="boring">    pub fn c_fn_get_b(x: &amp;SpecificLayout) -&gt; u32 {
</span><span class="boring">        x.b
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h4 id="repr-int-enum-remove"><a class="header" href="#repr-int-enum-remove">메이저: 열거형에서 <code>repr(&lt;int&gt;)</code> 제거</a></h4>
<p>열거형에서 <code>repr(&lt;int&gt;)</code>를 제거하는 것은 중단되는 변경(breaking change)입니다. 외부 크레이트가 판별자(discriminant)가 특정 크기라고 가정하고 있을 수 있습니다. 예를 들어, 열거형의 <a href="../../std/mem/fn.transmute.html"><code>std::mem::transmute</code></a>이 실패할 수 있습니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(u16)]
pub enum Example {
    Variant1,
    Variant2,
    Variant3,
}

///////////////////////////////////////////////////////////
// 변경 후
// repr(u16) 제거됨
pub enum Example {
    Variant1,
    Variant2,
    Variant3,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시

fn main() {
    let e = updated_crate::Example::Variant2;
    let i: u16 = unsafe { std::mem::transmute(e) }; // 에러: 크기가 다른 타입 간에 transmute할 수 없음
}</code></pre>
<h4 id="repr-int-enum-change"><a class="header" href="#repr-int-enum-change">메이저: <code>repr(&lt;int&gt;)</code> 열거형의 원시 표현 변경</a></h4>
<p><code>repr(&lt;int&gt;)</code> 열거형의 원시 표현을 변경하는 것은 중단되는 변경(breaking change)입니다. 외부 크레이트가 판별자(discriminant)가 특정 크기라고 가정하고 있을 수 있습니다. 예를 들어, 열거형의 <a href="../../std/mem/fn.transmute.html"><code>std::mem::transmute</code></a>이 실패할 수 있습니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(u16)]
pub enum Example {
    Variant1,
    Variant2,
    Variant3,
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(u8)] // repr 크기가 변경됨
pub enum Example {
    Variant1,
    Variant2,
    Variant3,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시

fn main() {
    let e = updated_crate::Example::Variant2;
    let i: u16 = unsafe { std::mem::transmute(e) }; // 에러: 크기가 다른 타입 간에 transmute할 수 없음
}</code></pre>
<h4 id="repr-transparent-remove"><a class="header" href="#repr-transparent-remove">메이저: 구조체 또는 열거형에서 <code>repr(transparent)</code> 제거</a></h4>
<p>구조체 또는 열거형에서 <code>repr(transparent)</code>를 제거하는 것은 중단되는 변경(breaking change)입니다. 외부 크레이트가 해당 타입이 투명 필드(transparent field)의 정렬, 레이아웃 또는 크기를 갖는 것에 의존하고 있을 수 있습니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(transparent)]
pub struct Transparent&lt;T&gt;(T);

///////////////////////////////////////////////////////////
// 변경 후
// repr 제거됨
pub struct Transparent&lt;T&gt;(T);

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
#![deny(improper_ctypes)]
use updated_crate::Transparent;

unsafe extern "C" {
    fn c_fn() -&gt; Transparent&lt;f64&gt;; // 에러: FFI 안전하지 않음
}

fn main() {}</code></pre>
<h3 id="struct-add-private-field-when-public"><a class="header" href="#struct-add-private-field-when-public">메이저: 현재 모든 필드가 공개인 상태에서 비공개 구조체 필드 추가</a></h3>
<p>이전에 모든 필드가 공개였던 구조체에 비공개 필드가 추가되면, <a href="../../reference/expressions/struct-expr.html">구조체 리터럴</a>을 사용하여 해당 구조체를 생성하려는 모든 코드가 중단됩니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Foo {
    pub f1: i32,
}

///////////////////////////////////////////////////////////
// 변경 후
pub struct Foo {
    pub f1: i32,
    f2: i32,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
fn main() {
    let x = updated_crate::Foo { f1: 123 }; // 에러: `Foo`를 생성할 수 없음
}</code></pre>
<p>완화 전략:</p>
<ul>
<li>모든 필드가 공개인 구조체에 새로운 필드를 추가하지 마세요.</li>
<li>구조체를 처음 도입할 때 사용자가 구조체 리터럴 구문을 사용하지 못하도록 <a href="../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>로 표시하고, 대신 생성자 메서드 및/또는 <a href="../../std/default/trait.Default.html">Default</a> 구현을 제공하세요.</li>
</ul>
<h3 id="struct-add-public-field-when-no-private"><a class="header" href="#struct-add-public-field-when-no-private">메이저: 비공개 필드가 없는 상태에서 공개 필드 추가</a></h3>
<p>모든 필드가 공개인 구조체에 공개 필드가 추가되면, <a href="../../reference/expressions/struct-expr.html">구조체 리터럴</a>을 사용하여 해당 구조체를 생성하려는 모든 코드가 중단됩니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Foo {
    pub f1: i32,
}

///////////////////////////////////////////////////////////
// 변경 후
pub struct Foo {
    pub f1: i32,
    pub f2: i32,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
fn main() {
    let x = updated_crate::Foo { f1: 123 }; // 에러: `f2` 필드가 누락됨
}</code></pre>
<p>완화 전략:</p>
<ul>
<li>모든 필드가 공개인 구조체에 새로운 필드를 추가하지 마세요.</li>
<li>구조체를 처음 도입할 때 사용자가 구조체 리터럴 구문을 사용하지 못하도록 <a href="../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>로 표시하고, 대신 생성자 메서드 및/또는 <a href="../../std/default/trait.Default.html">Default</a> 구현을 제공하세요.</li>
</ul>
<h3 id="struct-private-fields-with-private"><a class="header" href="#struct-private-fields-with-private">마이너: 적어도 하나의 비공개 필드가 이미 존재하는 상태에서 비공개 필드 추가 또는 제거</a></h3>
<p>구조체에 이미 적어도 하나의 비공개 필드가 있는 경우, 비공개 필드를 추가하거나 제거하는 것은 안전합니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
#[derive(Default)]
pub struct Foo {
    f1: i32,
}

///////////////////////////////////////////////////////////
// 변경 후
#[derive(Default)]
pub struct Foo {
    f2: f64,
}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
fn main() {
    // 비공개 필드에 접근할 수 없음.
    let x = updated_crate::Foo::default();
}</code></pre>
<p>기존 코드가 <a href="../../reference/expressions/struct-expr.html">구조체 리터럴</a>을 사용하여 이를 생성할 수 없고, 그 내용을 철저하게 매칭(exhaustive match)할 수도 없기 때문에 이는 안전합니다.</p>
<p>튜플 구조체의 경우, 튜플에 공개 필드가 포함되어 있고 비공개 필드의 추가 또는 제거가 공개 필드의 인덱스를 변경한다면 이는 <strong>메이저 변경</strong>이라는 점에 유의하세요.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[derive(Default)]
pub struct Foo(pub i32, i32);

///////////////////////////////////////////////////////////
// 변경 후
#[derive(Default)]
pub struct Foo(f64, pub i32, i32);

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
fn main() {
    let x = updated_crate::Foo::default();
    let y = x.0; // 에러: 비공개임
}</code></pre>
<h3 id="struct-tuple-normal-with-private"><a class="header" href="#struct-tuple-normal-with-private">마이너: (하나 이상의 필드가 있는) 모든 필드가 비공개인 튜플 구조체에서 일반 구조체로의 전환, 또는 그 반대</a></h3>
<p>모든 필드가 비공개인 경우 튜플 구조체를 일반 구조체로 변경하는 것(또는 그 반대)은 안전합니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
#[derive(Default)]
pub struct Foo(i32);

///////////////////////////////////////////////////////////
// 변경 후
#[derive(Default)]
pub struct Foo {
    f1: i32,
}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
fn main() {
    // 비공개 필드에 접근할 수 없음.
    let x = updated_crate::Foo::default();
}</code></pre>
<p>기존 코드가 <a href="../../reference/expressions/struct-expr.html">구조체 리터럴</a>을 사용하여 이를 생성할 수 없고, 그 내용을 매칭할 수도 없기 때문에 이는 안전합니다.</p>
<h3 id="enum-variant-new"><a class="header" href="#enum-variant-new">메이저: 새로운 열거형 변형(variant) 추가 (<code>non_exhaustive</code> 없이)</a></h3>
<p>열거형이 <a href="../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a> 속성을 사용하지 않는 경우 새로운 열거형 변형을 추가하는 것은 중단되는 변경(breaking change)입니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub enum E {
    Variant1,
}

///////////////////////////////////////////////////////////
// 변경 후
pub enum E {
    Variant1,
    Variant2,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
fn main() {
    use updated_crate::E;
    let x = E::Variant1;
    match x { // 에러: `E::Variant2`가 처리되지 않음
        E::Variant1 =&gt; {}
    }
}</code></pre>
<p>완화 전략:</p>
<ul>
<li>열거형을 도입할 때 <a href="../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>로 표시하여 사용자가 새로운 변형을 처리하기 위해 <a href="../../reference/patterns.html#wildcard-pattern">와일드카드 패턴</a>을 사용하도록 강제하세요.</li>
</ul>
<h3 id="enum-fields-new"><a class="header" href="#enum-fields-new">메이저: 열거형 변형에 새로운 필드 추가</a></h3>
<p>열거형 변형의 모든 필드는 공개이므로 새로운 필드를 추가하면 생성자와 매칭의 컴파일이 실패하게 되어 중단되는 변경(breaking change)이 됩니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub enum E {
    Variant1 { f1: i32 },
}

///////////////////////////////////////////////////////////
// 변경 후
pub enum E {
    Variant1 { f1: i32, f2: i32 },
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
fn main() {
    use updated_crate::E;
    let x = E::Variant1 { f1: 1 }; // 에러: f2가 누락됨
    match x {
        E::Variant1 { f1 } =&gt; {} // 에러: f2가 누락됨
    }
}</code></pre>
<p>완화 전략:</p>
<ul>
<li>
<p>열거형을 도입할 때 변형을 <a href="../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>non_exhaustive</code></a>로 표시하여 와일드카드 없이 생성하거나 매칭할 수 없도록 하세요.</p>
<pre><code class="language-rust ignore skip">pub enum E {
    #[non_exhaustive]
    Variant1{f1: i32}
}</code></pre>
</li>
<li>
<p>열거형을 도입할 때 필드 가시성을 제어할 수 있는 명시적인 구조체를 값으로 사용하세요.</p>
<pre><code class="language-rust ignore skip">pub struct Foo {
   f1: i32,
   f2: i32,
}
pub enum E {
    Variant1(Foo)
}</code></pre>
</li>
</ul>
<h3 id="trait-new-item-no-default"><a class="header" href="#trait-new-item-no-default">메이저: 기본값이 없는 트레이트 아이템 추가</a></h3>
<p>트레이트에 기본값이 없는 아이템을 추가하는 것은 중단되는 변경(breaking change)입니다. 이는 트레이트의 모든 구현체를 중단시킵니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub trait Trait {}

///////////////////////////////////////////////////////////
// 변경 후
pub trait Trait {
    fn foo(&amp;self);
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}  // 에러: 모든 트레이트 아이템이 구현되지 않음</code></pre>
<p>완화 전략:</p>
<ul>
<li>새로운 연관 트레이트 아이템에는 항상 기본 구현이나 값을 제공하세요.</li>
<li>트레이트를 도입할 때, 크레이트 외부의 사용자가 트레이트를 구현하지 못하도록 <a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed">봉인된 트레이트(sealed trait)</a> 기법을 사용하세요.</li>
</ul>
<h3 id="trait-item-signature"><a class="header" href="#trait-item-signature">메이저: 트레이트 아이템 시그니처의 모든 변경</a></h3>
<p>트레이트 아이템 시그니처를 변경하는 것은 중단되는 변경(breaking change)입니다. 이는 트레이트의 외부 구현체를 중단시킬 수 있습니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub trait Trait {
    fn f(&amp;self, x: i32) {}
}

///////////////////////////////////////////////////////////
// 변경 후
pub trait Trait {
    // 봉인된 트레이트나 일반 함수의 경우, 제네릭을 사용한 일반화가 가능한 용도를 엄격하게 확장하기 때문에 이는 마이너 변경일 것입니다.
    // 하지만 이 경우 트레이트 구현은 동일한 시그니처를 사용해야 합니다.
    fn f&lt;V&gt;(&amp;self, x: V) {}
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {
    fn f(&amp;self, x: i32) {}  // 에러: 트레이트 선언에 1개의 타입 매개변수가 있음
}</code></pre>
<p>완화 전략:</p>
<ul>
<li>기존 아이템을 수정하는 대신, 새로운 기능을 제공하기 위해 기본 구현이 포함된 새로운 아이템을 도입하세요.</li>
<li>트레이트를 도입할 때, 크레이트 외부의 사용자가 트레이트를 구현하지 못하도록 <a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed">봉인된 트레이트(sealed trait)</a> 기법을 사용하세요.</li>
</ul>
<h3 id="trait-new-default-item"><a class="header" href="#trait-new-default-item">중단 가능성 있음: 기본값이 있는 트레이트 아이템 추가</a></h3>
<p>기본값이 있는 트레이트 아이템을 추가하는 것은 일반적으로 안전합니다. 하지만 때때로 컴파일 오류를 일으킬 수 있습니다. 예를 들어, 다른 트레이트에 동일한 이름의 메서드가 존재하는 경우 모호함이 발생할 수 있습니다.</p>
<pre><code class="language-rust ignore">// 중단되는 변경 예시

///////////////////////////////////////////////////////////
// 변경 전
pub trait Trait {}

///////////////////////////////////////////////////////////
// 변경 후
pub trait Trait {
    fn foo(&amp;self) {}
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Trait;
struct Foo;

trait LocalTrait {
    fn foo(&amp;self) {}
}

impl Trait for Foo {}
impl LocalTrait for Foo {}

fn main() {
    let x = Foo;
    x.foo(); // 에러: 스코프 내에 적용 가능한 아이템이 여러 개 있음
}</code></pre>
<p><a href="../../reference/items/implementations.html#inherent-implementations">고유 구현(inherent implementations)</a>의 이름 충돌에 대해서는 이러한 모호함이 발생하지 않습니다. 고유 구현이 트레이트 아이템보다 우선순위를 갖기 때문입니다.</p>
<p>트레이트 아이템을 추가할 때 고려해야 할 특별한 경우에 대해서는 <a href="#trait-object-safety">trait-object-safety</a>를 참조하세요.</p>
<p>완화 전략:</p>
<ul>
<li>일부 프로젝트에서는 특히 새로운 아이템 이름이 기존 코드와 충돌할 가능성이 낮은 경우, 이를 허용 가능한 중단으로 간주할 수 있습니다. 이러한 충돌을 피하기 위해 이름을 신중하게 선택하세요. 또한, 의존성을 업데이트할 때 다운스트림 사용자가 올바른 함수를 선택하기 위해 <a href="../../reference/expressions/call-expr.html#disambiguating-function-calls">모호성 해소 구문(disambiguation syntax)</a>을 추가하도록 요구하는 것이 허용될 수 있습니다.</li>
</ul>
<h3 id="trait-object-safety"><a class="header" href="#trait-object-safety">메이저: 트레이트를 객체 안전하지 않게 만드는 트레이트 아이템 추가</a></h3>
<p>트레이트를 <a href="../../reference/items/traits.html#object-safety">객체 안전(object safe)</a>하지 않게 변경하는 트레이트 아이템을 추가하는 것은 중단되는 변경(breaking change)입니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub trait Trait {}

///////////////////////////////////////////////////////////
// 변경 후
pub trait Trait {
    // 연관 상수는 트레이트를 객체 안전하지 않게 만듭니다.
    const CONST: i32 = 123;
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}

fn main() {
    let obj: Box&lt;dyn Trait&gt; = Box::new(Foo); // Error: the trait `Trait` is not dyn compatible
}</code></pre>
<p>그 반대(객체 안전하지 않은 트레이트를 객체 안전하게 만드는 것)는 안전합니다.</p>
<h3 id="trait-new-parameter-no-default"><a class="header" href="#trait-new-parameter-no-default">메이저: 기본값 없이 타입 매개변수 추가</a></h3>
<p>트레이트에 기본값 없이 타입 매개변수를 추가하는 것은 중단되는 변경(breaking change)입니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub trait Trait {}

///////////////////////////////////////////////////////////
// 변경 후
pub trait Trait&lt;T&gt; {}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}  // 에러: 제네릭이 누락됨</code></pre>
<p>완화 전략:</p>
<ul>
<li><a href="#trait-new-parameter-default">기본값이 있는 트레이트 타입 매개변수 추가</a>를 참조하세요.</li>
</ul>
<h3 id="trait-new-parameter-default"><a class="header" href="#trait-new-parameter-default">마이너: 기본값이 있는 트레이트 타입 매개변수 추가</a></h3>
<p>기본값이 있는 한 트레이트에 타입 매개변수를 추가하는 것은 안전합니다. 외부 구현체는 매개변수를 지정할 필요 없이 기본값을 사용하게 됩니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
pub trait Trait {}

///////////////////////////////////////////////////////////
// 변경 후
pub trait Trait&lt;T = i32&gt; {}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}</code></pre>
<h3 id="impl-item-new"><a class="header" href="#impl-item-new">중단 가능성 있음: 고유 아이템(inherent items) 추가</a></h3>
<p>일반적으로 고유 아이템이 트레이트 아이템보다 우선순위를 갖기 때문에 구현에 고유 아이템을 추가하는 것은 안전할 것입니다. 그러나 이름이 구현된 트레이트 아이템과 같고 시그니처가 다른 경우 충돌이 발생하여 문제가 생길 수 있습니다.</p>
<pre><code class="language-rust ignore">// 중단되는 변경 예시

///////////////////////////////////////////////////////////
// 변경 전
pub struct Foo;

///////////////////////////////////////////////////////////
// 변경 후
pub struct Foo;

impl Foo {
    pub fn foo(&amp;self) {}
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Foo;

trait Trait {
    fn foo(&amp;self, x: i32) {}
}

impl Trait for Foo {}

fn main() {
    let x = Foo;
    x.foo(1); // 에러: 이 메서드는 0개의 인수를 받지만 1개의 인수가 제공됨
}</code></pre>
<p>시그니처가 일치하는 경우에는 컴파일 오류는 발생하지 않지만, 런타임 동작이 조용히 변경될 수 있습니다(이제 다른 함수를 실행하게 되기 때문입니다).</p>
<p>완화 전략:</p>
<ul>
<li>일부 프로젝트에서는 특히 새로운 아이템 이름이 기존 코드와 충돌할 가능성이 낮은 경우, 이를 허용 가능한 중단으로 간주할 수 있습니다. 이러한 충돌을 피하기 위해 이름을 신중하게 선택하세요. 또한, 의존성을 업데이트할 때 다운스트림 사용자가 올바른 함수를 선택하기 위해 <a href="../../reference/expressions/call-expr.html#disambiguating-function-calls">모호성 해소 구문(disambiguation syntax)</a>을 추가하도록 요구하는 것이 허용될 수 있습니다.</li>
</ul>
<h3 id="generic-bounds-tighten"><a class="header" href="#generic-bounds-tighten">메이저: 제네릭 바운드 강화</a></h3>
<p>타입의 제네릭 바운드를 강화하는 것은 더 느슨한 바운드를 예상하는 사용자들을 중단시킬 수 있으므로 중단되는 변경(breaking change)입니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Foo&lt;A&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// 변경 후
pub struct Foo&lt;A: Eq&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Foo;

fn main() {
    let s = Foo { f1: 1.23 }; // 에러: 트레이트 바운드 `{float}: Eq`가 충족되지 않음
}</code></pre>
<h3 id="generic-bounds-loosen"><a class="header" href="#generic-bounds-loosen">마이너: 제네릭 바운드 완화</a></h3>
<p>타입의 제네릭 바운드를 완화하는 것은 허용되는 범위를 확장할 뿐이므로 안전합니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Foo&lt;A: Clone&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// 변경 후
pub struct Foo&lt;A&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
use updated_crate::Foo;

fn main() {
    let s = Foo { f1: 123 };
}</code></pre>
<h3 id="generic-new-default"><a class="header" href="#generic-new-default">마이너: 기본값이 있는 타입 매개변수 추가</a></h3>
<p>기본값이 있는 한 타입에 타입 매개변수를 추가하는 것은 안전합니다. 모든 기존 참조는 매개변수를 지정할 필요 없이 기본값을 사용하게 됩니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
#[derive(Default)]
pub struct Foo {}

///////////////////////////////////////////////////////////
// 변경 후
#[derive(Default)]
pub struct Foo&lt;A = i32&gt; {
    f1: A,
}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
use updated_crate::Foo;

fn main() {
    let s: Foo = Default::default();
}</code></pre>
<h3 id="generic-generalize-identical"><a class="header" href="#generic-generalize-identical">마이너: 타입을 제네릭을 사용하도록 일반화 (동일한 타입 사용)</a></h3>
<p>구조체 또는 열거형 필드는 변경 결과가 모든 기존 사용 사례에 대해 동일한 타입이 되는 한, 구체적인 타입에서 제네릭 타입 매개변수로 변경할 수 있습니다. 예를 들어, 다음과 같은 변경은 허용됩니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Foo(pub u8);

///////////////////////////////////////////////////////////
// 변경 후
pub struct Foo&lt;T = u8&gt;(pub T);

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
use updated_crate::Foo;

fn main() {
    let s: Foo = Foo(123);
}</code></pre>
<p><code>Foo</code>의 기존 용법은 동일한 필드 타입을 생성하는 <code>Foo&lt;u8&gt;</code>의 약어이기 때문입니다.</p>
<h3 id="generic-generalize-different"><a class="header" href="#generic-generalize-different">메이저: 타입을 제네릭을 사용하도록 일반화 (다른 타입이 될 수 있음)</a></h3>
<p>구조체 또는 열거형 필드를 구체적인 타입에서 제네릭 타입 매개변수로 변경하면 타입이 바뀔 수 있는 경우 중단될 수 있습니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Foo&lt;T = u8&gt;(pub T, pub u8);

///////////////////////////////////////////////////////////
// 변경 후
pub struct Foo&lt;T = u8&gt;(pub T, pub T);

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Foo;

fn main() {
    let s: Foo&lt;f32&gt; = Foo(3.14, 123); // 에러: 타입 불일치
}</code></pre>
<h3 id="generic-more-generic"><a class="header" href="#generic-more-generic">마이너: 제네릭 타입을 더 일반적인 타입으로 변경</a></h3>
<p>제네릭 타입을 더 일반적인 타입으로 변경하는 것은 안전합니다. 예를 들어, 다음은 원래 타입으로 기본 설정되는 제네릭 매개변수를 추가하는데, 모든 기존 사용자가 두 필드에 대해 동일한 타입을 사용하게 되며 기본 매개변수를 지정할 필요가 없기 때문에 안전합니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Foo&lt;T&gt;(pub T, pub T);

///////////////////////////////////////////////////////////
// 변경 후
pub struct Foo&lt;T, U = T&gt;(pub T, pub U);

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
use updated_crate::Foo;

fn main() {
    let s: Foo&lt;f32&gt; = Foo(1.0, 2.0);
}</code></pre>
<h3 id="generic-rpit-capture"><a class="header" href="#generic-rpit-capture">메이저: RPIT(Return Position Impl Trait)에서 더 많은 제네릭 매개변수 캡처</a></h3>
<p><a href="../../reference/types/impl-trait.html#abstract-return-types">RPIT(return-position impl trait)</a>에서 추가적인 제네릭 매개변수를 캡처하는 것은 중단되는 변경(breaking change)입니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub fn f&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; impl Iterator&lt;Item = char&gt; + use&lt;'a&gt; {
    x.chars()
}

///////////////////////////////////////////////////////////
// 변경 후
pub fn f&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; impl Iterator&lt;Item = char&gt; + use&lt;'a, 'b&gt; {
    x.chars().chain(y.chars())
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
fn main() {
    let a = String::new();
    let b = String::new();
    let iter = updated_crate::f(&amp;a, &amp;b);
    drop(b); // 에러: `b`가 대여 중이므로 이동할 수 없음
}</code></pre>
<p>RPIT에 제네릭 매개변수를 추가하면 결과 타입이 사용되는 방식에 추가적인 제약 조건이 생깁니다.</p>
<p><code>use&lt;&gt;</code> 구문을 지정하지 않았을 때 암시적 캡처가 발생한다는 점에 유의하세요. Rust 2021 및 이전 에디션에서 수명(lifetime) 매개변수는 RPIT 타입 시그니처의 바운드 내에 구문적으로 나타나는 경우에만 캡처됩니다. Rust 2024부터는 모든 수명 매개변수가 무조건 캡처됩니다. 이는 Rust 2024부터 기본값이 최대 호환성을 갖도록 설정되었음을 의미하며, 더 적게 캡처하고 싶을 때는 이를 명시해야 함을 뜻합니다. 이는 SemVer 약속의 일부입니다.</p>
<p>RPIT 캡처에 대한 자세한 내용은 <a href="../../edition-guide/rust-2024/rpit-lifetime-capture.html">에디션 가이드</a> 및 <a href="../../reference/types/impl-trait.html#capturing">레퍼런스</a>를 참조하세요.</p>
<p>RPIT에서 더 적은 수의 제네릭 매개변수를 캡처하는 것은 마이너 변경입니다.</p>
<blockquote>
<p>참고: 스코프 내의 모든 타입 및 상수 제네릭 매개변수는 암시적으로 캡처되거나(<code>+ use&lt;…&gt;</code>가 지정되지 않은 경우) 명시적으로 캡처되어야(<code>+ use&lt;…&gt;</code>에 나열되어야 함) 합니다. 따라서 현재는 이러한 종류의 제네릭에서 무엇이 캡처되는지 변경하는 것이 허용되지 않습니다.</p>
</blockquote>
<h3 id="fn-change-arity"><a class="header" href="#fn-change-arity">메이저: 함수 매개변수 추가/제거</a></h3>
<p>함수의 매개변수 개수(arity)를 변경하는 것은 중단되는 변경(breaking change)입니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub fn foo() {}

///////////////////////////////////////////////////////////
// 변경 후
pub fn foo(x: i32) {}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
fn main() {
    updated_crate::foo(); // 에러: 이 함수는 1개의 인수를 받음
}</code></pre>
<p>완화 전략:</p>
<ul>
<li>새로운 시그니처를 가진 새로운 함수를 도입하고, 가능하면 기존 함수를 <a href="../../reference/attributes/diagnostics.html#the-deprecated-attribute">권장되지 않음(deprecate)</a>으로 표시하세요.</li>
<li>구조체 인수를 받는 함수를 도입하고, 해당 구조체는 빌더 패턴으로 생성되도록 하세요. 이렇게 하면 나중에 구조체에 새로운 필드를 추가할 수 있습니다.</li>
</ul>
<h3 id="fn-generic-new"><a class="header" href="#fn-generic-new">중단 가능성 있음: 새로운 함수 타입 매개변수 도입</a></h3>
<p>일반적으로 기본값이 없는 타입 매개변수를 추가하는 것은 안전하지만, 경우에 따라 중단 변경이 될 수 있습니다:</p>
<pre><code class="language-rust ignore">// 중단되는 변경 예시

///////////////////////////////////////////////////////////
// 변경 전
pub fn foo&lt;T&gt;() {}

///////////////////////////////////////////////////////////
// 변경 후
pub fn foo&lt;T, U&gt;() {}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::foo;

fn main() {
    foo::&lt;u8&gt;(); // 에러: 함수는 2개의 제네릭 인수를 받지만 1개의 제네릭 인수가 제공됨
}</code></pre>
<p>그러나 이러한 명시적 호출은 충분히 드물며(대개 다른 방식으로 작성할 수 있음), 이러한 중단은 보통 허용됩니다. 해당 함수가 명시적 타입 인수와 함께 호출될 가능성이 얼마나 되는지 고려해야 합니다.</p>
<h3 id="fn-generalize-compatible"><a class="header" href="#fn-generalize-compatible">마이너: 함수를 제네릭을 사용하도록 일반화 (원래 타입 지원)</a></h3>
<p>함수의 매개변수 타입 또는 반환 값은 원래 타입으로 인스턴스화될 수 있는 한, 새로운 타입 매개변수 도입을 포함하여 제네릭을 사용하도록 _일반화_될 수 있습니다. 예를 들어, 다음 변경은 허용됩니다:</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
pub fn foo(x: u8) -&gt; u8 {
    x
}
pub fn bar&lt;T: Iterator&lt;Item = u8&gt;&gt;(t: T) {}

///////////////////////////////////////////////////////////
// 변경 후
use std::ops::Add;
pub fn foo&lt;T: Add&gt;(x: T) -&gt; T {
    x
}
pub fn bar&lt;T: IntoIterator&lt;Item = u8&gt;&gt;(t: T) {}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
use updated_crate::{bar, foo};

fn main() {
    foo(1);
    bar(vec![1, 2, 3].into_iter());
}</code></pre>
<p>모든 기존 사용은 새 시그니처의 인스턴스화이기 때문입니다.</p>
<p>다소 놀랍게도, 모든 트레이트가 자기 자신을 구현한다는 점을 고려하면 일반화는 트레이트 객체에도 적용됩니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
pub trait Trait {}
pub fn foo(t: &amp;dyn Trait) {}

///////////////////////////////////////////////////////////
// 변경 후
pub trait Trait {}
pub fn foo&lt;T: Trait + ?Sized&gt;(t: &amp;T) {}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
use updated_crate::{foo, Trait};

struct Foo;
impl Trait for Foo {}

fn main() {
    let obj = Foo;
    foo(&amp;obj);
}</code></pre>
<p>(<code>?Sized</code>를 사용하는 것은 필수적입니다. 그렇지 않으면 원래의 시그니처를 복구할 수 없습니다.)</p>
<p>이런 방식으로 제네릭을 도입하면 잠재적으로 타입 추론 실패가 발생할 수 있습니다. 이는 보통 드문 경우이며, 추가적인 타입 어노테이션으로 해결할 수 있으므로 일부 프로젝트에서는 허용 가능한 중단일 수 있습니다.</p>
<pre><code class="language-rust ignore">// 중단되는 변경 예시

///////////////////////////////////////////////////////////
// 변경 전
pub fn foo() -&gt; i32 {
    0
}

///////////////////////////////////////////////////////////
// 변경 후
pub fn foo&lt;T: Default&gt;() -&gt; T {
    Default::default()
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::foo;

fn main() {
    let x = foo(); // 에러: 타입 어노테이션이 필요함
}</code></pre>
<h3 id="fn-generalize-mismatch"><a class="header" href="#fn-generalize-mismatch">메이저: 타입 불일치가 발생하는 제네릭을 사용하도록 함수 일반화</a></h3>
<p>제네릭 타입이 이전에 허용되었던 타입을 제한하거나 변경하는 경우 함수 매개변수나 반환 타입을 변경하는 것은 중단되는 변경(breaking change)입니다. 예를 들어, 다음은 기존 코드에서 충족되지 않을 수 있는 제네릭 제약 조건을 추가합니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub fn foo(x: Vec&lt;u8&gt;) {}

///////////////////////////////////////////////////////////
// 변경 후
pub fn foo&lt;T: Copy + IntoIterator&lt;Item = u8&gt;&gt;(x: T) {}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::foo;

fn main() {
    foo(vec![1, 2, 3]); // 에러: `Vec&lt;u8&gt;`에 `Copy`가 구현되지 않음
}</code></pre>
<h3 id="fn-unsafe-safe"><a class="header" href="#fn-unsafe-safe">마이너: <code>unsafe</code> 함수를 안전하게 만들기</a></h3>
<p>이전에 <code>unsafe</code>였던 함수는 코드를 중단시키지 않고 안전하게 만들 수 있습니다.</p>
<p>하지만 아래 예시와 같이 <a href="../../rustc/lints/listing/warn-by-default.html#unused-unsafe"><code>unused_unsafe</code></a> 린트가 트리거될 수 있으며, 이로 인해 <code>#![deny(warnings)]</code>를 지정한 로컬 크레이트의 컴파일이 중단될 수 있습니다. <a href="#new-lints">새로운 린트 도입</a>에 따라 업데이트 시 새로운 경고가 도입되는 것은 허용됩니다.</p>
<p>반대 방향(안전한 함수를 <code>unsafe</code>로 만들기)은 중단되는 변경입니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
pub unsafe fn foo() {}

///////////////////////////////////////////////////////////
// 변경 후
pub fn foo() {}

///////////////////////////////////////////////////////////
// 린트를 트리거하는 라이브러리 사용 예시
use updated_crate::foo;

unsafe fn bar(f: unsafe fn()) {
    f()
}

fn main() {
    unsafe { foo() }; // 여기서 `unused_unsafe` 린트가 트리거됩니다.
    unsafe { bar(foo) };
}</code></pre>
<p>구조체나 열거형의 이전에 <code>unsafe</code>였던 연관 함수나 메서드를 안전하게 만드는 것도 마이너 변경이지만, 트레이트의 연관 함수의 경우에는 해당되지 않습니다 (<a href="#trait-item-signature">트레이트 아이템 시그니처의 모든 변경</a> 참조).</p>
<h3 id="attr-no-std-to-std"><a class="header" href="#attr-no-std-to-std">메이저: <code>no_std</code> 지원에서 <code>std</code> 필요로 전환</a></h3>
<p>라이브러리가 특별히 <a href="../../reference/names/preludes.html#the-no_std-attribute"><code>no_std</code></a> 환경을 지원하는 경우, <code>std</code>를 필요로 하는 새 릴리스를 만드는 것은 중단되는 변경입니다.</p>
<pre><code class="language-rust ignore skip">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#![no_std]
pub fn foo() {}

///////////////////////////////////////////////////////////
// 변경 후
pub fn foo() {
    std::time::SystemTime::now();
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
// no_std 타겟에는 `std` 크레이트가 없기 때문에 링크에 실패합니다.
#![no_std]
use updated_crate::foo;

fn example() {
    foo();
}</code></pre>
<p>완화 전략:</p>
<ul>
<li>이를 피하기 위한 일반적인 관용구는 <code>std</code> 지원을 선택적으로 활성화하는 <code>std</code> <a href="features.html">Cargo 기능</a>을 포함하고, 해당 기능이 꺼져 있을 때 라이브러리를 <code>no_std</code> 환경에서 사용할 수 있도록 하는 것입니다.</li>
</ul>
<h3 id="attr-adding-non-exhaustive"><a class="header" href="#attr-adding-non-exhaustive">메이저: 비공개 필드가 없는 기존 열거형, 변형(variant) 또는 구조체에 <code>non_exhaustive</code> 추가</a></h3>
<p>아이템을 <a href="../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>로 만들면 해당 아이템이 정의된 크레이트 외부에서 사용되는 방식이 변경됩니다.</p>
<ul>
<li>Non-exhaustive 구조체 및 열거형 변형은 <a href="../../reference/expressions/struct-expr.html">구조체 리터럴</a> 구문( <a href="../../reference/expressions/struct-expr.html#functional-update-syntax">함수형 업데이트 구문</a> 포함)을 사용하여 생성할 수 없습니다.</li>
<li>Non-exhaustive 구조체에 대한 패턴 매칭에는 <code>..</code>이 필요하며, 열거형에 대한 매칭은 철저함(exhaustiveness)에 포함되지 않습니다.</li>
<li><code>as</code>를 사용하여 열거형 변형을 해당 판별자(discriminant)로 캐스팅하는 것은 허용되지 않습니다.</li>
</ul>
<p>비공개 필드가 있는 구조체는 <a href="../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a> 사용 여부와 관계없이 <a href="../../reference/expressions/struct-expr.html">구조체 리터럴</a> 구문을 사용하여 생성할 수 없습니다. 그러한 구조체에 <a href="../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>를 추가하는 것은 중단되는 변경이 아닙니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Foo {
    pub bar: usize,
}

pub enum Bar {
    X,
    Y(usize),
    Z { a: usize },
}

pub enum Quux {
    Var,
}

///////////////////////////////////////////////////////////
// 변경 후
#[non_exhaustive]
pub struct Foo {
    pub bar: usize,
}

pub enum Bar {
    #[non_exhaustive]
    X,

    #[non_exhaustive]
    Y(usize),

    #[non_exhaustive]
    Z { a: usize },
}

#[non_exhaustive]
pub enum Quux {
    Var,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::{Bar, Foo, Quux};

fn main() {
    let foo = Foo { bar: 0 }; // 에러: 구조체 식을 사용하여 non-exhaustive 구조체를 생성할 수 없음

    let bar_x = Bar::X; // 에러: 유닛 변형 `X`는 비공개임
    let bar_y = Bar::Y(0); // 에러: 튜플 변형 `Y`는 비공개임
    let bar_z = Bar::Z { a: 0 }; // 에러: 구조체 식을 사용하여 non-exhaustive 변형을 생성할 수 없음

    let q = Quux::Var;
    match q {
        Quux::Var =&gt; 0,
        // 에러: non-exhaustive 패턴: `_`가 포함되지 않음
    };
}</code></pre>
<p>완화 전략:</p>
<ul>
<li>구조체, 열거형 및 열거형 변형을 나중에 추가하기보다는 처음 도입할 때 <a href="../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>로 표시하세요.</li>
</ul>
<h2 id="도구-및-환경-호환성"><a class="header" href="#도구-및-환경-호환성">도구 및 환경 호환성</a></h2>
<h3 id="env-new-rust"><a class="header" href="#env-new-rust">중단 가능성 있음: 필요한 최소 Rust 버전 변경</a></h3>
<p>새로운 Rust 릴리스에서 새로운 기능을 사용하도록 도입하면 이전 버전의 Rust를 사용하는 프로젝트가 중단될 수 있습니다. 여기에는 새로운 Cargo 릴리스의 새로운 기능을 사용하는 것과, 이전에는 stable에서 작동하던 크레이트에서 nightly 전용 기능을 사용하도록 요구하는 것이 포함됩니다.</p>
<p><a href="https://github.com/rust-lang/api-guidelines/discussions/231">다양한 이유</a>로 인해 이를 메이저 변경보다는 마이너 변경으로 취급하는 것이 일반적으로 권장됩니다. 새로운 버전의 Rust로 업데이트하는 것은 보통 상대적으로 쉽습니다. Rust는 6주의 빠른 릴리스 주기를 가지고 있으며, 일부 프로젝트는 일정 범위 내의 릴리스(예: 현재 stable 릴리스 + 이전 N개의 릴리스) 내에서 호환성을 제공합니다. 다만 일부 대규모 프로젝트는 Rust 툴체인을 빠르게 업데이트하지 못할 수도 있다는 점을 유의하세요.</p>
<p>완화 전략:</p>
<ul>
<li>Document your package’s minimum-supported Rust version by setting <a href="rust-version.html"><code>package.rust-version</code></a>, allowing Cargo’s dependency resolution to attempt to <a href="resolver.html#rust-version">select older versions of your package</a> when needed. Be sure to consider the <a href="rust-version.html#support-expectations">support expectations</a> when doing so.</li>
<li><a href="features.html">Cargo 기능</a>을 사용하여 새로운 기능을 선택 사항(opt-in)으로 만드세요.</li>
<li>이전 릴리스에 대해 충분한 지원 범위를 제공하세요.</li>
<li>가능하다면 새로운 표준 라이브러리 아이템의 소스를 복사하여, 이전 버전을 계속 사용하면서도 새로운 기능을 활용할 수 있도록 하세요.</li>
<li>중요한 버그 수정을 백포트(backport)받을 수 있는 이전 마이너 릴리스를 위한 별도의 브랜치를 제공하세요.</li>
<li>새로운 기능에 대한 선택 메커니즘을 제공하는 <a href="https://github.com/rust-lang/rust/issues/64796"><code>[cfg(version(..))]</code></a> 및 <a href="https://github.com/rust-lang/rust/issues/64797"><code>#[cfg(accessible(..))]</code></a> 기능을 주시하세요. 이 기능들은 현재 불안정하며 nightly 채널에서만 사용할 수 있습니다.</li>
</ul>
<h3 id="env-change-requirements"><a class="header" href="#env-change-requirements">중단 가능성 있음: 플랫폼 및 환경 요구 사항 변경</a></h3>
<p>라이브러리는 호스트 플랫폼, 운영 체제 버전, 사용 가능한 서비스, 파일 시스템 지원 등 라이브러리가 실행되는 환경에 대해 매우 광범위한 가정을 합니다. 예를 들어 더 최신 버전의 운영 체제를 요구하는 등 이전에 지원되었던 것을 제한하는 새 릴리스를 만드는 것은 중단되는 변경이 될 수 있습니다. 이러한 변경 사항은 자동으로 테스트되지 않는 환경에서 변경이 중단되는지 여부를 항상 알 수 없기 때문에 추적하기 어려울 수 있습니다.</p>
<p>일부 프로젝트에서는 특히 대부분의 사용자에게 중단이 발생할 가능성이 낮거나 프로젝트에 모든 환경을 지원할 리소스가 없는 경우 이를 허용 가능한 중단으로 간주할 수 있습니다. 또 다른 주목할 만한 상황은 벤더가 특정 하드웨어나 OS에 대한 지원을 중단할 때, 프로젝트에서도 지원을 중단하는 것이 합리적이라고 판단할 수 있는 경우입니다.</p>
<p>완화 전략:</p>
<ul>
<li>특별히 지원하는 플랫폼과 환경을 문서화하세요.</li>
<li>CI에서 광범위한 환경에 대해 코드를 테스트하세요.</li>
</ul>
<h3 id="new-lints"><a class="header" href="#new-lints">마이너: 새로운 린트 도입</a></h3>
<p>라이브러리의 일부 변경으로 인해 해당 라이브러리 사용자에게 새로운 린트가 트리거될 수 있습니다. 이는 일반적으로 호환되는 변경으로 간주되어야 합니다.</p>
<pre><code class="language-rust ignore dont-deny">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
pub fn foo() {}

///////////////////////////////////////////////////////////
// 변경 후
#[deprecated]
pub fn foo() {}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.

fn main() {
    updated_crate::foo(); // 경고: 권장되지 않는(deprecated) 함수 사용
}</code></pre>
<p>사용자가 경고를 명시적으로 거부(deny)했고 업데이트된 크레이트가 직접적인 의존성인 경우, 이로 인해 기술적으로 프로젝트가 실패할 수 있음에 유의하세요. 경고를 거부하는 것은 시간이 지남에 따라 새로운 린트가 도입될 수 있음을 이해하고 주의 깊게 수행해야 합니다. 하지만 라이브러리 작성자 또한 새로운 경고를 도입하는 데 신중해야 하며 사용자에게 미칠 잠재적 영향을 고려해야 합니다.</p>
<p>다음 린트들은 의존성을 업데이트할 때 도입될 수 있는 예시들입니다.</p>
<ul>
<li><a href="../../rustc/lints/listing/warn-by-default.html#deprecated"><code>deprecated</code></a> — 사용 중인 아이템에 의존성이 <a href="../../reference/attributes/diagnostics.html#the-deprecated-attribute"><code>#[deprecated]</code> 속성</a>을 추가할 때 도입됩니다.</li>
<li><a href="../../rustc/lints/listing/warn-by-default.html#unused-must-use"><code>unused_must_use</code></a> — 결과를 사용하지 않는 아이템에 의존성이 <a href="../../reference/attributes/diagnostics.html#the-must_use-attribute"><code>#[must_use]</code> 속성</a>을 추가할 때 도입됩니다.</li>
<li><a href="../../rustc/lints/listing/warn-by-default.html#unused-unsafe"><code>unused_unsafe</code></a> — 의존성이 함수에서 <code>unsafe</code> 한정자를 _제거_하고, 그 함수가 unsafe 블록에서 호출되는 유일한 unsafe 함수일 때 도입됩니다.</li>
</ul>
<p>또한, <code>rustc</code>를 새 버전으로 업데이트하면 새로운 린트가 도입될 수 있습니다.</p>
<p>새로운 린트를 도입하는 전이적(transitive) 의존성은 보통 실패를 일으키지 않는데, 이는 Cargo가 <a href="../../rustc/lints/levels.html#capping-lints"><code>--cap-lints</code></a>를 사용하여 의존성의 모든 린트를 억제하기 때문입니다.</p>
<p>완화 전략:</p>
<ul>
<li>경고를 거부(deny)하도록 빌드하는 경우, 의존성을 업데이트할 때마다 새로운 경고를 해결해야 할 수도 있음을 이해해야 합니다. RUSTFLAGS를 사용하여 <code>-Dwarnings</code>를 전달하는 경우, <code>-Adeprecated</code>와 같이 문제를 일으킬 가능성이 높은 린트를 허용하기 위해 <code>-A</code> 플래그도 함께 추가하세요.</li>
<li>권장되지 않는(deprecation) 사항을 <a href="features.html">기능(feature)</a> 뒤에 도입하세요. 예를 들어 <code>#[cfg_attr(feature = "deprecated", deprecated="use bar instead")]</code>와 같이 작성합니다. 그런 다음 향후 SemVer 중단 변경 시 아이템을 제거할 계획이 있을 때, 사용자에게 권장되지 않는 아이템의 사용을 제거하기 위해 업데이트하기 <em>전에</em> <code>deprecated</code> 기능을 활성화해야 한다고 알릴 수 있습니다. 이를 통해 사용자는 즉시 대응할 필요 없이 언제 대응할지 선택할 수 있습니다. 단점은 메이저 업데이트를 준비하기 위해 이러한 수동 단계를 거쳐야 한다는 점을 사용자에게 전달하기 어려울 수 있다는 것입니다.</li>
</ul>
<h3 id="cargo"><a class="header" href="#cargo">Cargo</a></h3>
<h4 id="cargo-feature-add"><a class="header" href="#cargo-feature-add">마이너: 새로운 Cargo 기능 추가</a></h4>
<p>새로운 <a href="features.html">Cargo 기능</a>을 추가하는 것은 보통 안전합니다. 기능이 중단되는 변경을 일으키는 새로운 변화를 도입하는 경우, 엄격한 하위 호환성 요구 사항이 있는 프로젝트에 어려움을 줄 수 있습니다. 그런 시나리오에서는 해당 기능을 “default” 목록에 추가하는 것을 피하고, 기능을 활성화할 때의 결과를 문서화하는 것이 좋습니다.</p>
<pre><code class="language-toml"># MINOR CHANGE

###########################################################
# Before
[features]
# ..empty

###########################################################
# After
[features]
std = []
</code></pre>
<h4 id="cargo-feature-remove"><a class="header" href="#cargo-feature-remove">메이저: Cargo 기능 제거</a></h4>
<p><a href="features.html">Cargo 기능</a>을 제거하는 것은 보통 중단되는 변경입니다. 이는 해당 기능을 활성화한 모든 프로젝트에서 오류를 일으킵니다.</p>
<pre><code class="language-toml"># MAJOR CHANGE

###########################################################
# Before
[features]
logging = []

###########################################################
# After
[dependencies]
# ..logging removed
</code></pre>
<p>완화 전략:</p>
<ul>
<li>기능을 명확하게 문서화하세요. 내부용이거나 실험적인 기능이 있다면 그렇게 표시하여 사용자가 해당 기능의 상태를 알 수 있도록 하세요.</li>
<li><code>Cargo.toml</code>에 기존 기능을 남겨두되, 기능 자체는 제거하세요. 해당 기능이 권장되지 않음(deprecated)을 문서화하고, 향후 메이저 SemVer 릴리스에서 제거하세요.</li>
</ul>
<h4 id="cargo-feature-remove-another"><a class="header" href="#cargo-feature-remove-another">메이저: 기능이나 공개 아이템을 변경하는 경우 기능 목록에서 기능 제거</a></h4>
<p>다른 기능에서 특정 기능을 제거하는 경우, 해당 기능을 통해 그 기능이 제공될 것으로 기대하는 기존 사용자들에게는 중단될 수 있습니다.</p>
<pre><code class="language-toml"># 중단되는 변경 예시

###########################################################
# 변경 전
[features]
default = ["std"]
std = []

###########################################################
# 변경 후
[features]
default = []  # std가 활성화될 것으로 기대하는 패키지에서 실패가 발생할 수 있습니다.
std = []
</code></pre>
<h4 id="cargo-remove-opt-dep"><a class="header" href="#cargo-remove-opt-dep">중단 가능성 있음: 선택적 의존성 제거</a></h4>
<p><a href="features.html#optional-dependencies">선택적 의존성(optional dependency)</a>을 제거하는 것은 귀하의 라이브러리를 사용하는 프로젝트를 중단시킬 수 있습니다. 다른 프로젝트에서 <a href="features.html">Cargo 기능</a>을 통해 해당 의존성을 활성화하고 있을 수 있기 때문입니다.</p>
<p>선택적 의존성이 있을 때, Cargo는 의존성을 활성화하고 활성화 여부를 확인하는 메커니즘을 제공하기 위해 동일한 이름의 기능을 암시적으로 정의합니다. 이 문제는 <code>[features]</code> 표에서 <code>dep:</code> 구문을 사용하여 해당 암시적 기능을 비활성화함으로써 피할 수 있습니다. <code>dep:</code>를 사용하면 선택적 의존성의 존재를 보다 의미 있는 이름 아래에 숨길 수 있으며, 이를 통해 보다 안전하게 수정할 수 있습니다.</p>
<pre><code class="language-toml"># 중단되는 변경 예시

###########################################################
# 변경 전
[dependencies]
curl = { version = "0.4.31", optional = true }

###########################################################
# 변경 후
[dependencies]
# ..curl 제거됨
</code></pre>
<pre><code class="language-toml"># 마이너 변경
#
# 이 예제는 선택적 의존성을 사용하여 중단되는 변경을 피하는 방법을 보여줍니다.

###########################################################
# 변경 전
[dependencies]
curl = { version = "0.4.31", optional = true }

[features]
networking = ["dep:curl"]

###########################################################
# 변경 후
[dependencies]
# 여기서 하나의 선택적 의존성이 다른 것으로 교체되었습니다.
hyper = { version = "0.14.27", optional = true }

[features]
networking = ["dep:hyper"]
</code></pre>
<p>완화 전략:</p>
<ul>
<li>애초에 선택적 의존성이 노출되지 않도록 <code>[features]</code> 표에서 <code>dep:</code> 구문을 사용하세요. 자세한 내용은 <a href="features.html#optional-dependencies">선택적 의존성</a>을 참조하세요.</li>
<li>기능을 명확하게 문서화하세요. 선택적 의존성이 문서화된 기능 목록에 포함되어 있지 않다면, 문서화되지 않은 항목을 변경하는 것은 안전하다고 판단할 수 있습니다.</li>
<li>선택적 의존성을 그대로 두고, 라이브러리 내에서 사용하지 마세요.</li>
<li>선택적 의존성을 아무 작업도 하지 않는 <a href="features.html">Cargo 기능</a>으로 교체하고, 해당 기능이 권장되지 않음(deprecated)을 문서화하세요.</li>
<li>선택적 의존성을 활성화하는 고수준 기능을 사용하고, 이를 확장 기능을 활성화하는 권장되는 방법으로 문서화하세요. 예를 들어, 귀하의 라이브러리에 “네트워킹“과 같은 것에 대한 선택적 지원이 있는 경우, “네트워킹” 구현에 필요한 선택적 의존성을 활성화하는 일반적인 기능 이름인 “networking“을 만드세요. 그런 다음 “networking” 기능을 문서화합니다.</li>
</ul>
<h4 id="cargo-change-dep-feature"><a class="header" href="#cargo-change-dep-feature">마이너: 의존성 기능 변경</a></h4>
<p>기능이 중단되는 변경을 도입하지 않는 한, 의존성의 기능을 변경하는 것은 보통 안전합니다.</p>
<pre><code class="language-toml"># 마이너 변경

###########################################################
# 변경 전
[dependencies]
rand = { version = "0.7.3", features = ["small_rng"] }


###########################################################
# 변경 후
[dependencies]
rand = "0.7.3"
</code></pre>
<h4 id="cargo-dep-add"><a class="header" href="#cargo-dep-add">마이너: 의존성 추가</a></h4>
<p>새로운 의존성이 중단되는 변경을 초래하는 새로운 요구 사항을 도입하지 않는 한, 새로운 의존성을 추가하는 것은 보통 안전합니다. 예를 들어, 이전에 stable에서 작동하던 프로젝트에 nightly를 요구하는 새로운 의존성을 추가하는 것은 메이저 변경입니다.</p>
<pre><code class="language-toml"># 마이너 변경

###########################################################
# 변경 전
[dependencies]
# ..비어 있음

###########################################################
# 변경 후
[dependencies]
log = "0.4.11"
</code></pre>
<h2 id="애플리케이션-호환성"><a class="header" href="#애플리케이션-호환성">애플리케이션 호환성</a></h2>
<p>Cargo 프로젝트에는 고유한 인터페이스(예: CLI 인터페이스, OS 수준 상호작용 등)를 가진 실행 파일 바이너리도 포함될 수 있습니다. 이러한 바이너리는 Cargo 패키지의 일부이므로 패키지와 동일한 버전을 사용하고 공유하는 경우가 많습니다. 귀하의 애플리케이션을 변경할 때 사용자에게 SemVer 계약을 어떻게 적용할지 결정해야 합니다. 애플리케이션에서 발생할 수 있는 중단 및 호환 변경 사항은 너무 많아서 일일이 열거할 수 없으므로, <a href="https://semver.org/">SemVer</a> 명세의 정신을 활용하여 애플리케이션에 버전을 적용하는 방법을 결정하거나, 최소한 귀하의 약속이 무엇인지 문서화하는 것이 좋습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../reference/registry-web-api.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../reference/future-incompat-report.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../reference/registry-web-api.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../reference/future-incompat-report.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
