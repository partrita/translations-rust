<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>빌드 스크립트 - The Cargo Book</title>


        <!-- Custom HTML head -->
        <style>
            dd {
                margin-bottom: 1em;
            }
        </style>
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/cargo";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/reference/build-scripts.md`;
                    } else {
                        canonical_href = `${base}/${lang}/reference/build-scripts.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/cargo.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cargo Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/cargo/edit/master/src/doc/src/reference/build-scripts.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="빌드-스크립트"><a class="header" href="#빌드-스크립트">빌드 스크립트</a></h1>
<p>일부 패키지는 C 라이브러리와 같은 제3자 비 Rust 코드를 컴파일해야 할 필요가 있습니다. 어떤 패키지는 시스템에 있거나 소스에서 직접 빌드해야 하는 C 라이브러리에 링크해야 할 수도 있습니다. 또 어떤 패키지는 빌드 전 코드 생성(예: 파서 생성기)과 같은 기능이 필요할 수 있습니다.</p>
<p>Cargo의 목표는 이러한 작업에 최적화된 다른 도구들을 대체하는 것이 아니라, 사용자 정의 빌드 스크립트를 통해 해당 도구들과 통합하는 것입니다. 패키지 루트에 <code>build.rs</code> 라는 이름의 파일을 두면, Cargo는 해당 스크립트를 컴파일하고 패키지를 빌드하기 직전에 이를 실행합니다.</p>
<pre><code class="language-rust ignore">// 사용자 정의 빌드 스크립트 예제
fn main() {
    // 지정된 파일이 변경되면 이 빌드 스크립트를 다시 실행하도록 Cargo에 알립니다.
    println!("cargo::rerun-if-changed=src/hello.c");
    // `cc` 크레이트를 사용하여 C 파일을 빌드하고 정적으로 링크합니다.
    cc::Build::new()
        .file("src/hello.c")
        .compile("hello");
}</code></pre>
<p>빌드 스크립트의 몇 가지 사용 예는 다음과 같습니다.</p>
<ul>
<li>번들된 C 라이브러리 빌드.</li>
<li>호스트 시스템에서 C 라이브러리 찾기.</li>
<li>명세(specification)로부터 Rust 모듈 생성.</li>
<li>크레이트에 필요한 플랫폼별 설정 수행.</li>
</ul>
<p>아래 섹션들에서는 빌드 스크립트의 작동 방식을 설명하며, <a href="build-script-examples.html">예제 장</a> 에서는 스크립트 작성 방법에 대한 다양한 예제를 보여줍니다.</p>
<blockquote>
<p>참고: <a href="manifest.html#the-build-field"><code>package.build</code> 매니페스트 키</a> 를 사용하여 빌드 스크립트의 이름을 변경하거나 완전히 비활성화할 수 있습니다.</p>
</blockquote>
<h2 id="빌드-스크립트의-생명-주기"><a class="header" href="#빌드-스크립트의-생명-주기">빌드 스크립트의 생명 주기</a></h2>
<p>패키지가 빌드되기 직전에 Cargo는 빌드 스크립트를 실행 파일로 컴파일합니다 (이미 빌드되어 있지 않은 경우). 그 후 스크립트를 실행하며, 스크립트는 임의의 작업을 수행할 수 있습니다. 스크립트는 <code>cargo::</code> 접두사가 붙은 특수한 형식의 명령을 표준 출력(stdout)으로 출력하여 Cargo와 통신할 수 있습니다.</p>
<p>빌드 스크립트의 소스 파일이나 의존성이 변경되면 빌드 스크립트가 다시 빌드됩니다.</p>
<p>기본적으로 Cargo는 패키지의 파일 중 하나라도 변경되면 빌드 스크립트를 다시 실행합니다. 일반적으로 아래의 <a href="#change-detection">변경 감지(#change-detection)</a> 섹션에 설명된 <code>rerun-if</code> 명령을 사용하여 빌드 스크립트 재실행을 트리거하는 대상을 좁히는 것이 가장 좋습니다.</p>
<p>빌드 스크립트가 성공적으로 실행을 마치면 패키지의 나머지 부분이 컴파일됩니다. 오류가 발생한 경우 스크립트는 0이 아닌 종료 코드를 반환하여 빌드를 중단해야 하며, 이 경우 빌드 스크립트의 출력이 터미널에 표시됩니다.</p>
<h2 id="빌드-스크립트의-입력"><a class="header" href="#빌드-스크립트의-입력">빌드 스크립트의 입력</a></h2>
<p>빌드 스크립트가 실행될 때 여러 입력이 제공되며, 이들은 모두 <a href="environment-variables.html#environment-variables-cargo-sets-for-build-scripts">환경 변수</a> 형태로 전달됩니다.</p>
<p>환경 변수 외에도, 빌드 스크립트의 현재 디렉토리는 해당 빌드 스크립트가 속한 패키지의 소스 디렉토리입니다.</p>
<h2 id="빌드-스크립트의-출력"><a class="header" href="#빌드-스크립트의-출력">빌드 스크립트의 출력</a></h2>
<p>빌드 스크립트는 모든 결과물 파일이나 중간 산출물을 <a href="environment-variables.html#environment-variables-cargo-sets-for-build-scripts"><code>OUT_DIR</code> 환경 변수</a> 에 지정된 디렉토리에 저장할 수 있습니다. 스크립트는 해당 디렉토리 외부의 어떤 파일도 수정해서는 안 됩니다.</p>
<blockquote>
<p><strong>Note:</strong> Cargo does not clean or reset <code>OUT_DIR</code> between builds. The contents of this directory may persist across rebuilds, even if the build script is re-run. This behavior is intentional to support incremental builds, such as native code compilation.</p>
<p>Build scripts should not rely on <code>OUT_DIR</code> being empty, as its contents may persist across rebuilds. If a script requires a clean directory, it is currently responsible for managing or cleaning up any files or subdirectories it creates. Future improvements in this area are being discussed (see <a href="https://github.com/rust-lang/cargo/issues/16427">#16427</a> and <a href="https://github.com/rust-lang/cargo/issues/9661">#9661</a>).</p>
</blockquote>
<p>빌드 스크립트는 표준 출력(stdout)에 내용을 인쇄하여 Cargo와 통신합니다. Cargo는 <code>cargo::</code> 로 시작하는 각 줄을 패키지 컴파일에 영향을 주는 지시문으로 해석합니다. 그 외의 모든 줄은 무시됩니다.</p>
<blockquote>
<p>빌드 스크립트에서 출력되는 <code>cargo::</code> 지시문의 순서는 <code>cargo</code> 가 <code>rustc</code> 에 전달하는 인수의 순서에 영향을 줄 <em>수도</em> 있습니다. 결과적으로 <code>rustc</code> 에 전달되는 인수의 순서는 링커에 전달되는 인수의 순서에 영향을 줄 수 있습니다. 따라서 빌드 스크립트 지시문의 순서에 주의를 기울여야 합니다. 예를 들어, 객체 <code>foo</code> 가 라이브러리 <code>bar</code> 에 링크되어야 한다면, 라이브러리 <code>bar</code> 를 위한 <a href="#rustc-link-lib"><code>cargo::rustc-link-lib</code></a> 지시문이 객체 <code>foo</code> 를 링크하는 지시문 <em>뒤</em> 에 나타나도록 해야 할 수도 있습니다.</p>
</blockquote>
<p>스크립트의 출력은 일반적인 컴파일 도중에는 터미널에 표시되지 않습니다. 터미널에서 출력을 직접 보고 싶다면 <code>-vv</code> 플래그를 사용하여 Cargo를 “매우 상세(very verbose)” 모드로 실행하세요. 이는 빌드 스크립트가 실제로 실행될 때만 발생합니다. Cargo가 변경 사항이 없다고 판단하여 스크립트를 다시 실행하지 않는 경우에는 출력되지 않습니다. 자세한 내용은 아래의 <a href="#change-detection">변경 감지(#change-detection)</a> 를 참조하세요.</p>
<p>빌드 스크립트가 표준 출력으로 내보낸 모든 줄은 <code>target/debug/build/&lt;pkg&gt;/output</code> 과 같은 파일에 기록됩니다 (정확한 위치는 설정에 따라 다를 수 있습니다). 표준 에러(stderr) 출력도 같은 디렉토리에 저장됩니다.</p>
<p>다음은 Cargo가 인식하는 지시문들의 요약이며, 각 지시문에 대한 자세한 설명은 아래에 나와 있습니다.</p>
<ul>
<li>
<p><a href="#rerun-if-changed"><code>cargo::rerun-if-changed=PATH</code></a> — 언제 스크립트를 다시 실행할지 Cargo에 알립니다.</p>
</li>
<li>
<p><a href="#rerun-if-env-changed"><code>cargo::rerun-if-env-changed=VAR</code></a> — 언제 스크립트를 다시 실행할지 Cargo에 알립니다.</p>
</li>
<li>
<p><a href="#rustc-link-arg"><code>cargo::rustc-link-arg=FLAG</code></a> — 벤치마크, 바이너리, <code>cdylib</code> 크레이트, 예제 및 테스트를 위해 링커에 사용자 정의 플래그를 전달합니다.</p>
</li>
<li>
<p><a href="#rustc-cdylib-link-arg"><code>cargo::rustc-link-arg-cdylib=FLAG</code></a> — Passes custom flags to a linker for cdylib crates.</p>
</li>
<li>
<p><a href="#rustc-link-arg-bin"><code>cargo::rustc-link-arg-bin=BIN=FLAG</code></a> — 바이너리 <code>BIN</code> 을 위해 링커에 사용자 정의 플래그를 전달합니다.</p>
</li>
<li>
<p><a href="#rustc-link-arg-bins"><code>cargo::rustc-link-arg-bins=FLAG</code></a> — 바이너리들을 위해 링커에 사용자 정의 플래그를 전달합니다.</p>
</li>
<li>
<p><a href="#rustc-link-arg-tests"><code>cargo::rustc-link-arg-tests=FLAG</code></a> — 테스트들을 위해 링커에 사용자 정의 플래그를 전달합니다.</p>
</li>
<li>
<p><a href="#rustc-link-arg-examples"><code>cargo::rustc-link-arg-examples=FLAG</code></a> — 예제들을 위해 링커에 사용자 정의 플래그를 전달합니다.</p>
</li>
<li>
<p><a href="#rustc-link-arg-benches"><code>cargo::rustc-link-arg-benches=FLAG</code></a> — 벤치마크들을 위해 링커에 사용자 정의 플래그를 전달합니다.</p>
</li>
<li>
<p><a href="#rustc-link-lib"><code>cargo::rustc-link-lib=LIB</code></a> — 링크할 라이브러리를 추가합니다.</p>
</li>
<li>
<p><a href="#rustc-link-search"><code>cargo::rustc-link-search=[KIND=]PATH</code></a> — 라이브러리 검색 경로를 추가합니다.</p>
</li>
<li>
<p><a href="#rustc-flags"><code>cargo::rustc-flags=FLAGS</code></a> — 컴파일러에 특정 플래그를 전달합니다.</p>
</li>
<li>
<p><a href="#rustc-cfg"><code>cargo::rustc-cfg=KEY[="VALUE"]</code></a> — 컴파일 타임 <code>cfg</code> 설정을 활성화합니다.</p>
</li>
<li>
<p><a href="#rustc-check-cfg"><code>cargo::rustc-check-cfg=CHECK_CFG</code></a> – 컴파일 타임 설정 확인을 위해 예상되는 사용자 정의 <code>cfg</code> 들을 등록합니다.</p>
</li>
<li>
<p><a href="#rustc-env"><code>cargo::rustc-env=VAR=VALUE</code></a> — 환경 변수를 설정합니다.</p>
</li>
<li>
<p><a href="#cargo-error"><code>cargo::error=MESSAGE</code></a> — 터미널에 오류 메시지를 표시합니다.</p>
</li>
<li>
<p><a href="#cargo-warning"><code>cargo::warning=MESSAGE</code></a> — 터미널에 경고 메시지를 표시합니다.</p>
</li>
<li>
<p><a href="#the-links-manifest-key"><code>cargo::metadata=KEY=VALUE</code></a> — <code>links</code> 스크립트에서 사용되는 메타데이터입니다.</p>
</li>
</ul>
<blockquote>
<p><strong>MSRV:</strong> <code>cargo::KEY=VALUE</code> 구문에는 1.77 버전이 필요합니다. 이전 버전을 지원하려면 <code>cargo:KEY=VALUE</code> 구문을 사용하세요.</p>
</blockquote>
<h3 id="rustc-link-arg"><a class="header" href="#rustc-link-arg"><code>cargo::rustc-link-arg=FLAG</code></a></h3>
<p><code>rustc-link-arg</code> 지시문은 지원되는 타겟(벤치마크, 바이너리, <code>cdylib</code> 크레이트, 예제 및 테스트)을 빌드할 때만 컴파일러에 <a href="../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> 옵션</a> 을 전달하도록 Cargo에 알립니다. 이 지시문의 사용은 플랫폼에 따라 매우 다르며, 공유 라이브러리 버전이나 링커 스크립트를 설정할 때 유용합니다.</p>
<h3 id="rustc-cdylib-link-arg"><a class="header" href="#rustc-cdylib-link-arg"><code>cargo::rustc-link-arg-cdylib=FLAG</code></a></h3>
<p>The <code>rustc-link-arg-cdylib</code> instruction tells Cargo to pass the <a href="../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> to the compiler, but only when building a <code>cdylib</code> library target. Its usage is highly platform specific. It is useful to set the shared library version or the runtime-path.</p>
<p>For historical reasons, the <code>cargo::rustc-cdylib-link-arg</code> form is an alias for <code>cargo::rustc-link-arg-cdylib</code>, and has the same meaning.</p>
<h3 id="rustc-link-arg-bin"><a class="header" href="#rustc-link-arg-bin"><code>cargo::rustc-link-arg-bin=BIN=FLAG</code></a></h3>
<p><code>rustc-link-arg-bin</code> 지시문은 이름이 <code>BIN</code> 인 바이너리 타겟을 빌드할 때만 컴파일러에 <a href="../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> 옵션</a> 을 전달하도록 Cargo에 알립니다. 이 지시문의 사용은 플랫폼에 따라 매우 다르며, 링커 스크립트나 기타 링커 옵션을 설정할 때 유용합니다.</p>
<h3 id="rustc-link-arg-bins"><a class="header" href="#rustc-link-arg-bins"><code>cargo::rustc-link-arg-bins=FLAG</code></a></h3>
<p><code>rustc-link-arg-bins</code> 지시문은 바이너리 타겟을 빌드할 때만 컴파일러에 <a href="../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> 옵션</a> 을 전달하도록 Cargo에 알립니다. 이 지시문의 사용은 플랫폼에 따라 매우 다르며, 링커 스크립트나 기타 링커 옵션을 설정할 때 유용합니다.</p>
<h3 id="rustc-link-arg-tests"><a class="header" href="#rustc-link-arg-tests"><code>cargo::rustc-link-arg-tests=FLAG</code></a></h3>
<p><code>rustc-link-arg-tests</code> 지시문은 테스트 타겟을 빌드할 때만 컴파일러에 <a href="../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> 옵션</a> 을 전달하도록 Cargo에 알립니다.</p>
<h3 id="rustc-link-arg-examples"><a class="header" href="#rustc-link-arg-examples"><code>cargo::rustc-link-arg-examples=FLAG</code></a></h3>
<p><code>rustc-link-arg-examples</code> 지시문은 예제 타겟을 빌드할 때만 컴파일러에 <a href="../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> 옵션</a> 을 전달하도록 Cargo에 알립니다.</p>
<h3 id="rustc-link-arg-benches"><a class="header" href="#rustc-link-arg-benches"><code>cargo::rustc-link-arg-benches=FLAG</code></a></h3>
<p><code>rustc-link-arg-benches</code> 지시문은 벤치마크 타겟을 빌드할 때만 컴파일러에 <a href="../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> 옵션</a> 을 전달하도록 Cargo에 알립니다.</p>
<h3 id="rustc-link-lib"><a class="header" href="#rustc-link-lib"><code>cargo::rustc-link-lib=LIB</code></a></h3>
<p><code>rustc-link-lib</code> 지시문은 컴파일러의 <a href="../../rustc/command-line-arguments.html#option-l-link-lib"><code>-l</code> 플래그</a> 를 사용하여 지정된 라이브러리를 링크하도록 Cargo에 알립니다. 이는 일반적으로 <a href="../../nomicon/ffi.html">FFI</a> 를 사용하여 네이티브 라이브러리를 링크할 때 사용됩니다.</p>
<p><code>LIB</code> 문자열은 rustc에 직접 전달되므로 <code>-l</code> 이 지원하는 모든 구문을 지원합니다. 현재 <code>LIB</code> 에 대해 완전히 지원되는 구문은 <code>[KIND[:MODIFIERS]=]NAME[:RENAME]</code> 입니다.</p>
<p>패키지에 라이브러리 타겟이 있는 경우 <code>-l</code> 플래그는 해당 라이브러리 타겟에만 전달되며, 라이브러리 타겟이 없는 경우에만 모든 타겟에 전달됩니다. 이는 다른 모든 타겟이 라이브러리 타겟에 암시적으로 의존하고 있으며, 링크할 라이브러리는 한 번만 포함되어야 하기 때문입니다. 즉, 패키지에 라이브러리와 바이너리 타겟이 모두 있는 경우, <em>라이브러리</em> 는 해당 lib의 심볼에 접근할 수 있고, 바이너리는 라이브러리 타겟의 공개 API를 통해 접근해야 합니다.</p>
<p>선택적 요소인 <code>KIND</code> 는 <code>dylib</code>, <code>static</code>, <code>framework</code> 중 하나일 수 있습니다. 자세한 내용은 <a href="../../rustc/command-line-arguments.html#option-l-link-lib">rustc 북</a> 을 참조하세요.</p>
<h3 id="rustc-link-search"><a class="header" href="#rustc-link-search"><code>cargo::rustc-link-search=[KIND=]PATH</code></a></h3>
<p><code>rustc-link-search</code> 지시문은 컴파일러에 <a href="../../rustc/command-line-arguments.html#option-l-search-path"><code>-L</code> 플래그</a> 를 전달하여 라이브러리 검색 경로에 디렉토리를 추가하도록 Cargo에 알립니다.</p>
<p>선택적 요소인 <code>KIND</code> 는 <code>dependency</code>, <code>crate</code>, <code>native</code>, <code>framework</code>, <code>all</code> 중 하나일 수 있습니다. 자세한 내용은 <a href="../../rustc/command-line-arguments.html#option-l-search-path">rustc 북</a> 을 참조하세요.</p>
<p>이 경로들이 <code>OUT_DIR</code> 내에 있는 경우 <a href="environment-variables.html#dynamic-library-paths">동적 라이브러리 검색 경로 환경 변수</a> 에도 추가됩니다. 이러한 동작에 의존하는 것은 결과 바이너리 사용을 어렵게 만들 수 있으므로 권장되지 않습니다. 일반적으로 빌드 스크립트에서 동적 라이브러리를 생성하는 것은 피하는 것이 좋으며, 기존 시스템 라이브러리를 사용하는 것은 괜찮습니다.</p>
<h3 id="rustc-flags"><a class="header" href="#rustc-flags"><code>cargo::rustc-flags=FLAGS</code></a></h3>
<p><code>rustc-flags</code> 지시문은 지정된 공백으로 구분된 플래그들을 컴파일러에 전달하도록 Cargo에 알립니다. 이 지시문은 <code>-l</code> 및 <code>-L</code> 플래그만 허용하며, <a href="#rustc-link-lib"><code>rustc-link-lib</code></a> 및 <a href="#rustc-link-search"><code>rustc-link-search</code></a> 를 사용하는 것과 동일합니다.</p>
<h3 id="rustc-cfg"><a class="header" href="#rustc-cfg"><code>cargo::rustc-cfg=KEY[="VALUE"]</code></a></h3>
<p><code>rustc-cfg</code> 지시문은 컴파일러의 <a href="../../rustc/command-line-arguments.html#option-cfg"><code>--cfg</code> 플래그</a> 에 지정된 값을 전달하도록 Cargo에 알립니다. 이는 <a href="../../reference/conditional-compilation.html">조건부 컴파일</a> 을 활성화하기 위해 컴파일 타임에 기능을 감지하는 데 사용될 수 있습니다. 사용자 정의 cfg는 <a href="#rustc-check-cfg"><code>cargo::rustc-check-cfg</code></a> 지시문을 사용하여 예상되는 값으로 등록하거나, 예기치 않은 cfg 경고를 피하기 위해 <a href="../../rustc/lints/listing/warn-by-default.html#unexpected-cfgs"><code>unexpected_cfgs</code></a> 린트(lint)를 허용해야 합니다.</p>
<p>이는 Cargo의 의존성 해결(dependency resolution)에는 영향을 주지 <em>않음</em> 에 유의하세요. 이를 통해 선택적 의존성이나 다른 Cargo 기능을 활성화할 수는 없습니다.</p>
<p><a href="features.html">Cargo 기능(features)</a> 은 <code>feature="foo"</code> 형식을 사용한다는 점에 유의하세요. 이 플래그와 함께 전달되는 <code>cfg</code> 값은 해당 형식으로 제한되지 않으며, 단일 식별자나 임의의 키/값 쌍을 제공할 수 있습니다. 예를 들어 <code>cargo::rustc-cfg=abc</code> 를 출력하면 코드에서 <code>#[cfg(abc)]</code> 를 사용할 수 있게 됩니다 (<code>feature=</code> 가 없음에 주의). 또는 <code>cargo::rustc-cfg=my_component="foo"</code> 와 같이 <code>=</code> 기호를 사용하여 임의의 키/값 쌍을 사용할 수 있습니다. 키는 Rust 식별자여야 하고, 값은 문자열이어야 합니다.</p>
<h3 id="rustc-check-cfg"><a class="header" href="#rustc-check-cfg"><code>cargo::rustc-check-cfg=CHECK_CFG</code></a></h3>
<p><a href="../../rustc/lints/listing/warn-by-default.html#unexpected-cfgs"><code>unexpected_cfgs</code></a> 린트를 사용하여 <em>도달 가능한</em> cfg 식을 확인할 때 사용할 예상 설정 이름 및 값 목록에 추가합니다.</p>
<p><code>CHECK_CFG</code> 의 구문은 <code>rustc</code> 의 <a href="../../rustc/command-line-arguments.html#option-check-cfg"><code>--check-cfg</code> 플래그</a> 와 동일합니다. 자세한 내용은 <a href="../../rustc/check-cfg.html">조건부 설정 확인</a> 을 참조하세요.</p>
<p>이 지시문은 다음과 같이 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// build.rs
println!("cargo::rustc-check-cfg=cfg(foo, values(\"bar\"))");
if foo_bar_condition {
    println!("cargo::rustc-cfg=foo=\"bar\"");
}
<span class="boring">}</span></code></pre></pre>
<p>현재 활성화된 cfg가 무엇인지와 관계없이 가능한 모든 cfg를 정의해야 한다는 점에 유의하세요. 여기에는 지정된 cfg 이름의 가능한 모든 값이 포함됩니다.</p>
<p>오타, 누락된 check-cfg, 오래된 cfg 등을 방지하기 위해 <code>cargo::rustc-check-cfg</code> 와 <a href="../../rustc/command-line-arguments.html#option-cfg"><code>cargo::rustc-cfg</code></a> 지시문을 가능한 한 가깝게 그룹화하는 것이 권장됩니다.</p>
<p><a href="build-script-examples.html#conditional-compilation">조건부 컴파일</a> 예제도 참조하세요.</p>
<blockquote>
<p><strong>MSRV:</strong> 1.80 버전부터 적용됩니다.</p>
</blockquote>
<h3 id="rustc-env"><a class="header" href="#rustc-env"><code>cargo::rustc-env=VAR=VALUE</code></a></h3>
<p><code>rustc-env</code> 지시문은 패키지 컴파일 시 지정된 환경 변수를 설정하도록 Cargo에 알립니다. 설정된 값은 컴파일된 크레이트 내에서 <a href="../../std/macro.env.html"><code>env!</code> 매크로</a> 를 통해 가져올 수 있습니다. 이는 git HEAD의 해시값이나 지속적 통합(CI) 서버의 고유 식별자와 같은 추가 메타데이터를 크레이트 코드에 삽입할 때 유용합니다.</p>
<p><a href="environment-variables.html#environment-variables-cargo-sets-for-crates">Cargo에 의해 자동으로 포함되는 환경 변수</a> 도 참조하세요.</p>
<blockquote>
<p><strong>참고</strong>: 이러한 환경 변수들은 <code>cargo run</code> 이나 <code>cargo test</code> 로 실행 파일을 실행할 때도 설정됩니다. 하지만 이는 실행 파일을 Cargo의 실행 환경에 종속시키므로 권장되지 않습니다. 일반적으로 이러한 환경 변수들은 <code>env!</code> 매크로를 사용하여 컴파일 타임에만 확인해야 합니다.</p>
</blockquote>
<h3 id="cargo-error"><a class="header" href="#cargo-error"><code>cargo::error=MESSAGE</code></a></h3>
<p><code>error</code> 지시문은 빌드 스크립트 실행이 끝난 후 오류를 표시하고 빌드를 실패시키도록 Cargo에 알립니다.</p>
<blockquote>
<p>참고: 빌드 스크립트 라이브러리는 <code>cargo::error</code> 를 직접 사용할지 아니면 <code>Result</code> 를 반환할지 신중히 고려해야 합니다. <code>Result</code> 를 반환하여 호출자가 해당 오류가 치명적인지 여부를 결정하게 하는 것이 더 나을 수 있습니다. 그 후 호출자는 <code>cargo::error</code> 를 사용하여 해당 오류를 표시할지 말지를 결정할 수 있습니다.</p>
</blockquote>
<blockquote>
<p><strong>MSRV:</strong> 1.84 버전부터 적용됩니다.</p>
</blockquote>
<h3 id="cargo-warning"><a class="header" href="#cargo-warning"><code>cargo::warning=MESSAGE</code></a></h3>
<p>The <code>warning</code> instruction tells Cargo to display a warning after the build script has finished running. Warnings are only shown for <code>path</code> dependencies (that is, those you’re working on locally), so for example warnings printed out in <a href="https://crates.io/">crates.io</a> crates are not emitted by default, unless the build fails. The <code>-vv</code> “very verbose” flag may be used to have Cargo display warnings for all crates.</p>
<h2 id="빌드-의존성"><a class="header" href="#빌드-의존성">빌드 의존성</a></h2>
<p>빌드 스크립트도 다른 Cargo 기반 크레이트에 의존성을 가질 수 있습니다. 의존성은 매니페스트의 <code>build-dependencies</code> 섹션을 통해 선언됩니다.</p>
<pre><code class="language-toml">[build-dependencies]
cc = "1.0.46"
</code></pre>
<p>빌드 스크립트는 <code>dependencies</code> 또는 <code>dev-dependencies</code> 섹션에 나열된 의존성에 접근할 수 없습니다 (아직 빌드되지 않았기 때문입니다!). 또한, 빌드 의존성은 <code>[dependencies]</code> 테이블에 명시적으로 추가되지 않는 한 패키지 자체에서 사용할 수 없습니다.</p>
<p>컴파일 시간, 라이선스, 유지 관리 등에 미치는 영향을 고려하여 각 의존성을 신중하게 선택하는 것이 좋습니다. Cargo는 빌드 의존성과 일반 의존성 간에 공유되는 의존성이 있으면 재사용을 시도합니다. 그러나 교차 컴파일(cross-compiling) 시와 같이 항상 가능한 것은 아니므로 컴파일 시간에 미치는 영향을 고려해야 합니다.</p>
<h2 id="변경-감지"><a class="header" href="#변경-감지">변경 감지</a></h2>
<p>패키지를 다시 빌드할 때, Cargo가 반드시 빌드 스크립트를 다시 실행해야 하는지 여부를 항상 아는 것은 아닙니다. 기본적으로 Cargo는 패키지 내의 파일이 하나라도 변경되면(또는 <a href="manifest.html#the-exclude-and-include-fields"><code>exclude</code> 및 <code>include</code> 필드</a> 로 제어되는 파일 목록이 변경되면) 항상 빌드 스크립트를 다시 실행하는 보수적인 방식을 취합니다. 대부분의 경우 이는 좋은 선택이 아니므로, 모든 빌드 스크립트는 적어도 하나 이상의 <code>rerun-if</code> 지시문(아래 설명 참조)을 내보내는 것이 권장됩니다. 이 지시문들이 내보내지면, Cargo는 지정된 값이 변경된 경우에만 스크립트를 다시 실행합니다. 만약 Cargo가 본인의 크레이트나 의존성의 빌드 스크립트를 계속 다시 실행하는데 그 이유를 모르겠다면, FAQ의 <a href="../faq.html#why-is-cargo-rebuilding-my-code">“왜 Cargo가 내 코드를 다시 빌드하나요?”</a> 를 참조하세요.</p>
<h3 id="rerun-if-changed"><a class="header" href="#rerun-if-changed"><code>cargo::rerun-if-changed=PATH</code></a></h3>
<p><code>rerun-if-changed</code> 지시문은 지정된 경로의 파일이 변경된 경우 빌드 스크립트를 다시 실행하도록 Cargo에 알립니다. 현재 Cargo는 파일의 변경 여부를 판단하기 위해 파일 시스템의 최종 수정 시간인 “mtime” 타임스탬프만 사용합니다. 이는 빌드 스크립트가 마지막으로 실행되었을 때의 내부적으로 캐시된 타임스탬프와 비교됩니다.</p>
<p>경로가 디렉토리를 가리키는 경우, 해당 디렉토리 전체에서 수정 사항이 있는지 스캔합니다.</p>
<p>만약 빌드 스크립트가 어떤 상황에서도 다시 실행될 필요가 없다면, <code>cargo::rerun-if-changed=build.rs</code> 를 내보내는 것이 재실행을 방지하는 간단한 방법입니다 (그렇지 않고 <code>rerun-if</code> 지시문이 전혀 없으면 기본적으로 패키지 디렉토리 전체를 스캔하여 변경 사항을 확인합니다). Cargo는 스크립트 자체가 재컴파일되어야 하는지 여부를 자동으로 처리하며, 당연히 재컴파일된 후에는 스크립트가 다시 실행됩니다. 그렇지 않은 경우 <code>build.rs</code> 를 지정하는 것은 불필요하고 중복된 작업입니다.</p>
<h3 id="rerun-if-env-changed"><a class="header" href="#rerun-if-env-changed"><code>cargo::rerun-if-env-changed=NAME</code></a></h3>
<p><code>rerun-if-env-changed</code> 지시문은 지정된 이름의 환경 변수 값이 변경된 경우 빌드 스크립트를 다시 실행하도록 Cargo에 알립니다.</p>
<p>여기서의 환경 변수는 <code>CC</code> 와 같은 전역 환경 변수를 위한 것이며, <a href="environment-variables.html#environment-variables-cargo-sets-for-build-scripts">Cargo가 빌드 스크립트를 위해 설정하는</a> <code>TARGET</code> 과 같은 환경 변수에는 사용할 수 없습니다. 사용되는 환경 변수는 빌드 스크립트의 실행 파일이 받는 것이 아니라, <code>cargo</code> 명령 호출 시 받는 것들입니다.</p>
<p>1.46 버전부터 소스 코드에서 <a href="../../std/macro.env.html"><code>env!</code></a> 와 <a href="../../std/macro.option_env.html"><code>option_env!</code></a> 를 사용하면 자동으로 변경 사항을 감지하고 재빌드를 트리거합니다. 이러한 매크로에 의해 이미 참조되는 변수들에 대해서는 <code>rerun-if-env-changed</code> 가 더 이상 필요하지 않습니다.</p>
<h2 id="links-매니페스트-키"><a class="header" href="#links-매니페스트-키"><code>links</code> 매니페스트 키</a></h2>
<p><code>package.links</code> 키를 <code>Cargo.toml</code> 매니페스트에 설정하여 패키지가 지정된 네이티브 라이브러리와 링크됨을 선언할 수 있습니다. 이 매니페스트 키의 목적은 Cargo가 패키지가 가진 네이티브 의존성 세트를 이해하도록 돕고, 패키지 빌드 스크립트 간에 메타데이터를 전달하는 체계적인 시스템을 제공하는 것입니다.</p>
<pre><code class="language-toml">[package]
# ...
links = "foo"
</code></pre>
<p>이 매니페스트는 패키지가 <code>libfoo</code> 네이티브 라이브러리에 링크됨을 나타냅니다. <code>links</code> 키를 사용할 때 패키지는 반드시 빌드 스크립트를 가져야 하며, 빌드 스크립트는 라이브러리를 링크하기 위해 <a href="#rustc-link-lib"><code>rustc-link-lib</code> 지시문</a> 을 사용해야 합니다.</p>
<p>기본적으로 Cargo는 <code>links</code> 값 하나당 최대 하나의 패키지만 허용합니다. 즉, 두 개의 패키지가 동일한 네이티브 라이브러리에 링크되는 것은 금지됩니다. 이는 크레이트 간의 심볼 중복을 방지하는 데 도움이 됩니다. 다만, 이를 완화하기 위한 <a href="#-sys-packages">관례</a> 가 존재합니다.</p>
<p>빌드 스크립트는 키-값 쌍 형태의 임의의 메타데이터 세트를 생성할 수 있습니다. 이 메타데이터는 <code>cargo::metadata=KEY=VALUE</code> 지시문을 사용하여 설정합니다.</p>
<p>The metadata is passed to the build scripts of <strong>dependent</strong> packages. For example, if the package <code>foo</code> depends on <code>bar</code>, which links <code>baz</code>, then if <code>bar</code> generates <code>key=value</code> as part of its build script metadata, then the build script of <code>foo</code> will have the environment variables <code>DEP_BAZ_KEY=value</code> (note that the value of the <code>links</code> key is used and the case change for <code>key</code>). See the <a href="build-script-examples.html#using-another-sys-crate">“Using another <code>sys</code> crate”</a> for an example of how this can be used.</p>
<p>메타데이터는 직속 의존 패키지(immediate dependents)에게만 전달되며, 전이적 의존 패키지(transitive dependents)에게는 전달되지 않음에 유의하세요.</p>
<blockquote>
<p><strong>MSRV:</strong> 1.77 is required for <code>cargo::metadata=KEY=VALUE</code>. To support older versions, use <code>cargo:KEY=VALUE</code> (unsupported directives are assumed to be metadata keys).</p>
</blockquote>
<h2 id="-sys-패키지"><a class="header" href="#-sys-패키지"><code>*-sys</code> 패키지</a></h2>
<p>시스템 라이브러리에 링크하는 일부 Cargo 패키지들은 이름 뒤에 <code>-sys</code> 접미사를 붙이는 명명 관례가 있습니다. <code>foo-sys</code> 라는 이름의 패키지는 다음과 같은 두 가지 주요 기능을 제공해야 합니다.</p>
<ul>
<li>라이브러리 크레이트는 네이티브 라이브러리 <code>libfoo</code> 에 링크되어야 합니다. 이는 종종 소스에서 직접 빌드하기 전에 현재 시스템에서 <code>libfoo</code> 를 탐색하는 과정을 거칩니다.</li>
<li>라이브러리 크레이트는 <code>libfoo</code> 의 타입과 함수에 대한 <strong>선언(declarations)</strong> 을 제공해야 하며, 고수준의 추상화는 제공하지 <strong>않아야</strong> 합니다.</li>
</ul>
<p><code>*-sys</code> 패키지 세트는 네이티브 라이브러리 링크를 위한 공통 의존성 세트를 제공합니다. 이러한 네이티브 라이브러리 관련 패키지 관례를 통해 얻을 수 있는 이점은 다음과 같습니다.</p>
<ul>
<li><code>foo-sys</code> 에 대한 공통 의존성을 통해 <code>links</code> 값당 하나의 패키지만 허용된다는 규칙의 제약을 완화할 수 있습니다.</li>
<li>Other <code>-sys</code> packages can take advantage of the <code>DEP_LINKS_KEY=value</code> environment variables to better integrate with other packages. See the <a href="build-script-examples.html#using-another-sys-crate">“Using another <code>sys</code> crate”</a> example.</li>
<li>공통 의존성을 사용하면 <code>libfoo</code> 자체를 찾거나 소스에서 빌드하는 로직을 중앙 집중화할 수 있습니다.</li>
<li>이러한 의존성들은 쉽게 <a href="#overriding-build-scripts">재정의 가능</a> 합니다.</li>
</ul>
<p>sys 패키지 위에 안전하고 고수준의 추상화를 제공하는, <code>-sys</code> 접미사가 없는 동반 패키지를 두는 것이 일반적입니다. 예를 들어, <a href="https://crates.io/crates/git2"><code>git2</code> 크레이트</a> 는 <a href="https://crates.io/crates/libgit2-sys"><code>libgit2-sys</code> 크레이트</a> 에 대한 고수준 인터페이스를 제공합니다.</p>
<h2 id="빌드-스크립트-재정의"><a class="header" href="#빌드-스크립트-재정의">빌드 스크립트 재정의</a></h2>
<p>매니페스트에 <code>links</code> 키가 포함된 경우, Cargo는 지정된 빌드 스크립트를 사용자 정의 라이브러리로 재정의하는 기능을 지원합니다. 이 기능의 목적은 해당 빌드 스크립트의 실행을 완전히 방지하고 대신 메타데이터를 미리 제공하는 것입니다.</p>
<p>빌드 스크립트를 재정의하려면 허용되는 임의의 <a href="config.html"><code>config.toml</code></a> 파일에 다음과 같은 설정을 추가하세요.</p>
<pre><code class="language-toml">[target.x86_64-unknown-linux-gnu.foo]
rustc-link-lib = ["foo"]
rustc-link-search = ["/path/to/foo"]
rustc-flags = "-L /some/path"
rustc-cfg = ['key="value"']
rustc-env = {key = "value"}
rustc-cdylib-link-arg = ["…"]
metadata_key1 = "value"
metadata_key2 = "value"
</code></pre>
<p>이 설정을 사용하면, 패키지가 <code>foo</code> 에 링크된다고 선언하더라도 빌드 스크립트는 컴파일되거나 실행되지 <strong>않으며</strong>, 대신 지정된 메타데이터가 사용됩니다.</p>
<p><code>warning</code>, <code>rerun-if-changed</code>, <code>rerun-if-env-changed</code> 키는 사용해서는 안 되며 무시됩니다.</p>
<h2 id="잡서버jobserver"><a class="header" href="#잡서버jobserver">잡서버(Jobserver)</a></h2>
<p>Cargo와 <code>rustc</code> 는 프로세스 간의 병렬 처리를 조율하기 위해 GNU make용으로 개발된 <a href="http://make.mad-scientist.net/papers/jobserver-implementation/">잡서버 프로토콜</a> 을 사용합니다. 이는 본질적으로 동시에 실행되는 작업 수를 제어하는 세마포어입니다. 병렬 처리 수준은 <code>--jobs</code> 플래그로 설정할 수 있으며, 기본값은 논리 CPU 개수입니다.</p>
<p>각 빌드 스크립트는 Cargo로부터 하나의 작업 슬롯을 상속받으며, 실행되는 동안 하나의 CPU만 사용하도록 노력해야 합니다. 스크립트가 더 많은 CPU를 병렬로 사용하려면 <a href="https://crates.io/crates/jobserver"><code>jobserver</code> 크레이트</a> 를 사용하여 Cargo와 조율해야 합니다.</p>
<p>예를 들어, <a href="https://crates.io/crates/cc"><code>cc</code> 크레이트</a> 는 선택적인 <code>parallel</code> 기능을 활성화하여 잡서버 프로토콜을 사용해 여러 C 파일을 동시에 빌드하도록 시도할 수 있습니다.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../reference/environment-variables.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../reference/build-script-examples.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../reference/environment-variables.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../reference/build-script-examples.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
