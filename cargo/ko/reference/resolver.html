<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>의존성 해결 - The Cargo Book</title>


        <!-- Custom HTML head -->
        <style>
            dd {
                margin-bottom: 1em;
            }
        </style>
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/cargo";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/reference/resolver.md`;
                    } else {
                        canonical_href = `${base}/${lang}/reference/resolver.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../theme/cargo.css">
        <link rel="stylesheet" href="../theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cargo Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/rust-lang/cargo/edit/master/src/doc/src/reference/resolver.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="의존성-해결"><a class="header" href="#의존성-해결">의존성 해결</a></h1>
<p>One of Cargo’s primary tasks is to determine the versions of dependencies to use based on the version requirements specified in each package. This process is called “dependency resolution” and is performed by the “resolver”. The result of the resolution is stored in the <a href="../guide/cargo-toml-vs-cargo-lock.html"><code>Cargo.lock</code> file</a> which “locks” the dependencies to specific versions, and keeps them fixed over time. The <a href="../commands/cargo-tree.html"><code>cargo tree</code></a> command can be used to visualize the result of the resolver.</p>
<h2 id="제약-조건-및-휴리스틱"><a class="header" href="#제약-조건-및-휴리스틱">제약 조건 및 휴리스틱</a></h2>
<p>대부분의 경우 단 하나의 “최선“의 의존성 해결책은 없습니다. 리졸버는 일반적으로 적용 가능한 해결책을 찾기 위해 다양한 제약 조건과 휴리스틱 하에서 작동합니다. 이것들이 어떻게 상호 작용하는지 이해하려면 의존성 해결이 어떻게 작동하는지 대략적으로 파악하는 것이 도움이 됩니다.</p>
<p>이 의사 코드는 Cargo 리졸버가 수행하는 작업을 대략적으로 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn resolve(workspace: &amp;[Package], policy: Policy) -&gt; Option&lt;ResolveGraph&gt; {
    let dep_queue = Queue::new(workspace);
    let resolved = ResolveGraph::new();
    resolve_next(dep_queue, resolved, policy)
}

fn resolve_next(dep_queue: Queue, resolved: ResolveGraph, policy: Policy) -&gt; Option&lt;ResolveGraph&gt; {
    let Some(dep_spec) = policy.pick_next_dep(&amp;mut dep_queue) else {
        // 완료
        return Some(resolved);
    };

    if let Some(resolved) = policy.try_unify_version(dep_spec, resolved.clone()) {
        return Some(resolved);
    }

    let dep_versions = dep_spec.lookup_versions()?;
    let mut dep_versions = policy.filter_versions(dep_spec, dep_versions);
    while let Some(dep_version) = policy.pick_next_version(&amp;mut dep_versions) {
        if policy.needs_version_unification(&amp;dep_version, &amp;resolved) {
            continue;
        }

        let mut dep_queue = dep_queue.clone();
        dep_queue.enqueue(&amp;dep_version.dependencies);
        let mut resolved = resolved.clone();
        resolved.register(dep_version);
        if let Some(resolved) = resolve_next(dep_queue, resolved, policy) {
            return Some(resolved);
        }
    }

    // 유효한 해결책을 찾지 못함, 백트래킹(backtrack) 후 `pick_next_version` 수행
    None
}
<span class="boring">}</span></code></pre></pre>
<p>주요 단계:</p>
<ul>
<li>의존성 탐색(<code>pick_next_dep</code>): 의존성을 탐색하는 순서는 동일한 의존성에 대한 관련 버전 요구 사항이 어떻게 해결되는지에 영향을 줄 수 있으며(버전 통합 참조), 리졸버가 얼마나 백트래킹하는지에도 영향을 주어 리졸버 성능에 영향을 미칩니다.</li>
<li>버전 통합(<code>try_unify_version</code>, <code>needs_version_unification</code>): Cargo는 빌드 시간을 단축하고 공통 의존성의 타입이 API 간에 전달될 수 있도록 가능한 한 버전을 재사용합니다. 만약 <a href="specifying-dependencies.html">의존성 사양</a>의 충돌만 아니었다면 통합되었을 여러 버전이 있는 경우, Cargo는 여러 버전을 선택하는 대신 해결책을 찾지 못하면 오류를 발생시키며 백트래킹합니다. <a href="specifying-dependencies.html">의존성 사양</a> 또는 Cargo는 특정 버전이 바람직하지 않다고 판단하여 해당 버전을 사용하는 대신 백트래킹하거나 오류를 발생시키는 것을 선호할 수 있습니다.</li>
<li>버전 선호(<code>pick_next_version</code>): Cargo는 특정 버전을 선호하기로 결정할 수 있으며, 백트래킹 시 다음 버전으로 폴백합니다.</li>
</ul>
<h3 id="버전-번호"><a class="header" href="#버전-번호">버전 번호</a></h3>
<p>일반적으로 Cargo는 현재 사용 가능한 가장 높은 버전을 선호합니다.</p>
<p>예를 들어 해결 그래프에 다음과 같은 패키지가 있다면:</p>
<pre><code class="language-toml">[dependencies]
bitflags = "*"
</code></pre>
<p><code>Cargo.lock</code> 파일이 생성될 시점에 <code>bitflags</code>의 가장 높은 버전이 <code>1.2.1</code>이라면, 패키지는 <code>1.2.1</code>을 사용하게 됩니다.</p>
<p>발생 가능한 예외의 예시는 <a href="#rust-version">Rust 버전</a>을 참조하세요.</p>
<h3 id="버전-요구-사항"><a class="header" href="#버전-요구-사항">버전 요구 사항</a></h3>
<p>패키지는 <a href="specifying-dependencies.html#version-requirement-syntax">버전 요구 사항</a>을 통해 지원하는 버전을 지정하고 다른 모든 버전은 거부합니다.</p>
<p>예를 들어 해결 그래프에 다음과 같은 패키지가 있다면:</p>
<pre><code class="language-toml">[dependencies]
bitflags = "1.0"  # `&gt;=1.0.0,&lt;2.0.0`을 의미함
</code></pre>
<p><code>Cargo.lock</code> 파일이 생성될 시점에 <code>bitflags</code>의 가장 높은 버전이 <code>1.2.1</code>이라면, 호환 범위 내에서 가장 높으므로 패키지는 <code>1.2.1</code>을 사용하게 됩니다. <code>2.0.0</code>이 게시되더라도 <code>2.0.0</code>은 호환되지 않는 것으로 간주되므로 여전히 <code>1.2.1</code>을 사용합니다.</p>
<h3 id="semver-호환성"><a class="header" href="#semver-호환성">SemVer 호환성</a></h3>
<p>Cargo는 패키지가 <a href="https://semver.org/">SemVer</a>를 따른다고 가정하며, <a href="specifying-dependencies.html#default-requirements">캐럿(Caret) 버전 요구 사항</a>에 따라 <a href="https://semver.org/">SemVer</a> 호환되는 경우 의존성 버전을 통합합니다. 버전 요구 사항의 충돌로 인해 호환되는 두 버전을 통합할 수 없는 경우 Cargo는 오류를 발생시킵니다.</p>
<p>무엇이 “호환되는” 변경으로 간주되는지에 대한 지침은 <a href="semver.html">SemVer 호환성</a> 장을 참조하세요.</p>
<p>예시:</p>
<p>다음 두 패키지는 선택된 모든 버전이 서로 호환되므로 <code>bitflags</code>에 대한 의존성이 통합됩니다.</p>
<pre><code class="language-toml"># 패키지 A
[dependencies]
bitflags = "1.0"  # `&gt;=1.0.0,&lt;2.0.0`을 의미함

# 패키지 B
[dependencies]
bitflags = "1.1"  # `&gt;=1.1.0,&lt;2.0.0`을 의미함
</code></pre>
<p>다음 패키지들은 버전 요구 사항이 충돌하여 서로 다른 두 호환 버전을 선택하게 되므로 오류가 발생합니다.</p>
<pre><code class="language-toml"># 패키지 A
[dependencies]
log = "=0.4.11"

# 패키지 B
[dependencies]
log = "=0.4.8"
</code></pre>
<p>다음 두 패키지는 각각에 대해 호환되지 않는 버전만 사용할 수 있으므로 <code>rand</code>에 대한 의존성이 통합되지 않습니다. 대신 두 개의 다른 버전(예: 0.6.5 및 0.7.3)이 해결되어 빌드됩니다. 이는 잠재적인 문제를 일으킬 수 있으므로 자세한 내용은 <a href="#version-incompatibility-hazards">버전 비호환성 위험</a> 섹션을 참조하세요.</p>
<pre><code class="language-toml"># 패키지 A
[dependencies]
rand = "0.7"  # `&gt;=0.7.0,&lt;0.8.0`을 의미함

# 패키지 B
[dependencies]
rand = "0.6"  # `&gt;=0.6.0,&lt;0.7.0`을 의미함
</code></pre>
<p>일반적으로 다음 두 패키지는 버전 요구 사항을 만족하는 호환되지 않는 버전들이 있으므로 의존성이 통합되지 않습니다. 대신 두 개의 다른 버전(예: 0.6.5 및 0.7.3)이 해결되어 빌드됩니다. 다른 제약 조건이나 휴리스틱의 적용으로 인해 이들이 통합되어 한 버전(예: 0.6.5)이 선택될 수도 있습니다.</p>
<pre><code class="language-toml"># 패키지 A
[dependencies]
rand = "&gt;=0.6,&lt;0.8.0"

# 패키지 B
[dependencies]
rand = "0.6"  # `&gt;=0.6.0,&lt;0.7.0`을 의미함
</code></pre>
<h4 id="버전-비호환성-위험"><a class="header" href="#버전-비호환성-위험">버전 비호환성 위험</a></h4>
<p>해결 그래프에 크레이트의 여러 버전이 나타나면, 해당 크레이트를 사용하는 크레이트에 의해 해당 크레이트의 타입이 노출될 때 문제가 발생할 수 있습니다. 이는 이름이 같더라도 Rust 컴파일러가 타입과 아이템을 서로 다른 것으로 간주하기 때문입니다. 라이브러리는 SemVer 비호환 버전(예: <code>1.0.0</code>이 사용 중일 때 <code>2.0.0</code> 게시)을 게시할 때, 특히 널리 사용되는 라이브러리의 경우 주의를 기울여야 합니다.</p>
<p>“<a href="https://github.com/dtolnay/semver-trick">semver trick</a>“은 이전 버전과의 호환성을 유지하면서 파괴적 변경을 게시하는 문제에 대한 해결 방법입니다. 링크된 페이지는 무엇이 문제이고 어떻게 해결하는지 자세히 설명합니다. 요약하자면, 라이브러리가 SemVer 파괴적 릴리스를 게시하려 할 때, 새 릴리스를 게시함과 동시에 새 버전의 타입을 재내보내는 이전 버전의 포인트 릴리스도 게시하는 것입니다.</p>
<p>These incompatibilities usually manifest as a compile-time error, but sometimes they will only appear as a runtime misbehavior. For example, let’s say there is a common library named <code>foo</code> that ends up appearing with both version <code>1.0.0</code> and <code>2.0.0</code> in the resolve graph. If <a href="../../std/any/trait.Any.html#method.downcast_ref"><code>downcast_ref</code></a> is used on an object created by a library using version <code>1.0.0</code>, and the code calling <code>downcast_ref</code> is downcasting to a type from version <code>2.0.0</code>, the downcast will fail at runtime.</p>
<p>라이브러리의 여러 버전이 있는 경우 이를 적절하게 사용하고 있는지, 특히 서로 다른 버전의 타입이 함께 사용될 가능성이 있는지 확인하는 것이 중요합니다. <a href="../commands/cargo-tree.html"><code>cargo tree -d</code></a> 명령어를 사용하여 중복된 버전과 그 출처를 식별할 수 있습니다. 마찬가지로, 인기 있는 라이브러리의 SemVer 비호환 버전을 게시할 경우 에코시스템에 미칠 영향을 고려하는 것이 중요합니다.</p>
<h3 id="락-파일-lock-file"><a class="header" href="#락-파일-lock-file">락 파일 (Lock file)</a></h3>
<p>Cargo gives the highest priority to versions contained in the <a href="../guide/cargo-toml-vs-cargo-lock.html"><code>Cargo.lock</code> file</a>, when used. This is intended to balance reproducible builds with adjusting to changes in the manifest.</p>
<p>예를 들어 해결 그래프에 다음과 같은 패키지가 있다면:</p>
<pre><code class="language-toml">[dependencies]
bitflags = "*"
</code></pre>
<p>If at the time your <code>Cargo.lock</code> file is generated, the greatest version of <code>bitflags</code> is <code>1.2.1</code>, then the package will use <code>1.2.1</code> and recorded in the <code>Cargo.lock</code> file.</p>
<p>By the time Cargo next runs, <code>bitflags</code> <code>1.3.5</code> is out. When resolving dependencies, <code>1.2.1</code> will still be used because it is present in your <code>Cargo.lock</code> file.</p>
<p>The package is then edited to:</p>
<pre><code class="language-toml">[dependencies]
bitflags = "1.3.0"
</code></pre>
<p><code>bitflags</code> <code>1.2.1</code> does not match this version requirement and so that entry in your <code>Cargo.lock</code> file is ignored and version <code>1.3.5</code> will now be used and recorded in your <code>Cargo.lock</code> file.</p>
<h3 id="rust-버전"><a class="header" href="#rust-버전">Rust 버전</a></h3>
<p>최소 지원 <a href="rust-version.html">Rust 버전</a>으로 소프트웨어를 개발하는 것을 지원하기 위해, 리졸버는 의존성 버전의 Rust 버전 호환성을 고려할 수 있습니다. 이는 구성 필드 <a href="config.html#resolverincompatible-rust-versions"><code>resolver.incompatible-rust-versions</code></a>에 의해 제어됩니다.</p>
<p><code>fallback</code> 설정을 사용하면, 리졸버는 현재 사용 중인 Rust 버전보다 작거나 같은 Rust 버전을 가진 패키지를 선호합니다. 예를 들어, Rust 1.85를 사용하여 다음 패키지를 개발한다고 가정해 봅시다.</p>
<pre><code class="language-toml">[package]
name = "my-cli"
rust-version = "1.62"

[dependencies]
clap = "4.0"  # 4.0.32로 해결됨
</code></pre>
<p>리졸버는 1.60.0의 Rust 버전을 가진 4.0.32 버전을 선택할 것입니다.</p>
<ul>
<li>4.0.0 역시 1.60.0의 Rust 버전을 가지고 있지만, <a href="#version-numbers">버전 번호</a>가 더 낮기 때문에 선택되지 않습니다.</li>
<li>4.5.20은 훨씬 <a href="#version-numbers">높은 버전</a>이고 1.85 툴체인과 호환되는 1.74.0의 Rust 버전을 가지고 있음에도 불구하고, <code>my-cli</code>의 Rust 버전인 1.62와 호환되지 않으므로 선택되지 않습니다.</li>
</ul>
<p>버전 요구 사항에 Rust 버전 호환 의존성 버전이 포함되어 있지 않은 경우, 리졸버는 오류를 발생시키지 않고 잠재적으로 최적이 아닐지라도 버전을 선택합니다. 예를 들어 <code>clap</code>에 대한 의존성을 다음과 같이 변경했다고 합시다.</p>
<pre><code class="language-toml">[package]
name = "my-cli"
rust-version = "1.62"

[dependencies]
clap = "4.2"  # 4.5.20으로 해결됨
</code></pre>
<p>Rust 버전 1.62와 호환되면서 해당 <a href="#version-requirements">버전 요구 사항</a>을 만족하는 <code>clap</code> 버전이 없습니다. 그러면 리졸버는 1.74의 Rust 버전을 가졌음에도 불구하고 4.5.20과 같이 호환되지 않는 버전을 선택하게 됩니다.</p>
<p>리졸버가 패키지의 의존성 버전을 선택할 때, 해당 버전에 최종적으로 전이적 의존성을 가질 모든 워크스페이스 구성원을 알 수 없으므로 해당 의존성과 관련된 Rust 버전만 고려할 수는 없습니다. 리졸버는 워크스페이스 구성원들이 서로 다른 Rust 버전을 가질 때 “충분히 좋은” 해결책을 찾기 위한 휴리스틱을 가집니다. 이는 Rust 버전이 없는 워크스페이스 내 패키지에도 적용됩니다.</p>
<p>워크스페이스 구성원들이 서로 다른 Rust 버전을 가질 때, 리졸버는 필요한 것보다 낮은 의존성 버전을 선택할 수 있습니다. 예를 들어, 다음과 같은 워크스페이스 구성원들이 있다고 합시다.</p>
<pre><code class="language-toml">[package]
name = "a"
rust-version = "1.62"

[package]
name = "b"

[dependencies]
clap = "4.2"  # 4.0.32로 해결됨 (패키지 a 때문)
</code></pre>
<p>패키지 <code>b</code>는 Rust 버전이 없어 4.5.20과 같은 더 높은 버전을 사용할 수 있음에도 불구하고, 패키지 <code>a</code>의 Rust 버전인 1.62 때문에 4.0.32가 선택될 것입니다.</p>
<p>또는 리졸버가 너무 높은 버전을 선택할 수도 있습니다. 예를 들어, 다음과 같은 워크스페이스 구성원들이 있다고 합시다.</p>
<pre><code class="language-toml">[package]
name = "a"
rust-version = "1.62"

[dependencies]
clap = "4.2"  # 4.5.20으로 해결됨

[package]
name = "b"

[dependencies]
clap = "4.5"  # 4.5.20으로 해결됨
</code></pre>
<p>각 패키지가 자신의 Rust 버전을 만족하는 <code>clap</code> 버전 요구 사항을 가지고 있더라도, <a href="#version-numbers">버전 통합</a> 때문에 리졸버는 두 경우 모두에서 작동하는 하나의 버전을 선택해야 하며, 그것은 4.5.20과 같은 버전이 될 것입니다.</p>
<h3 id="기능"><a class="header" href="#기능">기능</a></h3>
<p><code>Cargo.lock</code>을 생성하기 위해, 리졸버는 모든 <a href="workspaces.html">워크스페이스</a> 구성원의 모든 <a href="features.html">기능(features)</a>이 활성화된 것처럼 의존성 그래프를 빌드합니다. 이는 <a href="features.html#command-line-feature-options"><code>--features</code> 명령줄 플래그</a>를 통해 기능이 추가되거나 제거될 때 모든 선택적 의존성을 사용할 수 있고 나머지 그래프와 적절하게 해결되도록 보장합니다. 리졸버는 명령줄에서 선택된 기능을 기반으로 크레이트를 _컴파일_할 때 실제로 사용되는 기능을 결정하기 위해 두 번째로 실행됩니다.</p>
<p>의존성은 활성화된 모든 기능의 합집합으로 해결됩니다. 예를 들어, 한 패키지가 <a href="https://github.com/bodil/im-rs/blob/v15.0.0/Cargo.toml#L46"><code>serde</code> 의존성</a>이 활성화된 <a href="https://crates.io/crates/im"><code>im</code></a> 패키지에 의존하고 다른 패키지가 <a href="https://github.com/bodil/im-rs/blob/v15.0.0/Cargo.toml#L47"><code>rayon</code> 의존성</a>이 활성화된 해당 패키지에 의존하는 경우, <code>im</code>은 두 기능이 모두 활성화된 상태로 빌드되며 <code>serde</code> 및 <code>rayon</code> 크레이트가 해결 그래프에 포함됩니다. 해당 기능들을 가진 <code>im</code>에 의존하는 패키지가 없으면 해당 선택적 의존성들은 무시되며 해결에 영향을 주지 않습니다.</p>
<p>워크스페이스에서 여러 패키지를 빌드할 때(예: <code>--workspace</code> 또는 여러 개의 <code>-p</code> 플래그 사용 시), 해당 패키지들의 모든 의존성 기능들이 통합됩니다. 서로 다른 워크스페이스 구성원에 대해 이러한 통합을 피하고 싶은 상황이라면, 별도의 <code>cargo</code> 호출을 통해 빌드해야 합니다.</p>
<p>리졸버는 필요한 기능이 누락된 패키지 버전을 건너뜁니다. 예를 들어, 한 패키지가 <a href="https://github.com/rust-lang/regex/blob/1.3.0/Cargo.toml#L56"><code>perf</code> 기능</a>이 활성화된 <a href="https://crates.io/crates/regex"><code>regex</code></a>의 <code>^1</code> 버전에 의존하는 경우, 그 이전 버전들에는 <code>perf</code> 기능이 포함되어 있지 않으므로 선택할 수 있는 가장 오래된 버전은 <code>1.3.0</code>이 됩니다. 마찬가지로 새로운 릴리스에서 기능이 제거되면, 해당 기능을 요구하는 패키지들은 해당 기능이 포함된 이전 릴리스에 고정됩니다. SemVer 호환 릴리스에서 기능을 제거하는 것은 권장되지 않습니다. 선택적 의존성도 암시적 기능을 정의하므로, 선택적 의존성을 제거하거나 비선택적으로 만드는 것은 문제를 일으킬 수 있습니다. <a href="semver.html#cargo-remove-opt-dep">선택적 의존성 제거</a>를 참조하세요.</p>
<h4 id="기능-리졸버-버전-2"><a class="header" href="#기능-리졸버-버전-2">기능 리졸버 버전 2</a></h4>
<p><code>Cargo.toml</code>에 <code>resolver = "2"</code>가 지정되면 (아래 <a href="#resolver-versions">리졸버 버전</a> 참조), 기능 통합을 위해 다른 알고리즘을 사용하는 별도의 기능 리졸버가 사용됩니다. 버전 <code>"1"</code> 리졸버는 패키지가 어디에 지정되어 있든 관계없이 해당 패키지의 기능들을 통합합니다. 버전 <code>"2"</code> 리졸버는 다음과 같은 상황에서 기능 통합을 피합니다.</p>
<ul>
<li>
<p>현재 빌드 중인 타겟이 아닌 경우 타겟별 의존성의 기능은 활성화되지 않습니다. 예를 들어 다음과 같습니다.</p>
<pre><code class="language-toml">[dependencies.common]
version = "1.0"
features = ["f1"]

[target.'cfg(windows)'.dependencies.common]
version = "1.0"
features = ["f2"]
</code></pre>
<p>이 예제를 윈도우가 아닌 플랫폼용으로 빌드할 때, <code>f2</code> 기능은 활성화되지 <em>않습니다</em>.</p>
</li>
<li>
<p><a href="specifying-dependencies.html#build-dependencies">빌드 의존성(build-dependencies)</a> 또는 절차적 매크로(proc-macro)에서 활성화된 기능들은 해당 의존성이 일반 의존성으로 사용될 때 통합되지 않습니다. 예를 들어 다음과 같습니다.</p>
<pre><code class="language-toml">[dependencies]
log = "0.4"

[build-dependencies]
log = {version = "0.4", features=['std']}
</code></pre>
<p>빌드 스크립트를 빌드할 때, <code>log</code> 크레이트는 <code>std</code> 기능이 활성화된 상태로 빌드됩니다. 사용자의 패키지 라이브러리를 빌드할 때는 해당 기능이 활성화되지 않습니다.</p>
</li>
<li>
<p><a href="specifying-dependencies.html#development-dependencies">개발 의존성(dev-dependencies)</a>에서 활성화된 기능들은 해당 의존성이 일반 의존성으로 사용될 때 통합되지 않습니다 (단, 해당 개발 의존성이 현재 빌드 중인 경우는 제외). 예를 들어 다음과 같습니다.</p>
<pre><code class="language-toml">[dependencies]
serde = {version = "1.0", default-features = false}

[dev-dependencies]
serde = {version = "1.0", features = ["std"]}
</code></pre>
<p>이 예시에서 라이브러리는 평소에는 <code>std</code> 기능 없이 <code>serde</code>에 링크됩니다. 하지만 테스트나 예제로 빌드될 때는 <code>std</code> 기능이 포함됩니다. 예를 들어, <code>cargo test</code>나 <code>cargo build --all-targets</code>는 이러한 기능들을 통합합니다. 의존성 내의 개발 의존성은 항상 무시되며, 이는 최상위 패키지 또는 워크스페이스 구성원에게만 해당된다는 점에 유의하세요.</p>
</li>
</ul>
<h3 id="links"><a class="header" href="#links"><code>links</code></a></h3>
<p><a href="manifest.html#the-links-field"><code>links</code> 필드</a>는 네이티브 라이브러리의 단 한 개의 복사본만 바이너리에 링크되도록 보장하는 데 사용됩니다. 리졸버는 각 <code>links</code> 이름의 인스턴스가 하나만 존재하는 그래프를 찾으려고 시도합니다. 해당 제약 조건을 만족하는 그래프를 찾을 수 없는 경우 오류를 반환합니다.</p>
<p>예를 들어, 한 패키지가 <a href="https://crates.io/crates/libgit2-sys"><code>libgit2-sys</code></a> <code>0.11</code> 버전에 의존하고 다른 패키지가 <code>0.12</code>에 의존하는 경우, Cargo가 이를 통합할 수 없으면서 둘 다 <code>git2</code> 네이티브 라이브러리에 링크하므로 오류가 발생합니다. 이러한 요구 사항 때문에, 라이브러리가 널리 사용되는 경우 <code>links</code> 필드를 사용하여 SemVer 비호환 릴리스를 만들 때 매우 주의할 것을 권장합니다.</p>
<h3 id="yank된-버전"><a class="header" href="#yank된-버전">Yank된 버전</a></h3>
<p><a href="publishing.html#cargo-yank">Yank된 릴리스</a>는 사용해서는 안 된다고 표시된 릴리스들입니다. 리졸버가 그래프를 빌드할 때, <code>Cargo.lock</code> 파일에 이미 존재하거나 <code>cargo update</code>의 <a href="../commands/cargo-update.html#option-cargo-update---precise"><code>--precise</code></a> 플래그(나이틀리 전용)에 의해 명시적으로 요청되지 않는 한 모든 yank된 릴리스를 무시합니다.</p>
<h2 id="의존성-업데이트"><a class="header" href="#의존성-업데이트">의존성 업데이트</a></h2>
<p>의존성 해결은 의존성 그래프를 알아야 하는 모든 Cargo 명령어에 의해 자동으로 수행됩니다. 예를 들어, <a href="../commands/cargo-build.html"><code>cargo build</code></a>는 빌드할 모든 의존성을 찾기 위해 리졸버를 실행합니다. 처음 실행된 후 결과는 <code>Cargo.lock</code> 파일에 저장됩니다. 이후의 명령어들은 <em>가능한 한</em> 의존성을 <code>Cargo.lock</code>의 버전에 고정된 상태로 유지하며 리졸버를 실행합니다.</p>
<p><code>Cargo.toml</code>의 의존성 목록이 수정된 경우(예: 의존성 버전을 <code>1.0</code>에서 <code>2.0</code>으로 변경), 리졸버는 새로운 요구 사항과 일치하는 해당 의존성의 새 버전을 선택합니다. 만약 그 새로운 의존성이 새로운 요구 사항을 도입한다면, 그러한 새로운 요구 사항들이 추가적인 업데이트를 유발할 수도 있습니다. <code>Cargo.lock</code> 파일은 새로운 결과로 업데이트됩니다. <code>--locked</code> 또는 <code>--frozen</code> 플래그를 사용하여 요구 사항이 변경될 때 자동 업데이트를 방지하고 대신 오류를 반환하도록 이 동작을 변경할 수 있습니다.</p>
<p>새 버전이 게시될 때 <a href="../commands/cargo-update.html"><code>cargo update</code></a>를 사용하여 <code>Cargo.lock</code>의 항목들을 업데이트할 수 있습니다. 옵션 없이 실행하면 락 파일의 모든 패키지 업데이트를 시도합니다. <code>-p</code> 플래그를 사용하여 특정 패키지에 대한 업데이트를 대상으로 삼을 수 있으며, <code>--recursive</code> 또는 <code>--precise</code>와 같은 다른 플래그들을 사용하여 버전 선택 방식을 제어할 수 있습니다.</p>
<h2 id="재정의overrides"><a class="header" href="#재정의overrides">재정의(Overrides)</a></h2>
<p>Cargo는 그래프 내의 의존성을 재정의하기 위한 여러 메커니즘을 가지고 있습니다. <a href="overriding-dependencies.html">의존성 재정의</a> 장에서 재정의 사용 방법에 대해 자세히 다룹니다. 재정의는 레지스트리에 대한 오버레이로 나타나며, 패치된 버전을 새 항목으로 대체합니다. 그 외에는 해결 과정이 정상적으로 수행됩니다.</p>
<h2 id="의존성-종류"><a class="header" href="#의존성-종류">의존성 종류</a></h2>
<p>패키지에는 세 가지 종류의 의존성이 있습니다: 일반(normal), <a href="specifying-dependencies.html#build-dependencies">빌드(build)</a>, <a href="specifying-dependencies.html#development-dependencies">개발(dev)</a>입니다. 리졸버의 관점에서는 대부분 이들 모두를 동일하게 취급합니다. 한 가지 차이점은 워크스페이스 구성원이 아닌 경우 개발 의존성은 항상 무시되며 해결에 영향을 주지 않는다는 것입니다.</p>
<p><code>[target]</code> 테이블을 사용하는 <a href="specifying-dependencies.html#platform-specific-dependencies">플랫폼별 의존성</a>은 모든 플랫폼이 활성화된 것처럼 해결됩니다. 즉, 리졸버는 플랫폼이나 <code>cfg</code> 식을 무시합니다.</p>
<h3 id="개발-의존성-순환"><a class="header" href="#개발-의존성-순환">개발 의존성 순환</a></h3>
<p>보통 리졸버는 그래프에서 순환(cycles)을 허용하지 않지만, <a href="specifying-dependencies.html#development-dependencies">개발 의존성</a>에 대해서는 허용합니다. 예를 들어, 프로젝트 “foo“가 “bar“를 개발 의존성으로 가지고 있고, “bar“가 “foo“를 일반 의존성(보통 “경로” 의존성으로)으로 가지고 있는 경우입니다. 이는 빌드 산출물 관점에서는 실제 순환이 아니므로 허용됩니다. 이 예에서 “foo” 라이브러리가 먼저 빌드되고(“bar“는 테스트용으로만 쓰이므로 빌드에 필요 없음), 그 다음 “foo“에 의존하는 “bar“가 빌드될 수 있으며, 마지막으로 “bar“를 링크하는 “foo” 테스트가 빌드될 수 있습니다.</p>
<p>이로 인해 혼란스러운 오류가 발생할 수 있음을 주의하세요. 라이브러리 단위 테스트를 빌드하는 경우, 최종 테스트 바이너리에는 실제로 두 개의 라이브러리 복사본이 링크됩니다: 하나는 “bar“와 링크된 것이고, 다른 하나는 단위 테스트를 포함하여 빌드된 것입니다. <a href="#version-incompatibility-hazards">버전 비호환성 위험</a> 섹션에서 강조된 문제와 유사하게, 이들 두 타입은 서로 호환되지 않습니다. 이 상황에서 “bar“에서 “foo“의 타입을 노출할 때 주의하십시오. “foo” 단위 테스트는 이를 로컬 타입과 동일하게 취급하지 않기 때문입니다.</p>
<p>가능하다면 패키지를 여러 패키지로 분할하고 구조를 재조정하여 엄격하게 비순환 상태를 유지하도록 하세요.</p>
<h2 id="리졸버-버전"><a class="header" href="#리졸버-버전">리졸버 버전</a></h2>
<p>다음과 같이 <code>Cargo.toml</code>의 리졸버 버전을 통해 서로 다른 리졸버 동작을 지정할 수 있습니다.</p>
<pre><code class="language-toml">[package]
name = "my-package"
version = "1.0.0"
resolver = "2"
</code></pre>
<ul>
<li><code>"1"</code> (기본값)</li>
<li><code>"2"</code> (<a href="manifest.html#the-edition-field"><code>edition = "2021"</code></a> 기본값): <a href="#features">기능 통합(feature unification)</a>에 변화를 도입합니다. 자세한 내용은 <a href="features.html#feature-resolver-version-2">기능(features) 장</a>을 참조하세요.</li>
<li><code>"3"</code> (<a href="manifest.html#the-edition-field"><code>edition = "2024"</code></a> 기본값, Rust 1.84 이상 필요): <a href="config.html#resolverincompatible-rust-versions"><code>resolver.incompatible-rust-versions</code></a>의 기본값을 <code>allow</code>에서 <code>fallback</code>으로 변경합니다.</li>
</ul>
<p>리졸버는 전체 워크스페이스에 영향을 미치는 전역 옵션입니다. 의존성 내의 <code>resolver</code> 버전은 무시되며, 최상위 패키지의 값만 사용됩니다. <a href="workspaces.html#virtual-workspace">가상 워크스페이스</a>를 사용하는 경우 <code>[workspace]</code> 테이블에 버전을 지정해야 합니다. 예를 들어 다음과 같습니다.</p>
<pre><code class="language-toml">[workspace]
members = ["member1", "member2"]
resolver = "2"
</code></pre>
<blockquote>
<p><strong>MSRV:</strong> 1.51 이상 필요</p>
</blockquote>
<h2 id="권장-사항"><a class="header" href="#권장-사항">권장 사항</a></h2>
<p>다음은 패키지 내 버전을 설정하고 의존성 요구 사항을 지정하기 위한 몇 가지 권장 사항입니다. 이는 일반적인 상황에 적용되어야 할 보편적인 지침이지만, 물론 일부 상황에서는 특이한 요구 사항을 지정해야 할 수도 있습니다.</p>
<ul>
<li>
<p>버전 번호를 업데이트하는 방법과 SemVer 비호환 버전 변경이 필요한지 여부를 결정할 때 <a href="semver.html">SemVer 가이드라인</a>을 따르세요.</p>
</li>
<li>
<p>대부분의 상황에서 의존성에 대해 <code>"1.2.3"</code>과 같은 캐럿 요구 사항을 사용하세요. 이는 리졸버가 빌드 호환성을 유지하면서 버전을 선택할 때 최대한의 유연성을 가질 수 있도록 보장합니다.</p>
<ul>
<li>현재 사용 중인 버전의 세 가지 구성 요소를 모두 지정하세요. 이는 사용될 최소 버전을 설정하는 데 도움이 되며, 다른 사용자가 사용자의 패키지가 필요로 하는 무언가가 누락된 오래된 버전의 의존성을 사용하게 되는 일을 방지합니다.</li>
<li><code>*</code> 요구 사항은 <a href="https://crates.io/">crates.io</a>에서 허용되지 않으며, 일반적인 <code>cargo update</code> 중에 SemVer 파괴적 변경을 가져올 수 있으므로 피하세요.</li>
<li>과도하게 넓은 버전 요구 사항을 피하세요. 예를 들어 <code>&gt;=2.0.0</code>은 <code>5.0.0</code> 버전과 같은 모든 SemVer 비호환 버전을 가져올 수 있으며, 이는 나중에 빌드 오류를 초래할 수 있습니다.</li>
<li>가능하다면 과도하게 좁은 버전 요구 사항도 피하세요. 예를 들어 <code>bar="~1.3"</code>과 같은 틸드 요구 사항을 지정하고 다른 패키지가 <code>bar="1.4"</code> 요구 사항을 지정한다면, 부 릴리스(minor releases) 간에 호환되어야 함에도 불구하고 해결에 실패하게 됩니다.</li>
</ul>
</li>
<li>
<p>의존성 버전을 라이브러리가 요구하는 실제 최소 버전으로 최신 상태로 유지하도록 노력하세요. 예를 들어 요구 사항이 <code>bar="1.0.12"</code>인데 향후 릴리스에서 “bar“의 <code>1.1.0</code> 릴리스에 추가된 새로운 기능을 사용하기 시작했다면, 의존성 요구 사항을 <code>bar="1.1.0"</code>으로 업데이트하세요.</p>
<p>이를 소홀히 하면, 일괄적인 <code>cargo update</code> 실행 시 Cargo가 기회주의적으로 최신 버전을 선택할 수 있기 때문에 즉시 드러나지 않을 수 있습니다. 그러나 다른 사용자가 사용자의 라이브러리에 의존하고 <code>cargo update your-library</code>를 실행할 때, “bar“가 그들의 <code>Cargo.lock</code>에 고정되어 있다면 자동으로 업데이트되지 <em>않습니다</em>. 그 상황에서 “bar“는 의존성 선언도 업데이트된 경우에만 업데이트됩니다. 그렇게 하지 않으면 <code>cargo update your-library</code>를 사용하는 사용자에게 혼란스러운 빌드 오류가 발생할 수 있습니다.</p>
</li>
<li>
<p>두 패키지가 밀접하게 결합된 경우, <code>=</code> 의존성 요구 사항이 두 패키지의 동기화 상태를 유지하는 데 도움이 될 수 있습니다. 예를 들어, 동반 절차적 매크로(proc-macro) 라이브러리가 있는 라이브러리는 가끔 두 라이브러리 간에 가정을 하게 되는데, 두 라이브러리가 동기화되지 않으면 제대로 작동하지 않을 수 있습니다 (그리고 두 라이브러리를 독립적으로 사용하는 일은 결코 예상되지 않습니다). 부모 라이브러리는 절차적 매크로에 대해 <code>=</code> 요구 사항을 사용하고, 쉬운 접근을 위해 매크로를 재내보낼 수 있습니다.</p>
</li>
<li>
<p><code>0.0.x</code> 버전은 영구적으로 불안정한 패키지에 사용될 수 있습니다.</p>
</li>
</ul>
<p>일반적으로 의존성 요구 사항을 엄격하게 만들수록 리졸버가 실패할 가능성이 높아집니다. 반대로 요구 사항을 너무 느슨하게 사용하면, 빌드를 깨뜨리는 새 버전이 게시될 가능성이 있습니다.</p>
<h2 id="문제-해결"><a class="header" href="#문제-해결">문제 해결</a></h2>
<p>다음은 발생할 수 있는 몇 가지 문제와 가능한 해결책을 보여줍니다.</p>
<h3 id="의존성이-왜-포함되었나요"><a class="header" href="#의존성이-왜-포함되었나요">의존성이 왜 포함되었나요?</a></h3>
<p><code>cargo check</code> 출력에 <code>rand</code> 의존성이 표시되는데 이것이 필요하지 않다고 생각되어 왜 끌어와졌는지 이해하고 싶다고 합시다.</p>
<p>다음을 실행할 수 있습니다.</p>
<pre><code class="language-console">$ cargo tree --workspace --target all --all-features --invert rand
rand v0.8.5
└── ...

rand v0.8.5
└── ...
</code></pre>
<h3 id="이-의존성의-해당-기능이-왜-활성화되었나요"><a class="header" href="#이-의존성의-해당-기능이-왜-활성화되었나요">이 의존성의 해당 기능이 왜 활성화되었나요?</a></h3>
<p>활성화된 어떤 기능 때문에 <code>rand</code>가 나타났다는 것을 알게 될 수도 있습니다. <strong>어떤 패키지가 그 기능을 활성화했는지 확인하려면 <code>--edges features</code>를 추가하면 됩니다.</strong></p>
<pre><code class="language-console">$ cargo tree --workspace --target all --all-features --edges features --invert rand
rand v0.8.5
└── ...

rand v0.8.5
└── ...
</code></pre>
<h3 id="예기치-않은-의존성-중복"><a class="header" href="#예기치-않은-의존성-중복">예기치 않은 의존성 중복</a></h3>
<p>다음을 실행할 때 <code>rand</code> 인스턴스가 여러 개 표시되는 경우입니다.</p>
<pre><code class="language-console">$ cargo tree --workspace --target all --all-features --duplicates
rand v0.7.3
└── ...

rand v0.8.5
└── ...
</code></pre>
<p>리졸버 알고리즘이 하나면 충분한 의존성 복사본을 두 개 포함하는 해결책으로 수렴되었습니다. 예를 들어 다음과 같습니다.</p>
<pre><code class="language-toml"># 패키지 A
[dependencies]
rand = "0.7"

# 패키지 B
[dependencies]
rand = "&gt;=0.6"  # 참고: 이와 같이 열린 요구 사항은 권장되지 않습니다
</code></pre>
<p>이 예에서 <code>0.7.3</code> 버전의 단일 복사본이 모든 요구 사항을 충족함에도 불구하고, Cargo는 <code>rand</code> 크레이트 복사본 두 개를 빌드할 수 있습니다. 이는 리졸버 알고리즘이 패키지 B에 대해 현재 사용 가능한 최신 <code>rand</code> 버전(이 글을 쓰는 시점에는 <code>0.8.5</code>) 빌드를 선호하며, 이는 패키지 A의 명세와 호환되지 않기 때문입니다. 리졸버 알고리즘은 현재 이 상황에서 “중복 제거(deduplicate)“를 시도하지 않습니다.</p>
<p>Cargo에서는 <code>&gt;=0.6</code>과 같은 개방형 버전 요구 사항의 사용을 권장하지 않습니다. 하지만 이런 상황에 처하게 된다면, <code>--precise</code> 플래그와 함께 <a href="../commands/cargo-update.html"><code>cargo update</code></a> 명령어를 사용하여 이러한 중복을 수동으로 제거할 수 있습니다.</p>
<h3 id="왜-더-최신-버전이-선택되지-않았나요"><a class="header" href="#왜-더-최신-버전이-선택되지-않았나요">왜 더 최신 버전이 선택되지 않았나요?</a></h3>
<p>다음을 실행했을 때 의존성의 최신 버전이 선택되지 않은 것을 발견했다고 합시다.</p>
<pre><code class="language-console">$ cargo update
</code></pre>
<p>왜 이런 일이 발생했는지 확인하기 위해 몇 가지 추가 로깅을 활성화할 수 있습니다.</p>
<pre><code class="language-console">$ env CARGO_LOG=cargo::core::resolver=trace cargo update
</code></pre>
<p><strong>참고:</strong> Cargo 로그 타겟 및 레벨은 시간이 지남에 따라 변경될 수 있습니다.</p>
<h3 id="semver를-파괴하는-패치-릴리스가-빌드를-깨뜨림"><a class="header" href="#semver를-파괴하는-패치-릴리스가-빌드를-깨뜨림">SemVer를 파괴하는 패치 릴리스가 빌드를 깨뜨림</a></h3>
<p>때로는 프로젝트가 실수로 SemVer 파괴적 변경이 포함된 포인트 릴리스(point release)를 게시할 수 있습니다. 사용자가 <code>cargo update</code>를 통해 업데이트하면 이 새로운 릴리스를 가져오게 되고 빌드가 깨질 수 있습니다. 이런 상황에서 해당 프로젝트는 릴리스를 <a href="publishing.html#cargo-yank">yank</a>하고, SemVer 파괴적 변경을 제거하거나 새로운 SemVer 주 버전(major version) 상향으로 게시할 것을 권장합니다.</p>
<p>만약 제삼자 프로젝트에서 변경이 발생했다면, 가능하다면 (정중하게!) 해당 프로젝트와 협력하여 문제를 해결해 보세요.</p>
<p>릴리스가 yank되기를 기다리는 동안, 상황에 따라 몇 가지 우회 방법이 있습니다.</p>
<ul>
<li>사용자의 프로젝트가 최종 제품(예: 바이너리 실행 파일)이라면, <code>Cargo.lock</code>에서 문제가 되는 패키지를 업데이트하지 않도록 하세요. 이는 <a href="../commands/cargo-update.html"><code>cargo update</code></a>의 <code>--precise</code> 플래그를 통해 수행할 수 있습니다.</li>
<li><a href="https://crates.io/">crates.io</a>에 바이너리를 게시하는 경우, 일시적으로 <code>=</code> 요구 사항을 추가하여 의존성을 특정 안정 버전으로 강제할 수 있습니다.
<ul>
<li>바이너리 프로젝트는 대안으로 사용자에게 <a href="../commands/cargo-install.html"><code>cargo install</code></a> 시 <code>--locked</code> 플래그를 사용하여 알려진 안정 버전이 포함된 원래의 <code>Cargo.lock</code>을 사용하도록 권장할 수 있습니다.</li>
</ul>
</li>
<li>라이브러리는 문제가 되는 의존성을 피하기 위해 더 엄격한 요구 사항을 가진 임시 새 릴리스 게시를 고려할 수 있습니다. 동일한 의존성을 사용하는 다른 패키지와 충돌할 수 있는 지나치게 엄격한 요구 사항을 피하기 위해 (<code>=</code> 대신) 범위 요구 사항 사용을 고려할 수도 있습니다. 문제가 해결되면 의존성을 다시 캐럿 요구 사항으로 완화하는 또 다른 포인트 릴리스를 게시할 수 있습니다.</li>
<li>제삼자 프로젝트가 릴리스를 yank할 수 없거나 의사가 없는 것으로 보인다면, 한 가지 옵션은 사용자의 코드를 변경 사항과 호환되도록 업데이트하고 의존성 요구 사항의 최소 버전을 새 릴리스로 업데이트하는 것입니다. 이때 의존성의 타입을 노출하는 등의 이유로 사용자의 라이브러리에도 SemVer 파괴적 변경이 발생하는지 여부도 고려해야 합니다.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../reference/source-replacement.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../reference/features.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../reference/source-replacement.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../reference/features.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../theme/language-picker.js"></script>


    </div>
    </body>
</html>
