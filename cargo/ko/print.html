<!DOCTYPE HTML>
<html lang="ko" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Cargo Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        <style>
            dd {
                margin-bottom: 1em;
            }
        </style>
        
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-L455DH98TK"></script>
        <script>
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
        
          gtag('config', 'G-L455DH98TK');
        </script>
        
        
        <script>
            (function () {
                // See these pages for details:
                // https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls
                // https://developers.google.com/search/docs/crawling-indexing/javascript/javascript-seo-basics
        
                function gen_canonical_href(lang) {
        
                    let base = "https://rust-lang-translations.org/cargo";
        
                    let canonical_href;
                    if (lang == "en") {
                        canonical_href = `${base}/print.md`;
                    } else {
                        canonical_href = `${base}/${lang}/print.md`;
                    }
                    canonical_href = canonical_href.slice(0, -"md".length) + "html";
                    if (canonical_href.endsWith("/index.html")) {
                        canonical_href = canonical_href.slice(0, -"index.html".length);
                    }
                    return canonical_href;
                }
        
                const canonical_href = gen_canonical_href("ko");

                let link = document.createElement("link");
                link.rel = "canonical";
                link.href = canonical_href;
                document.head.appendChild(link);
        
        
                const langs = ["en"  , "ja"  , "ko" ];
        
                for (const lang of langs) {
                    const canonical_href = gen_canonical_href(lang);
        
                    let link = document.createElement("link");
                    link.rel = "alternate";
                    link.hreflang = lang;
                    link.href = canonical_href;
                    document.head.appendChild(link);
                }
            })()
        </script>
        

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/cargo.css">
        <link rel="stylesheet" href="theme/language-picker.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Cargo Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang-translations/project" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cargo-북"><a class="header" href="#cargo-북">Cargo 북</a></h1>
<p><img src="images/Cargo-Logo-Small.png" alt="Cargo 로고" /></p>
<p>Cargo는 <a href="https://www.rust-lang.org/">Rust</a> 의 [<em>패키지 관리자</em>](./appendix/glossary.md#package-manager “패키지 관리자” (용어집 항목)“)입니다. Cargo는 Rust [패키지](./appendix/glossary.md#package “패키지” (용어집 항목)“)의 의존성을 다운로드하고, 패키지를 컴파일하고, 배포 가능한 패키지를 만들고, Rust 커뮤니티의 <a href="./appendix/glossary.html#package-registry" title="&quot;패키지 레지스트리&quot; (용어집 항목)"><em>패키지 레지스트리</em></a>인 <a href="https://crates.io/">crates.io</a>에 업로드합니다. <a href="https://github.com/rust-lang/cargo/tree/master/src/doc">GitHub</a>에서 이 책에 기여할 수 있습니다.</p>
<h2 id="섹션"><a class="header" href="#섹션">섹션</a></h2>
<p><strong><a href="getting-started/index.html">시작하기</a></strong></p>
<p>Cargo를 시작하려면 Cargo(및 Rust)를 설치하고 첫 번째 <a href="./appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)"><em>크레이트</em></a>를 설정하세요.</p>
<p><strong><a href="guide/index.html">Cargo 가이드</a></strong></p>
<p>가이드는 Rust 패키지를 개발하기 위해 Cargo를 사용하는 방법에 대해 알아야 할 모든 것을 제공합니다.</p>
<p><strong><a href="reference/index.html">Cargo 레퍼런스</a></strong></p>
<p>레퍼런스는 Cargo의 다양한 영역에 대한 세부 사항을 다룹니다.</p>
<p><strong><a href="commands/index.html">Cargo 명령어</a></strong></p>
<p>명령어들은 명령줄 인터페이스를 사용하여 Cargo와 상호작용할 수 있게 해줍니다.</p>
<p><strong><a href="faq.html">자주 묻는 질문</a></strong></p>
<p><strong>부록:</strong></p>
<ul>
<li><a href="appendix/glossary.html">용어집</a></li>
<li><a href="appendix/git-authentication.html">Git 인증</a></li>
</ul>
<p><strong>기타 문서:</strong></p>
<ul>
<li><a href="CHANGELOG.html">변경 로그</a> — 각 릴리스의 Cargo 변경 사항에 대한 자세한 정보입니다.</li>
<li><a href="https://doc.rust-lang.org/">Rust 문서 웹사이트</a> — 공식 Rust 문서 및 도구 링크입니다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="시작하기"><a class="header" href="#시작하기">시작하기</a></h1>
<p>Cargo를 시작하려면 Cargo(및 Rust)를 설치하고 첫 번째 <a href="getting-started/../appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)"><em>크레이트</em></a>를 설정하세요.</p>
<ul>
<li><a href="getting-started/installation.html">설치</a></li>
<li><a href="getting-started/first-steps.html">Cargo 첫 걸음</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="설치"><a class="header" href="#설치">설치</a></h1>
<h2 id="rust와-cargo-설치하기"><a class="header" href="#rust와-cargo-설치하기">Rust와 Cargo 설치하기</a></h2>
<p>Cargo를 얻는 가장 쉬운 방법은 <a href="https://rustup.rs/">rustup</a> 을 사용하여 현재 안정 버전의 <a href="https://www.rust-lang.org/">Rust</a> 를 설치하는 것입니다. <code>rustup</code> 을 사용하여 Rust를 설치하면 <code>cargo</code> 도 함께 설치됩니다.</p>
<p>리눅스와 macOS 시스템에서는 다음과 같이 할 수 있습니다:</p>
<pre><code class="language-console">curl https://sh.rustup.rs -sSf | sh
</code></pre>
<p>스크립트를 다운로드하고 설치를 시작합니다. 모든 것이 순조롭게 진행되면 다음과 같은 메시지가 나타납니다:</p>
<pre><code class="language-console">Rust is installed now. Great!
</code></pre>
<p>윈도우에서는 <a href="https://win.rustup.rs/">rustup-init.exe</a> 를 다운로드하여 실행하세요. 콘솔에서 설치가 시작되고 성공하면 위와 같은 메시지가 나타납니다.</p>
<p>이후 <code>rustup</code> 명령어를 사용하여 Rust와 Cargo의 <code>beta</code> 또는 <code>nightly</code> 채널을 설치할 수도 있습니다.</p>
<p>다른 설치 옵션 및 정보는 Rust 웹사이트의 <a href="https://www.rust-lang.org/tools/install">설치</a> 페이지를 참조하세요.</p>
<h2 id="소스에서-cargo-빌드-및-설치하기"><a class="header" href="#소스에서-cargo-빌드-및-설치하기">소스에서 Cargo 빌드 및 설치하기</a></h2>
<p>또는 <a href="https://github.com/rust-lang/cargo#compiling-from-source">소스에서 Cargo를 빌드</a> 할 수도 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-첫-걸음"><a class="header" href="#cargo-첫-걸음">Cargo 첫 걸음</a></h1>
<p>이 섹션에서는 <code>cargo</code> 명령줄 도구에 대한 간략한 개요를 제공합니다. 새로운 <a href="getting-started/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)"><em><strong>패키지</strong></em></a>를 생성하고, 패키지 내의 <a href="getting-started/../appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)"><em><strong>크레이트</strong></em></a>를 컴파일하고, 결과 프로그램을 실행하는 기능을 보여줍니다.</p>
<p>Cargo로 새 패키지를 시작하려면 <code>cargo new</code> 를 사용하세요:</p>
<pre><code class="language-console">$ cargo new hello_world
</code></pre>
<p>Cargo는 기본적으로 바이너리 프로그램을 만들기 위해 <code>--bin</code> 을 사용합니다. 라이브러리를 만들려면 대신 <code>--lib</code> 를 전달합니다.</p>
<p>Cargo가 우리를 위해 무엇을 생성했는지 확인해 봅시다:</p>
<pre><code class="language-console">$ cd hello_world
$ tree .
.
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
</code></pre>
<p>시작하는 데 필요한 모든 것입니다. 먼저 <code>Cargo.toml</code> 을 확인해 봅시다:</p>
<pre><code class="language-toml">[package]
name = "hello_world"
version = "0.1.0"
edition = "2024"

[dependencies]
</code></pre>
<p>이것을 <a href="getting-started/../appendix/glossary.html#manifest" title="&quot;manifest&quot; (glossary entry)"><em><strong>매니페스트</strong></em></a>라고 하며, Cargo가 패키지를 컴파일하는 데 필요한 모든 메타데이터를 포함합니다.</p>
<p><code>src/main.rs</code> 의 내용은 다음과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>Cargo는 우리를 위해 “hello world” 프로그램을 생성했습니다. 이를 <a href="getting-started/../appendix/glossary.html#crate" title="&quot;crate&quot; (glossary entry)"><em><strong>바이너리 크레이트</strong></em></a>라고도 합니다. 컴파일해 봅시다:</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
</code></pre>
<p>그리고 실행합니다:</p>
<pre><code class="language-console">$ ./target/debug/hello_world
Hello, world!
</code></pre>
<p>또한 <code>cargo run</code> 을 사용하여 한 번에 컴파일하고 실행할 수도 있습니다:</p>
<pre><code class="language-console">$ cargo run
     Fresh hello_world v0.1.0 (file:///path/to/package/hello_world)
   Running `target/hello_world`
Hello, world!
</code></pre>
<h2 id="더-나아가기"><a class="header" href="#더-나아가기">더 나아가기</a></h2>
<p>Cargo 사용에 대한 자세한 내용은 <a href="getting-started/../guide/index.html">Cargo 가이드</a> 를 확인하세요.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-가이드"><a class="header" href="#cargo-가이드">Cargo 가이드</a></h1>
<p>이 가이드는 Rust 패키지를 개발하기 위해 Cargo를 사용하는 방법에 대해 알아야 할 모든 것을 제공합니다.</p>
<ul>
<li><a href="guide/why-cargo-exists.html">Cargo가 존재하는 이유</a></li>
<li><a href="guide/creating-a-new-project.html">새 패키지 만들기</a></li>
<li><a href="guide/working-on-an-existing-project.html">기존 Cargo 패키지 작업하기</a></li>
<li><a href="guide/dependencies.html">의존성</a></li>
<li><a href="guide/project-layout.html">패키지 레이아웃</a></li>
<li><a href="guide/cargo-toml-vs-cargo-lock.html">Cargo.toml vs Cargo.lock</a></li>
<li><a href="guide/tests.html">테스트</a></li>
<li><a href="guide/continuous-integration.html">지속적 통합</a></li>
<li><a href="guide/../reference/publishing.html">crates.io에 게시하기</a></li>
<li><a href="guide/cargo-home.html">Cargo 홈</a></li>
<li><a href="guide/build-performance.html">Optimizing Build Performance</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo가-존재하는-이유"><a class="header" href="#cargo가-존재하는-이유">Cargo가 존재하는 이유</a></h1>
<h2 id="사전-준비"><a class="header" href="#사전-준비">사전 준비</a></h2>
<p>아시다시피 Rust에서는 라이브러리나 실행 프로그램을 [<em>크레이트</em>](../appendix/glossary.md#crate “crate” (glossary entry)“)라고 합니다. 크레이트는 Rust 컴파일러인 <code>rustc</code> 를 사용하여 컴파일됩니다. Rust를 시작할 때 대부분의 사람들이 처음 접하는 소스 코드는 고전적인 “hello world” 프로그램의 소스 코드이며, <code>rustc</code> 를 직접 호출하여 컴파일합니다:</p>
<pre><code class="language-console">$ rustc hello.rs
$ ./hello
Hello, world!
</code></pre>
<p>위의 명령어는 파일 이름을 명시적으로 지정해야 했습니다. 다른 프로그램을 컴파일하기 위해 <code>rustc</code> 를 직접 사용하려면 다른 명령줄 호출이 필요합니다. 특정 컴파일러 플래그를 지정하거나 외부 의존성을 포함해야 하는 경우 필요한 명령어는 더욱 구체적이고 복잡해집니다.</p>
<p>또한, 대부분의 간단하지 않은 프로그램은 외부 라이브러리에 대한 의존성을 가질 가능성이 높으며, 따라서 <em>그들의</em> 의존성에도 전이적으로 의존하게 됩니다. 필요한 모든 의존성의 올바른 버전을 얻고 최신 상태로 유지하는 것은 수동으로 수행하면 어렵고 오류가 발생하기 쉽습니다.</p>
<p>크레이트와 <code>rustc</code> 만으로 작업하는 대신, 상위 수준의 <a href="guide/../appendix/glossary.html#package" title="&quot;패키지&quot; (용어집 항목)">“_패키지 _”</a> 추상화를 도입하고 <a href="guide/../appendix/glossary.html#package-manager" title="&quot;패키지 관리자&quot; (용어집 항목)">_ 패키지 관리자_</a>를 사용하여 위 작업을 수행하는 데 따르는 어려움을 피할 수 있습니다.</p>
<h2 id="cargo-등장"><a class="header" href="#cargo-등장">Cargo 등장</a></h2>
<p><em>Cargo</em> 는 Rust 패키지 관리자입니다. Rust [<em>패키지</em>](../appendix/glossary.md#package “패키지” (용어집 항목)“)가 다양한 의존성을 선언하고 항상 반복 가능한 빌드를 얻을 수 있도록 보장하는 도구입니다.</p>
<p>이 목표를 달성하기 위해 Cargo는 네 가지 작업을 수행합니다:</p>
<ul>
<li>다양한 패키지 정보가 포함된 두 개의 메타데이터 파일을 도입합니다.</li>
<li>패키지의 의존성을 가져와 빌드합니다.</li>
<li>패키지를 빌드하기 위해 올바른 매개변수로 <code>rustc</code> 또는 다른 빌드 도구를 호출합니다.</li>
<li>Rust 패키지 작업을 더 쉽게 만들기 위한 규칙을 도입합니다.</li>
</ul>
<p>Cargo는 주어진 프로그램이나 라이브러리를 빌드하는 데 필요한 명령어를 상당 부분 표준화합니다. 이것이 위에서 언급한 규칙의 한 측면입니다. 나중에 보여주겠지만, 이름에 관계없이 동일한 명령어를 사용하여 다른 [<em>산출물</em>](../appendix/glossary.md#artifact “산출물” (용어집 항목)“)을 빌드할 수 있습니다. <code>rustc</code> 를 직접 호출하는 대신 <code>cargo build</code> 와 같은 일반적인 명령어를 호출하고 Cargo가 올바른 <code>rustc</code> 호출을 구성하도록 할 수 있습니다. 또한 Cargo는 [<em>레지스트리</em>](../appendix/glossary.md#registry “레지스트리” (용어집 항목)“)에서 산출물에 대해 정의한 모든 의존성을 자동으로 가져와 필요에 따라 빌드에 추가하도록 정렬합니다.</p>
<p>하나의 Cargo 기반 프로젝트를 빌드하는 방법을 알면 <em>모든</em> 프로젝트를 빌드하는 방법을 안다고 말하는 것은 약간의 과장일 뿐입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="새-패키지-만들기"><a class="header" href="#새-패키지-만들기">새 패키지 만들기</a></h1>
<p>Cargo로 새 <a href="guide/../appendix/glossary.html#package" title="&quot;패키지&quot; (용어집 항목)">패키지</a>를 시작하려면 <code>cargo new</code> 를 사용하세요:</p>
<pre><code class="language-console">$ cargo new hello_world --bin
</code></pre>
<p>바이너리 프로그램을 만들고 있으므로 <code>--bin</code> 을 전달합니다. 라이브러리를 만들고 있었다면 <code>--lib</code> 를 전달했을 것입니다. 이것은 또한 기본적으로 새로운 <code>git</code> 저장소를 초기화합니다. 원하지 않으면 <code>--vcs none</code> 을 전달하세요.</p>
<p>Cargo가 우리를 위해 무엇을 생성했는지 확인해 봅시다:</p>
<pre><code class="language-console">$ cd hello_world
$ tree .
.
├── Cargo.toml
└── src
    └── main.rs

1 directory, 2 files
</code></pre>
<p><code>Cargo.toml</code> 을 자세히 살펴봅시다:</p>
<pre><code class="language-toml">[package]
name = "hello_world"
version = "0.1.0"
edition = "2024"

[dependencies]

</code></pre>
<p>이것을 <a href="guide/../appendix/glossary.html#manifest" title="&quot;매니페스트&quot; (용어집 항목)"><em><strong>매니페스트</strong></em></a>라고 하며, Cargo가 패키지를 컴파일하는 데 필요한 모든 메타데이터를 포함합니다. 이 파일은 <a href="https://toml.io/">TOML</a> 형식(/tɑməl/로 발음)으로 작성되었습니다.</p>
<p><code>src/main.rs</code> 의 내용은 다음과 같습니다:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>Cargo는 “hello world” 프로그램을 생성했습니다. 이를 [<em>바이너리 크레이트</em>](../appendix/glossary.md#crate “크레이트” (용어집 항목)“)라고도 합니다. 컴파일해 봅시다:</p>
<pre><code class="language-console">$ cargo build
   Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
</code></pre>
<p>그리고 실행합니다:</p>
<pre><code class="language-console">$ ./target/debug/hello_world
Hello, world!
</code></pre>
<p><code>cargo run</code> 을 사용하여 한 번에 컴파일하고 실행할 수도 있습니다 (마지막으로 컴파일한 이후 변경 사항이 없으면 <code>Compiling</code> 줄이 표시되지 않습니다):</p>
<pre><code class="language-console">$ cargo run
   Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
     Running `target/debug/hello_world`
Hello, world!
</code></pre>
<p>이제 <code>Cargo.lock</code> 이라는 새 파일이 표시됩니다. 여기에는 의존성에 대한 정보가 포함되어 있습니다. 아직 의존성이 없으므로 그다지 흥미롭지 않습니다.</p>
<p>릴리스 준비가 되면 <code>cargo build --release</code> 를 사용하여 최적화가 켜진 상태로 파일을 컴파일할 수 있습니다:</p>
<pre><code class="language-console">$ cargo build --release
   Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
</code></pre>
<p><code>cargo build --release</code> 는 결과 바이너리를 <code>target/debug</code> 대신 <code>target/release</code> 에 넣습니다.</p>
<p>디버그 모드에서 컴파일하는 것이 개발의 기본값입니다. 컴파일러가 최적화를 수행하지 않기 때문에 컴파일 시간이 더 짧지만 코드는 더 느리게 실행됩니다. 릴리스 모드는 컴파일하는 데 시간이 더 오래 걸리지만 코드는 더 빠르게 실행됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="기존-cargo-패키지-작업하기"><a class="header" href="#기존-cargo-패키지-작업하기">기존 Cargo 패키지 작업하기</a></h1>
<p>Cargo를 사용하는 기존 <a href="guide/../appendix/glossary.html#package" title="&quot;패키지&quot; (용어집 항목)">패키지</a>를 다운로드하면 시작하기가 정말 쉽습니다.</p>
<p>먼저 어딘가에서 패키지를 가져옵니다. 이 예에서는 GitHub의 저장소에서 복제한 <code>regex</code> 를 사용합니다:</p>
<pre><code class="language-console">$ git clone https://github.com/rust-lang/regex.git
$ cd regex
</code></pre>
<p>빌드하려면 <code>cargo build</code> 를 사용하세요:</p>
<pre><code class="language-console">$ cargo build
   Compiling regex v1.5.0 (file:///path/to/package/regex)
</code></pre>
<p>이렇게 하면 모든 의존성을 가져와 패키지와 함께 빌드합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="의존성"><a class="header" href="#의존성">의존성</a></h1>
<p><a href="https://crates.io/">crates.io</a> 는 Rust 커뮤니티의 중앙 <a href="guide/../appendix/glossary.html#package-registry" title="&quot;패키지 레지스트리&quot; (용어집 항목)"><em>패키지 레지스트리</em></a>로, <a href="guide/../appendix/glossary.html#package" title="&quot;패키지&quot; (용어집 항목)">패키지</a>를 검색하고 다운로드하는 위치 역할을 합니다. <code>cargo</code> 는 요청된 패키지를 찾기 위해 기본적으로 이를 사용하도록 구성되어 있습니다.</p>
<p><a href="https://crates.io/">crates.io</a> 에서 호스팅되는 라이브러리에 의존하려면 <code>Cargo.toml</code> 에 추가하세요.</p>
<h2 id="의존성-추가하기"><a class="header" href="#의존성-추가하기">의존성 추가하기</a></h2>
<p><code>Cargo.toml</code> 에 아직 <code>[dependencies]</code> 섹션이 없으면 추가한 다음 사용하려는 [크레이트](../appendix/glossary.md#crate “크레이트” (용어집 항목)“) 이름과 버전을 나열하세요. 이 예에서는 <code>time</code> 크레이트에 대한 의존성을 추가합니다:</p>
<pre><code class="language-toml">[dependencies]
time = "0.1.12"
</code></pre>
<p>버전 문자열은 <a href="https://semver.org">SemVer</a> 버전 요구 사항입니다. <a href="guide/../reference/specifying-dependencies.html">의존성 지정하기</a> 문서에서 여기에 있는 옵션에 대한 자세한 정보를 확인할 수 있습니다.</p>
<p><code>regex</code> 크레이트에 대한 의존성도 추가하려면 나열된 각 크레이트에 대해 <code>[dependencies]</code> 를 추가할 필요가 없습니다. <code>time</code> 및 <code>regex</code> 크레이트에 대한 의존성이 있는 전체 <code>Cargo.toml</code> 파일은 다음과 같습니다:</p>
<pre><code class="language-toml">[package]
name = "hello_world"
version = "0.1.0"
edition = "2024"

[dependencies]
time = "0.1.12"
regex = "0.1.41"
</code></pre>
<p><code>cargo build</code> 를 다시 실행하면 Cargo가 새 의존성과 모든 의존성을 가져와 모두 컴파일하고 <code>Cargo.lock</code> 을 업데이트합니다:</p>
<pre><code class="language-console">$ cargo build
      Updating crates.io index
   Downloading memchr v0.1.5
   Downloading libc v0.1.10
   Downloading regex-syntax v0.2.1
   Downloading memchr v0.1.5
   Downloading aho-corasick v0.3.0
   Downloading regex v0.1.41
     Compiling memchr v0.1.5
     Compiling libc v0.1.10
     Compiling regex-syntax v0.2.1
     Compiling memchr v0.1.5
     Compiling aho-corasick v0.3.0
     Compiling regex v0.1.41
     Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
</code></pre>
<p><code>Cargo.lock</code> 에는 이러한 모든 의존성에 사용된 리비전에 대한 정확한 정보가 포함되어 있습니다.</p>
<p>이제 <code>regex</code> 가 업데이트되더라도 <code>cargo update</code> 를 실행하기로 선택할 때까지 동일한 리비전으로 빌드됩니다.</p>
<p>이제 <code>main.rs</code> 에서 <code>regex</code> 라이브러리를 사용할 수 있습니다.</p>
<pre><code class="language-rust ignore">use regex::Regex;

fn main() {
    let re = Regex::new(r"^\d{4}-\d{2}-\d{2}$").unwrap();
    println!("Did our date match? {}", re.is_match("2014-01-01"));
}</code></pre>
<p>실행하면 다음과 같이 표시됩니다:</p>
<pre><code class="language-console">$ cargo run
   Running `target/hello_world`
Did our date match? true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="패키지-레이아웃"><a class="header" href="#패키지-레이아웃">패키지 레이아웃</a></h1>
<p>Cargo는 파일 배치에 대한 규칙을 사용하여 새로운 Cargo [패키지](../appendix/glossary.md#package “패키지” (용어집 항목)“)에 쉽게 뛰어들 수 있도록 합니다:</p>
<pre><code class="language-text">.
├── Cargo.lock
├── Cargo.toml
├── src/
│   ├── lib.rs
│   ├── main.rs
│   └── bin/
│       ├── named-executable.rs
│       ├── another-executable.rs
│       └── multi-file-executable/
│           ├── main.rs
│           └── some_module.rs
├── benches/
│   ├── large-input.rs
│   └── multi-file-bench/
│       ├── main.rs
│       └── bench_module.rs
├── examples/
│   ├── simple.rs
│   └── multi-file-example/
│       ├── main.rs
│       └── ex_module.rs
└── tests/
    ├── some-integration-tests.rs
    └── multi-file-test/
        ├── main.rs
        └── test_module.rs
</code></pre>
<ul>
<li><code>Cargo.toml</code> 과 <code>Cargo.lock</code> 은 패키지의 루트(<em>패키지 루트</em>)에 저장됩니다.</li>
<li>소스 코드는 <code>src</code> 디렉토리에 있습니다.</li>
<li>기본 라이브러리 파일은 <code>src/lib.rs</code> 입니다.</li>
<li>기본 실행 파일은 <code>src/main.rs</code> 입니다.
<ul>
<li>다른 실행 파일은 <code>src/bin/</code> 에 넣을 수 있습니다.</li>
</ul>
</li>
<li>벤치마크는 <code>benches</code> 디렉토리에 있습니다.</li>
<li>예제는 <code>examples</code> 디렉토리에 있습니다.</li>
<li>통합 테스트는 <code>tests</code> 디렉토리에 있습니다.</li>
</ul>
<p>바이너리, 예제, 벤치 또는 통합 테스트가 여러 소스 파일로 구성된 경우 <code>src/bin</code>, <code>examples</code>, <code>benches</code> 또는 <code>tests</code> 디렉토리의 하위 디렉토리 내에 추가 <a href="guide/../appendix/glossary.html#module" title="&quot;모듈&quot; (용어집 항목)"><em>모듈</em></a>과 함께 <code>main.rs</code> 파일을 배치하세요. 실행 파일의 이름은 디렉토리 이름이 됩니다.</p>
<blockquote>
<p><strong>Note:</strong> By convention, binaries, examples, benches and integration tests follow <code>kebab-case</code> naming style, unless there are compatibility reasons to do otherwise (e.g. compatibility with a pre-existing binary name). Modules within those targets are <code>snake_case</code> following the <a href="https://rust-lang.github.io/rfcs/0430-finalizing-naming-conventions.html">Rust standard</a>.</p>
</blockquote>
<p>Rust의 모듈 시스템에 대한 자세한 내용은 <a href="guide/../../book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">책</a> 에서 배울 수 있습니다.</p>
<p>수동으로 타겟을 구성하는 방법에 대한 자세한 내용은 <a href="guide/../reference/cargo-targets.html#configuring-a-target">타겟 구성하기</a>를 참조하세요. Cargo가 타겟 이름을 자동으로 유추하는 방법을 제어하는 방법에 대한 자세한 내용은 <a href="guide/../reference/cargo-targets.html#target-auto-discovery">타겟 자동 검색</a>을 참조하세요.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargotoml-vs-cargolock"><a class="header" href="#cargotoml-vs-cargolock">Cargo.toml vs Cargo.lock</a></h1>
<p><code>Cargo.toml</code> 과 <code>Cargo.lock</code> 은 두 가지 다른 목적을 가지고 있습니다. 그것들에 대해 이야기하기 전에 요약은 다음과 같습니다:</p>
<ul>
<li><code>Cargo.toml</code> 은 넓은 의미에서 의존성을 설명하는 것이며, 당신이 작성합니다.</li>
<li><code>Cargo.lock</code> 은 의존성에 대한 정확한 정보를 포함합니다. Cargo에 의해 유지 관리되며 수동으로 편집해서는 안 됩니다.</li>
</ul>
<p>확실하지 않은 경우 <code>Cargo.lock</code> 을 버전 관리 시스템(예: Git)에 체크인하세요. 이유와 대안이 무엇인지 더 잘 이해하려면 FAQ의 <a href="guide/../faq.html#why-have-cargolock-in-version-control">“왜 Cargo.lock을 버전 관리에 두어야 하나요?”</a> 를 참조하세요. 이것을 <a href="guide/continuous-integration.html#verifying-latest-dependencies">최신 의존성 확인</a> 과 함께 사용하는 것을 권장합니다.</p>
<p>조금 더 자세히 알아봅시다.</p>
<p><code>Cargo.toml</code> 은 패키지에 대한 다양한 메타데이터를 지정할 수 있는 [<strong>매니페스트</strong>](../appendix/glossary.md#manifest “매니페스트” (용어집 항목)“) 파일입니다. 예를 들어, 다른 패키지에 의존한다고 말할 수 있습니다:</p>
<pre><code class="language-toml">[package]
name = "hello_world"
version = "0.1.0"

[dependencies]
regex = { git = "https://github.com/rust-lang/regex.git" }
</code></pre>
<p>이 패키지는 <code>regex</code> 라이브러리에 대한 단일 의존성을 가지고 있습니다. 이 경우 GitHub에 있는 특정 Git 저장소에 의존한다고 명시합니다. 다른 정보를 지정하지 않았으므로 Cargo는 기본 브랜치의 최신 커밋을 사용하여 패키지를 빌드하려는 것으로 가정합니다.</p>
<p>좋게 들리나요? 음, 한 가지 문제가 있습니다. 오늘 이 패키지를 빌드하고 내일 저에게 사본을 보내면 제가 내일 이 패키지를 빌드할 때 나쁜 일이 일어날 수 있습니다. 그 사이에 <code>regex</code> 에 더 많은 커밋이 있을 수 있으며, 제 빌드에는 새 커밋이 포함되지만 당신의 빌드에는 포함되지 않을 것입니다. 따라서 우리는 다른 빌드를 얻게 될 것입니다. 이것은 재현 가능한 빌드를 원하기 때문에 나쁜 일입니다.</p>
<p><code>Cargo.toml</code> 에 특정 <code>rev</code> 값을 정의하여 이 문제를 해결할 수 있습니다. 그러면 Cargo가 패키지를 빌드할 때 사용할 리비전을 정확히 알 수 있습니다:</p>
<pre><code class="language-toml">[dependencies]
regex = { git = "https://github.com/rust-lang/regex.git", rev = "9f9f693" }
</code></pre>
<p>이제 우리의 빌드는 동일할 것입니다. 그러나 큰 단점이 있습니다. 이제 라이브러리를 업데이트할 때마다 수동으로 SHA-1을 생각해야 합니다. 이것은 지루하고 오류가 발생하기 쉽습니다.</p>
<p><code>Cargo.lock</code> 을 입력하세요. 그것의 존재 때문에 정확한 리비전을 수동으로 추적할 필요가 없습니다. Cargo가 대신 해줄 것입니다. 다음과 같은 매니페스트가 있을 때:</p>
<pre><code class="language-toml">[package]
name = "hello_world"
version = "0.1.0"

[dependencies]
regex = { git = "https://github.com/rust-lang/regex.git" }
</code></pre>
<p>Cargo는 최신 커밋을 가져와 처음 빌드할 때 해당 정보를 <code>Cargo.lock</code> 에 씁니다. 해당 파일은 다음과 같습니다:</p>
<pre><code class="language-toml">[[package]]
name = "hello_world"
version = "0.1.0"
dependencies = [
 "regex 1.5.0 (git+https://github.com/rust-lang/regex.git#9f9f693768c584971a4d53bc3c586c33ed3a6831)",
]

[[package]]
name = "regex"
version = "1.5.0"
source = "git+https://github.com/rust-lang/regex.git#9f9f693768c584971a4d53bc3c586c33ed3a6831"
</code></pre>
<p>빌드에 사용한 정확한 리비전을 포함하여 여기에 훨씬 더 많은 정보가 있음을 알 수 있습니다. 이제 다른 사람에게 패키지를 줄 때 <code>Cargo.toml</code> 에 지정하지 않았더라도 정확히 동일한 SHA를 사용하게 됩니다.</p>
<p>라이브러리의 새 버전을 사용하기로 결정할 준비가 되면 Cargo가 의존성을 다시 계산하고 업데이트할 수 있습니다:</p>
<pre><code class="language-console">$ cargo update         # updates all dependencies
$ cargo update regex   # updates just “regex”
</code></pre>
<p>이렇게 하면 새 버전 정보가 포함된 새 <code>Cargo.lock</code> 이 작성됩니다. <code>cargo update</code> 에 대한 인수는 실제로 <a href="guide/../reference/pkgid-spec.html">패키지 ID 명세</a> 이며 <code>regex</code> 는 짧은 명세일 뿐입니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="테스트"><a class="header" href="#테스트">테스트</a></h1>
<p>Cargo는 <code>cargo test</code> 명령어로 테스트를 실행할 수 있습니다. Cargo는 두 곳에서 실행할 테스트를 찾습니다: 각 <code>src</code> 파일과 <code>tests/</code> 의 모든 테스트. <code>src</code> 파일의 테스트는 단위 테스트와 <a href="guide/../../rustdoc/write-documentation/documentation-tests.html">문서 테스트</a> 여야 합니다. <code>tests/</code> 의 테스트는 통합 스타일 테스트여야 합니다. 따라서 <code>tests</code> 의 파일로 크레이트를 가져와야 합니다.</p>
<p>현재 테스트가 없는 <a href="guide/../appendix/glossary.html#package" title="&quot;패키지&quot; (용어집 항목)">패키지</a>에서 <code>cargo test</code> 를 실행하는 예는 다음과 같습니다:</p>
<pre><code class="language-console">$ cargo test
   Compiling regex v1.5.0 (https://github.com/rust-lang/regex.git#9f9f693)
   Compiling hello_world v0.1.0 (file:///path/to/package/hello_world)
     Running target/test/hello_world-9c2b65bbb79eabce

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
</code></pre>
<p>패키지에 테스트가 있었다면 올바른 수의 테스트와 함께 더 많은 출력이 표시되었을 것입니다.</p>
<p>필터를 전달하여 특정 테스트를 실행할 수도 있습니다:</p>
<pre><code class="language-console">$ cargo test foo
</code></pre>
<p>이것은 이름에 <code>foo</code> 가 있는 모든 테스트를 실행합니다.</p>
<p><code>cargo test</code> 는 추가 검사도 실행합니다. 포함된 모든 예제를 컴파일하여 여전히 컴파일되는지 확인합니다. 또한 문서 주석의 코드 샘플이 컴파일되는지 확인하기 위해 문서 테스트를 실행합니다. 테스트 작성 및 구성에 대한 일반적인 내용은 Rust 문서의 <a href="guide/../../book/ch11-00-testing.html">테스팅 가이드</a> 를 참조하세요. Cargo의 다양한 테스트 스타일에 대해 자세히 알아보려면 <a href="guide/../reference/cargo-targets.html#tests">Cargo 타겟: 테스트</a> 를 참조하세요.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="지속적-통합"><a class="header" href="#지속적-통합">지속적 통합</a></h1>
<h2 id="시작하기-1"><a class="header" href="#시작하기-1">시작하기</a></h2>
<p>기본 CI는 프로젝트를 빌드하고 테스트합니다:</p>
<h3 id="github-actions"><a class="header" href="#github-actions">GitHub Actions</a></h3>
<p>GitHub Actions에서 패키지를 테스트하려면 다음은 샘플 <code>.github/workflows/ci.yml</code> 파일입니다:</p>
<pre><code class="language-yaml">name: Cargo 빌드 및 테스트

on:
  push:
  pull_request:

env: 
  CARGO_TERM_COLOR: always

jobs:
  build_and_test:
    name: Rust 프로젝트 - 최신
    runs-on: ubuntu-latest
    strategy:
      matrix:
        toolchain:
          - stable
          - beta
          - nightly
    steps:
      - uses: actions/checkout@v4
      - run: rustup update ${{ matrix.toolchain }} &amp;&amp; rustup default ${{ matrix.toolchain }}
      - run: cargo build --verbose
      - run: cargo test --verbose
  
</code></pre>
<p>이렇게 하면 세 개의 릴리스 채널을 모두 테스트합니다(툴체인 버전 중 하나라도 실패하면 전체 작업이 실패합니다). GitHub UI에서 <code>"Actions" &gt; "new workflow"</code> 를 클릭하고 Rust를 선택하여 <a href="https://github.com/actions/starter-workflows/blob/main/ci/rust.yml">기본 구성</a>을 저장소에 추가할 수도 있습니다. 자세한 내용은 <a href="https://docs.github.com/en/actions">GitHub Actions 문서</a> 를 참조하세요.</p>
<h3 id="gitlab-ci"><a class="header" href="#gitlab-ci">GitLab CI</a></h3>
<p>GitLab CI에서 패키지를 테스트하려면 다음은 샘플 <code>.gitlab-ci.yml</code> 파일입니다:</p>
<pre><code class="language-yaml">stages:
  - build

rust-latest:
  stage: build
  image: rust:latest
  script:
    - cargo build --verbose
    - cargo test --verbose

rust-nightly:
  stage: build
  image: rustlang/rust:nightly
  script:
    - cargo build --verbose
    - cargo test --verbose
  allow_failure: true
</code></pre>
<p>이렇게 하면 안정 채널과 나이틀리 채널에서 테스트하지만 나이틀리의 모든 중단은 전체 빌드를 실패시키지 않습니다. 자세한 내용은 <a href="https://docs.gitlab.com/ce/ci/yaml/index.html">GitLab CI 문서</a> 를 참조하세요.</p>
<h3 id="buildssrht"><a class="header" href="#buildssrht">builds.sr.ht</a></h3>
<p>sr.ht에서 패키지를 테스트하려면 다음은 샘플 <code>.build.yml</code> 파일입니다. <code>&lt;your repo&gt;</code> 와 <code>&lt;your project&gt;</code> 를 복제할 저장소와 복제된 디렉토리로 변경해야 합니다.</p>
<pre><code class="language-yaml">image: archlinux
packages:
  - rustup
sources:
  - &lt;your repo&gt;
tasks:
  - setup: |
      rustup toolchain install nightly stable
      cd &lt;your project&gt;/
      rustup run stable cargo fetch
  - stable: |
      rustup default stable
      cd &lt;your project&gt;/
      cargo build --verbose
      cargo test --verbose
  - nightly: |
      rustup default nightly
      cd &lt;your project&gt;/
      cargo build --verbose ||:
      cargo test --verbose  ||:
  - docs: |
      cd &lt;your project&gt;/
      rustup run stable cargo doc --no-deps
      rustup run nightly cargo doc --no-deps ||:
</code></pre>
<p>이렇게 하면 안정 채널과 나이틀리 채널에서 문서를 테스트하고 빌드하지만 나이틀리의 모든 중단은 전체 빌드를 실패시키지 않습니다. 자세한 내용은 <a href="https://man.sr.ht/builds.sr.ht/">builds.sr.ht 문서</a> 를 참조하세요.</p>
<h3 id="circleci"><a class="header" href="#circleci">CircleCI</a></h3>
<p>CircleCI에서 패키지를 테스트하려면 다음은 샘플 <code>.circleci/config.yml</code> 파일입니다:</p>
<pre><code class="language-yaml">version: 2.1
jobs:
  build:
    docker:
      # 최신 정보는 https://circleci.com/developer/images/image/cimg/rust#image-tags를 확인하세요
      - image: cimg/rust:1.77.2
    steps:
      - checkout
      - run: cargo test
</code></pre>
<p>불안정한 테스트 감지, 캐싱 및 산출물 관리를 포함한 더 복잡한 파이프라인을 실행하려면 <a href="https://circleci.com/docs/configuration-reference/">CircleCI 구성 참조</a>를 참조하세요.</p>
<h2 id="최신-의존성-확인"><a class="header" href="#최신-의존성-확인">최신 의존성 확인</a></h2>
<p><code>Cargo.toml</code> 에서 <a href="guide/../reference/specifying-dependencies.html">의존성을 지정할 때</a> 일반적으로 버전 범위와 일치합니다. 모든 버전 조합을 철저히 테스트하는 것은 번거로울 것입니다. 최신 버전을 확인하면 최소한 <a href="guide/../commands/cargo-add.html"><code>cargo add</code></a> 또는 <a href="guide/../commands/cargo-install.html"><code>cargo install</code></a> 을 실행하는 사용자에 대해 테스트할 수 있습니다.</p>
<p>최신 버전을 테스트할 때 고려해야 할 몇 가지 사항은 다음과 같습니다:</p>
<ul>
<li>로컬 개발 또는 CI에 영향을 미치는 외부 요인 최소화</li>
<li>새로운 의존성이 게시되는 속도</li>
<li>프로젝트가 수용할 의향이 있는 위험 수준</li>
<li>CI 서비스에 병렬 실행기에 대한 최대값이 있어 최대값에 도달하면 새 작업이 직렬화되는 것과 같은 간접 비용을 포함한 CI 비용.</li>
</ul>
<p>몇 가지 잠재적인 해결책은 다음과 같습니다:</p>
<ul>
<li><a href="guide/../faq.html#why-have-cargolock-in-version-control"><code>Cargo.lock</code> 을 체크인하지 않기</a>
<ul>
<li>PR 속도에 따라 많은 버전이 테스트되지 않을 수 있습니다.</li>
<li>이것은 결정성을 희생시킵니다.</li>
</ul>
</li>
<li>최신 의존성을 확인하는 CI 작업을 수행하되 “실패 시 계속“으로 표시합니다.
<ul>
<li>CI 서비스에 따라 실패가 명확하지 않을 수 있습니다.</li>
<li>PR 속도에 따라 필요 이상으로 많은 리소스를 사용할 수 있습니다.</li>
</ul>
</li>
<li>최신 의존성을 확인하기 위해 예약된 CI 작업을 수행합니다.
<ul>
<li>호스팅된 CI 서비스는 한동안 건드리지 않은 저장소에 대해 예약된 작업을 비활성화하여 수동적으로 유지 관리되는 패키지에 영향을 줄 수 있습니다.호스팅된 CI 서비스는 한동안 건드리지 않은 저장소에 대해 예약된 작업을 비활성화하여 수동적으로 유지 관리되는 패키지에 영향을 줄 수 있습니다.</li>
<li>CI 서비스에 따라 실패에 대해 조치를 취할 수 있는 사람들에게 알림이 전달되지 않을 수 있습니다.</li>
<li>의존성 게시 속도와 균형을 이루지 않으면 충분한 버전을 테스트하지 못하거나 중복 테스트를 수행할 수 있습니다.</li>
</ul>
</li>
<li><a href="https://docs.github.com/en/code-security/dependabot/working-with-dependabot">Dependabot</a> 또는 <a href="https://renovatebot.com/">RenovateBot</a> 과 같이 PR을 통해 정기적으로 의존성을 업데이트합니다.
<ul>
<li>의존성을 자체 PR로 격리하거나 단일 PR로 롤업할 수 있습니다.</li>
<li>필요한 리소스만 사용합니다.</li>
<li>CI 리소스와 의존성 버전의 적용 범위를 균형 있게 조정하기 위해 빈도를 구성할 수 있습니다.</li>
</ul>
</li>
</ul>
<p>GitHub Actions를 사용하여 최신 의존성을 확인하는 CI 작업의 예:</p>
<pre><code class="language-yaml">jobs:
  latest_deps:
    name: 최신 의존성
    runs-on: ubuntu-latest
    continue-on-error: true
    env:
      CARGO_RESOLVER_INCOMPATIBLE_RUST_VERSIONS: allow
    steps:
      - uses: actions/checkout@v4
      - run: rustup update stable &amp;&amp; rustup default stable
      - run: cargo update --verbose
      - run: cargo build --verbose
      - run: cargo test --verbose
</code></pre>
<p>참고:</p>
<ul>
<li><a href="guide/../reference/config.html#resolverincompatible-rust-versions"><code>CARGO_RESOLVER_INCOMPATIBLE_RUST_VERSIONS</code></a> 는 <a href="guide/../reference/resolver.html">리졸버</a> 가 프로젝트의 <a href="guide/../reference/rust-version.html">Rust 버전</a> 때문에 선택된 의존성을 제한하지 않도록 설정됩니다.</li>
</ul>
<p>플랫폼별 또는 Rust 버전별 실패 위험이 높은 프로젝트의 경우 더 많은 조합을 테스트하는 것이 좋습니다.</p>
<h2 id="rust-version-확인"><a class="header" href="#rust-version-확인"><code>rust-version</code> 확인</a></h2>
<p><a href="guide/../reference/manifest.html#the-rust-version-field"><code>rust-version</code></a> 을 지정하는 패키지를 게시할 때 해당 필드의 정확성을 확인하는 것이 중요합니다.</p>
<p>이에 도움이 될 수 있는 일부 타사 도구는 다음과 같습니다:</p>
<ul>
<li><a href="https://crates.io/crates/cargo-msrv"><code>cargo-msrv</code></a></li>
<li><a href="https://crates.io/crates/cargo-hack"><code>cargo-hack</code></a></li>
</ul>
<p>GitHub Actions를 사용하여 이 작업을 수행하는 한 가지 방법의 예:</p>
<pre><code class="language-yaml">jobs:
  msrv:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
    - uses: taiki-e/install-action@cargo-hack
    - run: cargo hack check --rust-version --workspace --all-targets --ignore-private
</code></pre>
<p>이것은 철저함과 처리 시간의 균형을 맞추려고 합니다:</p>
<ul>
<li>대부분의 프로젝트는 플랫폼에 구애받지 않으므로 단일 플랫폼이 사용되며, 플랫폼별 의존성이 동작을 확인하도록 신뢰합니다.</li>
<li>대부분의 기여자가 겪게 될 문제는 동작이 아닌 API 가용성이므로 <code>cargo check</code> 가 사용됩니다.</li>
<li>게시되지 않은 패키지는 레지스트리를 통해 확인된 프로젝트의 소비자만이 <code>rust-version</code> 에 관심을 가질 것이라고 가정하므로 건너뜁니다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cratesio에-게시하기"><a class="header" href="#cratesio에-게시하기">crates.io에 게시하기</a></h1>
<p>세상과 공유하고 싶은 라이브러리가 생겼다면 이제 <a href="https://crates.io/">crates.io</a> 에 게시할 시간입니다! 크레이트를 게시한다는 것은 특정 버전을 <a href="https://crates.io/">crates.io</a> 에 호스팅하기 위해 업로드하는 것입니다.</p>
<p>크레이트를 게시할 때는 주의하세요. 게시는 <strong>영구적</strong> 이기 때문입니다. 버전은 덮어쓸 수 없으며 코드는 삭제할 수 없습니다. 그러나 게시할 수 있는 버전 수에는 제한이 없습니다.</p>
<h2 id="첫-게시-전"><a class="header" href="#첫-게시-전">첫 게시 전</a></h2>
<p>먼저 API 토큰을 얻으려면 <a href="https://crates.io/">crates.io</a> 에 계정이 필요합니다. 그렇게 하려면 <a href="https://crates.io/">홈페이지를 방문</a> 하여 GitHub 계정을 통해 로그인하세요(현재 필수). 또한 <a href="https://crates.io/settings/profile">계정 설정</a> 페이지에서 이메일 주소를 제공하고 확인해야 합니다. 완료되면 <a href="https://crates.io/settings/tokens">API 토큰을 생성</a>하고 복사해야 합니다. 페이지를 떠나면 다시 볼 수 없습니다.</p>
<p>그런 다음 <a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> 명령어를 실행하세요.</p>
<pre><code class="language-console">$ cargo login
</code></pre>
<p>그런 다음 프롬프트에 지정된 토큰을 입력하세요.</p>
<pre><code class="language-console">please paste the API Token found on https://crates.io/me below
abcdefghijklmnopqrstuvwxyz012345
</code></pre>
<p>이 명령어는 Cargo에 API 토큰을 알리고 로컬의 <code>~/.cargo/credentials.toml</code> 에 저장합니다. 이 토큰은 <strong>비밀</strong> 이며 다른 사람과 공유해서는 안 됩니다. 어떤 이유로든 유출되면 즉시 해지해야 합니다.</p>
<blockquote>
<p><strong>참고</strong>: <a href="reference/../commands/cargo-logout.html"><code>cargo logout</code></a> 명령어를 사용하여 <code>credentials.toml</code> 에서 토큰을 제거할 수 있습니다. 로컬 컴퓨터에 더 이상 저장할 필요가 없는 경우 유용할 수 있습니다.</p>
</blockquote>
<h2 id="새-크레이트-게시-전"><a class="header" href="#새-크레이트-게시-전">새 크레이트 게시 전</a></h2>
<p><a href="https://crates.io/">crates.io</a> 의 크레이트 이름은 선착순으로 할당된다는 점을 명심하세요. 크레이트 이름이 사용되면 다른 크레이트에 사용할 수 없습니다.</p>
<p><code>Cargo.toml</code> 에서 <a href="reference/manifest.html">지정할 수 있는 메타데이터</a> 를 확인하여 크레이트를 더 쉽게 찾을 수 있도록 하세요! 게시하기 전에 다음 필드를 채웠는지 확인하세요:</p>
<ul>
<li><a href="reference/manifest.html#the-license-and-license-file-fields"><code>license</code> 또는 <code>license-file</code></a></li>
<li><a href="reference/manifest.html#the-description-field"><code>설명</code></a></li>
<li><a href="reference/manifest.html#the-homepage-field"><code>홈페이지</code></a></li>
<li><a href="reference/manifest.html#the-repository-field"><code>저장소</code></a></li>
<li><a href="reference/manifest.html#the-readme-field"><code>README</code></a></li>
</ul>
<p>필수는 아니지만 <a href="reference/manifest.html#the-keywords-field"><code>keywords</code></a> 및 <a href="reference/manifest.html#the-categories-field"><code>categories</code></a> 를 포함하는 것도 좋은 생각입니다.</p>
<p>라이브러리를 게시하는 경우 <a href="https://rust-lang.github.io/api-guidelines/">Rust API 가이드라인</a> 을 참조할 수도 있습니다.</p>
<h3 id="크레이트-패키징하기"><a class="header" href="#크레이트-패키징하기">크레이트 패키징하기</a></h3>
<p>다음 단계는 크레이트를 패키징하여 <a href="https://crates.io/">crates.io</a> 에 업로드하는 것입니다. 이를 위해 <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> 하위 명령을 사용합니다. 이 명령어는 다음 단계를 수행합니다:</p>
<ol>
<li>패키지에 대한 일부 검증 검사를 수행합니다.</li>
<li>소스 코드를 <code>.crate</code> 파일로 압축합니다.</li>
<li>.crate` 파일을 임시 디렉토리에 추출하고 컴파일되는지 확인합니다.</li>
<li><code>.crate</code> 파일을 <a href="https://crates.io/">crates.io</a> 에 업로드합니다.</li>
<li>레지스트리는 업로드된 패키지를 추가하기 전에 몇 가지 추가 검사를 수행합니다.</li>
</ol>
<p>게시하기 전에 경고나 오류가 없는지 확인하기 위해 먼저 <code>cargo publish --dry-run</code>(또는 동등한 <a href="reference/../commands/cargo-package.html"><code>cargo package</code></a>)을 실행하는 것이 좋습니다. 이렇게 하면 위에 나열된 처음 세 단계가 수행됩니다.</p>
<pre><code class="language-console">$ cargo publish --dry-run
</code></pre>
<p>생성된 <code>.crate</code> 파일은 <code>target/package</code> 디렉토리에서 검사할 수 있습니다. <a href="https://crates.io/">crates.io</a> 는 현재 <code>.crate</code> 파일에 10MB 크기 제한이 있습니다. <code>.crate</code> 파일의 크기를 확인하여 테스트 데이터, 웹사이트 문서 또는 코드 생성과 같이 패키지를 빌드하는 데 필요하지 않은 큰 자산을 실수로 패키징하지 않았는지 확인할 수 있습니다. 다음 명령으로 포함된 파일을 확인할 수 있습니다.</p>
<pre><code class="language-console">$ cargo package --list
</code></pre>
<p>Cargo는 패키징할 때 버전 관리 시스템에서 무시된 파일을 자동으로 무시하지만, 무시할 추가 파일 집합을 지정하려면 매니페스트에서 <a href="reference/manifest.html#the-exclude-and-include-fields"><code>exclude</code> 키</a> 를 사용할 수 있습니다.</p>
<pre><code class="language-toml">[package]
# ...
exclude = [
    "public/assets/*",
    "videos/*",
]
</code></pre>
<p>If you’d rather explicitly list the files to include, Cargo also supports an <a href="reference/manifest.html#the-exclude-and-include-fields"><code>include</code> key</a>, which if set, overrides the <code>exclude</code> key:</p>
<pre><code class="language-toml">[package]
# ...
include = [
    "**/*.rs",
]
</code></pre>
<h2 id="크레이트-업로드하기"><a class="header" href="#크레이트-업로드하기">크레이트 업로드하기</a></h2>
<p>게시할 준비가 되면 <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> 명령을 사용하여 <a href="https://crates.io/">crates.io</a> 에 업로드합니다.</p>
<pre><code class="language-console">$ cargo publish
</code></pre>
<p>이것으로 첫 번째 크레이트를 게시했습니다!</p>
<h2 id="기존-크레이트의-새-버전-게시하기"><a class="header" href="#기존-크레이트의-새-버전-게시하기">기존 크레이트의 새 버전 게시하기</a></h2>
<p>새 버전을 릴리스하려면 <code>Cargo.toml</code> 매니페스트에 지정된 <a href="reference/manifest.html#the-version-field"><code>version</code> 값</a> 을 변경하세요. 호환되는 변경 사항이 무엇인지에 대한 지침을 제공하는 <a href="reference/semver.html">SemVer 규칙</a> 을 염두에 두세요. 그런 다음 위에서 설명한 대로 <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> 를 실행하여 새 버전을 업로드하세요.</p>
<blockquote>
<p><strong>권장 사항:</strong> 전체 릴리스 프로세스를 고려하고 가능한 한 자동화하세요.</p>
<p>각 버전에는 다음이 포함되어야 합니다:</p>
<ul>
<li>변경 로그 항목, <a href="https://keepachangelog.com/en/1.0.0/">수동으로 관리</a> 하는 것이 좋지만 생성된 것이 없는 것보다는 낫습니다.</li>
<li>게시된 커밋을 가리키는 <a href="https://git-scm.com/book/en/v2/Git-Basics-Tagging">git 태그</a></li>
</ul>
<p>다양한 워크플로를 대표하는 타사 도구의 예는 다음과 같습니다(알파벳순):</p>
<ul>
<li><a href="https://crates.io/crates/cargo-release">cargo-release</a></li>
<li><a href="https://crates.io/crates/cargo-smart-release">cargo-smart-release</a></li>
<li><a href="https://crates.io/crates/release-plz">release-plz</a></li>
</ul>
<p>자세한 내용은 <a href="https://crates.io/search?q=cargo%20release">crates.io</a> 를 참조하세요.</p>
</blockquote>
<h2 id="cratesio-기반-크레이트-관리하기"><a class="header" href="#cratesio-기반-크레이트-관리하기">crates.io 기반 크레이트 관리하기</a></h2>
<p>크레이트 관리는 주로 <a href="https://crates.io/">crates.io</a> 웹 인터페이스보다는 명령줄 <code>cargo</code> 도구를 통해 이루어집니다. 이를 위해 크레이트를 관리하는 몇 가지 하위 명령이 있습니다.</p>
<h3 id="cargo-yank"><a class="header" href="#cargo-yank"><code>cargo yank</code></a></h3>
<p>구문 오류, 파일 포함 누락 등 여러 가지 이유로 인해 크레이트 버전이 손상되는 경우가 발생할 수 있습니다. 이러한 상황을 위해 Cargo는 크레이트 버전의 “yank”를 지원합니다.</p>
<pre><code class="language-console">$ cargo yank --version 1.0.1
$ cargo yank --version 1.0.1 --undo
</code></pre>
<p>yank는 코드를 삭제하지 <strong>않습니다</strong>. 이 기능은 실수로 업로드된 비밀을 삭제하기 위한 것이 아닙니다. 예를 들어, 그런 일이 발생하면 즉시 해당 비밀을 재설정해야 합니다.</p>
<p>yank된 버전의 의미는 해당 버전에 대해 새로운 의존성을 생성할 수 없지만, 기존의 모든 의존성은 계속 작동한다는 것입니다. <a href="https://crates.io/">crates.io</a> 의 주요 목표 중 하나는 시간이 지나도 변경되지 않는 크레이트의 영구 아카이브 역할을 하는 것이며, 버전 삭제를 허용하는 것은 이 목표에 위배됩니다. 본질적으로 yank는 <code>Cargo.lock</code> 이 있는 모든 패키지는 손상되지 않지만, 향후 생성될 <code>Cargo.lock</code> 파일에는 yank된 버전이 나열되지 않음을 의미합니다.</p>
<h3 id="cargo-owner"><a class="header" href="#cargo-owner"><code>cargo owner</code></a></h3>
<p>크레이트는 종종 한 명 이상의 개발자가 개발하거나, 주 유지보수자가 시간이 지남에 따라 변경될 수 있습니다! 크레이트 소유자는 크레이트의 새 버전을 게시할 수 있는 유일한 사람이지만, 소유자는 추가 소유자를 지정할 수 있습니다.</p>
<pre><code class="language-console">$ cargo owner --add github-handle
$ cargo owner --remove github-handle
$ cargo owner --add github:rust-lang:owners
$ cargo owner --remove github:rust-lang:owners
</code></pre>
<p>이 명령에 제공되는 소유자 ID는 GitHub 사용자 이름 또는 GitHub 팀이어야 합니다.</p>
<p><code>--add</code> 에 사용자 이름이 주어지면 해당 사용자는 크레이트에 대한 모든 권한을 가진 “지정된” 소유자로 초대됩니다. 크레이트 버전을 게시하거나 yank할 수 있을 뿐만 아니라, 소유자를 추가하거나 제거할 수 있으며, <em>자신을</em> 소유자로 만든 소유자도 포함됩니다. 말할 필요도 없이, 완전히 신뢰하지 않는 사람을 지정된 소유자로 만들어서는 안 됩니다. 지정된 소유자가 되려면 사용자는 이전에 <a href="https://crates.io/">crates.io</a> 에 로그인해야 합니다.</p>
<p><code>--add</code> 에 팀 이름이 주어지면 해당 팀은 크레이트에 대한 제한된 권한을 가진 “팀” 소유자로 초대됩니다. 이들은 크레이트 버전을 게시하거나 yank할 수 있는 권한은 있지만, 소유자를 추가하거나 제거할 수 있는 권한은 <em>없습니다</em>. 소유자 그룹을 관리하는 데 더 편리할 뿐만 아니라, 팀은 소유자가 악의적으로 변하는 것에 대해 약간 더 안전합니다.</p>
<p>팀에 대한 구문은 현재 <code>github:org:team</code> 입니다(위 예시 참조). 팀을 소유자로 초대하려면 해당 팀의 구성원이어야 합니다. 팀을 소유자에서 제거하는 데는 이러한 제한이 적용되지 않습니다.</p>
<h2 id="github-권한"><a class="header" href="#github-권한">GitHub 권한</a></h2>
<p>팀 멤버십은 GitHub에서 간단한 공개 액세스를 제공하는 것이 아니므로, 팀과 작업할 때 다음 메시지를 만날 가능성이 높습니다:</p>
<blockquote>
<p>이 요청을 완료하는 데 필요한 속성을 GitHub에서 쿼리할 권한이 없는 것 같습니다. GitHub 조직 멤버십을 읽을 권한을 부여하려면 <a href="https://crates.io/">crates.io</a> 에서 다시 인증해야 할 수 있습니다.</p>
</blockquote>
<p>이것은 기본적으로 “팀을 쿼리하려고 했지만, 멤버십 액세스 제어의 다섯 가지 수준 중 하나가 이를 거부했습니다”에 대한 포괄적인 설명입니다. 과장이 아닙니다. GitHub의 팀 액세스 제어 지원은 엔터프라이즈 등급입니다.</p>
<p>가장 가능성이 높은 원인은 이 기능이 추가되기 전에 마지막으로 로그인했기 때문입니다. 우리는 원래 사용자 인증 시 GitHub에 <em>어떤</em> 권한도 요청하지 않았습니다. 왜냐하면 사용자 토큰을 로그인 외에는 사용하지 않았기 때문입니다. 그러나 이제 사용자를 대신하여 팀 멤버십을 쿼리하려면 <a href="https://developer.github.com/apps/building-oauth-apps/understanding-scopes-for-oauth-apps/"><code>read:org</code> 범위</a> 가 필요합니다.</p>
<p>이 범위에 대한 접근을 거부할 수 있으며, 팀이 도입되기 전에 작동했던 모든 기능은 계속 작동합니다. 그러나 팀을 소유자로 추가하거나 팀 소유자로 크레이트를 게시할 수는 없습니다. 이를 시도하면 위와 같은 오류가 발생합니다. 또한 소유하지 않은 크레이트를 게시하려고 시도했지만 팀이 있는 경우에도 이 오류가 발생할 수 있습니다.</p>
<p>마음을 바꾸거나 <a href="https://crates.io/">crates.io</a> 에 충분한 권한이 있는지 확실하지 않은 경우, 언제든지 <a href="https://crates.io/">https://crates.io/</a>로 이동하여 다시 인증할 수 있습니다. 그러면 <a href="https://crates.io/">crates.io</a> 에 필요한 모든 범위가 없는 경우 권한을 요청하는 메시지가 표시됩니다.</p>
<p>GitHub를 쿼리하는 데 추가적인 장벽은 조직이 타사 액세스를 적극적으로 거부할 수 있다는 것입니다. 이를 확인하려면 다음으로 이동하세요:</p>
<pre><code class="language-text">https://github.com/organizations/:org/settings/oauth_application_policy
</code></pre>
<p>여기서 <code>:org</code> 는 조직의 이름입니다(예: <code>rust-lang</code>). 다음과 같은 것을 볼 수 있습니다:</p>
<p><img src="reference/../images/org-level-acl.png" alt="Organization Access Control" /></p>
<p>여기서 <a href="https://crates.io/">crates.io</a> 를 조직의 블랙리스트에서 명시적으로 제거하거나, 단순히 “제한 제거” 버튼을 눌러 모든 타사 애플리케이션이 이 데이터에 액세스하도록 허용할 수 있습니다.</p>
<p>또는 <a href="https://crates.io/">crates.io</a> 가 <code>read:org</code> 범위를 요청했을 때, 이름 옆에 있는 “액세스 허용” 버튼을 눌러 해당 조직을 쿼리하는 <a href="https://crates.io/">crates.io</a> 를 명시적으로 화이트리스트에 추가할 수 있습니다:</p>
<p><img src="reference/../images/auth-level-acl.png" alt="Authentication Access Control" /></p>
<h3 id="github-팀-액세스-오류-문제-해결"><a class="header" href="#github-팀-액세스-오류-문제-해결">GitHub 팀 액세스 오류 문제 해결</a></h3>
<p>GitHub 팀을 크레이트 소유자로 추가하려고 할 때 다음과 같은 오류가 발생할 수 있습니다:</p>
<pre><code class="language-text">error: failed to invite owners to crate &lt;crate_name&gt;: api errors (status 200 OK): could not find the github team org/repo
</code></pre>
<p>In that case, you should go to <a href="https://github.com/settings/applications">the GitHub Application settings page</a> and check if crates.io is listed in the <code>Authorized OAuth Apps</code> tab. If it isn’t, you should go to <a href="https://crates.io/">https://crates.io/</a> and authorize it. Then go back to the Application Settings page on GitHub, click on the crates.io application in the list, and make sure you or your organization is listed in the “Organization access” list with a green check mark. If there’s a button labeled <code>Grant</code> or <code>Request</code>, you should grant the access or request the org owner to do so.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-홈"><a class="header" href="#cargo-홈">Cargo 홈</a></h1>
<p>“Cargo 홈”은 다운로드 및 소스 캐시 역할을 합니다. <a href="guide/../appendix/glossary.html#crate" title="&quot;crate&quot; (용어집 항목)">크레이트</a>를 빌드할 때 Cargo는 다운로드된 빌드 의존성을 Cargo 홈에 저장합니다. <code>CARGO_HOME</code> <a href="guide/../reference/environment-variables.html">환경 변수</a> 를 설정하여 Cargo 홈의 위치를 변경할 수 있습니다. <a href="https://crates.io/crates/home">home</a> 크레이트는 Rust 크레이트 내에서 이 정보가 필요한 경우 이 위치를 가져오는 API를 제공합니다. 기본적으로 Cargo 홈은 <code>$HOME/.cargo/</code> 에 있습니다.</p>
<p>Please note that the internal structure of the Cargo home is not stabilized and may be subject to change at any time.</p>
<p>The Cargo home consists of following components:</p>
<h2 id="파일"><a class="header" href="#파일">파일:</a></h2>
<ul>
<li>
<p><code>config.toml</code> Cargo의 전역 설정 파일입니다. <a href="guide/../reference/config.html">참조의 config 항목</a> 을 확인하세요.</p>
</li>
<li>
<p><code>credentials.toml</code> Private login credentials from <a href="guide/../commands/cargo-login.html"><code>cargo login</code></a> in order to log in to a <a href="guide/../appendix/glossary.html#registry" title="&quot;registry&quot; (glossary entry)">registry</a>.</p>
</li>
<li>
<p><code>.crates.toml</code>, <code>.crates2.json</code> These hidden files contain <a href="guide/../appendix/glossary.html#package" title="&quot;package&quot; (glossary entry)">package</a> information of crates installed via <a href="guide/../commands/cargo-install.html"><code>cargo install</code></a>. Do NOT edit by hand!</p>
</li>
</ul>
<h2 id="디렉토리"><a class="header" href="#디렉토리">디렉토리:</a></h2>
<ul>
<li>
<p><code>bin</code> bin 디렉토리에는 <a href="guide/../commands/cargo-install.html"><code>cargo install</code></a> 또는 <a href="https://rust-lang.github.io/rustup/"><code>rustup</code></a> 를 통해 설치된 크레이트의 실행 파일이 포함되어 있습니다. 이 바이너리들을 접근 가능하게 하려면 디렉토리의 경로를 <code>$PATH</code> 환경 변수에 추가하세요.</p>
</li>
<li>
<p><code>git</code> Git 소스는 여기에 저장됩니다:</p>
<ul>
<li>
<p><code>git/db</code> When a crate depends on a git repository, Cargo clones the repo as a bare repo into this directory and updates it if necessary.</p>
</li>
<li>
<p><code>git/checkouts</code> If a git source is used, the required commit of the repo is checked out from the bare repo inside <code>git/db</code> into this directory. This provides the compiler with the actual files contained in the repo of the commit specified for that dependency. Multiple checkouts of different commits of the same repo are possible.</p>
</li>
</ul>
</li>
<li>
<p><code>registry</code> <a href="https://crates.io/">crates.io</a> 와 같은 크레이트 레지스트리의 패키지 및 메타데이터가 여기에 있습니다.</p>
<ul>
<li>
<p><code>registry/index</code> 인덱스는 레지스트리의 모든 사용 가능한 크레이트의 메타데이터(버전, 의존성 등)를 포함하는 bare git 저장소입니다.</p>
</li>
<li>
<p><code>registry/cache</code> 다운로드된 의존성은 캐시에 저장됩니다. 크레이트는 <code>.crate</code> 확장자로 이름이 지정된 압축된 gzip 아카이브입니다.</p>
</li>
<li>
<p><code>registry/src</code> 다운로드한 <code>.crate</code> 아카이브가 패키지에 필요한 경우, <code>registry/src</code> 폴더에 압축이 풀리고 rustc가 <code>.rs</code> 파일을 찾을 수 있습니다.</p>
</li>
</ul>
</li>
</ul>
<h2 id="ci에서-cargo-홈-캐싱하기"><a class="header" href="#ci에서-cargo-홈-캐싱하기">CI에서 Cargo 홈 캐싱하기</a></h2>
<p>지속적인 통합 중에 모든 크레이트 의존성을 다시 다운로드하지 않으려면 <code>$CARGO_HOME</code> 디렉토리를 캐시할 수 있습니다. 그러나 전체 디렉토리를 캐시하는 것은 다운로드된 소스를 두 번 포함하므로 비효율적인 경우가 많습니다. <code>serde 1.0.92</code> 와 같은 크레이트에 의존하고 전체 <code>$CARGO_HOME</code> 을 캐시하면 실제로는 소스를 두 번 캐시하게 됩니다. <code>registry/cache</code> 내부의 <code>serde-1.0.92.crate</code> 와 <code>registry/src</code> 내부의 serde의 압축 해제된 <code>.rs</code> 파일입니다. 캐시를 다운로드, 압축 해제, 재압축 및 CI 서버에 다시 업로드하는 데 시간이 걸릴 수 있으므로 빌드 속도가 불필요하게 느려질 수 있습니다.</p>
<p><a href="guide/../commands/cargo-install.html"><code>cargo install</code></a> 로 설치된 바이너리를 캐시하려면 <code>bin/</code> 폴더와 <code>.crates.toml</code> 및 <code>.crates2.json</code> 파일을 캐시해야 합니다.</p>
<p>빌드 간에 다음 파일 및 디렉토리를 캐시하는 것으로 충분합니다:</p>
<ul>
<li><code>.crates.toml</code></li>
<li><code>.crates2.json</code></li>
<li><code>bin/</code></li>
<li><code>registry/index/</code></li>
<li><code>registry/cache/</code></li>
<li><code>git/db/</code></li>
</ul>
<h2 id="프로젝트의-모든-의존성-벤더링하기"><a class="header" href="#프로젝트의-모든-의존성-벤더링하기">프로젝트의 모든 의존성 벤더링하기</a></h2>
<p><a href="guide/../commands/cargo-vendor.html"><code>cargo vendor</code></a> 하위 명령을 참조하세요.</p>
<h2 id="캐시-지우기"><a class="header" href="#캐시-지우기">캐시 지우기</a></h2>
<p>이론적으로 캐시의 일부를 언제든지 제거할 수 있으며, Cargo는 크레이트에 소스가 필요한 경우 아카이브를 다시 추출하거나 bare repo를 체크아웃하거나 웹에서 소스를 다시 다운로드하여 소스를 복원하기 위해 최선을 다할 것입니다.</p>
<p>또는 <a href="https://crates.io/crates/cargo-cache">cargo-cache</a> 크레이트는 캐시의 선택된 부분만 지우거나 명령줄에서 구성 요소의 크기를 표시하는 간단한 CLI 도구를 제공합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="optimizing-build-performance"><a class="header" href="#optimizing-build-performance">Optimizing Build Performance</a></h1>
<p>Cargo configuration options and source code organization patterns can help improve build performance, by prioritizing it over other aspects which may not be as important for your circumstances.</p>
<p>Same as when optimizing runtime performance, be sure to measure these changes against the workflows you actually care about, as we provide general guidelines and your circumstances may be different, it is possible that some of these approaches might actually make build performance worse for your use-case.</p>
<p>Example workflows to consider include:</p>
<ul>
<li>Compiler feedback as you develop (<code>cargo check</code> after making a code change)</li>
<li>Test feedback as you develop (<code>cargo test</code> after making a code change)</li>
<li>CI builds</li>
</ul>
<h2 id="cargo-and-compiler-configuration"><a class="header" href="#cargo-and-compiler-configuration">Cargo and Compiler Configuration</a></h2>
<p>Cargo uses configuration defaults that try to balance several aspects, including debuggability, runtime performance, build performance, binary size and others. This section describes several approaches for changing these defaults that should be designed to maximize build performance.</p>
<p>Common locations to override defaults are:</p>
<ul>
<li><a href="guide/../reference/profiles.html"><code>Cargo.toml</code> manifest</a>
<ul>
<li>Available to all developers contributing to your project</li>
<li>Limited in what configuration is supported (see <a href="https://github.com/rust-lang/cargo/issues/12738">#12738</a> for expanding this)</li>
</ul>
</li>
<li><a href="guide/../reference/config.html"><code>$WORKSPACE_ROOT/.cargo/config.toml</code> configuration file</a>
<ul>
<li>Available to all developers contributing to your project</li>
<li>Unlike <code>Cargo.toml</code>, this is sensitive to what directory you invoke <code>cargo</code> from (see <a href="https://github.com/rust-lang/cargo/issues/2930">#2930</a>)</li>
</ul>
</li>
<li><a href="guide/../reference/config.html"><code>$CARGO_HOME/.cargo/config.toml</code> configuration file</a>
<ul>
<li>For a developer to control the defaults for their development</li>
</ul>
</li>
</ul>
<h3 id="reduce-amount-of-generated-debug-information"><a class="header" href="#reduce-amount-of-generated-debug-information">Reduce amount of generated debug information</a></h3>
<p>Recommendation: Add to your <code>Cargo.toml</code> or <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[profile.dev]
debug = "line-tables-only"

[profile.dev.package."*"]
debug = false

[profile.debugging]
inherits = "dev"
debug = true
</code></pre>
<p>This will:</p>
<ul>
<li>Change the <a href="guide/../reference/profiles.html#dev"><code>dev</code> profile</a> (default for development commands) to:
<ul>
<li>Limit <a href="guide/../reference/profiles.html#debug">debug information</a> for workspace members to what is needed for useful panic backtraces</li>
<li>Avoid generating any debug information for dependencies</li>
</ul>
</li>
<li>Provide an opt-in for when debugging via <a href="guide/../reference/profiles.html#custom-profiles"><code>--profile debugging</code></a></li>
</ul>
<blockquote>
<p><strong>Note:</strong> re-evaluating the <code>dev</code> profile is being tracked in <a href="https://github.com/rust-lang/cargo/issues/15931">#15931</a>.</p>
</blockquote>
<p>Trade-offs:</p>
<ul>
<li>✅ Faster code generation (<code>cargo build</code>)</li>
<li>✅ Faster link times</li>
<li>✅ Smaller disk usage of the <code>target</code> directory</li>
<li>❌ Requires a full rebuild to have a high-quality debugger experience</li>
</ul>
<h3 id="use-an-alternative-codegen-backend"><a class="header" href="#use-an-alternative-codegen-backend">Use an alternative codegen backend</a></h3>
<p>Recommendation:</p>
<ul>
<li>
<p>Install the Cranelift codegen backend rustup component</p>
<pre><code class="language-console">$ rustup component add rustc-codegen-cranelift-preview --toolchain nightly
</code></pre>
</li>
<li>
<p>Add to your <code>Cargo.toml</code> or <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[profile.dev]
codegen-backend = "cranelift"
</code></pre>
</li>
<li>
<p>Run Cargo with <code>-Z codegen-backend</code> or enable the <a href="guide/../reference/unstable.html#codegen-backend"><code>codegen-backend</code></a> feature in <code>.cargo/config.toml</code>.</p>
<ul>
<li>This is required because this is currently an unstable feature.</li>
</ul>
</li>
</ul>
<p>This will change the <a href="guide/../reference/profiles.html#dev"><code>dev</code> profile</a> to use the <a href="https://github.com/rust-lang/rustc_codegen_cranelift">Cranelift codegen backend</a> for generating machine code, instead of the default LLVM backend. The Cranelift backend should generate code faster than LLVM, which should result in improved build performance.</p>
<p>Trade-offs:</p>
<ul>
<li>✅ Faster code generation (<code>cargo build</code>)</li>
<li>❌ <strong>Requires using nightly Rust and an <a href="guide/../reference/unstable.html#codegen-backend">unstable Cargo feature</a></strong></li>
<li>❌ Worse runtime performance of the generated code
<ul>
<li>Speeds up build part of <code>cargo test</code>, but might increase its test execution part</li>
</ul>
</li>
<li>❌ Only available for <a href="https://github.com/rust-lang/rustc_codegen_cranelift?tab=readme-ov-file#platform-support">certain targets</a></li>
<li>❌ Might not support all Rust features (e.g. unwinding)</li>
</ul>
<h3 id="enable-the-experimental-parallel-frontend"><a class="header" href="#enable-the-experimental-parallel-frontend">Enable the experimental parallel frontend</a></h3>
<p>Recommendation: Add to your <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[build]
rustflags = "-Zthreads=8"
</code></pre>
<p>This <a href="guide/../reference/config.html#buildrustflags"><code>rustflags</code></a> will enable the <a href="https://blog.rust-lang.org/2023/11/09/parallel-rustc/">parallel frontend</a> of the Rust compiler, and tell it to use <code>n</code> threads. The value of <code>n</code> should be chosen according to the number of cores available on your system, although there are diminishing returns. We recommend using at most <code>8</code> threads.</p>
<p>Trade-offs:</p>
<ul>
<li>✅ Faster build times (both <code>cargo check</code> and <code>cargo build</code>)</li>
<li>❌ <strong>Requires using nightly Rust and an <a href="https://github.com/rust-lang/rust/issues/113349">unstable Rust feature</a></strong></li>
</ul>
<h3 id="use-an-alternative-linker"><a class="header" href="#use-an-alternative-linker">Use an alternative linker</a></h3>
<p>Consider: installing and configuring an alternative linker, like <a href="https://lld.llvm.org/">LLD</a>, <a href="https://github.com/rui314/mold">mold</a> or <a href="https://github.com/davidlattimore/wild">wild</a>. For example, to configure mold on Linux, you can add to your <code>.cargo/config.toml</code>:</p>
<pre><code class="language-toml">[target.'cfg(target_os = "linux")']
# mold, if you have GCC 12+
rustflags = ["-C", "link-arg=-fuse-ld=mold"]

# mold, otherwise
linker = "clang"
rustflags = ["-C", "link-arg=-fuse-ld=/path/to/mold"]
</code></pre>
<p>While dependencies may be built in parallel, linking all of your dependencies happens at once at the end of your build, which can make linking dominate your build times, especially for incremental rebuilds. Often, the linker Rust uses is already fairly fast and the gains from switching may not be worth it, but it is not always the case. For example, Linux targets besides <code>x86_64-unknown-linux-gnu</code> still use the Linux system linker which is quite slow (see <a href="https://github.com/rust-lang/rust/issues/39915">rust#39915</a> for more details).</p>
<p>Trade-offs:</p>
<ul>
<li>✅ Faster link times</li>
<li>❌ Might not support all use-cases, in particular if you depend on C or C++ dependencies</li>
</ul>
<h3 id="resolve-features-for-the-whole-workspace"><a class="header" href="#resolve-features-for-the-whole-workspace">Resolve features for the whole workspace</a></h3>
<p>Consider: adding to your project’s <code>.cargo/config.toml</code></p>
<pre><code class="language-toml">[resolver]
feature-unification = "workspace"
</code></pre>
<p>When invoking <code>cargo</code>, <a href="guide/../reference/resolver.html#features">features get activated</a> based on which workspace members you have selected. However, when contributing to an application, you may need to build and test various packages within the application, which can cause extraneous rebuilds because different sets of features may be activated for common dependencies. With <a href="guide/../reference/unstable.html#feature-unification"><code>feature-unification</code></a>, you can reuse more dependency builds by ensuring the same set of dependency features are activated, independent of which package you are currently building and testing.</p>
<p>Trade-offs:</p>
<ul>
<li>✅ Fewer rebuilds when building different packages in a workspace</li>
<li>❌ <strong>Requires using nightly Rust and an <a href="guide/../reference/unstable.html#feature-unification">unstable Cargo feature</a></strong></li>
<li>❌ A package activating a feature can mask bugs in other packages that should activate it but don’t</li>
<li>❌ If the feature unification from <code>--workspace</code> doesn’t work for you, then this won’t either</li>
</ul>
<h2 id="reducing-built-code"><a class="header" href="#reducing-built-code">Reducing built code</a></h2>
<h3 id="removing-unused-dependencies"><a class="header" href="#removing-unused-dependencies">Removing unused dependencies</a></h3>
<p>Recommendation: Periodically review unused dependencies for removal using third-party tools like <a href="https://crates.io/crates/cargo-machete">cargo-machete</a>, <a href="https://crates.io/crates/cargo-udeps">cargo-udeps</a>, <a href="https://crates.io/crates/cargo-shear">cargo-shear</a>.</p>
<p>When changing code, it can be easy to miss that a dependency is no longer used and can be removed.</p>
<blockquote>
<p><strong>Note:</strong> native support for this in Cargo is being tracked in <a href="https://github.com/rust-lang/cargo/issues/15813">#15813</a>.</p>
</blockquote>
<p>Trade-offs:</p>
<ul>
<li>✅ Faster full build and link times</li>
<li>❌ May incorrectly flag dependencies as unused or miss some</li>
</ul>
<h3 id="removing-unused-features-from-dependencies"><a class="header" href="#removing-unused-features-from-dependencies">Removing unused features from dependencies</a></h3>
<p>Recommendation: Periodically review unused features from dependencies for removal using third-party tools like <a href="https://crates.io/crates/cargo-features-manager">cargo-features-manager</a>, <a href="https://crates.io/crates/cargo-unused-features">cargo-unused-features</a>.</p>
<p>When changing code, it can be easy to miss that a dependency’s feature is no longer used and can be removed. This can reduce the number of transitive dependencies being built or reduce the amount of code within a crate being built. When removing features, extra caution is needed because features may also be used for desired behavior or performance changes which may not always be obvious from compiling or testing.</p>
<p>Trade-offs:</p>
<ul>
<li>✅ Faster full build and link times</li>
<li>❌ May incorrectly flag features as unused</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-레퍼런스"><a class="header" href="#cargo-레퍼런스">Cargo 레퍼런스</a></h1>
<p>레퍼런스는 Cargo의 다양한 영역에 대한 세부 사항을 다룹니다.</p>
<ul>
<li><a href="reference/manifest.html">매니페스트 형식</a>
<ul>
<li><a href="reference/cargo-targets.html">Cargo 타겟</a></li>
<li><a href="reference/rust-version.html">Rust 버전</a></li>
</ul>
</li>
<li><a href="reference/workspaces.html">워크스페이스</a></li>
<li><a href="reference/specifying-dependencies.html">의존성 지정하기</a>
<ul>
<li><a href="reference/overriding-dependencies.html">의존성 재정의하기</a></li>
<li><a href="reference/source-replacement.html">소스 교체</a></li>
<li><a href="reference/resolver.html">의존성 해결</a></li>
</ul>
</li>
<li><a href="reference/features.html">기능</a>
<ul>
<li><a href="reference/features-examples.html">기능 예제</a></li>
</ul>
</li>
<li><a href="reference/profiles.html">프로파일</a></li>
<li><a href="reference/config.html">설정</a></li>
<li><a href="reference/environment-variables.html">환경 변수</a></li>
<li><a href="reference/build-scripts.html">빌드 스크립트</a>
<ul>
<li><a href="reference/build-script-examples.html">빌드 스크립트 예제</a></li>
</ul>
</li>
<li><a href="reference/build-cache.html">빌드 캐시</a></li>
<li><a href="reference/pkgid-spec.html">패키지 ID 명세</a></li>
<li><a href="reference/external-tools.html">외부 도구</a></li>
<li><a href="reference/registries.html">레지스트리</a>
<ul>
<li><a href="reference/registry-authentication.html">레지스트리 인증</a>
<ul>
<li><a href="reference/credential-provider-protocol.html">자격 증명 제공자 프로토콜</a></li>
</ul>
</li>
<li><a href="reference/running-a-registry.html">레지스트리 운영하기</a>
<ul>
<li><a href="reference/registry-index.html">레지스트리 인덱스</a></li>
<li><a href="reference/registry-web-api.html">레지스트리 웹 API</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="reference/semver.html">SemVer 호환성</a></li>
<li><a href="reference/future-incompat-report.html">미래 비호환성 보고서</a></li>
<li><a href="reference/timings.html">빌드 시간 보고</a></li>
<li><a href="reference/lints.html">린트</a></li>
<li><a href="reference/unstable.html">불안정한 기능</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="매니페스트-형식"><a class="header" href="#매니페스트-형식">매니페스트 형식</a></h1>
<p>각 패키지의 <code>Cargo.toml</code> 파일은 <em>매니페스트</em> 라고 합니다. <a href="https://toml.io/">TOML</a> 형식으로 작성됩니다. 패키지를 컴파일하는 데 필요한 메타데이터를 포함합니다. cargo가 매니페스트 파일을 찾는 방법에 대한 자세한 내용은 <code>cargo locate-project</code> 섹션을 확인하세요.</p>
<p>모든 매니페스트 파일은 다음 섹션으로 구성됩니다:</p>
<ul>
<li><a href="reference/unstable.html"><code>cargo-features</code></a> — 불안정한, 나이틀리 전용 기능입니다.</li>
<li><a href="reference/manifest.html#the-package-section"><code>[package]</code></a> — 패키지를 정의합니다.
<ul>
<li><a href="reference/manifest.html#the-name-field"><code>name</code></a> — 패키지의 이름입니다.</li>
<li><a href="reference/manifest.html#the-version-field"><code>version</code></a> — 패키지의 버전입니다.</li>
<li><a href="reference/manifest.html#the-authors-field"><code>authors</code></a> — 패키지의 저자입니다.</li>
<li><a href="reference/manifest.html#the-edition-field"><code>edition</code></a> — Rust 에디션입니다.</li>
<li><a href="reference/rust-version.html"><code>rust-version</code></a> — 최소 지원 Rust 버전입니다.</li>
<li><a href="reference/manifest.html#the-description-field"><code>description</code></a> — 패키지에 대한 설명입니다.</li>
<li><a href="reference/manifest.html#the-documentation-field"><code>documentation</code></a> — 패키지 문서의 URL입니다.</li>
<li><a href="reference/manifest.html#the-readme-field"><code>readme</code></a> — 패키지의 README 파일 경로입니다.</li>
<li><a href="reference/manifest.html#the-homepage-field"><code>homepage</code></a> — 패키지 홈페이지의 URL입니다.</li>
<li><a href="reference/manifest.html#the-repository-field"><code>repository</code></a> — 패키지 소스 저장소의 URL입니다.</li>
<li><a href="reference/manifest.html#the-license-and-license-file-fields"><code>license</code></a> — 패키지 라이선스입니다.</li>
<li><a href="reference/manifest.html#the-license-and-license-file-fields"><code>license-file</code></a> — 라이선스 텍스트 파일의 경로입니다.</li>
<li><a href="reference/manifest.html#the-keywords-field"><code>keywords</code></a> — 패키지의 키워드입니다.</li>
<li><a href="reference/manifest.html#the-categories-field"><code>categories</code></a> — 패키지의 카테고리입니다.</li>
<li><a href="reference/manifest.html#the-workspace-field"><code>workspace</code></a> — 패키지의 워크스페이스 경로입니다.</li>
<li><a href="reference/manifest.html#the-build-field"><code>build</code></a> — 패키지 빌드 스크립트의 경로입니다.</li>
<li><a href="reference/manifest.html#the-links-field"><code>links</code></a> — 패키지가 연결되는 네이티브 라이브러리의 이름입니다.</li>
<li><a href="reference/manifest.html#the-exclude-and-include-fields"><code>exclude</code></a> — 게시할 때 제외할 파일입니다.</li>
<li><a href="reference/manifest.html#the-exclude-and-include-fields"><code>include</code></a> — 게시할 때 포함할 파일입니다.</li>
<li><a href="reference/manifest.html#the-publish-field"><code>publish</code></a> — 패키지 게시를 방지하는 데 사용할 수 있습니다.</li>
<li><a href="reference/manifest.html#the-metadata-table"><code>metadata</code></a> — 외부 도구를 위한 추가 설정입니다.</li>
<li><a href="reference/manifest.html#the-default-run-field"><code>default-run</code></a> — <a href="reference/../commands/cargo-run.html"><code>cargo run</code></a> 이 실행할 기본 바이너리입니다.</li>
<li><a href="reference/cargo-targets.html#target-auto-discovery"><code>autolib</code></a> — 라이브러리 자동 검색을 비활성화합니다.</li>
<li><a href="reference/cargo-targets.html#target-auto-discovery"><code>autobins</code></a> — 바이너리 자동 검색을 비활성화합니다.</li>
<li><a href="reference/cargo-targets.html#target-auto-discovery"><code>autoexamples</code></a> — 예제 자동 검색을 비활성화합니다.</li>
<li><a href="reference/cargo-targets.html#target-auto-discovery"><code>autotests</code></a> — 테스트 자동 검색을 비활성화합니다.</li>
<li><a href="reference/cargo-targets.html#target-auto-discovery"><code>autobenches</code></a> — 벤치 자동 검색을 비활성화합니다.</li>
<li><a href="reference/resolver.html#resolver-versions"><code>resolver</code></a> — 사용할 의존성 해결사를 설정합니다.</li>
</ul>
</li>
<li>타겟 테이블: (설정은 <a href="reference/cargo-targets.html#configuring-a-target">구성</a> 참조)
<ul>
<li><a href="reference/cargo-targets.html#library"><code>[lib]</code></a> — 라이브러리 타겟 설정입니다.</li>
<li><a href="reference/cargo-targets.html#binaries"><code>[[bin]]</code></a> — 바이너리 타겟 설정입니다.</li>
<li><a href="reference/cargo-targets.html#examples"><code>[[example]]</code></a> — 예제 타겟 설정입니다.</li>
<li><a href="reference/cargo-targets.html#tests"><code>[[test]]</code></a> — 테스트 타겟 설정입니다.</li>
<li><a href="reference/cargo-targets.html#benchmarks"><code>[[bench]]</code></a> — 벤치마크 타겟 설정입니다.</li>
</ul>
</li>
<li>의존성 테이블:
<ul>
<li><a href="reference/specifying-dependencies.html"><code>[dependencies]</code></a> — 패키지 라이브러리 의존성입니다.</li>
<li><a href="reference/specifying-dependencies.html#development-dependencies"><code>[dev-dependencies]</code></a> — 예제, 테스트, 벤치마크를 위한 의존성입니다.</li>
<li><a href="reference/specifying-dependencies.html#build-dependencies"><code>[build-dependencies]</code></a> — 빌드 스크립트를 위한 의존성입니다.</li>
<li><a href="reference/specifying-dependencies.html#platform-specific-dependencies"><code>[target]</code></a> — 플랫폼별 의존성입니다.</li>
</ul>
</li>
<li><a href="reference/manifest.html#the-badges-section"><code>[badges]</code></a> — 레지스트리에 표시할 배지입니다.</li>
<li><a href="reference/features.html"><code>[features]</code></a> — 조건부 컴파일 기능입니다.</li>
<li><a href="reference/manifest.html#the-lints-section"><code>[lints]</code></a> — 이 패키지를 위한 린터를 구성합니다.</li>
<li><a href="reference/manifest.html#the-hints-section"><code>[hints]</code></a> — Provide hints for compiling this package.</li>
<li><a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code></a> — 의존성을 재정의합니다.</li>
<li><a href="reference/overriding-dependencies.html#the-replace-section"><code>[replace]</code></a> — 의존성을 재정의합니다 (사용 중단됨).</li>
<li><a href="reference/profiles.html"><code>[profile]</code></a> — 컴파일러 설정 및 최적화입니다.</li>
<li><a href="reference/workspaces.html"><code>[workspace]</code></a> — 워크스페이스 정의입니다.</li>
</ul>
<h2 id="package-섹션"><a class="header" href="#package-섹션"><code>[package]</code> 섹션</a></h2>
<p><code>Cargo.toml</code> 의 첫 번째 섹션은 <code>[package]</code> 입니다.</p>
<pre><code class="language-toml">[package]
name = "hello_world" # 패키지 이름
version = "0.1.0"    # 현재 버전 (semver 준수)
</code></pre>
<p>Cargo가 요구하는 유일한 필드는 <a href="reference/manifest.html#the-name-field"><code>name</code></a> 입니다. 레지스트리에 게시하는 경우 레지스트리에서 추가 필드를 요구할 수 있습니다. 아래 참고 사항과 <a href="reference/publishing.html">게시 장</a> 에서 <a href="https://crates.io/">crates.io</a> 게시 요건을 확인하세요.</p>
<h3 id="name-필드"><a class="header" href="#name-필드"><code>name</code> 필드</a></h3>
<p>패키지 이름은 패키지를 참조하는 데 사용되는 식별자입니다. 다른 패키지에서 의존성으로 나열될 때 사용되며, 유추된 lib 및 bin 타겟의 기본 이름으로도 사용됩니다.</p>
<p>이름은 <a href="reference/../../std/primitive.char.html#method.is_alphanumeric">영문자 및 숫자</a> 문자 또는 <code>-</code>, <code>_</code> 만 사용해야 하며 비워 둘 수 없습니다.</p>
<p><a href="reference/../commands/cargo-new.html"><code>cargo new</code></a> 및 <a href="reference/../commands/cargo-init.html"><code>cargo init</code></a> 은 패키지 이름에 대해 유효한 Rust 식별자여야 하고 키워드가 아니어야 하는 등의 추가 제한을 둡니다. <a href="https://crates.io/">crates.io</a> 는 다음과 같은 더 많은 제한을 둡니다.</p>
<ul>
<li>ASCII 문자만 허용됩니다.</li>
<li>예약된 이름을 사용하지 마세요.</li>
<li>“nul“과 같은 특수한 Windows 이름을 사용하지 마세요.</li>
<li>최대 길이는 64자입니다.</li>
</ul>
<h3 id="version-필드"><a class="header" href="#version-필드"><code>version</code> 필드</a></h3>
<p><code>version</code> 필드는 <a href="https://semver.org">SemVer</a> 사양에 따라 형식이 지정됩니다.</p>
<p>버전은 주 버전(major), 부 버전(minor), 패치 버전(patch)의 세 가지 숫자 부분으로 구성되어야 합니다.</p>
<p>대시 뒤에 <code>1.0.0-alpha</code> 와 같은 프리릴리스(pre-release) 부분을 추가할 수 있습니다. 프리릴리스 부분은 개별 구성 요소를 구분하기 위해 마침표로 나눌 수 있습니다. 숫자 구성 요소는 숫자 비교를 사용하고 다른 모든 구성 요소는 사전식 비교를 사용합니다. 예를 들어, <code>1.0.0-alpha.11</code> 은 <code>1.0.0-alpha.4</code> 보다 높습니다.</p>
<p>플러스 뒤에 <code>1.0.0+21AF26D3</code> 과 같은 메타데이터 부분을 추가할 수 있습니다. 이는 정보 제공 목적으로만 사용되며 일반적으로 Cargo에서는 무시됩니다.</p>
<p>Cargo는 <a href="https://semver.org/">시맨틱 버저닝(Semantic Versioning)</a> 개념을 기반으로 하므로, 가장 왼쪽의 0이 아닌 주/부/패치 구성 요소가 같으면 버전이 <a href="reference/semver.html">호환</a> 되는 것으로 간주됩니다. Cargo가 의존성 해결을 위해 버전을 사용하는 방법에 대한 자세한 내용은 <a href="reference/resolver.html">리졸버(Resolver)</a> 장을 참조하세요.</p>
<p>이 필드는 선택 사항이며 기본값은 <code>0.0.0</code> 입니다. 패키지를 게시하려면 이 필드가 필수입니다.</p>
<blockquote>
<p><strong>MSRV:</strong> 1.75 이전에는 이 필드가 필수였습니다.</p>
</blockquote>
<h3 id="authors-필드"><a class="header" href="#authors-필드"><code>authors</code> 필드</a></h3>
<blockquote>
<p><strong>경고</strong>: 이 필드는 사용 중단되었습니다.</p>
</blockquote>
<p>선택 사항인 <code>authors</code> 필드에는 패키지의 “저자“로 간주되는 사람이나 조직을 배열로 나열합니다. 각 저자 항목 끝의 꺽쇠 괄호 안에 선택 사항으로 이메일 주소를 포함할 수 있습니다.</p>
<pre><code class="language-toml">[package]
# ...
authors = ["Graydon Hoare", "Fnu Lnu &lt;no-reply@rust-lang.org&gt;"]
</code></pre>
<p>이 필드는 패키지 메타데이터와 하위 호환성을 위해 <code>build.rs</code> 내의 <code>CARGO_PKG_AUTHORS</code> 환경 변수에 나타납니다.</p>
<h3 id="edition-필드"><a class="header" href="#edition-필드"><code>edition</code> 필드</a></h3>
<p><code>edition</code> 키는 패키지가 어떤 <a href="reference/../../edition-guide/index.html">Rust 에디션</a> 으로 컴파일되는지에 영향을 미치는 선택 사항 키입니다. <code>[package]</code> 에서 <code>edition</code> 키를 설정하면 테스트 모음, 벤치마크, 바이너리, 예제 등을 포함하여 패키지의 모든 타겟/크레이트에 영향을 미칩니다.</p>
<pre><code class="language-toml">[package]
# ...
edition = '2024'
</code></pre>
<p>대부분의 매니페스트는 <a href="reference/../commands/cargo-new.html"><code>cargo new</code></a> 에 의해 최신 안정 에디션으로 <code>edition</code> 필드가 자동 채워집니다. 현재 <code>cargo new</code> 는 기본적으로 2024 에디션으로 매니페스트를 생성합니다.</p>
<p><code>Cargo.toml</code> 에 <code>edition</code> 필드가 없으면 하위 호환성을 위해 2015 에디션으로 간주됩니다. <a href="reference/../commands/cargo-new.html"><code>cargo new</code></a> 로 생성된 모든 매니페스트는 <code>edition</code> 이 더 최신 값으로 명시적으로 지정되므로 이 과거 폴백을 사용하지 않습니다.</p>
<h3 id="rust-version-필드"><a class="header" href="#rust-version-필드"><code>rust-version</code> 필드</a></h3>
<p><code>rust-version</code> 필드는 패키지에 대해 지원하는 Rust 툴체인 버전을 Cargo에 알려줍니다. 자세한 내용은 <a href="reference/rust-version.html">Rust 버전 장</a> 을 참조하세요.</p>
<h3 id="description-필드"><a class="header" href="#description-필드"><code>description</code> 필드</a></h3>
<p>설명은 패키지에 대한 짧은 홍보 문구입니다. <a href="https://crates.io/">crates.io</a> 는 패키지와 함께 이를 표시합니다. 마크다운이 아닌 일반 텍스트여야 합니다.</p>
<pre><code class="language-toml">[package]
# ...
description = "내 패키지에 대한 짧은 설명"
</code></pre>
<blockquote>
<p><strong>참고</strong>: <a href="https://crates.io/">crates.io</a> 에서는 <code>description</code> 설정이 필수입니다.</p>
</blockquote>
<h3 id="documentation-필드"><a class="header" href="#documentation-필드"><code>documentation</code> 필드</a></h3>
<p><code>documentation</code> 필드는 크레이트 문서를 호스팅하는 웹사이트의 URL을 지정합니다. 매니페스트 파일에 URL이 지정되지 않은 경우, 문서가 빌드되어 사용 가능해지면 <a href="https://crates.io/">crates.io</a> 가 자동으로 크레이트를 해당 <a href="https://docs.rs/">docs.rs</a> 페이지에 연결합니다 (<a href="https://docs.rs/releases/queue">docs.rs 큐</a> 참조).</p>
<pre><code class="language-toml">[package]
# ...
documentation = "https://docs.rs/bitflags"
</code></pre>
<h3 id="readme-필드"><a class="header" href="#readme-필드"><code>readme</code> 필드</a></h3>
<p><code>readme</code> 필드는 패키지에 대한 일반적인 정보가 포함된 패키지 루트의 파일 경로(<code>Cargo.toml</code> 기준 상대 경로)여야 합니다. 이 파일은 게시할 때 레지스트리로 전송됩니다. <a href="https://crates.io/">crates.io</a> 는 이를 마크다운으로 해석하여 크레이트 페이지에 렌더링합니다.</p>
<pre><code class="language-toml">[package]
# ...
readme = "README.md"
</code></pre>
<p>이 필드에 값이 지정되지 않고 패키지 루트에 <code>README.md</code>, <code>README.txt</code> 또는 <code>README</code> 라는 파일이 있으면 해당 파일의 이름이 사용됩니다. 이 필드를 <code>false</code> 로 설정하여 이 동작을 방지할 수 있습니다. 필드가 <code>true</code> 로 설정되면 기본값 <code>README.md</code> 가 가정됩니다.</p>
<h3 id="homepage-필드"><a class="header" href="#homepage-필드"><code>homepage</code> 필드</a></h3>
<p><code>homepage</code> 필드는 패키지의 홈페이지인 사이트의 URL이어야 합니다.</p>
<pre><code class="language-toml">[package]
# ...
homepage = "https://serde.rs"
</code></pre>
<p><code>homepage</code> 값은 소스 저장소나 API 문서 외에 크레이트를 위한 전용 웹사이트가 있는 경우에만 설정해야 합니다. <code>homepage</code> 가 <code>documentation</code> 또는 <code>repository</code> 값과 중복되지 않도록 하세요.</p>
<h3 id="repository-필드"><a class="header" href="#repository-필드"><code>repository</code> 필드</a></h3>
<p><code>repository</code> 필드는 패키지의 소스 저장소 URL이어야 합니다.</p>
<pre><code class="language-toml">[package]
# ...
repository = "https://github.com/rust-lang/cargo"
</code></pre>
<h3 id="license-및-license-file-필드"><a class="header" href="#license-및-license-file-필드"><code>license</code> 및 <code>license-file</code> 필드</a></h3>
<p><code>license</code> 필드에는 패키지가 출시되는 소프트웨어 라이선스 이름이 포함됩니다. <code>license-file</code> 필드에는 라이선스 텍스트가 포함된 파일의 경로(<code>Cargo.toml</code> 기준 상대 경로)가 포함됩니다.</p>
<p><a href="https://crates.io/">crates.io</a> 는 <code>license</code> 필드를 <a href="https://spdx.github.io/spdx-spec/v2.3/SPDX-license-expressions/">SPDX 2.3 라이선스 식</a> 으로 해석합니다. 이름은 <a href="https://github.com/spdx/license-list-data/tree/v3.20">SPDX 라이선스 목록 3.20</a> 에 있는 알려진 라이선스여야 합니다. 자세한 내용은 <a href="https://spdx.org">SPDX 사이트</a> 를 참조하세요.</p>
<p>SPDX 라이선스 식은 여러 라이선스를 결합하기 위해 AND 및 OR 연산자를 지원합니다.<sup class="footnote-reference"><a href="#slash">1</a></sup></p>
<pre><code class="language-toml">[package]
# ...
license = "MIT OR Apache-2.0"
</code></pre>
<p><code>OR</code> 를 사용하면 사용자가 두 라이선스 중 하나를 선택할 수 있음을 나타냅니다. <code>AND</code> 를 사용하면 사용자가 두 라이선스를 동시에 준수해야 함을 나타냅니다. <code>WITH</code> 연산자는 특수한 예외가 있는 라이선스를 나타냅니다. 몇 가지 예시:</p>
<ul>
<li><code>MIT OR Apache-2.0</code></li>
<li><code>LGPL-2.1-only AND MIT AND BSD-2-Clause</code></li>
<li><code>GPL-2.0-or-later WITH Bison-exception-2.2</code></li>
</ul>
<p>패키지가 비표준 라이선스를 사용하는 경우 <code>license</code> 필드 대신 <code>license-file</code> 필드를 지정할 수 있습니다.</p>
<pre><code class="language-toml">[package]
# ...
license-file = "LICENSE.txt"
</code></pre>
<blockquote>
<p><strong>참고</strong>: <a href="https://crates.io/">crates.io</a> 에서는 <code>license</code> 또는 <code>license-file</code> 중 하나를 설정해야 합니다.</p>
</blockquote>
<div class="footnote-definition" id="slash"><sup class="footnote-definition-label">1</sup>
<p>이전에는 여러 라이선스를 <code>/</code> 로 구분할 수 있었지만, 해당 용법은 사용 중단되었습니다.</p>
</div>
<h3 id="keywords-필드"><a class="header" href="#keywords-필드"><code>keywords</code> 필드</a></h3>
<p><code>keywords</code> 필드는 이 패키지를 설명하는 문자열 배열입니다. 레지스트리에서 패키지를 검색할 때 도움이 될 수 있으며, 누군가 이 크레이트를 찾는 데 도움이 될 단어를 선택할 수 있습니다.</p>
<pre><code class="language-toml">[package]
# ...
keywords = ["gamedev", "graphics"]
</code></pre>
<blockquote>
<p><strong>참고</strong>: <a href="https://crates.io/">crates.io</a> 는 최대 5개의 키워드를 허용합니다. 각 키워드는 ASCII 텍스트여야 하고, 최대 20자여야 하며, 영문자나 숫자로 시작해야 하고, 문자, 숫자, <code>_</code>, <code>-</code> 또는 <code>+</code> 만 포함해야 합니다.</p>
</blockquote>
<h3 id="categories-필드"><a class="header" href="#categories-필드"><code>categories</code> 필드</a></h3>
<p><code>categories</code> 필드는 이 패키지가 속한 카테고리의 문자열 배열입니다.</p>
<pre><code class="language-toml">categories = ["command-line-utilities", "development-tools::cargo-plugins"]
</code></pre>
<blockquote>
<p><strong>참고</strong>: <a href="https://crates.io/">crates.io</a> 는 최대 5개의 카테고리를 가집니다. 각 카테고리는 <a href="https://crates.io/category_slugs">https://crates.io/category_slugs</a>에서 사용 가능한 문자열 중 하나와 정확히 일치해야 합니다.</p>
</blockquote>
<h3 id="workspace-필드"><a class="header" href="#workspace-필드"><code>workspace</code> 필드</a></h3>
<p><code>workspace</code> 필드는 이 패키지가 구성원이 될 워크스페이스를 구성하는 데 사용할 수 있습니다. 지정하지 않으면 파일 시스템 상위 방향으로 <code>[workspace]</code> 가 있는 첫 번째 Cargo.toml로 유추됩니다. 구성원이 워크스페이스 루트의 하위 디렉토리에 있지 않은 경우 이를 설정하는 것이 유용합니다.</p>
<pre><code class="language-toml">[package]
# ...
workspace = "워크스페이스/루트/경로"
</code></pre>
<p>매니페스트에 이미 <code>[workspace]</code> 테이블이 정의되어 있는 경우 이 필드를 지정할 수 없습니다. 즉, 크레이트가 워크스페이스의 루트 크레이트(<code>[workspace]</code> 포함)이면서 동시에 다른 워크스페이스의 구성원 크레이트(<code>package.workspace</code> 포함)일 수는 없습니다.</p>
<p>자세한 내용은 <a href="reference/workspaces.html">워크스페이스 장</a> 을 참조하세요.</p>
<h3 id="build-필드"><a class="header" href="#build-필드"><code>build</code> 필드</a></h3>
<p><code>build</code> 필드는 네이티브 코드 빌드를 위한 <a href="reference/build-scripts.html">빌드 스크립트</a> 인 패키지 루트의 파일을 지정합니다. 자세한 내용은 <a href="reference/build-scripts.html">빌드 스크립트 가이드</a> 에서 확인할 수 있습니다.</p>
<pre><code class="language-toml">[package]
# ...
build = "build.rs"
</code></pre>
<p>기본값은 <code>"build.rs"</code> 이며, 패키지 루트에 있는 <code>build.rs</code> 라는 파일에서 스크립트를 로드합니다. 다른 파일에 대한 경로를 지정하려면 <code>build = "custom_build_name.rs"</code> 를 사용하고, 빌드 스크립트 자동 감지를 비활성화하려면 <code>build = false</code> 를 사용하세요.</p>
<h3 id="links-필드"><a class="header" href="#links-필드"><code>links</code> 필드</a></h3>
<p><code>links</code> 필드는 링크되는 네이티브 라이브러리의 이름을 지정합니다. 자세한 내용은 빌드 스크립트 가이드의 <a href="reference/build-scripts.html#the-links-manifest-key"><code>links</code></a> 섹션에서 확인할 수 있습니다.</p>
<p>예를 들어, “git2”(예: 리눅스의 <code>libgit2.a</code>)라는 네이티브 라이브러리를 링크하는 크레이트는 다음과 같이 지정할 수 있습니다.</p>
<pre><code class="language-toml">[package]
# ...
links = "git2"
</code></pre>
<h3 id="exclude-및-include-필드"><a class="header" href="#exclude-및-include-필드"><code>exclude</code> 및 <code>include</code> 필드</a></h3>
<p><code>exclude</code> 및 <code>include</code> 필드는 프로젝트를 <a href="reference/publishing.html">게시</a> 하기 위해 패키징할 때 어떤 파일이 포함될지 명시적으로 지정하는 데 사용되며, 특정 종류의 변경 사항 추적(아래 설명)에도 사용됩니다. <code>exclude</code> 필드에 지정된 패턴은 포함되지 않는 파일 집합을 식별하고, <code>include</code> 에 지정된 패턴은 명시적으로 포함되는 파일을 지정합니다. <a href="reference/../commands/cargo-package.html"><code>cargo package --list</code></a> 를 실행하여 패키지에 어떤 파일이 포함될지 확인할 수 있습니다.</p>
<pre><code class="language-toml">[package]
# ...
exclude = ["/ci", "images/", ".*"]
</code></pre>
<pre><code class="language-toml">[package]
# ...
include = ["/src", "COPYRIGHT", "/examples", "!/examples/big_example"]
</code></pre>
<p>두 필드가 모두 지정되지 않은 경우의 기본값은 아래 나열된 제외 대상을 제외하고 패키지 루트의 모든 파일을 포함하는 것입니다.</p>
<p><code>include</code> 가 지정되지 않은 경우 다음 파일들이 제외됩니다.</p>
<ul>
<li>패키지가 git 저장소에 있지 않은 경우, 점(<code>.</code>)으로 시작하는 모든 “숨김” 파일은 건너뜁니다.</li>
<li>패키지가 git 저장소에 있는 경우, 저장소의 <a href="https://git-scm.com/docs/gitignore">gitignore</a> 규칙 및 전역 git 구성에 의해 무시되는 모든 파일은 건너뜁니다.</li>
</ul>
<p><code>exclude</code> 또는 <code>include</code> 가 지정되었는지 여부와 관계없이 다음 파일은 항상 제외됩니다.</p>
<ul>
<li>모든 하위 패키지는 건너뜁니다 (<code>Cargo.toml</code> 파일을 포함하는 모든 하위 디렉토리).</li>
<li>패키지 루트에 있는 <code>target</code> 이라는 디렉토리는 건너뜁니다.</li>
</ul>
<p>다음 파일은 항상 포함됩니다.</p>
<ul>
<li>패키지 자체의 <code>Cargo.toml</code> 파일은 항상 포함되며, <code>include</code> 에 나열할 필요가 없습니다.</li>
<li>A minimized <code>Cargo.lock</code> is automatically included. See <a href="reference/../commands/cargo-package.html"><code>cargo package</code></a> for more information.</li>
<li><a href="reference/manifest.html#the-license-and-license-file-fields"><code>license-file</code></a> 가 지정된 경우 항상 포함됩니다.</li>
</ul>
<p>이 옵션들은 상호 배타적입니다. <code>include</code> 를 설정하면 <code>exclude</code> 가 무시됩니다. <code>include</code> 파일 집합에서 특정 파일을 제외해야 하는 경우 아래 설명된 <code>!</code> 연산자를 사용하세요.</p>
<p>패턴은 <a href="https://git-scm.com/docs/gitignore">gitignore</a> 스타일 패턴이어야 합니다. 요약하자면 다음과 같습니다.</p>
<ul>
<li><code>foo</code> 는 패키지 내 어디에서나 이름이 <code>foo</code> 인 모든 파일 또는 디렉토리에 일치합니다. 이는 <code>**/foo</code> 패턴과 동일합니다.</li>
<li><code>/foo</code> 는 패키지 루트에 있는 이름이 <code>foo</code> 인 파일 또는 디렉토리에만 일치합니다.</li>
<li><code>foo/</code> 는 패키지 내 어디에서나 이름이 <code>foo</code> 인 모든 <em>디렉토리</em> 에 일치합니다.</li>
<li><code>*</code>, <code>?</code>, <code>[]</code> 와 같은 일반적인 글로브(glob) 패턴이 지원됩니다.
<ul>
<li><code>*</code> 는 <code>/</code> 를 제외한 0개 이상의 문자에 일치합니다. 예를 들어 <code>*.html</code> 은 패키지 내 어디에서나 확장자가 <code>.html</code> 인 모든 파일 또는 디렉토리에 일치합니다.</li>
<li><code>?</code> 는 <code>/</code> 를 제외한 모든 한 문자에 일치합니다. 예를 들어 <code>foo?</code> 는 <code>food</code> 에는 일치하지만 <code>foo</code> 에는 일치하지 않습니다.</li>
<li><code>[]</code> 는 문자 범위를 일치시킬 수 있게 합니다. 예를 들어 <code>[ab]</code> 는 <code>a</code> 또는 <code>b</code> 중 하나에 일치합니다. <code>[a-z]</code> 는 a부터 z까지의 문자에 일치합니다.</li>
</ul>
</li>
<li><code>**/</code> 접두사는 모든 디렉토리에서 일치합니다. 예를 들어 <code>**/foo/bar</code> 는 <code>foo</code> 디렉토리 바로 아래에 있는 <code>bar</code> 파일 또는 디렉토리에 일치합니다.</li>
<li><code>/**</code> 접미사는 내부의 모든 항목에 일치합니다. 예를 들어 <code>foo/**</code> 는 <code>foo</code> 디렉토리 내부의 모든 파일과 <code>foo</code> 아래 하위 디렉토리의 모든 파일에 일치합니다.</li>
<li><code>/**/</code> 는 0개 이상의 디렉토리에 일치합니다. 예를 들어 <code>a/**/b</code> 는 <code>a/b</code>, <code>a/x/b</code>, <code>a/x/y/b</code> 등에 일치합니다.</li>
<li><code>!</code> 접두사는 패턴을 반전시킵니다. 예를 들어 <code>src/*.rs</code> 와 <code>!foo.rs</code> 패턴은 <code>src</code> 디렉토리 내에서 확장자가 <code>.rs</code> 인 모든 파일에 일치하지만, 이름이 <code>foo.rs</code> 인 파일은 제외합니다.</li>
</ul>
<p>include/exclude 목록은 일부 상황에서 변경 사항 추적을 위해서도 사용됩니다. <code>rustdoc</code> 으로 빌드되는 타겟의 경우, 타겟을 다시 빌드해야 하는지 결정하기 위해 추적할 파일 목록을 결정하는 데 사용됩니다. 패키지에 <code>rerun-if-*</code> 지시문을 내보내지 않는 <a href="reference/build-scripts.html">빌드 스크립트</a> 가 있는 경우, 해당 파일 중 하나라도 변경되면 빌드 스크립트를 다시 실행해야 하는지 추적하는 데 include/exclude 목록이 사용됩니다.</p>
<h3 id="publish-필드"><a class="header" href="#publish-필드"><code>publish</code> 필드</a></h3>
<p><code>publish</code> 필드를 사용하여 패키지를 게시할 수 있는 레지스트리 이름을 제어할 수 있습니다.</p>
<pre><code class="language-toml">[package]
# ...
publish = ["레지스트리-이름"]
</code></pre>
<p>예를 들어 회사의 패키지를 비공개로 유지하기 위해 실수로 레지스트리(예: crates.io)에 패키지가 게시되는 것을 방지하려면 <a href="reference/manifest.html#the-version-field"><code>version</code></a> 필드를 생략할 수 있습니다. 더 명시적으로 하려면 게시를 비활성화할 수 있습니다.</p>
<pre><code class="language-toml">[package]
# ...
publish = false
</code></pre>
<p>publish 배열에 단일 레지스트리가 포함된 경우, <code>--registry</code> 플래그가 지정되지 않았을 때 <code>cargo publish</code> 명령어가 해당 레지스트리를 사용합니다.</p>
<h3 id="metadata-테이블"><a class="header" href="#metadata-테이블"><code>metadata</code> 테이블</a></h3>
<p>Cargo는 기본적으로 오타 등을 감지하는 데 도움을 주기 위해 <code>Cargo.toml</code> 에서 사용되지 않는 키에 대해 경고를 표시합니다. 하지만 <code>package.metadata</code> 테이블은 Cargo에 의해 완전히 무시되며 경고도 발생하지 않습니다. 이 섹션은 <code>Cargo.toml</code> 에 패키지 구성을 저장하려는 도구에 사용할 수 있습니다. 예를 들어 다음과 같습니다.</p>
<pre><code class="language-toml">[package]
name = "..."
# ...

# 예를 들어 안드로이드 APK 생성 시 사용되는 메타데이터
[package.metadata.android]
package-name = "my-awesome-android-app"
assets = "static/경로"
</code></pre>
<p>이 필드를 사용하는 방법은 해당 도구의 문서를 참조해야 합니다. <code>package.metadata</code> 테이블을 사용하는 러스트 프로젝트의 예시는 다음과 같습니다.</p>
<ul>
<li><a href="https://docs.rs/about/metadata">docs.rs</a></li>
</ul>
<p>워크스페이스 수준에도 <a href="reference/workspaces.html#the-metadata-table"><code>workspace.metadata</code></a> 라는 유사한 테이블이 있습니다. Cargo는 이러한 테이블의 내용에 대한 형식을 지정하지 않지만, 외부 도구에서 해당 도구에 적합하다면 <code>package.metadata</code> 에 데이터가 없는 경우 <code>workspace.metadata</code> 의 데이터를 참조하는 등 일관된 방식으로 사용하도록 제안됩니다.</p>
<h3 id="default-run-필드"><a class="header" href="#default-run-필드"><code>default-run</code> 필드</a></h3>
<p>매니페스트의 <code>[package]</code> 섹션에 있는 <code>default-run</code> 필드는 <a href="reference/../commands/cargo-run.html"><code>cargo run</code></a> 에서 선택할 기본 바이너리를 지정하는 데 사용할 수 있습니다. 예를 들어, <code>src/bin/a.rs</code> 와 <code>src/bin/b.rs</code> 가 모두 있는 경우 다음과 같이 설정할 수 있습니다.</p>
<pre><code class="language-toml">[package]
default-run = "a"
</code></pre>
<h2 id="lints-섹션"><a class="header" href="#lints-섹션"><code>[lints]</code> 섹션</a></h2>
<p>테이블에서 서로 다른 도구의 린트 기본 레벨을 새로운 레벨로 재정의할 수 있습니다. 예를 들어 다음과 같습니다.</p>
<pre><code class="language-toml">[lints.rust]
unsafe_code = "forbid"
</code></pre>
<p>이것은 다음과 같은 표현의 축약형입니다.</p>
<pre><code class="language-toml">[lints.rust]
unsafe_code = { level = "forbid", priority = 0 }
</code></pre>
<p><code>level</code> 은 <code>rustc</code> 의 <a href="https://doc.rust-lang.org/rustc/lints/levels.html">린트 레벨</a> 에 대응합니다.</p>
<ul>
<li><code>forbid</code></li>
<li><code>deny</code></li>
<li><code>warn</code></li>
<li><code>allow</code></li>
</ul>
<p><code>priority</code> 는 어떤 린트나 린트 그룹이 다른 린트 그룹을 재정의할지 제어하는 부호 있는 정수입니다.</p>
<ul>
<li>낮은 수(특히 음수)는 우선순위가 낮으며 높은 수에 의해 재정의되고, <code>rustc</code> 와 같은 도구의 명령줄에 먼저 나타납니다.</li>
</ul>
<p><code>[lints]</code> 아래의 어느 테이블에 특정 린트가 속하는지 알기 위해서는 린트 이름에서 <code>::</code> 앞부분을 확인하면 됩니다. <code>::</code> 가 없다면 해당 도구는 <code>rust</code> 입니다. 예를 들어 <code>unsafe_code</code> 에 대한 경고는 <code>lints.rust.unsafe_code</code> 가 되고, <code>clippy::enum_glob_use</code> 에 대한 린트는 <code>lints.clippy.enum_glob_use</code> 가 됩니다.</p>
<p>예를 들어 다음과 같습니다.</p>
<pre><code class="language-toml">[lints.rust]
unsafe_code = "forbid"

[lints.clippy]
enum_glob_use = "deny"
</code></pre>
<p>일반적으로 이러한 설정은 현재 패키지의 로컬 개발에만 영향을 미칩니다. Cargo는 이를 현재 패키지에만 적용하고 의존성에는 적용하지 않습니다. 의존하는 패키지들의 경우, Cargo는 <a href="reference/../../rustc/lints/levels.html#capping-lints"><code>--cap-lints</code></a> 와 같은 기능을 사용하여 경로 기반이 아닌 의존성에서 발생하는 린트를 억제합니다.</p>
<blockquote>
<p><strong>MSRV:</strong> 1.74 버전부터 적용됨</p>
</blockquote>
<h2 id="the-hints-section"><a class="header" href="#the-hints-section">The <code>[hints]</code> section</a></h2>
<p>The <code>[hints]</code> section allows specifying hints for compiling this package. Cargo will respect these hints by default when compiling this package, though the top-level package being built can override these values through the <code>[profile]</code> mechanism. Hints are, by design, always safe for Cargo to ignore; if Cargo encounters a hint it doesn’t understand, or a hint it understands but with a value it doesn’t understand, it will warn, but not error. As a result, specifying hints in a crate does not impact the MSRV of the crate.</p>
<p>Individual hints may have an associated unstable feature gate that you need to pass in order to apply the configuration they specify, but if you don’t specify that unstable feature gate, you will again get only a warning, not an error.</p>
<p>There are no stable hints at this time. See the <a href="reference/unstable.html#profile-hint-mostly-unused-option">hint-mostly-unused documentation</a> for information on an unstable hint.</p>
<blockquote>
<p><strong>MSRV:</strong> Respected as of 1.90.</p>
</blockquote>
<h2 id="badges-섹션"><a class="header" href="#badges-섹션"><code>[badges]</code> 섹션</a></h2>
<p><code>[badges]</code> 섹션은 패키지가 게시될 때 레지스트리 웹사이트에 표시될 수 있는 상태 배지(status badge)를 지정하기 위한 것입니다.</p>
<blockquote>
<p>참고: <a href="https://crates.io/">crates.io</a> 는 이전에 웹사이트의 크레이트 옆에 배지를 표시했지만, 해당 기능은 제거되었습니다. 패키지는 배지를 README 파일에 포함해야 하며, 해당 파일은 <a href="https://crates.io/">crates.io</a> 에 표시됩니다 (<a href="reference/manifest.html#the-readme-field"><code>readme</code> 필드</a> 참조).</p>
</blockquote>
<pre><code class="language-toml">[badges]
# `maintenance` 테이블은 크레이트의 유지 관리 상태를 나타냅니다.
# 이는 레지스트리에서 사용될 수 있지만, 현재 crates.io에서는 사용되지 않습니다.
# 자세한 내용은 https://github.com/rust-lang/crates.io/issues/2437 및
# https://github.com/rust-lang/crates.io/issues/2438 을 참조하세요.
#
# `status` 필드는 필수입니다. 사용 가능한 옵션은 다음과 같습니다.
# - `actively-developed`: 새로운 기능이 추가되고 버그가 수정되고 있음.
# - `passively-maintained`: 새로운 기능 계획은 없지만, 제기된 이슈에 대해
#   유지 관리자가 대응할 의사가 있음.
# - `as-is`: 크레이트의 기능이 완성되었으며, 유지 관리자가 작업을 계속하거나
#   지원을 제공할 계획은 없지만, 설계된 목적대로 작동함.
# - `experimental`: 저자가 커뮤니티와 공유하고 싶어 하지만, 특정 유스케이스를
#   충족시키려는 의도는 없음.
# - `looking-for-maintainer`: 현재 유지 관리자가 크레이트를 다른 사람에게
#   양도하고 싶어 함.
# - `deprecated`: 유지 관리자가 이 크레이트 사용을 권장하지 않음 (크레이트 설명에
#   그 이유를 기재할 수 있으며, 더 나은 대안이 있거나 저자가 수정하고 싶지 않은
#   문제가 있을 수 있음).
# - `none`: 유지 관리자가 의도를 명시하지 않았으므로 crates.io에 배지를 표시하지 않음.
#   잠재적 사용자는 직접 조사해야 함.
maintenance = { status = "..." }
</code></pre>
<h2 id="의존성-섹션"><a class="header" href="#의존성-섹션">의존성 섹션</a></h2>
<p><code>[dependencies]</code>, <code>[dev-dependencies]</code>, <code>[build-dependencies]</code>, 그리고 타겟별 <code>[target.*.dependencies]</code> 섹션에 대한 자세한 정보는 <a href="reference/specifying-dependencies.html">의존성 지정하기 페이지</a> 를 참조하세요.</p>
<h2 id="profile-섹션"><a class="header" href="#profile-섹션"><code>[profile.*]</code> 섹션</a></h2>
<p><code>[profile]</code> 테이블은 최적화 및 디버그 설정과 같은 컴파일러 설정을 사용자 정의할 수 있는 방법을 제공합니다. 자세한 내용은 <a href="reference/profiles.html">프로파일(Profiles) 장</a> 을 참조하세요.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-타겟"><a class="header" href="#cargo-타겟">Cargo 타겟</a></h1>
<p>Cargo 패키지는 크레이트로 컴파일될 수 있는 소스 파일에 대응하는 <em>타겟(targets)</em> 들로 구성됩니다. 패키지는 <a href="reference/cargo-targets.html#library">라이브러리</a>, <a href="reference/cargo-targets.html#binaries">바이너리</a>, <a href="reference/cargo-targets.html#examples">예제</a>, <a href="reference/cargo-targets.html#tests">테스트</a>, <a href="reference/cargo-targets.html#benchmarks">벤치마크</a> 타겟을 가질 수 있습니다. 타겟 목록은 <code>Cargo.toml</code> 매니페스트에서 구성할 수 있으며, 종종 소스 파일의 <a href="reference/../guide/project-layout.html">디렉토리 레이아웃</a> 에 따라 <a href="reference/cargo-targets.html#target-auto-discovery">자동으로 유추</a> 됩니다.</p>
<p>타겟 설정을 구성하는 방법에 대한 자세한 내용은 아래의 <a href="reference/cargo-targets.html#configuring-a-target">타겟 구성하기</a> 를 참조하세요.</p>
<h2 id="라이브러리"><a class="header" href="#라이브러리">라이브러리</a></h2>
<p>라이브러리 타겟은 다른 라이브러리 및 실행 파일에서 사용하고 링크할 수 있는 “라이브러리“를 정의합니다. 파일 이름의 기본값은 <code>src/lib.rs</code> 이며, 라이브러리 이름의 기본값은 패키지 이름에서 대시(<code>-</code>)를 밑줄(<code>_</code>)로 바꾼 이름입니다. 패키지는 단 하나의 라이브러리만 가질 수 있습니다. 라이브러리 설정은 <code>Cargo.toml</code> 의 <code>[lib]</code> 테이블에서 <a href="reference/cargo-targets.html#configuring-a-target">사용자 정의</a> 할 수 있습니다.</p>
<pre><code class="language-toml"># Cargo.toml에서 라이브러리를 사용자 정의하는 예시
[lib]
crate-type = ["cdylib"]
bench = false
</code></pre>
<h2 id="바이너리"><a class="header" href="#바이너리">바이너리</a></h2>
<p>바이너리 타겟은 컴파일 후 실행할 수 있는 실행 프로그램입니다. 바이너리의 소스는 <code>src/main.rs</code> 일 수 있으며, 또는 <a href="reference/../guide/project-layout.html"><code>src/bin/</code> 디렉토리</a> 에 저장될 수도 있습니다. <code>src/main.rs</code> 의 경우 기본 바이너리 이름은 패키지 이름입니다. 각 바이너리의 설정은 <code>Cargo.toml</code> 의 <code>[[bin]]</code> 테이블에서 <a href="reference/cargo-targets.html#configuring-a-target">사용자 정의</a> 할 수 있습니다.</p>
<p>바이너리는 패키지 라이브러리의 공개 API를 사용할 수 있습니다. 또한 <code>Cargo.toml</code> 에 정의된 <a href="reference/specifying-dependencies.html"><code>[dependencies]</code></a>와 링크됩니다.</p>
<p>개별 바이너리는 <a href="reference/../commands/cargo-run.html"><code>cargo run</code></a> 명령어에 <code>--bin &lt;bin-이름&gt;</code> 옵션을 주어 실행할 수 있습니다. <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> 을 사용하면 실행 파일을 공통 위치로 복사할 수 있습니다.</p>
<pre><code class="language-toml"># Cargo.toml에서 바이너리를 사용자 정의하는 예시
[[bin]]
name = "cool-tool"
test = false
bench = false

[[bin]]
name = "frobnicator"
required-features = ["frobnicate"]
</code></pre>
<h2 id="예제"><a class="header" href="#예제">예제</a></h2>
<p><a href="reference/../guide/project-layout.html"><code>examples</code> 디렉토리</a> 에 있는 파일들은 라이브러리가 제공하는 기능의 사용 예제입니다. 컴파일되면 <a href="reference/build-cache.html"><code>target/debug/examples</code> 디렉토리</a> 에 배치됩니다.</p>
<p>예제는 패키지 라이브러리의 공개 API를 사용할 수 있습니다. 또한 <code>Cargo.toml</code> 에 정의된 <a href="reference/specifying-dependencies.html"><code>[dependencies]</code></a> 및 <a href="reference/specifying-dependencies.html#development-dependencies"><code>[dev-dependencies]</code></a>와 링크됩니다.</p>
<p>기본적으로 예제는 실행 가능한 바이너리(<code>main()</code> 함수 포함)입니다. <a href="reference/cargo-targets.html#the-crate-type-field"><code>crate-type</code> 필드</a> 를 지정하여 예제를 라이브러리로 컴파일할 수 있습니다.</p>
<pre><code class="language-toml">[[example]]
name = "foo"
crate-type = ["staticlib"]
</code></pre>
<p>개별 실행 예제는 <a href="reference/../commands/cargo-run.html"><code>cargo run</code></a> 명령어에 <code>--example &lt;예제-이름&gt;</code> 옵션을 주어 실행할 수 있습니다. 라이브러리 예제는 <a href="reference/../commands/cargo-build.html"><code>cargo build</code></a> 에 <code>--example &lt;예제-이름&gt;</code> 옵션을 주어 빌드할 수 있습니다. <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> 에 <code>--example &lt;예제-이름&gt;</code> 옵션을 사용하면 실행 바이너리를 공통 위치로 복사할 수 있습니다. 예제는 소스 코드가 노후화(bit-rotting)되는 것을 방지하기 위해 기본적으로 <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> 에 의해 컴파일됩니다. 예제 안에 <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> 로 실행하고 싶은 <code>#[test]</code> 함수가 있다면 <a href="reference/cargo-targets.html#the-test-field">the <code>test</code> 필드</a> 를 <code>true</code> 로 설정하세요.</p>
<h2 id="테스트-1"><a class="header" href="#테스트-1">테스트</a></h2>
<p>Cargo 프로젝트 내에는 두 가지 스타일의 테스트가 있습니다.</p>
<ul>
<li><em>단위 테스트(Unit tests)</em> 는 라이브러리나 바이너리(또는 <a href="reference/cargo-targets.html#the-test-field"><code>test</code> 필드</a> 가 활성화된 모든 타겟) 내에 위치하며 <a href="reference/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code> 속성</a>이 표시된 함수입니다. 이 테스트들은 정의된 타겟 내부의 비공개 API에 접근할 수 있습니다.</li>
<li><em>통합 테스트(Integration tests)</em> 는 별도의 실행 바이너리로, 역시 <code>#[test]</code> 함수를 포함하며 프로젝트의 라이브러리와 링크되어 <em>공개</em> API에 접근할 수 있습니다.</li>
</ul>
<p>테스트는 <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> 명령어로 실행됩니다. 기본적으로 Cargo와 <code>rustc</code> 는 <a href="reference/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code> 속성</a>이 붙은 함수들을 수집하고 병렬로 실행하며 각 테스트의 성공 및 실패를 보고하는 <a href="reference/../../rustc/tests/index.html">libtest 하네스</a> 를 사용합니다. 다른 하네스나 테스트 전략을 사용하고 싶다면 <a href="reference/cargo-targets.html#the-harness-field"><code>harness</code> 필드</a> 를 참조하세요.</p>
<blockquote>
<p><strong>참고</strong>: Cargo에는 또 다른 특별한 스타일의 테스트인 <a href="reference/../../rustdoc/documentation-tests.html">문서 테스트</a> 가 있습니다. 이는 <code>rustdoc</code> 에 의해 처리되며 실행 모델이 약간 다릅니다. 자세한 내용은 <a href="reference/../commands/cargo-test.html#documentation-tests"><code>cargo test</code></a> 를 참조하세요.</p>
</blockquote>
<h3 id="통합-테스트"><a class="header" href="#통합-테스트">통합 테스트</a></h3>
<p><a href="reference/../guide/project-layout.html"><code>tests</code> 디렉토리</a> 에 있는 파일들은 통합 테스트입니다. <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> 를 실행하면 Cargo는 이 파일들을 각각 별도의 크레이트로 컴파일하고 실행합니다.</p>
<p>통합 테스트는 패키지 라이브러리의 공개 API를 사용할 수 있습니다. 또한 <code>Cargo.toml</code> 에 정의된 <a href="reference/specifying-dependencies.html"><code>[dependencies]</code></a> 및 <a href="reference/specifying-dependencies.html#development-dependencies"><code>[dev-dependencies]</code></a>와 링크됩니다.</p>
<p>여러 통합 테스트 간에 코드를 공유하고 싶다면 <code>tests/common/mod.rs</code> 와 같은 별도의 모듈에 코드를 배치한 다음, 각 테스트에서 <code>mod common;</code> 을 사용하여 가져올 수 있습니다.</p>
<p>각 통합 테스트는 별도의 실행 바이너리로 생성되며, <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> 는 이를 순차적으로 실행합니다. 어떤 경우에는 컴파일 시간이 더 길어지고 테스트 실행 시 여러 CPU를 충분히 활용하지 못해 비효율적일 수 있습니다. 통합 테스트가 많은 경우, 단일 통합 테스트 파일을 만들고 테스트를 여러 모듈로 나누는 것을 고려해 보세요. libtest 하네스는 <code>#[test]</code> 속성이 붙은 모든 함수를 자동으로 찾아 병렬로 실행합니다. <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> 에 모듈 이름을 전달하여 해당 모듈 내의 테스트만 실행할 수도 있습니다.</p>
<p>Binary targets are automatically built if there is an integration test. This allows an integration test to execute the binary to exercise and test its behavior. The <code>CARGO_BIN_EXE_&lt;name&gt;</code> <a href="reference/environment-variables.html#environment-variables-cargo-sets-for-crates">environment variable</a> is set when the integration test is built and run so that it can use the <a href="reference/../../std/macro.env.html"><code>env</code> macro</a> or <a href="reference/../../std/env/fn.var.html"><code>var</code> function</a> to locate the executable.</p>
<h2 id="벤치마크"><a class="header" href="#벤치마크">벤치마크</a></h2>
<p>벤치마크는 <a href="reference/../commands/cargo-bench.html"><code>cargo bench</code></a> 명령어를 사용하여 코드의 성능을 테스트하는 방법을 제공합니다. 벤치마크는 <a href="reference/cargo-targets.html#tests">테스트</a> 와 동일한 구조를 따르며, 각 벤치마크 함수에는 <code>#[bench]</code> 속성이 표시됩니다. 테스트와 마찬가지로 다음과 같습니다.</p>
<ul>
<li>벤치마크는 <a href="reference/../guide/project-layout.html"><code>benches</code> 디렉토리</a> 에 위치합니다.</li>
<li>라이브러리 및 바이너리에 정의된 벤치마크 함수는 정의된 타겟 내부의 <em>비공개</em> API에 접근할 수 있습니다. <code>benches</code> 디렉토리에 있는 벤치마크는 <em>공개</em> API를 사용할 수 있습니다.</li>
<li><a href="reference/cargo-targets.html#the-bench-field"><code>bench</code> 필드</a> 를 사용하여 어떤 타겟을 기본적으로 벤치마크할지 정의할 수 있습니다.</li>
<li><a href="reference/cargo-targets.html#the-harness-field"><code>harness</code> 필드</a> 를 사용하여 내장 하네스를 비활성화할 수 있습니다.</li>
</ul>
<blockquote>
<p><strong>참고</strong>: <a href="reference/../../unstable-book/library-features/test.html"><code>#[bench]</code> 속성</a>은 현재 불안정하며 <a href="reference/../../book/appendix-07-nightly-rust.html">나이틀리 채널(nightly channel)</a> 에서만 사용할 수 있습니다. <a href="https://crates.io/crates/criterion">Criterion</a> 과 같이 안정 채널에서 벤치마크를 실행하는 데 도움이 될 수 있는 일부 패키지들이 <a href="https://crates.io/keywords/benchmark">crates.io</a> 에 있습니다.</p>
</blockquote>
<h2 id="타겟-구성하기"><a class="header" href="#타겟-구성하기">타겟 구성하기</a></h2>
<p><code>Cargo.toml</code> 의 모든 <code>[lib]</code>, <code>[[bin]]</code>, <code>[[example]]</code>, <code>[[test]]</code>, <code>[[bench]]</code> 섹션은 타겟 빌드 방식을 지정하기 위한 유사한 구성을 지원합니다. <code>[[bin]]</code> 과 같이 이중 대괄호를 사용하는 섹션은 <a href="https://toml.io/en/v1.0.0-rc.3#array-of-tables">TOML의 테이블 배열(array-of-table)</a> 로, 크레이트 내에 여러 개의 실행 파일을 만들기 위해 하나 이상의 <code>[[bin]]</code> 섹션을 작성할 수 있음을 의미합니다. 라이브러리는 하나만 지정할 수 있으므로 <code>[lib]</code> 은 일반적인 TOML 테이블입니다.</p>
<p>다음은 각 타겟에 대한 TOML 설정의 개요이며, 각 필드에 대한 자세한 설명은 아래에 나와 있습니다.</p>
<pre><code class="language-toml">[lib]
name = "foo"           # The name of the target.
path = "src/lib.rs"    # The source file of the target.
test = true            # Is tested by default.
doctest = true         # Documentation examples are tested by default.
bench = true           # Is benchmarked by default.
doc = true             # Is documented by default.
proc-macro = false     # Set to `true` for a proc-macro library.
harness = true         # Use libtest harness.
crate-type = ["lib"]   # The crate types to generate.
required-features = [] # Features required to build this target (N/A for lib).
</code></pre>
<h3 id="name-필드-1"><a class="header" href="#name-필드-1"><code>name</code> 필드</a></h3>
<p><code>name</code> 필드는 생성될 결과물의 파일 이름에 대응하는 타겟의 이름을 지정합니다. 라이브러리의 경우, 의존성 패키지들이 해당 라이브러리를 참조할 때 사용하는 크레이트 이름이 됩니다.</p>
<p>라이브러리 타겟의 경우, 기본값은 패키지 이름에서 모든 대시(<code>-</code>)를 밑줄(<code>_</code>)로 바꾼 것입니다. 기본 바이너리(<code>src/main.rs</code>)의 경우에도 기본값은 패키지 이름이지만 대시가 유지됩니다. [자동 검색(#target-auto-discovery)된 타겟의 경우, 디렉토리 또는 파일 이름이 기본값이 됩니다.</p>
<p>이 설정은 <code>[lib]</code> 를 제외한 모든 타겟에 필수입니다.</p>
<h3 id="path-필드"><a class="header" href="#path-필드"><code>path</code> 필드</a></h3>
<p><code>path</code> 필드는 <code>Cargo.toml</code> 파일의 위치를 기준으로 크레이트의 소스가 어디에 있는지 지정합니다.</p>
<p>지정하지 않으면 타겟 이름을 기반으로 <a href="reference/cargo-targets.html#target-auto-discovery">유추된 경로</a> 가 사용됩니다.</p>
<h3 id="test-필드"><a class="header" href="#test-필드"><code>test</code> 필드</a></h3>
<p><code>test</code> 필드는 해당 타겟이 <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> 에 의해 기본적으로 테스트되는지 여부를 나타냅니다. 라이브러리, 바이너리, 테스트 타겟의 기본값은 <code>true</code> 입니다.</p>
<blockquote>
<p><strong>참고</strong>: 예제는 컴파일이 계속 가능한지 확인하기 위해 기본적으로 <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> 에 의해 빌드되지만, 기본적으로 <em>테스트</em> 되지는 않습니다. 예제에 대해 <code>test = true</code> 를 설정하면 테스트로도 빌드되며, 예제 내에 정의된 모든 <a href="reference/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code></a> 함수를 실행합니다.</p>
</blockquote>
<h3 id="doctest-필드"><a class="header" href="#doctest-필드"><code>doctest</code> 필드</a></h3>
<p><code>doctest</code> 필드는 <a href="reference/../../rustdoc/documentation-tests.html">문서 예제</a> 가 <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> 에 의해 기본적으로 테스트되는지 여부를 나타냅니다. 이는 라이브러리에만 해당되며 다른 섹션에는 영향을 주지 않습니다. 라이브러리의 기본값은 <code>true</code> 입니다.</p>
<h3 id="bench-필드"><a class="header" href="#bench-필드"><code>bench</code> 필드</a></h3>
<p><code>bench</code> 필드는 해당 타겟이 <a href="reference/../commands/cargo-bench.html"><code>cargo bench</code></a> 에 의해 기본적으로 벤치마크되는지 여부를 나타냅니다. 라이브러리, 바이너리, 벤치마크 타겟의 기본값은 <code>true</code> 입니다.</p>
<h3 id="doc-필드"><a class="header" href="#doc-필드"><code>doc</code> 필드</a></h3>
<p><code>doc</code> 필드는 해당 타겟이 <a href="reference/../commands/cargo-doc.html"><code>cargo doc</code></a> 에 의해 생성되는 문서에 기본적으로 포함되는지 여부를 나타냅니다. 라이브러리와 바이너리의 기본값은 <code>true</code> 입니다.</p>
<blockquote>
<p><strong>참고</strong>: 바이너리 이름이 라이브러리 타겟 이름과 같으면 바이너리는 건너뜁니다.</p>
</blockquote>
<h3 id="plugin-필드"><a class="header" href="#plugin-필드"><code>plugin</code> 필드</a></h3>
<p>이 옵션은 사용이 중단되었으며 사용되지 않습니다.</p>
<h3 id="proc-macro-필드"><a class="header" href="#proc-macro-필드"><code>proc-macro</code> 필드</a></h3>
<p><code>proc-macro</code> 필드는 라이브러리가 <a href="reference/../../book/ch19-06-macros.html">절차적 매크로(procedural macro)</a> (<a href="reference/../../reference/procedural-macros.html">참조</a>)임을 나타냅니다. 이는 <code>[lib]</code> 타겟에만 유효합니다.</p>
<h3 id="harness-필드"><a class="header" href="#harness-필드"><code>harness</code> 필드</a></h3>
<p><code>harness</code> 필드는 <code>rustc</code> 에 <a href="reference/../../rustc/command-line-arguments.html#option-test"><code>--test</code> 플래그</a> 를 전달할지 여부를 나타냅니다. 이 플래그를 전달하면 <a href="reference/../../reference/attributes/testing.html#the-test-attribute"><code>#[test]</code> 속성</a>이 붙은 테스트나 <code>#[bench]</code> 속성이 붙은 벤치마크를 수집하고 실행하는 드라이버인 libtest 라이브러리를 자동으로 포함합니다. 모든 타겟의 기본값은 <code>true</code> 입니다.</p>
<p><code>false</code> 로 설정된 경우, 테스트와 벤치마크를 실행하기 위한 <code>main()</code> 함수를 직접 정의해야 할 책임이 사용자에게 있습니다.</p>
<p>하네스 활성화 여부와 관계없이, 테스트 시에는 <a href="reference/../../reference/conditional-compilation.html#test"><code>cfg(test)</code> 조건식</a> 이 활성화됩니다.</p>
<h3 id="crate-type-필드"><a class="header" href="#crate-type-필드"><code>crate-type</code> 필드</a></h3>
<p><code>crate-type</code> 필드는 타겟에 의해 생성될 <a href="reference/../../reference/linkage.html">크레이트 타입</a> 을 정의합니다. 문자열 배열 형식이므로 하나의 타겟에 대해 여러 크레이트 타입을 지정할 수 있습니다. 이 설정은 라이브러리와 예제 타겟에만 지정할 수 있습니다. 바이너리, 테스트, 벤치마크는 항상 “bin” 크레이트 타입입니다. 기본값은 다음과 같습니다.</p>
<div class="table-wrapper"><table><thead><tr><th>타겟</th><th>크레이트 타입</th></tr></thead><tbody>
<tr><td>일반 라이브러리</td><td><code>"lib"</code></td></tr>
<tr><td>절차적 매크로(Proc-macro) 라이브러리</td><td><code>"proc-macro"</code></td></tr>
<tr><td>예제</td><td><code>"bin"</code></td></tr>
</tbody></table>
</div>
<p>사용 가능한 옵션은 <code>bin</code>, <code>lib</code>, <code>rlib</code>, <code>dylib</code>, <code>cdylib</code>, <code>staticlib</code>, <code>proc-macro</code> 입니다. 다양한 크레이트 타입에 대한 자세한 내용은 <a href="reference/../../reference/linkage.html">Rust 레퍼런스 매뉴얼</a> 을 참조하세요.</p>
<h3 id="required-features-필드"><a class="header" href="#required-features-필드"><code>required-features</code> 필드</a></h3>
<p><code>required-features</code> 필드는 타겟을 빌드하는 데 필요한 <a href="reference/features.html">기능(features)</a> 을 지정합니다. 필요한 기능 중 하나라도 활성화되지 않으면 해당 타겟은 건너뜁니다. 이 설정은 <code>[[bin]]</code>, <code>[[bench]]</code>, <code>[[test]]</code>, <code>[[example]]</code> 섹션에만 해당되며 <code>[lib]</code> 에는 영향을 주지 않습니다.</p>
<pre><code class="language-toml">[features]
# ...
postgres = []
sqlite = []
tools = []

[[bin]]
name = "my-pg-tool"
required-features = ["postgres", "tools"]
</code></pre>
<h3 id="edition-필드-1"><a class="header" href="#edition-필드-1"><code>edition</code> 필드</a></h3>
<p>The <code>edition</code> field defines the <a href="reference/../../edition-guide/index.html">Rust edition</a> the target will use. If not specified, it defaults to the <a href="reference/manifest.html#the-edition-field"><code>edition</code> field</a> for the <code>[package]</code>.</p>
<blockquote>
<p><strong>Note:</strong> This field is deprecated and will be removed in a future Edition</p>
</blockquote>
<h2 id="타겟-자동-검색"><a class="header" href="#타겟-자동-검색">타겟 자동 검색</a></h2>
<p>기본적으로 Cargo는 파일 시스템의 <a href="reference/../guide/project-layout.html">파일 레이아웃</a> 을 기반으로 빌드할 타겟을 자동으로 결정합니다. 표준 디렉토리 레이아웃을 따르지 않는 추가 타겟을 더하려면 <code>[lib]</code>, <code>[[bin]]</code>, <code>[[test]]</code>, <code>[[bench]]</code>, <code>[[example]]</code> 과 같은 타겟 구성 테이블을 사용할 수 있습니다.</p>
<p>수동으로 구성된 타겟만 빌드되도록 타겟 자동 검색을 비활성화할 수 있습니다. <code>[package]</code> 섹션에서 <code>autolib</code>, <code>autobins</code>, <code>autoexamples</code>, <code>autotests</code>, <code>autobenches</code> 키를 <code>false</code> 로 설정하면 해당 타겟 유형의 자동 검색이 비활성화됩니다.</p>
<pre><code class="language-toml">[package]
# ...
autolib = false
autobins = false
autoexamples = false
autotests = false
autobenches = false
</code></pre>
<p>자동 검색 비활성화는 특수한 상황에서만 필요합니다. 예를 들어 라이브러리에 <code>bin</code> 이라는 이름의 <em>모듈</em> 을 두고 싶은 경우, Cargo는 보통 <code>bin</code> 디렉토리의 모든 파일을 실행 파일로 컴파일하려고 하므로 문제가 발생합니다. 다음은 이러한 시나리오의 레이아웃 예시입니다.</p>
<pre><code class="language-text">├── Cargo.toml
└── src
    ├── lib.rs
    └── bin
        └── mod.rs
</code></pre>
<p>Cargo가 <code>src/bin/mod.rs</code> 를 실행 파일로 유추하지 못하도록 하려면, <code>Cargo.toml</code> 에서 <code>autobins = false</code> 를 설정하여 자동 검색을 비활성화하세요.</p>
<pre><code class="language-toml">[package]
# …
autobins = false
</code></pre>
<blockquote>
<p><strong>참고</strong>: 2015 에디션 패키지의 경우, <code>Cargo.toml</code> 에 수동으로 정의된 타겟이 하나라도 있으면 자동 검색의 기본값은 <code>false</code> 입니다. 2018 에디션부터는 기본값이 항상 <code>true</code> 입니다.</p>
</blockquote>
<blockquote>
<p><strong>MSRV:</strong> <code>autobins</code>, <code>autoexamples</code>, <code>autotests</code>, <code>autobenches</code> 는 1.27 버전부터 적용됨</p>
</blockquote>
<blockquote>
<p><strong>MSRV:</strong> <code>autolib</code> 는 1.83 버전부터 적용됨</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rust-버전"><a class="header" href="#rust-버전">Rust 버전</a></h1>
<p><code>rust-version</code> 필드는 패키지에서 지원하는 Rust 툴체인 버전을 Cargo에 알려주는 선택적 키입니다.</p>
<pre><code class="language-toml">[package]
# ...
rust-version = "1.56"
</code></pre>
<p>Rust 버전은 최소 하나 이상의 구성 요소가 포함된 순수 버전 번호여야 합니다. SemVer 연산자나 프리릴리스 식별자를 포함할 수 없습니다. Rust 버전을 확인할 때 <code>-nightly</code> 와 같은 컴파일러 프리릴리스 식별자는 무시됩니다.</p>
<blockquote>
<p><strong>MSRV:</strong> 1.56 버전부터 적용됨</p>
</blockquote>
<h2 id="사용-사례"><a class="header" href="#사용-사례">사용 사례</a></h2>
<p><strong>진단:</strong></p>
<p>When your package is compiled on an unsupported toolchain, Cargo will report that as an error to the user. This makes the support expectations clear and avoids reporting a less direct diagnostic like invalid syntax or missing functionality in the standard library. This affects all <a href="reference/cargo-targets.html">Cargo targets</a> in the package, including binaries, examples, test suites, benchmarks, etc. A user can opt-in to an unsupported build of a package with the <code>--ignore-rust-version</code> flag.</p>
<p><strong>개발 지원:</strong></p>
<p><code>cargo add</code> 는 의존성의 버전 요구 사항을 사용자의 <code>rust-version</code> 과 호환되는 최신 버전으로 자동으로 선택합니다. 그것이 최신 버전이 아닌 경우, <code>cargo add</code> 는 사용자에게 이를 알려 사용자가 해당 버전을 유지할지 아니면 <code>rust-version</code> 을 업데이트할지 선택할 수 있게 합니다.</p>
<p><a href="reference/resolver.html#rust-version">리졸버</a> 는 의존성을 선택할 때 Rust 버전을 고려할 수 있습니다.</p>
<p>Other tools may also take advantage of it, like <code>cargo clippy</code>’s <a href="https://rust-lang.github.io/rust-clippy/stable/index.html#incompatible_msrv"><code>incompatible_msrv</code> lint</a>.</p>
<blockquote>
<p><strong>참고:</strong> <code>rust-version</code> 은 <code>--ignore-rust-version</code> 옵션을 사용하여 무시될 수 있습니다.</p>
</blockquote>
<h2 id="지원-기대-사항"><a class="header" href="#지원-기대-사항">지원 기대 사항</a></h2>
<p>이는 일반적인 기대 사항입니다. 일부 패키지는 이를 따르지 않을 때 별도로 문서화할 수 있습니다.</p>
<p><strong>완전성:</strong></p>
<p>바이너리 및 API를 포함한 모든 기능은 모든 <a href="reference/features.html">기능(feature)</a> 하에서 지원되는 Rust 버전에서 사용 가능해야 합니다.</p>
<p><strong>검증:</strong></p>
<p>패키지의 기능은 자동화된 테스트를 포함하여 지원되는 Rust 버전에서 검증되어야 합니다. <a href="reference/../guide/continuous-integration.html#verifying-rust-version">Rust 버전 CI 가이드</a> 도 참조하세요.</p>
<p><strong>패치 가능성:</strong></p>
<p>라이선스가 허용하는 경우, 사용자는 패키지의 포크를 사용하여 <a href="reference/overriding-dependencies.html">로컬 의존성을 재정의</a> 할 수 있습니다. 이 상황에서 Cargo는 패치된 의존성을 위해 전체 워크스페이스를 로드할 수 있으며, 워크스페이스의 다른 패키지들이 서로 다른 지원 Rust 버전을 가지고 있더라도 지원되는 Rust 버전에서 작동해야 합니다.</p>
<p><strong>의존성 지원:</strong></p>
<p>위 사항을 지원하기 위해, 각 의존성의 버전 요구 사항이 사용자의 <code>rust-version</code> 과 호환되는 버전을 적어도 하나 이상 지원할 것으로 기대됩니다. 하지만 의존성 명세에서 사용자의 <code>rust-version</code> 과 호환되지 않는 버전을 반드시 제외해야 하는 것은 <strong>아닙니다</strong>. 사실 두 가지 모두를 지원함으로써 이전 Rust 버전을 사용하는 사용자와 그렇지 않은 사용자 사이의 요구 사항을 균형 있게 맞출 수 있습니다.</p>
<h2 id="rust-버전-설정-및-업데이트"><a class="header" href="#rust-버전-설정-및-업데이트">Rust 버전 설정 및 업데이트</a></h2>
<p>어떤 Rust 버전을 지원할지는 다음과 같은 사항들 사이의 절충안입니다.</p>
<ul>
<li>Rust 툴체인이나 그 의존성의 최신 기능을 사용하지 못하는 유지 관리자의 비용</li>
<li>툴체인의 새로운 기능을 사용하는 패키지를 통해 혜택을 볼 수 있는 사용자의 비용 (예: 폴필(polyfill) 대신 표준 라이브러리 기능을 사용하여 빌드 시간 단축)</li>
<li>이전 Rust 버전을 사용하는 사용자들에 대한 패키지 가용성</li>
</ul>
<blockquote>
<p><strong>참고:</strong> <a href="reference/semver.html#env-new-rust"><code>rust-version</code> 변경</a> 은 마이너 비호환성으로 간주됩니다.</p>
</blockquote>
<blockquote>
<p><strong>권장 사항:</strong> 어떤 Rust 버전을 지원할지, 그리고 언제 변경할지에 대한 정책을 선택하세요. 이를 통해 사용자가 자신의 정책과 비교하고, 호환되지 않는 경우 일반적인 개선 사항의 손실이나 수정되지 않을 버그의 위험을 감수할지 결정할 수 있게 하세요.</p>
<p>지원하기 가장 간단한 정책은 항상 최신 Rust 버전을 사용하는 것입니다.</p>
<p>위험 프로필에 따라, 다음으로 간단한 방법은 이전 Rust 버전을 지원하는 패키지의 이전 주 버전이나 부 버전을 계속 지원하는 것입니다.</p>
</blockquote>
<h3 id="지원되는-rust-버전-선택"><a class="header" href="#지원되는-rust-버전-선택">지원되는 Rust 버전 선택</a></h3>
<p>패키지 사용자는 다음과 같은 기준으로 지원되는 Rust 버전을 추적할 가능성이 높습니다.</p>
<ul>
<li>Rust 툴체인 벤더의 지원 정책 (예: Rust 프로젝트 또는 리눅스 배포판)
<ul>
<li>참고: Rust 프로젝트는 최신 버전에 대해서만 버그 수정 및 보안 업데이트를 제공합니다.</li>
</ul>
</li>
<li>새로운 툴체인으로 패키지를 재검증하기 위한 고정된 일정 (예: 매년 첫 번째 릴리스, 매 5번째 릴리스 등)</li>
</ul>
<p>또한 사용자가 새로운 Rust 버전을 즉시 사용하기보다는 이를 인지하고 재검증할 시간이 필요하거나, 일정이 정확히 일치하지 않을 수도 있습니다.</p>
<p>버전 정책 예시:</p>
<ul>
<li>“N-2”: 최신 버전에서 2회 릴리스만큼의 업데이트 유예 기간을 둠을 의미함</li>
<li>모든 짝수 릴리스마다 2회 릴리스의 업데이트 유예 기간을 둠</li>
<li>이번 역년(calendar year)의 모든 버전에 대해 1년의 업데이트 유예 기간을 둠</li>
</ul>
<blockquote>
<p><strong>참고:</strong> 현재 프로젝트와 호환되는 최소 <code>rust-version</code> 을 찾으려면 <a href="https://crates.io/crates/cargo-msrv"><code>cargo-msrv</code></a> 와 같은 타사 도구를 사용할 수 있습니다.</p>
</blockquote>
<h3 id="업데이트-타임라인"><a class="header" href="#업데이트-타임라인">업데이트 타임라인</a></h3>
<p>정책에 따라 더 이상 특정 Rust 버전을 지원할 필요가 없는 경우, 즉시 또는 필요할 때 <code>rust-version</code> 을 업데이트할 수 있습니다.</p>
<p><code>rust-version</code> 이 정책에서 벗어나도록 허용함으로써 사용자에게 업그레이드를 위한 유예 기간을 더 많이 제공할 수 있습니다. 그러나 이는 사용자가 추적하는 Rust 버전과 맞추기 위해 신뢰하기에는 너무 예측 불가능합니다.</p>
<p><code>rust-version</code> 이 지정된 정책에서 멀어질수록 사용자가 의도하지 않은 정책을 추측할 가능성이 높아지며, 이는 기대에 미치지 못하는 결과로 인한 불만으로 이어질 수 있습니다.</p>
<p>차이를 허용할 때, 지원되는 버전을 중단하기 위해 무엇이 “충분히 정당화“되는지에 대한 문제가 발생합니다. 사람마다 합리적으로 다른 정당성을 제시할 수 있으며, 그러한 논의 과정은 관련 당사자들에게 좌절감을 줄 수 있습니다. 이는 갈등을 피하고 싶어 하는 사람들의 의욕을 꺾을 수 있으며, 특히 질문을 제기할 입장이 아니라고 느끼거나 갈등이 자신의 변경 사항이 병합될 기회를 해칠 수 있다고 생각하는 신규 또는 비정기 기여자들에게 그렇습니다.</p>
<h3 id="워크스페이스-내의-여러-정책"><a class="header" href="#워크스페이스-내의-여러-정책">워크스페이스 내의 여러 정책</a></h3>
<p>Cargo는 하나의 워크스페이스 내에서 여러 정책을 지원할 수 있도록 허용합니다.</p>
<p>특정 Rust 버전에서 특정 패키지를 검증하는 것은 복잡해질 수 있습니다. <a href="https://crates.io/crates/cargo-hack"><code>cargo-hack</code></a> 과 같은 도구가 도움이 될 수 있습니다.</p>
<p>여러 정책에서 공유되는 의존성의 경우, Cargo가 <a href="reference/resolver.html#semver-compatibility">SemVer 호환 버전을 통합</a> 하므로 가장 낮은 공통 버전을 사용해야 하며, 이로 인해 더 높은 <code>rust-version</code> 을 가진 워크스페이스 구성원이 공유 의존성의 기능에 접근하는 것이 제한될 수 있습니다.</p>
<p>사용자가 워크스페이스 구성원 중 하나에 대한 의존성을 패치할 수 있도록 하려면 워크스페이스의 모든 패키지가 워크스페이스에서 지원하는 가장 오래된 Rust 버전에서 로드될 수 있어야 합니다.</p>
<p><a href="reference/config.html#resolverincompatible-rust-versions"><code>incompatible-rust-versions = "fallback"</code></a> 을 사용할 때, 한 패키지의 Rust 버전이 다른 Rust 버전을 가진 다른 패키지에 대해 선택된 의존성 버전에 영향을 줄 수 있습니다. 자세한 내용은 <a href="reference/resolver.html#rust-version">리졸버</a> 장을 참조하세요.</p>
<h3 id="하나-이상의-정책"><a class="header" href="#하나-이상의-정책">하나 이상의 정책</a></h3>
<p>이전 Rust 버전을 지원하는 것의 단점을 완화하는 한 가지 방법은 계속 지원하는 패키지의 이전 주 또는 부 버전에 정책을 적용하는 것입니다. 해당 주 또는 부 버전의 릴리스 브랜치와 비교하여 개발 브랜치가 어떤 Rust 버전을 지원하는지에 대한 정책이 여전히 필요할 것입니다.</p>
<p>“필요할 때“만 개발 브랜치를 업데이트하면 지원되는 릴리스 브랜치의 수를 줄이는 데 도움이 될 수 있습니다.</p>
<p>이러한 릴리스 브랜치로 무엇을 백포트(backport)할 수 있는지의 문제가 있습니다. 부 버전 사이에 새로운 기능을 백포트하면 다음 가용 버전에는 해당 기능이 누락되어 SemVer를 위반하는 파괴적 변경(breaking change)으로 간주될 수 있습니다. 변경 사항을 백포트하는 것에는 버그가 발생할 위험도 따릅니다.</p>
<p>이전 버전을 지원하는 데는 비용이 듭니다. 이 비용은 패키지 내 버그의 위험과 영향, 그리고 백포트에 허용되는 수준에 따라 달라집니다. 필요에 따라 릴리스 브랜치를 생성하고 백포트 부담을 커뮤니티에 맡기는 것이 이러한 비용의 균형을 맞추는 방법입니다.</p>
<p>의존성 관리 도구가 최신이 아닌 버전이 여전히 지원된다는 것을 보고할 방법이 아직 없으므로, 문서에서 이를 인지하는 책임은 사용자에게 전가됩니다.</p>
<p>예를 들어 Rust 버전 지원 정책은 다음과 같을 수 있습니다.</p>
<ul>
<li>개발 브랜치는 Rust 프로젝트의 최신 안정 릴리스를 추적하며, 필요할 때 업데이트됨
<ul>
<li><code>rust-version</code> 을 변경할 때 부 버전이 상향됨</li>
</ul>
</li>
<li>프로젝트는 이번 연도의 모든 버전을 지원하며, 추가로 1년의 유예 기간을 둠
<ul>
<li>지원되는 Rust 버전을 지원하는 마지막 부 버전은 커뮤니티에서 제공하는 버그 수정을 받음</li>
<li>수정 사항은 개발 브랜치와 필요한 지원 Rust 버전 사이의 지원되는 모든 부 릴리스로 백포트되어야 함</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="워크스페이스"><a class="header" href="#워크스페이스">워크스페이스</a></h1>
<p><em>워크스페이스(workspace)</em> 는 함께 관리되는 하나 이상의 패키지(구성원 패키지라고 함)의 모음입니다.</p>
<p>워크스페이스의 핵심 요점은 다음과 같습니다.</p>
<ul>
<li><code>cargo check --workspace</code> 와 같이 공통 명령어를 모든 워크스페이스 구성원에 대해 실행할 수 있습니다.</li>
<li>모든 패키지는 <em>워크스페이스 루트</em> 에 있는 공통 <a href="reference/../guide/cargo-toml-vs-cargo-lock.html"><code>Cargo.lock</code></a> 파일을 공유합니다.</li>
<li>모든 패키지는 공통 <a href="reference/build-cache.html">출력 디렉토리</a> 를 공유하며, 기본값은 <em>워크스페이스 루트</em> 의 <code>target</code> 디렉토리입니다.</li>
<li><a href="reference/workspaces.html#the-package-table"><code>workspace.package</code></a> 를 사용하는 것처럼 패키지 메타데이터를 공유합니다.</li>
<li><code>Cargo.toml</code> 의 <a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code></a>, <a href="reference/overriding-dependencies.html#the-replace-section"><code>[replace]</code></a>, <a href="reference/profiles.html"><code>[profile.*]</code></a> 섹션은 <em>루트</em> 매니페스트에서만 인식되며 구성원 크레이트의 매니페스트에서는 무시됩니다.</li>
</ul>
<p>워크스페이스의 루트 <code>Cargo.toml</code> 은 다음 섹션을 지원합니다.</p>
<ul>
<li><a href="reference/workspaces.html#the-workspace-section"><code>[workspace]</code></a> — 워크스페이스를 정의합니다.
<ul>
<li><a href="reference/resolver.html#resolver-versions"><code>resolver</code></a> — 사용할 의존성 해결사를 설정합니다.</li>
<li><a href="reference/workspaces.html#the-members-and-exclude-fields"><code>members</code></a> — 워크스페이스에 포함할 패키지입니다.</li>
<li><a href="reference/workspaces.html#the-members-and-exclude-fields"><code>exclude</code></a> — 워크스페이스에서 제외할 패키지입니다.</li>
<li><a href="reference/workspaces.html#the-default-members-field"><code>default-members</code></a> — 특정 패키지가 선택되지 않았을 때 작동할 패키지입니다.</li>
<li><a href="reference/workspaces.html#the-package-table"><code>package</code></a> — 패키지에서 상속할 키입니다.</li>
<li><a href="reference/workspaces.html#the-dependencies-table"><code>dependencies</code></a> — 패키지 의존성에서 상속할 키입니다.</li>
<li><a href="reference/workspaces.html#the-lints-table"><code>lints</code></a> — 패키지 린트에서 상속할 키입니다.</li>
<li><a href="reference/workspaces.html#the-metadata-table"><code>metadata</code></a> — 외부 도구를 위한 추가 설정입니다.</li>
</ul>
</li>
<li><a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code></a> — 의존성을 재정의합니다.</li>
<li><a href="reference/overriding-dependencies.html#the-replace-section"><code>[replace]</code></a> — 의존성을 재정의합니다 (사용 중단됨).</li>
<li><a href="reference/profiles.html"><code>[profile]</code></a> — 컴파일러 설정 및 최적화입니다.</li>
</ul>
<h2 id="workspace-섹션"><a class="header" href="#workspace-섹션"><code>[workspace]</code> 섹션</a></h2>
<p>워크스페이스를 만들려면 <code>Cargo.toml</code> 에 <code>[workspace]</code> 테이블을 추가합니다.</p>
<pre><code class="language-toml">[workspace]
# ...
</code></pre>
<p>최소한 워크스페이스는 루트 패키지나 가상 매니페스트 중 하나를 통해 구성원을 가져야 합니다.</p>
<h3 id="루트-패키지"><a class="header" href="#루트-패키지">루트 패키지</a></h3>
<p><a href="reference/workspaces.html#the-workspace-section"><code>[workspace]</code> 섹션</a>이 이미 <code>[package]</code> 를 정의한 <code>Cargo.toml</code> 에 추가된 경우, 해당 패키지는 워크스페이스의 <em>루트 패키지</em> 입니다. <em>워크스페이스 루트</em> 는 워크스페이스의 <code>Cargo.toml</code> 이 위치한 디렉토리입니다.</p>
<pre><code class="language-toml">[workspace]

[package]
name = "hello_world" # 패키지 이름
version = "0.1.0"    # 현재 버전 (semver 준수)
</code></pre>
<h3 id="가상-워크스페이스"><a class="header" href="#가상-워크스페이스">가상 워크스페이스</a></h3>
<p>또는 <code>[workspace]</code> 섹션은 있지만 <a href="reference/manifest.html#the-package-section"><code>[package]</code> 섹션</a>이 없는 <code>Cargo.toml</code> 파일을 만들 수 있습니다. 이를 <em>가상 매니페스트(virtual manifest)</em> 라고 합니다. 이는 보통 “주요” 패키지가 없거나 모든 패키지를 별도의 디렉토리로 구성하고 싶을 때 유용합니다.</p>
<pre><code class="language-toml"># [프로젝트_디렉토리]/Cargo.toml
[workspace]
members = ["hello_world"]
resolver = "3"
</code></pre>
<pre><code class="language-toml"># [프로젝트 _디렉토리]/hello_world/Cargo.toml
[package]
name = "hello_world" # 패키지 이름
version = "0.1.0"    # 현재 버전 (semver 준수)
edition = "2024"     # 에디션 (워크스페이스에서 사용되는 리졸버에는 영향을 주지 않음)
</code></pre>
<p>루트 패키지 없이 워크스페이스를 구성하면 다음과 같습니다.</p>
<ul>
<li>가상 워크스페이스는 <a href="reference/resolver.html#resolver-versions">리졸버 버전</a> 을 유추할 수 있는 <a href="reference/manifest.html#the-edition-field"><code>package.edition</code></a> 이 없으므로 <a href="reference/resolver.html#resolver-versions"><code>resolver</code></a> 를 명시적으로 설정해야 합니다.</li>
<li>워크스페이스 루트에서 실행되는 명령어는 기본적으로 모든 워크스페이스 구성원에 대해 실행됩니다. <a href="reference/workspaces.html#the-default-members-field"><code>default-members</code></a> 를 참조하세요.</li>
</ul>
<h2 id="members-및-exclude-필드"><a class="header" href="#members-및-exclude-필드"><code>members</code> 및 <code>exclude</code> 필드</a></h2>
<p><code>members</code> 및 <code>exclude</code> 필드는 워크스페이스의 구성원인 패키지를 정의합니다.</p>
<pre><code class="language-toml">[workspace]
members = ["member1", "path/to/member2", "crates/*"]
exclude = ["crates/foo", "path/to/other"]
</code></pre>
<p>워크스페이스 디렉토리에 있는 모든 <a href="reference/specifying-dependencies.html#specifying-path-dependencies"><code>경로(path)</code> 의존성</a> 은 자동으로 구성원이 됩니다. 추가 구성원은 <code>members</code> 키를 사용하여 나열할 수 있으며, 이는 <code>Cargo.toml</code> 파일이 있는 디렉토리를 포함하는 문자열 배열이어야 합니다.</p>
<p><code>members</code> 목록은 <code>*</code> 및 <code>?</code> 와 같은 일반적인 파일 이름 글로브 패턴을 사용하여 여러 경로를 일치시키는 <a href="https://docs.rs/glob/0.3.0/glob/struct.Pattern.html">글로브(globs)</a> 를 지원합니다.</p>
<p><code>exclude</code> 키는 경로가 워크스페이스에 포함되는 것을 방지하는 데 사용할 수 있습니다. 이는 일부 경로 의존성이 워크스페이스에 포함되는 것을 전혀 원하지 않거나, 글로브 패턴을 사용 중인데 특정 디렉토리를 제거하고 싶을 때 유용할 수 있습니다.</p>
<p>워크스페이스 내의 하위 디렉토리에 있을 때, Cargo는 사용할 워크스페이스를 결정하기 위해 상위 디렉토리에서 <code>[workspace]</code> 정의가 있는 <code>Cargo.toml</code> 파일을 자동으로 검색합니다. 구성원 크레이트의 <a href="reference/manifest.html#the-workspace-field"><code>package.workspace</code></a> 매니페스트 키를 사용하여 워크스페이스 루트를 가리킴으로써 이 자동 검색을 무시할 수 있습니다. 수동 설정은 구성원이 워크스페이스 루트의 하위 디렉토리에 있지 않은 경우 유용할 수 있습니다.</p>
<h3 id="패키지-선택"><a class="header" href="#패키지-선택">패키지 선택</a></h3>
<p>워크스페이스에서 <a href="reference/../commands/cargo-build.html"><code>cargo build</code></a> 와 같은 패키지 관련 Cargo 명령어는 <code>-p</code> / <code>--package</code> 또는 <code>--workspace</code> 명령줄 플래그를 사용하여 작동할 패키지를 결정할 수 있습니다. 해당 플래그가 지정되지 않은 경우, Cargo는 현재 작업 디렉토리의 패키지를 사용합니다. 그러나 현재 디렉토리가 워크스페이스 루트인 경우 <a href="reference/workspaces.html#the-default-members-field"><code>default-members</code></a> 가 사용됩니다.</p>
<h2 id="default-members-필드"><a class="header" href="#default-members-필드"><code>default-members</code> 필드</a></h2>
<p><code>default-members</code> 필드는 워크스페이스 루트에 있고 패키지 선택 플래그를 사용하지 않을 때 작동할 <a href="reference/workspaces.html#the-members-and-exclude-fields">구성원</a> 의 경로를 지정합니다.</p>
<pre><code class="language-toml">[workspace]
members = ["path/to/member1", "path/to/member2", "path/to/member3/*"]
default-members = ["path/to/member2", "path/to/member3/foo"]
</code></pre>
<blockquote>
<p>참고: <a href="reference/workspaces.html#root-package">루트 패키지</a> 가 있을 때는 <code>--package</code> 및 <code>--workspace</code> 플래그를 사용해야만 해당 패키지에 대해 작업할 수 있습니다.</p>
</blockquote>
<p>지정되지 않은 경우 <a href="reference/workspaces.html#root-package">루트 패키지</a> 가 사용됩니다. <a href="reference/workspaces.html#virtual-workspace">가상 워크스페이스</a> 의 경우 모든 구성원이 사용됩니다 (명령줄에서 <code>--workspace</code> 가 지정된 것과 같음).</p>
<h2 id="package-테이블"><a class="header" href="#package-테이블"><code>package</code> 테이블</a></h2>
<p><code>workspace.package</code> 테이블은 워크스페이스의 구성원이 상속할 수 있는 키를 정의하는 곳입니다. 이러한 키는 구성원 패키지에서 <code>{key}.workspace = true</code> 로 정의하여 상속할 수 있습니다.</p>
<p>지원되는 키는 다음과 같습니다.</p>
<div class="table-wrapper"><table><thead><tr><th></th><th></th></tr></thead><tbody>
<tr><td><code>authors</code></td><td><code>categories</code></td></tr>
<tr><td><code>description</code></td><td><code>documentation</code></td></tr>
<tr><td><code>edition</code></td><td><code>exclude</code></td></tr>
<tr><td><code>homepage</code></td><td><code>include</code></td></tr>
<tr><td><code>keywords</code></td><td><code>license</code></td></tr>
<tr><td><code>license-file</code></td><td><code>publish</code></td></tr>
<tr><td><code>readme</code></td><td><code>repository</code></td></tr>
<tr><td><code>rust-version</code></td><td><code>version</code></td></tr>
</tbody></table>
</div>
<ul>
<li><code>license-file</code> 및 <code>readme</code> 는 워크스페이스 루트를 기준으로 합니다.</li>
<li><code>include</code> 및 <code>exclude</code> 는 사용자의 패키지 루트를 기준으로 합니다.</li>
</ul>
<p>예시:</p>
<pre><code class="language-toml"># [프로젝트_디렉토리]/Cargo.toml
[workspace]
members = ["bar"]

[workspace.package]
version = "1.2.3"
authors = ["Nice Folks"]
description = "내 패키지에 대한 짧은 설명"
documentation = "https://example.com/bar"
</code></pre>
<pre><code class="language-toml"># [프로젝트_디렉토리]/bar/Cargo.toml
[package]
name = "bar"
version.workspace = true
authors.workspace = true
description.workspace = true
documentation.workspace = true
</code></pre>
<blockquote>
<p><strong>MSRV:</strong> 1.64 이상 필요</p>
</blockquote>
<h2 id="dependencies-테이블"><a class="header" href="#dependencies-테이블"><code>dependencies</code> 테이블</a></h2>
<p><code>workspace.dependencies</code> 테이블은 워크스페이스의 구성원이 상속할 의존성을 정의하는 곳입니다.</p>
<p>워크스페이스 의존성을 지정하는 것은 다음을 제외하고 <a href="reference/specifying-dependencies.html">패키지 의존성</a> 과 유사합니다.</p>
<ul>
<li>이 테이블의 의존성은 <code>optional</code> 로 선언될 수 없습니다.</li>
<li>이 테이블에 선언된 <a href="reference/features.html"><code>기능(features)</code></a> 은 <code>[dependencies]</code> 의 <code>features</code> 에 추가됩니다.</li>
</ul>
<p>그런 다음 <a href="reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace">워크스페이스 의존성을 패키지 의존성으로 상속</a> 할 수 있습니다.</p>
<p>예시:</p>
<pre><code class="language-toml"># [프로젝트_디렉토리]/Cargo.toml
[workspace]
members = ["bar"]

[workspace.dependencies]
cc = "1.0.73"
rand = "0.8.5"
regex = { version = "1.6.0", default-features = false, features = ["std"] }
</code></pre>
<pre><code class="language-toml"># [프로젝트_디렉토리]/bar/Cargo.toml
[package]
name = "bar"
version = "0.2.0"

[dependencies]
regex = { workspace = true, features = ["unicode"] }

[build-dependencies]
cc.workspace = true

[dev-dependencies]
rand.workspace = true
</code></pre>
<blockquote>
<p><strong>MSRV:</strong> 1.64 이상 필요</p>
</blockquote>
<h2 id="lints-테이블"><a class="header" href="#lints-테이블"><code>lints</code> 테이블</a></h2>
<p><code>workspace.lints</code> 테이블은 워크스페이스의 구성원이 상속할 린트 구성을 정의하는 곳입니다.</p>
<p>워크스페이스 린트 구성을 지정하는 것은 <a href="reference/manifest.html#the-lints-section">패키지 린트</a> 와 유사합니다.</p>
<p>예시:</p>
<pre><code class="language-toml"># [프로젝트_디렉토리]/Cargo.toml
[workspace]
members = ["crates/*"]

[workspace.lints.rust]
unsafe_code = "forbid"
</code></pre>
<pre><code class="language-toml"># [프로젝트_디렉토리]/crates/bar/Cargo.toml
[package]
name = "bar"
version = "0.1.0"

[lints]
workspace = true
</code></pre>
<blockquote>
<p><strong>MSRV:</strong> 1.74 버전부터 적용됨</p>
</blockquote>
<h2 id="metadata-테이블-1"><a class="header" href="#metadata-테이블-1"><code>metadata</code> 테이블</a></h2>
<p><code>workspace.metadata</code> 테이블은 Cargo에 의해 무시되며 경고가 발생하지 않습니다. 이 섹션은 <code>Cargo.toml</code> 에 워크스페이스 구성을 저장하려는 도구에 사용할 수 있습니다. 예를 들어 다음과 같습니다.</p>
<pre><code class="language-toml">[workspace]
members = ["member1", "member2"]

[workspace.metadata.webcontents]
root = "웹프로젝트/경로"
tool = ["npm", "run", "build"]
# ...
</code></pre>
<p>패키지 수준에도 <a href="reference/manifest.html#the-metadata-table"><code>package.metadata</code></a> 라는 유사한 테이블 세트가 있습니다. Cargo는 이러한 테이블의 내용에 대한 형식을 지정하지 않지만, 외부 도구에서 관련 도구에 적합하다면 <code>package.metadata</code> 에 데이터가 없는 경우 <code>workspace.metadata</code> 의 데이터를 참조하는 등 일관된 방식으로 사용하도록 제안됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="의존성-지정하기"><a class="header" href="#의존성-지정하기">의존성 지정하기</a></h1>
<p>사용자의 크레이트는 <a href="https://crates.io/">crates.io</a> 나 다른 레지스트리, <code>git</code> 저장소 또는 로컬 파일 시스템의 하위 디렉토리에 있는 다른 라이브러리에 의존할 수 있습니다. 또한 의존성의 위치를 일시적으로 재정의할 수도 있습니다. 예를 들어 로컬에서 작업 중인 의존성의 버그 수정을 테스트하려는 경우입니다. 플랫폼마다 다른 의존성을 가질 수 있고 개발 중에만 사용되는 의존성을 가질 수도 있습니다. 이들 각각을 어떻게 수행하는지 살펴보겠습니다.</p>
<h2 id="cratesio의-의존성-지정하기"><a class="header" href="#cratesio의-의존성-지정하기">crates.io의 의존성 지정하기</a></h2>
<p>Cargo는 기본적으로 <a href="https://crates.io/">crates.io</a> 에서 의존성을 찾도록 구성되어 있습니다. 이 경우 이름과 버전 문자열만 필요합니다. <a href="reference/../guide/index.html">Cargo 가이드</a> 에서는 <code>time</code> 크레이트에 대한 의존성을 지정했습니다.</p>
<pre><code class="language-toml">[dependencies]
time = "0.1.12"
</code></pre>
<p>버전 문자열 <code>"0.1.12"</code> 는 <a href="reference/specifying-dependencies.html#version-requirement-syntax">버전 요구 사항</a> 이라고 불립니다. 이는 <a href="reference/resolver.html">의존성 해결(resolving dependencies)</a> 시 선택할 수 있는 버전 범위를 지정합니다. 이 경우 <code>"0.1.12"</code> 는 <code>&gt;=0.1.12, &lt;0.2.0</code> 버전 범위를 나타냅니다. 해당 범위 내에 있으면 업데이트가 허용됩니다. 이 경우 <code>cargo update time</code> 을 실행하면 최신 <code>0.1.z</code> 릴리스인 경우 <code>0.1.13</code> 버전으로 업데이트되지만, <code>0.2.0</code> 으로는 업데이트되지 않습니다.</p>
<h2 id="버전-요구-사항-구문"><a class="header" href="#버전-요구-사항-구문">버전 요구 사항 구문</a></h2>
<h3 id="기본-요구-사항"><a class="header" href="#기본-요구-사항">기본 요구 사항</a></h3>
<p><strong>기본 요구 사항</strong> 은 <a href="https://semver.org">SemVer</a> 호환 버전으로 업데이트할 수 있는 최소 버전을 지정합니다. 가장 왼쪽의 0이 아닌 주/부/패치 구성 요소가 동일하면 버전이 호환되는 것으로 간주됩니다. 이는 1.0.0 이전의 모든 패키지를 호환되지 않는 것으로 간주하는 <a href="https://semver.org">SemVer</a> 와 다릅니다.</p>
<p><code>1.2.3</code> 은 기본 요구 사항의 예입니다.</p>
<pre><code class="language-notrust">1.2.3  :=  &gt;=1.2.3, &lt;2.0.0
1.2    :=  &gt;=1.2.0, &lt;2.0.0
1      :=  &gt;=1.0.0, &lt;2.0.0
0.2.3  :=  &gt;=0.2.3, &lt;0.3.0
0.2    :=  &gt;=0.2.0, &lt;0.3.0
0.0.3  :=  &gt;=0.0.3, &lt;0.0.4
0.0    :=  &gt;=0.0.0, &lt;0.1.0
0      :=  &gt;=0.0.0, &lt;1.0.0
</code></pre>
<h3 id="캐럿caret-요구-사항"><a class="header" href="#캐럿caret-요구-사항">캐럿(Caret) 요구 사항</a></h3>
<p><strong>캐럿 요구 사항</strong> 은 기본 버전 요구 사항 전략입니다. 이 버전 전략은 <a href="https://semver.org">SemVer</a> 호환 업데이트를 허용합니다. 앞에 캐럿(<code>^</code>)이 붙은 버전 요구 사항으로 지정됩니다.</p>
<p><code>^1.2.3</code> 은 캐럿 요구 사항의 예입니다.</p>
<p>캐럿을 생략하는 것은 캐럿 요구 사항을 사용하는 것과 동일한 단순화된 구문입니다. 캐럿 요구 사항이 기본값이지만 가능하면 단순화된 구문을 사용하는 것이 좋습니다.</p>
<p><code>log = "^1.2.3"</code> 은 <code>log = "1.2.3"</code> 과 정확히 동일합니다.</p>
<h3 id="틸드tilde-요구-사항"><a class="header" href="#틸드tilde-요구-사항">틸드(Tilde) 요구 사항</a></h3>
<p><strong>틸드 요구 사항</strong> 은 어느 정도 업데이트가 가능한 최소 버전을 지정합니다. 주, 부, 패치 버전을 모두 지정하거나 주 및 부 버전만 지정하는 경우 패치 수준의 변경만 허용됩니다. 주 버전만 지정하는 경우에는 부 및 패치 수준의 변경이 허용됩니다.</p>
<p><code>~1.2.3</code> 은 틸드 요구 사항의 예입니다.</p>
<pre><code class="language-notrust">~1.2.3  := &gt;=1.2.3, &lt;1.3.0
~1.2    := &gt;=1.2.0, &lt;1.3.0
~1      := &gt;=1.0.0, &lt;2.0.0
</code></pre>
<h3 id="와일드카드wildcard-요구-사항"><a class="header" href="#와일드카드wildcard-요구-사항">와일드카드(Wildcard) 요구 사항</a></h3>
<p><strong>와일드카드 요구 사항</strong> 은 와일드카드가 배치된 위치에 어떤 버전이든 허용합니다.</p>
<p><code>*</code>, <code>1.*</code>, <code>1.2.*</code> 는 와일드카드 요구 사항의 예입니다.</p>
<pre><code class="language-notrust">*     := &gt;=0.0.0
1.*   := &gt;=1.0.0, &lt;2.0.0
1.2.* := &gt;=1.2.0, &lt;1.3.0
</code></pre>
<blockquote>
<p><strong>참고</strong>: <a href="https://crates.io/">crates.io</a> 는 <code>*</code> 만 있는 버전은 허용하지 않습니다.</p>
</blockquote>
<h3 id="비교-요구-사항"><a class="header" href="#비교-요구-사항">비교 요구 사항</a></h3>
<p><strong>비교 요구 사항</strong> 은 의존할 버전 범위 또는 정확한 버전을 수동으로 지정할 수 있도록 합니다.</p>
<p>다음은 비교 요구 사항의 몇 가지 예입니다.</p>
<pre><code class="language-notrust">&gt;= 1.2.0
&gt; 1
&lt; 2
= 1.2.3
</code></pre>
<p><span id="multiple-requirements"></span></p>
<h3 id="여러-버전-요구-사항"><a class="header" href="#여러-버전-요구-사항">여러 버전 요구 사항</a></h3>
<p>As shown in the examples above, multiple version requirements can be separated with a comma, e.g., <code>&gt;= 1.2, &lt; 1.5</code>. All requirements must be satisfied, so non-overlapping requirements like <code>&lt;1.2, ^1.2.2</code> result in no matching versions.</p>
<h3 id="프리릴리스pre-releases"><a class="header" href="#프리릴리스pre-releases">프리릴리스(Pre-releases)</a></h3>
<p>버전 요구 사항은 명시적으로 요청하지 않는 한 <code>1.0.0-alpha</code> 와 같은 <a href="reference/manifest.html#the-version-field">프리릴리스 버전</a> 을 제외합니다. 예를 들어 <code>foo</code> 패키지의 <code>1.0.0-alpha</code> 가 게시된 경우 <code>foo = "1.0"</code> 요구 사항은 일치하지 않으며 오류를 반환합니다. <code>foo = "1.0.0-alpha"</code> 와 같이 프리릴리스를 명시해야 합니다. 마찬가지로 <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> 은 명시적으로 요청하지 않는 한 프리릴리스를 피합니다.</p>
<p>Cargo는 “더 새로운” 프리릴리스가 자동으로 사용되도록 허용합니다. 예를 들어 <code>1.0.0-beta</code> 가 게시된 경우 <code>foo = "1.0.0-alpha"</code> 요구 사항은 <code>beta</code> 버전으로의 업데이트를 허용합니다. 이는 동일한 릴리스 버전에서만 작동하며, <code>foo = "1.0.0-alpha"</code> 가 <code>foo = "1.0.1-alpha"</code> 또는 <code>foo = "1.0.1-beta"</code> 로의 업데이트를 허용하지는 않습니다.</p>
<p>Cargo는 또한 프리릴리스에서 SemVer 호환 정식 릴리스 버전으로 자동 업그레이드합니다. <code>foo = "1.0.0-alpha"</code> 요구 사항은 <code>foo = "1.0.0"</code> 뿐만 아니라 <code>foo = "1.2.0"</code> 으로의 업데이트도 허용합니다.</p>
<p>프리릴리스 버전은 불안정할 수 있으므로 사용할 때 주의해야 합니다. 일부 프로젝트는 프리릴리스 버전 사이에 파괴적 변경을 게시하기로 할 수도 있습니다. 사용자의 라이브러리 자체가 프리릴리스가 아닌 경우 라이브러리에서 프리릴리스 의존성을 사용하지 않는 것이 좋습니다. <code>Cargo.lock</code> 을 업데이트할 때도 주의를 기울여야 하며 프리릴리스 업데이트로 인해 문제가 발생할 경우에 대비해야 합니다.</p>
<h3 id="버전-메타데이터"><a class="header" href="#버전-메타데이터">버전 메타데이터</a></h3>
<p><code>1.0.0+21AF26D3</code> 과 같은 <a href="reference/manifest.html#the-version-field">버전 메타데이터</a> 는 무시되며 버전 요구 사항에 사용해서는 안 됩니다.</p>
<blockquote>
<p><strong>권장 사항:</strong> 확실하지 않은 경우 기본 버전 요구 사항 연산자를 사용하세요.</p>
<p>드문 경우지만, 여러 SemVer 비호환 버전과 호환되는 “공개 의존성(public dependency)”(의존성을 재내보내거나 공개 API에서 상호 운용함)이 있는 패키지(예: <code>Id</code> 와 같이 릴리스 간에 변경되지 않은 단순한 타입만 사용함)는 사용자가 어떤 버전의 “공개 의존성“을 사용할지 선택하는 것을 지원할 수 있습니다. 이 경우 <code>"&gt;=0.4, &lt;2"</code> 와 같은 버전 요구 사항이 유용할 수 있습니다. <em>하지만</em> Cargo가 <a href="reference/resolver.html">의존성 버전을 해결</a> 할 때 서로 다른 버전의 “공개 의존성“을 선택할 수 있으므로, 해당 패키지의 사용자도 동일한 의존성에 의존하는 경우 오류가 발생할 가능성이 높으며 <code>cargo update</code> 를 통해 수동으로 “공개 의존성” 버전을 선택해야 할 수도 있습니다. (<a href="https://github.com/rust-lang/cargo/issues/10599">#10599</a> 참조)</p>
<p>Avoid constraining the upper bound of a version to be anything less than the next semver incompatible version (e.g. avoid <code>"&gt;=2.0, &lt;2.4"</code>, <code>"2.0.*"</code>, or <code>~2.0</code>), as other packages in the dependency tree may require a newer version, leading to an unresolvable error (see <a href="https://github.com/rust-lang/cargo/issues/9029">#9029</a>). Consider whether controlling the version in your <a href="reference/../guide/cargo-toml-vs-cargo-lock.html"><code>Cargo.lock</code></a> would be more appropriate.</p>
<p>다음과 같은 일부 사례에서는 이것이 문제가 되지 않거나 이점이 비용보다 클 수 있습니다.</p>
<ul>
<li>When no one else depends on your package; e.g. it only has a <code>[[bin]]</code></li>
<li>When depending on a pre-release package and wishing to avoid breaking changes, then a fully specified <code>"=1.2.3-alpha.3"</code> might be warranted (see <a href="https://github.com/rust-lang/cargo/issues/2222">#2222</a>)</li>
<li>When a library re-exports a proc-macro but the proc-macro generates code that calls into the re-exporting library, then a fully specified <code>=1.2.3</code> might be warranted to ensure the proc-macro isn’t newer than the re-exporting library and generating code that uses parts of the API that don’t exist within the current version</li>
</ul>
</blockquote>
<h2 id="다른-레지스트리의-의존성-지정하기"><a class="header" href="#다른-레지스트리의-의존성-지정하기">다른 레지스트리의 의존성 지정하기</a></h2>
<p><a href="https://crates.io/">crates.io</a> 이외의 레지스트리에서 의존성을 지정하려면 <code>registry</code> 키를 사용할 레지스트리 이름으로 설정하세요.</p>
<pre><code class="language-toml">[dependencies]
some-crate = { version = "1.0", registry = "my-registry" }
</code></pre>
<p>여기서 <code>my-registry</code> 는 <code>.cargo/config.toml</code> 파일에 구성된 레지스트리 이름입니다. 자세한 내용은 <a href="reference/registries.html">레지스트리 문서</a> 를 참조하세요.</p>
<blockquote>
<p><strong>참고</strong>: <a href="https://crates.io/">crates.io</a> 는 <a href="https://crates.io/">crates.io</a> 외부에서 게시된 코드에 의존하는 패키지의 게시를 허용하지 않습니다.</p>
</blockquote>
<h2 id="git-저장소의-의존성-지정하기"><a class="header" href="#git-저장소의-의존성-지정하기"><code>git</code> 저장소의 의존성 지정하기</a></h2>
<p><code>git</code> 저장소에 위치한 라이브러리에 의존하려면, 지정해야 하는 최소한의 정보는 <code>git</code> 키를 사용한 저장소 위치입니다.</p>
<pre><code class="language-toml">[dependencies]
regex = { git = "https://github.com/rust-lang/regex.git" }
</code></pre>
<p>Cargo는 해당 위치에서 <code>git</code> 저장소를 가져와 파일 트리를 탐색하여 <code>git</code> 저장소 내부 어디에서나 요청된 크레이트의 <code>Cargo.toml</code> 파일을 찾습니다. 예를 들어, <code>regex-lite</code> 와 <code>regex-syntax</code> 는 <code>rust-lang/regex</code> 저장소의 구성원이며, 파일 트리의 어디에 있든 관계없이 저장소의 루트 URL(<code>https://github.com/rust-lang/regex.git</code>)로 참조될 수 있습니다.</p>
<pre><code class="language-toml">regex-lite   = { git = "https://github.com/rust-lang/regex.git" }
regex-syntax = { git = "https://github.com/rust-lang/regex.git" }
</code></pre>
<p>위의 규칙은 <a href="reference/specifying-dependencies.html#specifying-path-dependencies"><code>경로(path)</code> 의존성</a> 에는 적용되지 않습니다.</p>
<h3 id="커밋-선택"><a class="header" href="#커밋-선택">커밋 선택</a></h3>
<p>위의 예시처럼 저장소 URL만 지정하는 경우, Cargo는 패키지 빌드를 위해 기본 브랜치의 최신 커밋을 사용하려는 것으로 가정합니다.</p>
<p>사용할 커밋을 더 구체적으로 지정하기 위해 <code>git</code> 키를 <code>rev</code>, <code>tag</code> 또는 <code>branch</code> 키와 조합할 수 있습니다. 다음은 <code>next</code> 라는 이름의 브랜치에서 최신 커밋을 사용하는 예입니다.</p>
<pre><code class="language-toml">[dependencies]
regex = { git = "https://github.com/rust-lang/regex.git", branch = "next" }
</code></pre>
<p>브랜치나 태그가 아닌 모든 것은 <code>rev</code> 키에 해당합니다. 이는 <code>rev = "4c59b707"</code> 과 같은 커밋 해시이거나, <code>rev = "refs/pull/493/head"</code> 와 같이 원격 저장소에서 공개한 명명된 참조일 수 있습니다.</p>
<p><code>rev</code> 키에 사용 가능한 참조는 저장소가 호스팅되는 위치에 따라 다릅니다. GitHub는 위의 예시와 같이 모든 풀 리퀘스트의 최신 커밋에 대한 참조를 공개합니다. 다른 git 호스트도 다른 명명 체계에 따라 동등한 것을 제공할 수 있습니다.</p>
<p><strong>기타 <code>git</code> 의존성 예시:</strong></p>
<pre><code class="language-toml"># 호스트가 해당 URL을 허용한다면 .git 접미사는 생략할 수 있습니다 - 두 예시는 동일하게 작동합니다
regex = { git = "https://github.com/rust-lang/regex" }
regex = { git = "https://github.com/rust-lang/regex.git" }

# 특정 태그가 있는 커밋
regex = { git = "https://github.com/rust-lang/regex.git", tag = "1.10.3" }

# SHA1 해시를 통한 커밋
regex = { git = "https://github.com/rust-lang/regex.git", rev = "0c0990399270277832fbb5b91a1fa118e6f63dba" }

# PR 493의 HEAD 커밋
regex = { git = "https://github.com/rust-lang/regex.git", rev = "refs/pull/493/head" }

# 잘못된 예시

# # 뒤에 커밋을 지정하면 커밋 ID를 무시하고 경고를 발생시킵니다
regex = { git = "https://github.com/rust-lang/regex.git#4c59b70" }

# git과 path는 동시에 사용할 수 없습니다
regex = { git = "https://github.com/rust-lang/regex.git#4c59b70", path = "../regex" }
</code></pre>
<p>Cargo는 <code>git</code> 의존성을 추가할 때 <code>Cargo.lock</code> 파일에 커밋을 고정(lock)하며, <code>cargo update</code> 명령어를 실행할 때만 업데이트를 확인합니다.</p>
<h3 id="version-키의-역할"><a class="header" href="#version-키의-역할"><code>version</code> 키의 역할</a></h3>
<p><code>version</code> 키는 <code>git</code> 또는 <code>path</code> 키의 존재 여부와 관계없이 항상 패키지가 레지스트리에서 사용 가능함을 의미합니다.</p>
<p><code>version</code> 키는 Cargo가 <code>git</code> 의존성을 가져올 때 어떤 커밋을 사용할지에 영향을 주지 않지만, Cargo는 의존성의 <code>Cargo.toml</code> 파일에 있는 버전 정보를 <code>version</code> 키와 대조하여 확인하고 실패할 경우 오류를 발생시킵니다.</p>
<p>이 예시에서 Cargo는 Git에서 <code>next</code> 라는 이름의 브랜치의 HEAD 커밋을 가져오고, 크레이트의 버전이 <code>version = "1.10.3"</code> 과 호환되는지 확인합니다.</p>
<pre><code class="language-toml">[dependencies]
regex = { version = "1.10.3", git = "https://github.com/rust-lang/regex.git", branch = "next" }
</code></pre>
<p><code>version</code>, <code>git</code>, <code>path</code> 키는 의존성 해결을 위한 별개의 위치로 간주됩니다. 자세한 설명은 아래의 <a href="reference/specifying-dependencies.html#multiple-locations">여러 위치(Multiple locations)</a> 섹션을 참조하세요.</p>
<blockquote>
<p><strong>참고</strong>: <a href="https://crates.io/">crates.io</a> 는 <a href="https://crates.io/">crates.io</a> 자체 이외의 곳에 게시된 코드에 의존하는 패키지의 게시를 허용하지 않습니다. (<a href="reference/specifying-dependencies.html#development-dependencies">개발 의존성(dev-dependencies)</a> 은 무시됩니다). <code>git</code> 및 <code>path</code> 의존성에 대한 폴백(fallback) 대안은 <a href="reference/specifying-dependencies.html#multiple-locations">여러 위치(Multiple locations)</a> 섹션을 참조하세요.</p>
</blockquote>
<h3 id="git-submodules"><a class="header" href="#git-submodules">Git submodules</a></h3>
<p>When cloning a <code>git</code> dependency, Cargo automatically fetches its submodules recursively so that all required code is available for the build.</p>
<p>To skip fetching submodules unrelated to the build, you can set <a href="https://git-scm.com/docs/gitmodules#Documentation/gitmodules.txt-submodulenameupdate"><code>submodule.&lt;name&gt;.update = none</code></a> in the dependency repo’s <code>.gitmodules</code>. This requires write access to the repo and will disable submodule updates more generally.</p>
<h3 id="비공개-git-저장소-접근하기"><a class="header" href="#비공개-git-저장소-접근하기">비공개 Git 저장소 접근하기</a></h3>
<p>비공개 저장소에 대한 Git 인증 도움말은 <a href="reference/../appendix/git-authentication.html">Git 인증</a> 을 참조하세요.</p>
<h2 id="경로path-의존성-지정하기"><a class="header" href="#경로path-의존성-지정하기">경로(path) 의존성 지정하기</a></h2>
<p>시간이 지남에 따라 <a href="reference/../guide/index.html">가이드</a> 의 <code>hello_world</code> 패키지의 크기가 상당히 커졌습니다! 이제는 다른 사람들이 사용할 수 있도록 별도의 크레이트로 분리하고 싶을 정도입니다. 이를 위해 Cargo는 보통 하나의 저장소 내에 있는 하위 크레이트인 <strong>경로 의존성(path dependencies)</strong> 을 지원합니다. 먼저 <code>hello_world</code> 패키지 내에 새 크레이트를 만들어 보겠습니다.</p>
<pre><code class="language-console"># inside of hello_world/
$ cargo new hello_utils
</code></pre>
<p>이렇게 하면 <code>hello_utils</code> 라는 새 폴더가 생성되고 그 안에 <code>Cargo.toml</code> 과 <code>src</code> 폴더가 구성 준비를 마칩니다. Cargo에 이를 알리려면 <code>hello_world/Cargo.toml</code> 을 열고 의존성에 <code>hello_utils</code> 를 추가하세요.</p>
<pre><code class="language-toml">[dependencies]
hello_utils = { path = "hello_utils" }
</code></pre>
<p>이는 해당 <code>Cargo.toml</code> 파일이 작성된 위치를 기준으로 <code>hello_utils</code> 폴더에 있는 <code>hello_utils</code> 라는 크레이트에 의존함을 Cargo에 알려줍니다.</p>
<p>다음 <code>cargo build</code> 시 <code>hello_utils</code> 와 그 모든 의존성을 자동으로 빌드합니다.</p>
<h3 id="로컬-경로-탐색-없음"><a class="header" href="#로컬-경로-탐색-없음">로컬 경로 탐색 없음</a></h3>
<p>로컬 경로는 의존성의 <code>Cargo.toml</code> 이 있는 정확한 폴더를 가리켜야 합니다. <code>git</code> 의존성과 달리 Cargo는 로컬 경로를 탐색하지 않습니다. 예를 들어, <code>regex-lite</code> 와 <code>regex-syntax</code> 가 로컬에 복제된 <code>rust-lang/regex</code> 저장소의 구성원인 경우 전체 경로로 참조해야 합니다.</p>
<pre><code class="language-toml"># git 키는 저장소 루트 URL을 허용하며 Cargo가 크레이트를 찾기 위해 트리를 탐색합니다
[dependencies]
regex-lite   = { git = "https://github.com/rust-lang/regex.git" }
regex-syntax = { git = "https://github.com/rust-lang/regex.git" }

# path 키는 로컬 경로에 구성원 이름이 포함되어야 합니다
[dependencies]
regex-lite   = { path = "../regex/regex-lite" }
regex-syntax = { path = "../regex/regex-syntax" }
</code></pre>
<h3 id="게시된-크레이트의-로컬-경로"><a class="header" href="#게시된-크레이트의-로컬-경로">게시된 크레이트의 로컬 경로</a></h3>
<p>경로만으로 지정된 의존성을 사용하는 크레이트는 <a href="https://crates.io/">crates.io</a> 에서 허용되지 않습니다.</p>
<p><code>hello_world</code> 크레이트를 게시하려면 <code>hello_utils</code> 버전을 별도의 크레이트로 <a href="https://crates.io/">crates.io</a> 에 게시하고 <code>hello_world</code> 의 의존성 줄에 해당 버전을 지정해야 합니다.</p>
<pre><code class="language-toml">[dependencies]
hello_utils = { path = "hello_utils", version = "0.1.0" }
</code></pre>
<p><code>path</code> 및 <code>version</code> 키를 함께 사용하는 방법은 <a href="reference/specifying-dependencies.html#multiple-locations">여러 위치(Multiple locations)</a> 섹션에서 설명합니다.</p>
<blockquote>
<p><strong>참고</strong>: <a href="https://crates.io/">crates.io</a> 는 <a href="reference/specifying-dependencies.html#development-dependencies">개발 의존성(dev-dependencies)</a> 을 제외하고 <a href="https://crates.io/">crates.io</a> 외부 코드에 의존하는 패키지의 게시를 허용하지 않습니다. <code>git</code> 및 <code>path</code> 의존성에 대한 폴백 대안은 <a href="reference/specifying-dependencies.html#multiple-locations">여러 위치(Multiple locations)</a> 섹션을 참조하세요.</p>
</blockquote>
<h2 id="여러-위치"><a class="header" href="#여러-위치">여러 위치</a></h2>
<p>레지스트리 버전과 <code>git</code> 또는 <code>path</code> 위치를 모두 지정하는 것이 가능합니다. 로컬에서는 <code>git</code> 또는 <code>path</code> 의존성이 사용되며(이 경우 <code>version</code> 은 로컬 사본과 대조하여 확인됨), <a href="https://crates.io/">crates.io</a> 와 같은 레지스트리에 게시될 때는 레지스트리 버전이 사용됩니다. 다른 조합은 허용되지 않습니다. 예시:</p>
<pre><code class="language-toml">[dependencies]
# 로컬에서 사용될 때는 `my-bitflags` 를 사용하고,
# 게시될 때는 crates.io의 1.0 버전을 사용합니다.
bitflags = { path = "my-bitflags", version = "1.0" }

# 로컬에서 사용될 때는 지정된 git 저장소를 사용하고,
# 게시될 때는 crates.io의 1.0 버전을 사용합니다.
smallvec = { git = "https://github.com/servo/rust-smallvec.git", version = "1.0" }

# 참고: 버전이 일치하지 않으면 Cargo 빌드에 실패합니다!
</code></pre>
<p>이것이 유용할 수 있는 한 가지 예는 라이브러리를 동일한 워크스페이스 내의 여러 패키지로 분할한 경우입니다. 개발 중에는 <code>path</code> 의존성을 사용하여 워크스페이스 내의 로컬 패키지를 가리켜 로컬 버전을 사용하고, 게시된 후에는 <a href="https://crates.io/">crates.io</a> 버전을 사용할 수 있습니다. 이는 <a href="reference/overriding-dependencies.html">재정의(override)</a> 를 지정하는 것과 유사하지만, 이 하나의 의존성 선언에만 적용됩니다.</p>
<h2 id="플랫폼별-의존성"><a class="header" href="#플랫폼별-의존성">플랫폼별 의존성</a></h2>
<p>플랫폼별 의존성은 동일한 형식을 사용하지만 <code>target</code> 섹션 아래에 나열됩니다. 보통 이러한 섹션을 정의하기 위해 Rust와 유사한 <a href="reference/../../reference/conditional-compilation.html"><code>#[cfg]</code> 구문</a>이 사용됩니다.</p>
<pre><code class="language-toml">[target.'cfg(windows)'.dependencies]
winhttp = "0.4.0"

[target.'cfg(unix)'.dependencies]
openssl = "1.0.1"

[target.'cfg(target_arch = "x86")'.dependencies]
native-i686 = { path = "native/i686" }

[target.'cfg(target_arch = "x86_64")'.dependencies]
native-x86_64 = { path = "native/x86_64" }
</code></pre>
<p>Rust와 마찬가지로, 여기서의 구문은 다양한 cfg 이름/값 쌍을 결합하기 위해 <code>not</code>, <code>any</code>, <code>all</code> 연산자를 지원합니다.</p>
<p>사용자의 플랫폼에서 어떤 cfg 타겟을 사용할 수 있는지 알고 싶다면 명령줄에서 <code>rustc --print=cfg</code> 를 실행하세요. 64비트 윈도우와 같은 다른 플랫폼에 대해 어떤 <code>cfg</code> 타겟을 사용할 수 있는지 알고 싶다면 <code>rustc --print=cfg --target=x86_64-pc-windows-msvc</code> 를 실행하세요.</p>
<p>Rust 소스 코드와 달리, <code>[target.'cfg(feature = "fancy-feature")'.dependencies]</code> 를 사용하여 선택적 기능에 따른 의존성을 추가할 수는 없습니다. 대신 <a href="reference/features.html">기능(<code>[features]</code>) 섹션</a>을 사용하세요.</p>
<pre><code class="language-toml">[dependencies]
foo = { version = "1.0", optional = true }
bar = { version = "1.0", optional = true }

[features]
fancy-feature = ["foo", "bar"]
</code></pre>
<p><code>cfg(debug_assertions)</code>, <code>cfg(test)</code>, <code>cfg(proc_macro)</code> 에도 동일하게 적용됩니다. 이러한 값들은 예상대로 작동하지 않으며 항상 <code>rustc --print=cfg</code> 가 반환하는 기본값을 가집니다. 현재 이러한 구성 값에 따라 의존성을 추가할 수 있는 방법은 없습니다.</p>
<p><code>#[cfg]</code> 구문 외에도, Cargo는 의존성이 적용될 전체 타겟을 나열하는 것도 지원합니다.</p>
<pre><code class="language-toml">[target.x86_64-pc-windows-gnu.dependencies]
winhttp = "0.4.0"

[target.i686-unknown-linux-gnu.dependencies]
openssl = "1.0.1"
</code></pre>
<h3 id="사용자-정의-타겟-사양"><a class="header" href="#사용자-정의-타겟-사양">사용자 정의 타겟 사양</a></h3>
<p>사용자 정의 타겟 사양(예: <code>--target foo/bar.json</code>)을 사용하는 경우, <code>.json</code> 확장자를 제외한 기본 파일 이름을 사용하세요.</p>
<pre><code class="language-toml">[target.bar.dependencies]
winhttp = "0.4.0"

[target.my-special-i686-platform.dependencies]
openssl = "1.0.1"
native = { path = "native/i686" }
</code></pre>
<blockquote>
<p><strong>참고</strong>: 사용자 정의 타겟 사양은 안정 채널에서 사용할 수 없습니다.</p>
</blockquote>
<h2 id="개발-의존성"><a class="header" href="#개발-의존성">개발 의존성</a></h2>
<p><code>Cargo.toml</code> 에 <code>[dependencies]</code> 와 형식이 동일한 <code>[dev-dependencies]</code> 섹션을 추가할 수 있습니다.</p>
<pre><code class="language-toml">[dev-dependencies]
tempdir = "0.3"
</code></pre>
<p>개발 의존성은 빌드를 위한 패키지 컴파일 시에는 사용되지 않지만, 테스트, 예제, 벤치마크 컴파일 시에는 사용됩니다.</p>
<p>이러한 의존성은 이 패키지에 의존하는 다른 패키지로 전파되지 <em>않습니다</em>.</p>
<p>또한 <code>dependencies</code> 대신 타겟 섹션 헤더에 <code>dev-dependencies</code> 를 사용하여 플랫폼별 개발 의존성을 가질 수 있습니다. 예시:</p>
<pre><code class="language-toml">[target.'cfg(unix)'.dev-dependencies]
mio = "0.0.1"
</code></pre>
<blockquote>
<p><strong>참고</strong>: 패키지가 게시될 때 <code>version</code> 이 지정된 개발 의존성만 게시된 크레이트에 포함됩니다. 대부분의 경우 게시 시 개발 의존성이 필요하지 않지만, 일부 사용자(OS 패키지 관리자 등)는 크레이트 내에서 테스트를 실행하고 싶어 할 수 있으므로 가능하면 <code>version</code> 을 제공하는 것이 여전히 도움이 될 수 있습니다.</p>
</blockquote>
<h2 id="빌드-의존성"><a class="header" href="#빌드-의존성">빌드 의존성</a></h2>
<p>빌드 스크립트에서 사용하기 위해 다른 Cargo 기반 크레이트에 의존할 수 있습니다. 의존성은 매니페스트의 <code>build-dependencies</code> 섹션을 통해 선언됩니다.</p>
<pre><code class="language-toml">[build-dependencies]
cc = "1.0.3"
</code></pre>
<p>또한 <code>dependencies</code> 대신 타겟 섹션 헤더에 <code>build-dependencies</code> 를 사용하여 플랫폼별 빌드 의존성을 가질 수 있습니다. 예시:</p>
<pre><code class="language-toml">[target.'cfg(unix)'.build-dependencies]
cc = "1.0.3"
</code></pre>
<p>이 경우 호스트 플랫폼이 지정된 타겟과 일치할 때만 의존성이 빌드됩니다.</p>
<p>빌드 스크립트는 <code>dependencies</code> 또는 <code>dev-dependencies</code> 섹션에 나열된 의존성에 접근할 수 <strong>없습니다</strong>. 마찬가지로 빌드 의존성도 <code>dependencies</code> 섹션에도 나열되지 않는 한 패키지 자체에서 사용할 수 없습니다. 패키지 자체와 빌드 스크립트는 별도로 빌드되므로 의존성이 일치할 필요가 없습니다. Cargo는 독립적인 목적을 위해 독립적인 의존성을 사용하여 더 단순하고 깔끔하게 유지됩니다.</p>
<h2 id="기능-선택하기"><a class="header" href="#기능-선택하기">기능 선택하기</a></h2>
<p>의존하는 패키지가 조건부 기능을 제공하는 경우, 사용할 기능을 지정할 수 있습니다.</p>
<pre><code class="language-toml">[dependencies.awesome]
version = "1.3.5"
default-features = false # 기본 기능을 포함하지 않고,
                         # 선택적으로 개별 기능을 골라서 사용합니다
features = ["secure-password", "civet"]
</code></pre>
<p>기능에 대한 자세한 내용은 <a href="reference/features.html#dependency-features">기능(features) 장</a> 에서 확인할 수 있습니다.</p>
<h2 id="cargotoml-에서-의존성-이름-변경하기"><a class="header" href="#cargotoml-에서-의존성-이름-변경하기"><code>Cargo.toml</code> 에서 의존성 이름 변경하기</a></h2>
<p><code>Cargo.toml</code> 의 <code>[dependencies]</code> 섹션을 작성할 때 의존성에 대해 작성하는 키는 보통 코드에서 가져오는 크레이트 이름과 일치합니다. 하지만 일부 프로젝트에서는 crates.io에 어떻게 게시되었는지와 관계없이 코드에서 다른 이름으로 크레이트를 참조하고 싶을 수 있습니다. 예를 들어 다음과 같은 경우입니다.</p>
<ul>
<li>Rust 소스에서 <code>use foo as bar</code> 를 사용할 필요를 피하고 싶은 경우</li>
<li>크레이트의 여러 버전에 의존하고 싶은 경우</li>
<li>서로 다른 레지스트리에서 이름이 같은 크레이트에 의존하고 싶은 경우</li>
</ul>
<p>이를 지원하기 위해 Cargo는 <code>[dependencies]</code> 섹션에서 어떤 패키지에 의존해야 하는지를 지정하는 <code>package</code> 키를 지원합니다.</p>
<pre><code class="language-toml">[package]
name = "mypackage"
version = "0.0.1"

[dependencies]
foo = "0.1"
bar = { git = "https://github.com/example/project.git", package = "foo" }
baz = { version = "0.1", registry = "custom", package = "foo" }
</code></pre>
<p>이 예시에서 이제 Rust 코드에서 세 개의 크레이트를 사용할 수 있습니다.</p>
<pre><code class="language-rust ignore">extern crate foo; // crates.io
extern crate bar; // git 저장소
extern crate baz; // `custom` 레지스트리</code></pre>
<p>이 세 크레이트 모두 자체 <code>Cargo.toml</code> 에서 패키지 이름이 <code>foo</code> 이므로, 로컬에서 다른 이름으로 부르더라도 <code>foo</code> 패키지를 원한다는 것을 Cargo에 알리기 위해 <code>package</code> 키를 명시적으로 사용하고 있습니다. <code>package</code> 키를 지정하지 않으면 요청되는 의존성 이름이 기본값이 됩니다.</p>
<p>다음과 같은 선택적 의존성이 있는 경우 주의하세요.</p>
<pre><code class="language-toml">[dependencies]
bar = { version = "0.1", package = 'foo', optional = true }
</code></pre>
<p>crates.io의 <code>foo</code> 크레이트에 의존하고 있지만, 사용자의 크레이트에는 <code>foo</code> 기능 대신 <code>bar</code> 기능이 생깁니다. 즉, 이름을 변경할 때 기능의 이름은 패키지 이름이 아니라 의존성 이름을 따릅니다.</p>
<p>전이적 의존성(transitive dependencies)을 활성화하는 것도 비슷하게 작동합니다. 예를 들어 위 매니페스트에 다음을 추가할 수 있습니다.</p>
<pre><code class="language-toml">[features]
log-debug = ['bar/log-debug'] # using 'foo/log-debug' would be an error!
</code></pre>
<h2 id="워크스페이스에서-의존성-상속하기"><a class="header" href="#워크스페이스에서-의존성-상속하기">워크스페이스에서 의존성 상속하기</a></h2>
<p>워크스페이스의 <a href="reference/workspaces.html#the-dependencies-table"><code>[workspace.dependencies]</code></a> 테이블에 의존성을 지정하여 워크스페이스에서 의존성을 상속할 수 있습니다. 그 후, <code>[dependencies]</code> 테이블에 <code>workspace = true</code> 와 함께 추가하세요.</p>
<p><code>workspace</code> 키와 더불어 의존성에는 다음 키들이 포함될 수 있습니다.</p>
<ul>
<li><a href="reference/features.html#optional-dependencies"><code>optional</code></a>: <code>[workspace.dependencies]</code> 테이블에서는 <code>optional</code> 을 지정할 수 없습니다.</li>
<li><a href="reference/features.html"><code>기능(features)</code></a>: 이는 <code>[workspace.dependencies]</code> 에 선언된 기능에 추가됩니다.</li>
</ul>
<p><code>optional</code> 및 <code>features</code> 외에 상속된 의존성은 다른 의존성 키(<code>version</code> 또는 <code>default-features</code> 등)를 사용할 수 없습니다.</p>
<p><code>[dependencies]</code>, <code>[dev-dependencies]</code>, <code>[build-dependencies]</code>, <code>[target."...".dependencies]</code> 섹션의 의존성은 의존성의 <code>[workspace.dependencies]</code> 정의를 참조하는 기능을 지원합니다.</p>
<pre><code class="language-toml">[package]
name = "bar"
version = "0.2.0"

[dependencies]
regex = { workspace = true, features = ["unicode"] }

[build-dependencies]
cc.workspace = true

[dev-dependencies]
rand = { workspace = true, optional = true }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="의존성-재정의하기"><a class="header" href="#의존성-재정의하기">의존성 재정의하기</a></h1>
<p>의존성을 재정의하려는 욕구는 여러 시나리오를 통해 발생할 수 있습니다. 하지만 대부분은 크레이트가 <a href="https://crates.io/">crates.io</a> 에 게시되기 전에 해당 크레이트로 작업할 수 있는 기능으로 요약됩니다. 예를 들면 다음과 같습니다.</p>
<ul>
<li>작업 중인 크레이트가 작업 중인 훨씬 더 큰 애플리케이션에서도 사용되고 있으며, 해당 큰 애플리케이션 내부에서 라이브러리의 버그 수정을 테스트하고 싶은 경우</li>
<li>직접 작업하지 않는 상위(upstream) 크레이트의 git 저장소 master 브랜치에 새로운 기능이나 버그 수정이 있어 이를 테스트하고 싶은 경우</li>
<li>크레이트의 새로운 주 버전을 게시하려는데, 새 주 버전이 잘 작동하는지 확인하기 위해 전체 패키지에 걸쳐 통합 테스트를 수행하고 싶은 경우</li>
<li>발견한 버그에 대해 상위 크레이트에 수정을 제출했지만, 버그 수정이 병합될 때까지 기다리지 않고 즉시 애플리케이션이 크레이트의 수정된 버전에 의존하기 시작하게 하고 싶은 경우</li>
</ul>
<p>이러한 시나리오는 <a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code> 매니페스트 섹션</a>으로 해결할 수 있습니다.</p>
<p>이 장에서는 몇 가지 다른 유스케이스를 살펴보고, 의존성을 재정의하는 다양한 방법에 대한 세부 정보를 포함합니다.</p>
<ul>
<li>유스케이스 예시
<ul>
<li><a href="reference/overriding-dependencies.html#testing-a-bugfix">버그 수정 테스트</a></li>
<li><a href="reference/overriding-dependencies.html#working-with-an-unpublished-minor-version">게시되지 않은 부 버전으로 작업하기</a>
<ul>
<li><a href="reference/overriding-dependencies.html#overriding-repository-url">저장소 URL 재정의하기</a></li>
</ul>
</li>
<li><a href="reference/overriding-dependencies.html#prepublishing-a-breaking-change">파괴적 변경 사전 게시하기</a></li>
<li><a href="reference/overriding-dependencies.html#using-patch-with-multiple-versions">여러 버전에 <code>[patch]</code> 사용하기</a></li>
</ul>
</li>
<li>참조
<ul>
<li><a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code> 섹션</a></li>
<li><a href="reference/overriding-dependencies.html#the-replace-section"><code>[replace]</code> 섹션</a></li>
<li><a href="reference/overriding-dependencies.html#paths-overrides"><code>paths</code> 재정의</a></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>참고</strong>: 로컬 패키지의 단일 의존성 선언에 대한 소스를 재정의하는 데 사용할 수 있는 <a href="reference/specifying-dependencies.html#multiple-locations">여러 위치(multiple locations)</a> 로 의존성 지정하기를 참조하세요.</p>
</blockquote>
<h2 id="버그-수정-테스트하기"><a class="header" href="#버그-수정-테스트하기">버그 수정 테스트하기</a></h2>
<p><a href="https://crates.io/crates/uuid"><code>uuid</code> 크레이트</a> 를 사용하여 작업하던 중 버그를 발견했다고 가정해 봅시다. 당신은 매우 진취적인 사람이기에 직접 버그를 수정해 보기로 했습니다! 원래 매니페스트는 다음과 같을 것입니다.</p>
<pre><code class="language-toml">[package]
name = "my-library"
version = "0.1.0"

[dependencies]
uuid = "1.0"
</code></pre>
<p>가장 먼저 할 일은 <a href="https://github.com/uuid-rs/uuid"><code>uuid</code> 저장소</a> 를 로컬로 복제하는 것입니다.</p>
<pre><code class="language-console">$ git clone https://github.com/uuid-rs/uuid.git
</code></pre>
<p>다음으로 <code>my-library</code> 의 매니페스트를 다음과 같이 수정합니다.</p>
<pre><code class="language-toml">[patch.crates-io]
uuid = { path = "../uuid/경로" }
</code></pre>
<p>여기서 우리는 <code>crates-io</code> 소스를 새로운 의존성으로 <em>패칭(patching)</em> 한다고 선언합니다. 이렇게 하면 로컬 패키지의 crates.io 레지스트리에 로컬로 체크아웃된 <code>uuid</code> 버전이 실질적으로 추가됩니다.</p>
<p>다음으로, 패키지가 crates.io의 복사본 대신 로컬로 체크아웃된 복사본을 사용하도록 <code>uuid</code> 의 새 버전을 사용하도록 락 파일을 업데이트해야 합니다. <code>[patch]</code> 가 작동하는 방식은 <code>../path/to/uuid</code> 에 있는 의존성을 로드한 다음, <code>uuid</code> 버전에 대해 crates.io를 쿼리할 때마다 로컬 버전도 <em>함께</em> 반환하는 것입니다.</p>
<p>이는 로컬 체크아웃의 버전 번호가 중요하며 패치 사용 여부에 영향을 미친다는 것을 의미합니다. 매니페스트에서 <code>uuid = "1.0"</code> 을 선언했으므로 <code>&gt;= 1.0.0, &lt; 2.0.0</code> 만 해결(resolve)하며, Cargo의 탐욕적(greedy) 해결 알고리즘은 해당 범위 내에서 최대 버전을 해결함을 의미합니다. 보통 git 저장소의 버전이 이미 crates.io에 게시된 최대 버전보다 크거나 같으므로 문제가 되지 않지만, 이를 염두에 두는 것이 중요합니다!</p>
<p>어떤 경우든, 보통 지금 필요한 작업은 다음과 같습니다.</p>
<pre><code class="language-console">$ cargo build
   Compiling uuid v1.0.0 (.../uuid)
   Compiling my-library v0.1.0 (.../my-library)
    Finished dev [unoptimized + debuginfo] target(s) in 0.32 secs
</code></pre>
<p>이것으로 끝입니다! 이제 <code>uuid</code> 의 로컬 버전으로 빌드하게 됩니다 (빌드 출력의 괄호 안에 있는 경로를 확인하세요). 로컬 경로 버전이 빌드되는 것이 보이지 않는다면 <code>cargo update uuid --precise $version</code> 을 실행해야 할 수도 있습니다. 여기서 <code>$version</code> 은 로컬로 체크아웃된 <code>uuid</code> 사본의 버전입니다.</p>
<p>원래 발견했던 버그를 수정한 후 다음에 할 일은 아마도 이를 <code>uuid</code> 크레이트 자체에 풀 리퀘스트로 제출하는 것입니다. 이 작업을 마친 후에는 <code>[patch]</code> 섹션도 업데이트할 수 있습니다. <code>[patch]</code> 내부의 목록은 <code>[dependencies]</code> 섹션과 똑같으므로, 풀 리퀘스트가 병합되면 다음과 같이 <code>path</code> 의존성을 변경할 수 있습니다.</p>
<pre><code class="language-toml">[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid.git' }
</code></pre>
<h2 id="게시되지-않은-부-버전으로-작업하기"><a class="header" href="#게시되지-않은-부-버전으로-작업하기">게시되지 않은 부 버전으로 작업하기</a></h2>
<p>이제 버그 수정에서 기능 추가로 주제를 바꿔보겠습니다. <code>my-library</code> 를 작업하던 중 <code>uuid</code> 크레이트에 완전히 새로운 기능이 필요하다는 것을 발견했습니다. 이 기능을 구현했고, 위에서 <code>[patch]</code> 를 사용하여 로컬에서 테스트했으며, 풀 리퀘스트를 제출했습니다. 실제로 게시되기 전에 이를 어떻게 계속 사용하고 테스트하는지 살펴보겠습니다.</p>
<p>또한 crates.io의 현재 <code>uuid</code> 버전은 <code>1.0.0</code> 이지만, 그 이후 git 저장소의 master 브랜치가 <code>1.0.1</code> 로 업데이트되었다고 가정해 봅시다. 이 브랜치에는 이전에 제출한 새로운 기능이 포함되어 있습니다. 이 저장소를 사용하기 위해 <code>Cargo.toml</code> 을 다음과 같이 수정합니다.</p>
<pre><code class="language-toml">[package]
name = "my-library"
version = "0.1.0"

[dependencies]
uuid = "1.0.1"

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid.git' }
</code></pre>
<p>크레이트가 게시된 후 실제로 필요하게 될 버전인 <code>1.0.1</code> 로 <code>uuid</code> 에 대한 로컬 의존성을 업데이트했습니다. 하지만 이 버전은 crates.io에 존재하지 않으므로 매니페스트의 <code>[patch]</code> 섹션으로 제공합니다.</p>
<p>이제 라이브러리가 빌드될 때 git 저장소에서 <code>uuid</code> 를 가져오고, crates.io에서 버전을 다운로드하는 대신 저장소 내부의 1.0.1로 해결합니다. 1.0.1이 crates.io에 게시되면 <code>[patch]</code> 섹션을 삭제할 수 있습니다.</p>
<p><code>[patch]</code> 가 <em>전이적으로(transitively)</em> 적용된다는 점도 주목할 가치가 있습니다. 다음과 같이 더 큰 패키지에서 <code>my-library</code> 를 사용한다고 가정해 봅시다.</p>
<pre><code class="language-toml">[package]
name = "my-binary"
version = "0.1.0"

[dependencies]
my-library = { git = 'https://example.com/git/my-library' }
uuid = "1.0"

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid.git' }
</code></pre>
<p><code>[patch]</code> 는 <em>전이적으로</em> 적용 가능하지만 <em>최상위 수준(top level)</em> 에서만 정의될 수 있으므로, <code>my-library</code> 의 소비자인 우리는 필요한 경우 <code>[patch]</code> 섹션을 반복해야 합니다. 하지만 여기서는 새로운 <code>uuid</code> 크레이트가 우리의 <code>uuid</code> 의존성과 <code>my-library -&gt; uuid</code> 의존성 <em>둘 다</em> 에 적용됩니다. <code>uuid</code> 크레이트는 이 전체 크레이트 그래프에 대해 하나의 버전인 1.0.1로 해결되며 git 저장소에서 가져오게 됩니다.</p>
<h3 id="저장소-url-재정의하기"><a class="header" href="#저장소-url-재정의하기">저장소 URL 재정의하기</a></h3>
<p>재정의하려는 의존성이 <code>crates.io</code> 에서 로드되지 않는 경우, <code>[patch]</code> 사용법을 약간 변경해야 합니다. 예를 들어 의존성이 git 의존성인 경우 다음과 같이 로컬 경로로 재정의할 수 있습니다.</p>
<pre><code class="language-toml">[patch."https://github.com/your/repository"]
my-library = { path = "../my-library/경로" }
</code></pre>
<p>이게 전부입니다!</p>
<h2 id="파괴적-변경-사전-게시하기"><a class="header" href="#파괴적-변경-사전-게시하기">파괴적 변경 사전 게시하기</a></h2>
<p>보통 파괴적 변경을 동반하는 크레이트의 새로운 주 버전으로 작업하는 경우를 살펴보겠습니다. 이전 크레이트의 예를 이어가자면, <code>uuid</code> 크레이트의 2.0.0 버전을 만들려고 합니다. 상위에 모든 변경 사항을 제출한 후, <code>my-library</code> 의 매니페스트를 다음과 같이 업데이트할 수 있습니다.</p>
<pre><code class="language-toml">[dependencies]
uuid = "2.0"

[patch.crates-io]
uuid = { git = "https://github.com/uuid-rs/uuid.git", branch = "2.0.0" }
</code></pre>
<p>이게 전부입니다! 이전 예제와 마찬가지로 2.0.0 버전은 실제로 crates.io에 존재하지 않지만, <code>[patch]</code> 섹션을 사용하여 git 의존성을 통해 추가할 수 있습니다. 사고 실험으로 위에서 본 <code>my-binary</code> 매니페스트를 다시 한번 살펴보겠습니다.</p>
<pre><code class="language-toml">[package]
name = "my-binary"
version = "0.1.0"

[dependencies]
my-library = { git = 'https://example.com/git/my-library' }
uuid = "1.0"

[patch.crates-io]
uuid = { git = 'https://github.com/uuid-rs/uuid.git', branch = '2.0.0' }
</code></pre>
<p>이 경우 실제로 <code>uuid</code> 크레이트의 두 버전으로 해결됩니다. <code>my-binary</code> 크레이트는 계속해서 <code>uuid</code> 크레이트의 1.x.y 시리즈를 사용하지만, <code>my-library</code> 크레이트는 <code>2.0.0</code> 버전의 <code>uuid</code> 를 사용하게 됩니다. 이를 통해 모든 것을 한꺼번에 업데이트하도록 강요받지 않고도 의존성 그래프를 통해 크레이트에 파괴적 변경을 점진적으로 적용할 수 있습니다.</p>
<h2 id="여러-버전에-patch-사용하기"><a class="header" href="#여러-버전에-patch-사용하기">여러 버전에 <code>[patch]</code> 사용하기</a></h2>
<p>의존성 이름을 변경하는 데 사용되는 <code>package</code> 키를 사용하여 동일한 크레이트의 여러 버전을 패치할 수 있습니다. 예를 들어, <code>serde</code> 크레이트의 <code>1.*</code> 시리즈에 사용하고 싶은 버그 수정이 있지만, 동시에 우리 git 저장소에 있는 <code>2.0.0</code> 버전의 serde를 사용하여 프로토타입을 만들고 싶다고 가정해 봅시다. 이를 위해 다음과 같이 구성할 수 있습니다.</p>
<pre><code class="language-toml">[patch.crates-io]
serde = { git = 'https://github.com/serde-rs/serde.git' }
serde2 = { git = 'https://github.com/example/serde.git', package = 'serde', branch = 'v2' }
</code></pre>
<p>첫 번째 <code>serde = ...</code> 지시어는 git 저장소에서 serde <code>1.*</code> 를 사용해야 함을 나타내고(필요한 버그 수정을 가져옴), 두 번째 <code>serde2 = ...</code> 지시어는 <code>https://github.com/example/serde</code> 의 <code>v2</code> 브랜치에서도 <code>serde</code> 패키지를 가져와야 함을 나타냅니다. 여기서는 해당 브랜치의 <code>Cargo.toml</code> 이 <code>2.0.0</code> 버전을 명시하고 있다고 가정합니다.</p>
<p><code>package</code> 키를 사용할 때 여기서 <code>serde2</code> 식별자는 실제로 무시됩니다. 우리는 단지 다른 패치된 크레이트와 충돌하지 않는 고유한 이름이 필요할 뿐입니다.</p>
<h2 id="patch-섹션"><a class="header" href="#patch-섹션"><code>[patch]</code> 섹션</a></h2>
<p><code>Cargo.toml</code> 의 <code>[patch]</code> 섹션은 의존성을 다른 사본으로 재정의하는 데 사용될 수 있습니다. 구문은 <a href="reference/specifying-dependencies.html"><code>[dependencies]</code></a> 섹션과 유사합니다.</p>
<pre><code class="language-toml">[patch.crates-io]
foo = { git = 'https://github.com/example/foo.git' }
bar = { path = 'my/local/bar' }

[dependencies.baz]
git = 'https://github.com/example/baz.git'

[patch.'https://github.com/example/baz']
baz = { git = 'https://github.com/example/patched-baz.git', branch = 'my-branch' }
</code></pre>
<blockquote>
<p><strong>참고</strong>: <code>[patch]</code> 테이블은 <code>.cargo/config.toml</code> 파일이나 <code>--config 'patch.crates-io.rand.path="rand"'</code> 와 같은 CLI 옵션을 통해 <a href="reference/config.html">구성 옵션</a> 으로 지정할 수도 있습니다. 이는 커밋하고 싶지 않은 로컬 전용 변경 사항이나 임시로 패치를 테스트할 때 유용할 수 있습니다.</p>
</blockquote>
<p><code>[patch]</code> 테이블은 의존성과 유사한 하위 테이블들로 구성됩니다. <code>[patch]</code> 뒤의 각 키는 패치하려는 소스의 URL 또는 레지스트리 이름입니다. <code>crates-io</code> 라는 이름을 사용하여 기본 레지스트리인 <a href="https://crates.io/">crates.io</a> 를 재정의할 수 있습니다. 위의 예에서 첫 번째 <code>[patch]</code> 는 <a href="https://crates.io/">crates.io</a> 를 재정의하는 것을 보여주고, 두 번째 <code>[patch]</code> 는 git 소스를 재정의하는 것을 보여줍니다.</p>
<p>이러한 테이블의 각 항목은 매니페스트의 <code>[dependencies]</code> 섹션에 있는 것과 동일한 일반적인 의존성 사양입니다. <code>[patch]</code> 섹션에 나열된 의존성들은 해결(resolve)되어 지정된 URL의 소스를 패치하는 데 사용됩니다. 위의 매니페스트 코드 조각은 <code>foo</code> 크레이트와 <code>bar</code> 크레이트로 <code>crates-io</code> 소스(예: crates.io 자체)를 패치합니다. 또한 <code>https://github.com/example/baz</code> 소스를 다른 곳에서 가져온 <code>my-branch</code> 로 패치합니다.</p>
<p>소스는 존재하지 않는 버전의 크레이트로 패치될 수도 있고, 이미 존재하는 버전의 크레이트로 패치될 수도 있습니다. 소스에 이미 존재하는 크레이트 버전으로 패치하는 경우, 소스의 원래 크레이트가 대체됩니다.</p>
<p>Cargo는 워크스페이스 루트의 <code>Cargo.toml</code> 매니페스트에 있는 패치 설정만 확인합니다. 의존성에 정의된 패치 설정은 무시됩니다.</p>
<h2 id="replace-섹션"><a class="header" href="#replace-섹션"><code>[replace]</code> 섹션</a></h2>
<blockquote>
<p><strong>참고</strong>: <code>[replace]</code> 는 사용 중단되었습니다. 대신 <a href="reference/overriding-dependencies.html#the-patch-section"><code>[patch]</code></a> 테이블을 사용해야 합니다.</p>
</blockquote>
<p>Cargo.toml의 이 섹션은 의존성을 다른 사본으로 재정의하는 데 사용될 수 있습니다. 구문은 <code>[dependencies]</code> 섹션과 유사합니다.</p>
<pre><code class="language-toml">[replace]
"foo:0.1.0" = { git = 'https://github.com/example/foo.git' }
"bar:1.0.2" = { path = 'my/local/bar' }
</code></pre>
<p><code>[replace]</code> 테이블의 각 키는 <a href="reference/pkgid-spec.html">패키지 ID 사양(package ID specification)</a> 이며, 의존성 그래프에서 재정의할 노드를 임의로 선택할 수 있습니다(3부분으로 된 버전 번호가 필수입니다). 각 키의 값은 기능을 지정할 수 없다는 점을 제외하고는 의존성을 지정하는 <code>[dependencies]</code> 구문과 동일합니다. 크레이트가 재정의될 때 대체되는 사본은 이름과 버전이 모두 동일해야 하지만, 다른 소스(예: git 또는 로컬 경로)에서 가져올 수 있습니다.</p>
<p>Cargo는 워크스페이스 루트의 <code>Cargo.toml</code> 매니페스트에 있는 replace 설정만 확인합니다. 의존성에 정의된 replace 설정은 무시됩니다.</p>
<h2 id="paths-재정의"><a class="header" href="#paths-재정의"><code>paths</code> 재정의</a></h2>
<p>때로는 크레이트에서 일시적으로만 작업하고 있어 위의 <code>[patch]</code> 섹션처럼 <code>Cargo.toml</code> 을 수정하고 싶지 않을 때가 있습니다. 이 유스케이스를 위해 Cargo는 <strong>경로 재정의(path overrides)</strong> 라는 훨씬 더 제한적인 형태의 재정의를 제공합니다.</p>
<p>경로 재정의는 <code>Cargo.toml</code> 대신 <a href="reference/config.html"><code>.cargo/config.toml</code></a> 을 통해 지정됩니다. <code>.cargo/config.toml</code> 내부에 <code>paths</code> 라는 키를 지정합니다.</p>
<pre><code class="language-toml">paths = ["/uuid/경로"]
</code></pre>
<p>이 배열은 <code>Cargo.toml</code> 을 포함하는 디렉토리들로 채워져야 합니다. 이 예에서는 <code>uuid</code> 만 추가하고 있으므로 해당 크레이트만 재정의됩니다. 이 경로는 절대 경로일 수도 있고 <code>.cargo</code> 폴더를 포함하는 디렉토리를 기준으로 한 상대 경로일 수도 있습니다.</p>
<p>Path overrides are more restricted than the <code>[patch]</code> section, however, in that they cannot change the structure of the dependency graph. When a path replacement is used then the previous set of dependencies must all match exactly to the new <code>Cargo.toml</code> specification. For example this means that path overrides cannot be used to test out adding a dependency to a crate. Instead, <code>[patch]</code> must be used in that situation. As a result, usage of a path override is typically isolated to quick bug fixes rather than larger changes.</p>
<blockquote>
<p><strong>참고</strong>: 경로를 재정의하기 위해 로컬 구성을 사용하는 것은 <a href="https://crates.io/">crates.io</a> 에 게시된 크레이트에 대해서만 작동합니다. 이 기능을 사용하여 Cargo에 로컬의 게시되지 않은 크레이트를 찾는 방법을 알려줄 수는 없습니다.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="소스-교체"><a class="header" href="#소스-교체">소스 교체</a></h1>
<p>This document is about redirecting communication with <a href="reference/registries.html">registries</a> or repositories of <a href="reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories">git-based dependencies</a> to another data source, such as a server mirroring the original registry or an exact local copy.</p>
<p>If you want to patch individual dependencies, see <a href="reference/overriding-dependencies.html">overriding dependencies</a> section of this documentation. If you want to control how Cargo makes network requests, see <a href="reference/config.html#http"><code>[http]</code></a> and <a href="reference/config.html#net"><code>[net]</code></a> configuration.</p>
<p><em>소스(source)</em> 는 패키지의 의존성으로 포함될 수 있는 크레이트를 포함하는 제공자입니다. Cargo는 다음과 같은 전략을 표현하기 위해 <strong>한 소스를 다른 소스로 대체</strong> 하는 기능을 지원합니다.</p>
<ul>
<li>
<p>벤더링(Vendoring) — 로컬 파일 시스템의 크레이트를 나타내는 사용자 정의 소스를 정의할 수 있습니다. 이러한 소스는 대체하는 소스의 하위 집합이며 필요한 경우 패키지에 체크인될 수 있습니다.</p>
</li>
<li>
<p>미러링(Mirroring) — 소스를 crates.io 자체의 캐시 역할을 하는 동등한 버전으로 대체할 수 있습니다.</p>
</li>
</ul>
<p>Cargo는 소스 대체에 대해 두 소스의 소스 코드가 정확히 동일하다는 핵심 가정을 가지고 있습니다. 이는 대체 소스가 원래 소스에 없는 크레이트를 가질 수 없음을 의미하기도 합니다.</p>
<p>결과적으로, 소스 대체는 의존성 패치나 비공개 레지스트리와 같은 상황에는 적합하지 않습니다. Cargo는 <a href="reference/overriding-dependencies.html"><code>[patch]</code> 키</a>를 사용하여 의존성 패치를 지원하며, 비공개 레지스트리 지원은 <a href="reference/registries.html">레지스트리 장</a> 에서 설명합니다.</p>
<p>When using source replacement, running commands that need to contact the registry directly<sup class="footnote-reference"><a href="#1">1</a></sup> requires passing the <code>--registry</code> option. This helps avoid any ambiguity about which registry to contact, and will use the authentication token for the specified registry.</p>
<div class="footnote-definition" id="1"><sup class="footnote-definition-label">1</sup>
<p>Examples of such commands are in <a href="reference/../commands/publishing-commands.html">Publishing Commands</a>.</p>
</div>
<h2 id="설정"><a class="header" href="#설정">설정</a></h2>
<p>대체 소스 구성은 <a href="reference/config.html"><code>.cargo/config.toml</code></a> 을 통해 이루어지며 사용 가능한 키의 전체 세트는 다음과 같습니다.</p>
<pre><code class="language-toml"># `source` 테이블은 소스 대체와 관련된 모든 키가 저장되는 곳입니다.
[source]

# `source` 테이블 아래에는 해당 소스의 이름이 키가 되는 여러 테이블이 있습니다.
# 예를 들어, 이 섹션은 이 `.cargo/config.toml` 파일을 포함하는 디렉토리를 기준으로
# `vendor` 에 위치한 디렉토리에서 가져오는 `my-vendor-source` 라는 새 소스를 정의합니다.
[source.my-vendor-source]
directory = "vendor"

# crates.io 기본 크레이트 소스는 "crates-io"라는 이름으로 사용할 수 있으며,
# 여기서는 `replace-with` 키를 사용하여 위에서 정의한 소스로 대체됨을 나타냅니다.
#
# `replace-with` 키는 `[registries]` 테이블에 정의된 대체 레지스트리 이름을 참조할 수도 있습니다.
[source.crates-io]
replace-with = "my-vendor-source"

# 각 소스는 소스 이름이 키가 되는 자체 테이블을 가집니다.
[source.소스-이름]

# `소스-이름 ` 이 다른 곳에 정의된 `another-source` 로 대체됨을 나타냅니다.
replace-with = "another-source"

# 여러 종류의 소스를 지정할 수 있습니다 (아래에서 더 자세히 설명함):
registry = "https://example.com/path/to/index"
local-registry = "path/to/registry"
directory = "path/to/vendor"

# Git 소스는 선택적으로 브랜치/태그/리비전도 지정할 수 있습니다.
git = "https://example.com/path/to/repo"
# branch = "master"
# tag = "v1.0.1"
# rev = "313f44e8"
</code></pre>
<h2 id="레지스트리-소스"><a class="header" href="#레지스트리-소스">레지스트리 소스</a></h2>
<p>A “registry source” is one that works like crates.io itself. It’s an index that conforms to the specification at https://doc.rust-lang.org/cargo/reference/registry-index.html with a configuration file indicating where to download crates from.</p>
<p>Registry sources can use <a href="reference/registries.html#registry-protocols">either git or sparse HTTP protocol</a>:</p>
<pre><code class="language-toml"># Git protocol
registry = "ssh://git@example.com/path/to/index.git"

# Sparse HTTP protocol  
registry = "sparse+https://example.com/path/to/index"

# HTTPS git protocol
registry = "https://example.com/path/to/index"
</code></pre>
<h2 id="로컬-레지스트리-소스"><a class="header" href="#로컬-레지스트리-소스">로컬 레지스트리 소스</a></h2>
<p>“로컬 레지스트리 소스“는 다른 레지스트리 소스의 하위 집합이면서 로컬 파일 시스템에서 사용 가능한 소스(일명 벤더링)를 의도한 것입니다. 로컬 레지스트리는 미리 다운로드되며 일반적으로 <code>Cargo.lock</code> 과 동기화됩니다. 이는 일련의 <code>*.crate</code> 파일과 일반 레지스트리와 같은 인덱스로 구성됩니다.</p>
<p>로컬 레지스트리 소스를 관리하고 생성하는 주요 방법은 <a href="https://crates.io/crates/cargo-local-registry"><code>cargo-local-registry</code></a> 하위 명령어를 사용하는 것입니다. 이 도구는 <a href="https://crates.io/crates/cargo-local-registry">crates.io에서 사용 가능</a> 하며 <code>cargo install cargo-local-registry</code> 로 설치할 수 있습니다.</p>
<p>로컬 레지스트리는 하나의 디렉토리 내에 포함되며, crates.io에서 다운로드한 여러 <code>*.crate</code> 파일과 crates.io-index 프로젝트와 동일한 형식의 <code>index</code> 디렉토리를 포함합니다(존재하는 크레이트에 대한 항목들로만 채워짐).</p>
<h2 id="디렉토리-소스"><a class="header" href="#디렉토리-소스">디렉토리 소스</a></h2>
<p>“디렉토리 소스“는 로컬 파일 시스템에서 사용 가능한 여러 크레이트를 포함한다는 점에서 로컬 레지스트리 소스와 유사하며, 의존성 벤더링에 적합합니다. 디렉토리 소스는 주로 <code>cargo vendor</code> 하위 명령어로 관리됩니다.</p>
<p>디렉토리 소스는 <code>*.crate</code> 파일의 압축이 풀린 버전을 포함한다는 점에서 로컬 레지스트리와 구별되며, 따라서 모든 것을 소스 제어 시스템에 체크인하는 것이 더 적합한 상황에서 쓰입니다. 디렉토리 소스는 단순히 크레이트의 소스 코드(<code>*.crate</code> 파일의 압축이 풀린 버전)를 포함하는 여러 다른 디렉토리들을 포함하는 디렉토리일 뿐입니다. 현재 각 디렉토리의 이름에 대한 제한은 없습니다.</p>
<p>디렉토리 소스의 각 크레이트에는 우발적인 수정을 방지하기 위해 크레이트 내 각 파일의 체크섬을 나타내는 메타데이터 파일이 연결되어 있습니다.</p>
<h2 id="git-sources"><a class="header" href="#git-sources">Git sources</a></h2>
<p>Git sources represent repositories used by <a href="reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories">git-based dependencies</a>. They’re used to specify which git-based dependencies should be replaced with alternative sources.</p>
<p>Git sources are <em>not</em> related to the <a href="reference/registries.html#registry-protocols">git registries</a>, and can’t be used to replace registry sources.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="의존성-해결"><a class="header" href="#의존성-해결">의존성 해결</a></h1>
<p>One of Cargo’s primary tasks is to determine the versions of dependencies to use based on the version requirements specified in each package. This process is called “dependency resolution” and is performed by the “resolver”. The result of the resolution is stored in the <a href="reference/../guide/cargo-toml-vs-cargo-lock.html"><code>Cargo.lock</code> file</a> which “locks” the dependencies to specific versions, and keeps them fixed over time. The <a href="reference/../commands/cargo-tree.html"><code>cargo tree</code></a> command can be used to visualize the result of the resolver.</p>
<h2 id="제약-조건-및-휴리스틱"><a class="header" href="#제약-조건-및-휴리스틱">제약 조건 및 휴리스틱</a></h2>
<p>대부분의 경우 단 하나의 “최선“의 의존성 해결책은 없습니다. 리졸버는 일반적으로 적용 가능한 해결책을 찾기 위해 다양한 제약 조건과 휴리스틱 하에서 작동합니다. 이것들이 어떻게 상호 작용하는지 이해하려면 의존성 해결이 어떻게 작동하는지 대략적으로 파악하는 것이 도움이 됩니다.</p>
<p>이 의사 코드는 Cargo 리졸버가 수행하는 작업을 대략적으로 보여줍니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn resolve(workspace: &amp;[Package], policy: Policy) -&gt; Option&lt;ResolveGraph&gt; {
    let dep_queue = Queue::new(workspace);
    let resolved = ResolveGraph::new();
    resolve_next(dep_queue, resolved, policy)
}

fn resolve_next(dep_queue: Queue, resolved: ResolveGraph, policy: Policy) -&gt; Option&lt;ResolveGraph&gt; {
    let Some(dep_spec) = policy.pick_next_dep(&amp;mut dep_queue) else {
        // 완료
        return Some(resolved);
    };

    if let Some(resolved) = policy.try_unify_version(dep_spec, resolved.clone()) {
        return Some(resolved);
    }

    let dep_versions = dep_spec.lookup_versions()?;
    let mut dep_versions = policy.filter_versions(dep_spec, dep_versions);
    while let Some(dep_version) = policy.pick_next_version(&amp;mut dep_versions) {
        if policy.needs_version_unification(&amp;dep_version, &amp;resolved) {
            continue;
        }

        let mut dep_queue = dep_queue.clone();
        dep_queue.enqueue(&amp;dep_version.dependencies);
        let mut resolved = resolved.clone();
        resolved.register(dep_version);
        if let Some(resolved) = resolve_next(dep_queue, resolved, policy) {
            return Some(resolved);
        }
    }

    // 유효한 해결책을 찾지 못함, 백트래킹(backtrack) 후 `pick_next_version` 수행
    None
}
<span class="boring">}</span></code></pre></pre>
<p>주요 단계:</p>
<ul>
<li>의존성 탐색(<code>pick_next_dep</code>): 의존성을 탐색하는 순서는 동일한 의존성에 대한 관련 버전 요구 사항이 어떻게 해결되는지에 영향을 줄 수 있으며(버전 통합 참조), 리졸버가 얼마나 백트래킹하는지에도 영향을 주어 리졸버 성능에 영향을 미칩니다.</li>
<li>버전 통합(<code>try_unify_version</code>, <code>needs_version_unification</code>): Cargo는 빌드 시간을 단축하고 공통 의존성의 타입이 API 간에 전달될 수 있도록 가능한 한 버전을 재사용합니다. 만약 <a href="reference/specifying-dependencies.html">의존성 사양</a> 의 충돌만 아니었다면 통합되었을 여러 버전이 있는 경우, Cargo는 여러 버전을 선택하는 대신 해결책을 찾지 못하면 오류를 발생시키며 백트래킹합니다. <a href="reference/specifying-dependencies.html">의존성 사양</a> 또는 Cargo는 특정 버전이 바람직하지 않다고 판단하여 해당 버전을 사용하는 대신 백트래킹하거나 오류를 발생시키는 것을 선호할 수 있습니다.</li>
<li>버전 선호(<code>pick_next_version</code>): Cargo는 특정 버전을 선호하기로 결정할 수 있으며, 백트래킹 시 다음 버전으로 폴백합니다.</li>
</ul>
<h3 id="버전-번호"><a class="header" href="#버전-번호">버전 번호</a></h3>
<p>일반적으로 Cargo는 현재 사용 가능한 가장 높은 버전을 선호합니다.</p>
<p>예를 들어 해결 그래프에 다음과 같은 패키지가 있다면:</p>
<pre><code class="language-toml">[dependencies]
bitflags = "*"
</code></pre>
<p><code>Cargo.lock</code> 파일이 생성될 시점에 <code>bitflags</code> 의 가장 높은 버전이 <code>1.2.1</code> 이라면, 패키지는 <code>1.2.1</code> 을 사용하게 됩니다.</p>
<p>발생 가능한 예외의 예시는 <a href="reference/resolver.html#rust-version">Rust 버전</a> 을 참조하세요.</p>
<h3 id="버전-요구-사항"><a class="header" href="#버전-요구-사항">버전 요구 사항</a></h3>
<p>패키지는 <a href="reference/specifying-dependencies.html#version-requirement-syntax">버전 요구 사항</a> 을 통해 지원하는 버전을 지정하고 다른 모든 버전은 거부합니다.</p>
<p>예를 들어 해결 그래프에 다음과 같은 패키지가 있다면:</p>
<pre><code class="language-toml">[dependencies]
bitflags = "1.0"  # `&gt;=1.0.0,&lt;2.0.0` 을 의미함
</code></pre>
<p><code>Cargo.lock</code> 파일이 생성될 시점에 <code>bitflags</code> 의 가장 높은 버전이 <code>1.2.1</code> 이라면, 호환 범위 내에서 가장 높으므로 패키지는 <code>1.2.1</code> 을 사용하게 됩니다. <code>2.0.0</code> 이 게시되더라도 <code>2.0.0</code> 은 호환되지 않는 것으로 간주되므로 여전히 <code>1.2.1</code> 을 사용합니다.</p>
<h3 id="semver-호환성"><a class="header" href="#semver-호환성">SemVer 호환성</a></h3>
<p>Cargo는 패키지가 <a href="https://semver.org/">SemVer</a> 를 따른다고 가정하며, <a href="reference/specifying-dependencies.html#default-requirements">캐럿(Caret) 버전 요구 사항</a> 에 따라 <a href="https://semver.org/">SemVer</a> 호환되는 경우 의존성 버전을 통합합니다. 버전 요구 사항의 충돌로 인해 호환되는 두 버전을 통합할 수 없는 경우 Cargo는 오류를 발생시킵니다.</p>
<p>무엇이 “호환되는” 변경으로 간주되는지에 대한 지침은 <a href="reference/semver.html">SemVer 호환성</a> 장을 참조하세요.</p>
<p>예시:</p>
<p>다음 두 패키지는 선택된 모든 버전이 서로 호환되므로 <code>bitflags</code> 에 대한 의존성이 통합됩니다.</p>
<pre><code class="language-toml"># 패키지 A
[dependencies]
bitflags = "1.0"  # `&gt;=1.0.0,&lt;2.0.0` 을 의미함

# 패키지 B
[dependencies]
bitflags = "1.1"  # `&gt;=1.1.0,&lt;2.0.0` 을 의미함
</code></pre>
<p>다음 패키지들은 버전 요구 사항이 충돌하여 서로 다른 두 호환 버전을 선택하게 되므로 오류가 발생합니다.</p>
<pre><code class="language-toml"># 패키지 A
[dependencies]
log = "=0.4.11"

# 패키지 B
[dependencies]
log = "=0.4.8"
</code></pre>
<p>다음 두 패키지는 각각에 대해 호환되지 않는 버전만 사용할 수 있으므로 <code>rand</code> 에 대한 의존성이 통합되지 않습니다. 대신 두 개의 다른 버전(예: 0.6.5 및 0.7.3)이 해결되어 빌드됩니다. 이는 잠재적인 문제를 일으킬 수 있으므로 자세한 내용은 <a href="reference/resolver.html#version-incompatibility-hazards">버전 비호환성 위험</a> 섹션을 참조하세요.</p>
<pre><code class="language-toml"># 패키지 A
[dependencies]
rand = "0.7"  # `&gt;=0.7.0,&lt;0.8.0` 을 의미함

# 패키지 B
[dependencies]
rand = "0.6"  # `&gt;=0.6.0,&lt;0.7.0` 을 의미함
</code></pre>
<p>일반적으로 다음 두 패키지는 버전 요구 사항을 만족하는 호환되지 않는 버전들이 있으므로 의존성이 통합되지 않습니다. 대신 두 개의 다른 버전(예: 0.6.5 및 0.7.3)이 해결되어 빌드됩니다. 다른 제약 조건이나 휴리스틱의 적용으로 인해 이들이 통합되어 한 버전(예: 0.6.5)이 선택될 수도 있습니다.</p>
<pre><code class="language-toml"># 패키지 A
[dependencies]
rand = "&gt;=0.6,&lt;0.8.0"

# 패키지 B
[dependencies]
rand = "0.6"  # `&gt;=0.6.0,&lt;0.7.0` 을 의미함
</code></pre>
<h4 id="버전-비호환성-위험"><a class="header" href="#버전-비호환성-위험">버전 비호환성 위험</a></h4>
<p>해결 그래프에 크레이트의 여러 버전이 나타나면, 해당 크레이트를 사용하는 크레이트에 의해 해당 크레이트의 타입이 노출될 때 문제가 발생할 수 있습니다. 이는 이름이 같더라도 Rust 컴파일러가 타입과 아이템을 서로 다른 것으로 간주하기 때문입니다. 라이브러리는 SemVer 비호환 버전(예: <code>1.0.0</code> 이 사용 중일 때 <code>2.0.0</code> 게시)을 게시할 때, 특히 널리 사용되는 라이브러리의 경우 주의를 기울여야 합니다.</p>
<p>“<a href="https://github.com/dtolnay/semver-trick">semver trick</a>“은 이전 버전과의 호환성을 유지하면서 파괴적 변경을 게시하는 문제에 대한 해결 방법입니다. 링크된 페이지는 무엇이 문제이고 어떻게 해결하는지 자세히 설명합니다. 요약하자면, 라이브러리가 SemVer 파괴적 릴리스를 게시하려 할 때, 새 릴리스를 게시함과 동시에 새 버전의 타입을 재내보내는 이전 버전의 포인트 릴리스도 게시하는 것입니다.</p>
<p>These incompatibilities usually manifest as a compile-time error, but sometimes they will only appear as a runtime misbehavior. For example, let’s say there is a common library named <code>foo</code> that ends up appearing with both version <code>1.0.0</code> and <code>2.0.0</code> in the resolve graph. If <a href="reference/../../std/any/trait.Any.html#method.downcast_ref"><code>downcast_ref</code></a> is used on an object created by a library using version <code>1.0.0</code>, and the code calling <code>downcast_ref</code> is downcasting to a type from version <code>2.0.0</code>, the downcast will fail at runtime.</p>
<p>라이브러리의 여러 버전이 있는 경우 이를 적절하게 사용하고 있는지, 특히 서로 다른 버전의 타입이 함께 사용될 가능성이 있는지 확인하는 것이 중요합니다. <a href="reference/../commands/cargo-tree.html"><code>cargo tree -d</code></a> 명령어를 사용하여 중복된 버전과 그 출처를 식별할 수 있습니다. 마찬가지로, 인기 있는 라이브러리의 SemVer 비호환 버전을 게시할 경우 에코시스템에 미칠 영향을 고려하는 것이 중요합니다.</p>
<h3 id="락-파일-lock-file"><a class="header" href="#락-파일-lock-file">락 파일 (Lock file)</a></h3>
<p>Cargo gives the highest priority to versions contained in the <a href="reference/../guide/cargo-toml-vs-cargo-lock.html"><code>Cargo.lock</code> file</a>, when used. This is intended to balance reproducible builds with adjusting to changes in the manifest.</p>
<p>예를 들어 해결 그래프에 다음과 같은 패키지가 있다면:</p>
<pre><code class="language-toml">[dependencies]
bitflags = "*"
</code></pre>
<p>If at the time your <code>Cargo.lock</code> file is generated, the greatest version of <code>bitflags</code> is <code>1.2.1</code>, then the package will use <code>1.2.1</code> and recorded in the <code>Cargo.lock</code> file.</p>
<p>By the time Cargo next runs, <code>bitflags</code> <code>1.3.5</code> is out. When resolving dependencies, <code>1.2.1</code> will still be used because it is present in your <code>Cargo.lock</code> file.</p>
<p>The package is then edited to:</p>
<pre><code class="language-toml">[dependencies]
bitflags = "1.3.0"
</code></pre>
<p><code>bitflags</code> <code>1.2.1</code> does not match this version requirement and so that entry in your <code>Cargo.lock</code> file is ignored and version <code>1.3.5</code> will now be used and recorded in your <code>Cargo.lock</code> file.</p>
<h3 id="rust-버전-1"><a class="header" href="#rust-버전-1">Rust 버전</a></h3>
<p>최소 지원 <a href="reference/rust-version.html">Rust 버전</a> 으로 소프트웨어를 개발하는 것을 지원하기 위해, 리졸버는 의존성 버전의 Rust 버전 호환성을 고려할 수 있습니다. 이는 구성 필드 <a href="reference/config.html#resolverincompatible-rust-versions"><code>resolver.incompatible-rust-versions</code></a> 에 의해 제어됩니다.</p>
<p><code>fallback</code> 설정을 사용하면, 리졸버는 현재 사용 중인 Rust 버전보다 작거나 같은 Rust 버전을 가진 패키지를 선호합니다. 예를 들어, Rust 1.85를 사용하여 다음 패키지를 개발한다고 가정해 봅시다.</p>
<pre><code class="language-toml">[package]
name = "my-cli"
rust-version = "1.62"

[dependencies]
clap = "4.0"  # 4.0.32로 해결됨
</code></pre>
<p>리졸버는 1.60.0의 Rust 버전을 가진 4.0.32 버전을 선택할 것입니다.</p>
<ul>
<li>4.0.0 역시 1.60.0의 Rust 버전을 가지고 있지만, <a href="reference/resolver.html#version-numbers">버전 번호</a> 가 더 낮기 때문에 선택되지 않습니다.</li>
<li>4.5.20은 훨씬 <a href="reference/resolver.html#version-numbers">높은 버전</a> 이고 1.85 툴체인과 호환되는 1.74.0의 Rust 버전을 가지고 있음에도 불구하고, <code>my-cli</code> 의 Rust 버전인 1.62와 호환되지 않으므로 선택되지 않습니다.</li>
</ul>
<p>버전 요구 사항에 Rust 버전 호환 의존성 버전이 포함되어 있지 않은 경우, 리졸버는 오류를 발생시키지 않고 잠재적으로 최적이 아닐지라도 버전을 선택합니다. 예를 들어 <code>clap</code> 에 대한 의존성을 다음과 같이 변경했다고 합시다.</p>
<pre><code class="language-toml">[package]
name = "my-cli"
rust-version = "1.62"

[dependencies]
clap = "4.2"  # 4.5.20으로 해결됨
</code></pre>
<p>Rust 버전 1.62와 호환되면서 해당 <a href="reference/resolver.html#version-requirements">버전 요구 사항</a> 을 만족하는 <code>clap</code> 버전이 없습니다. 그러면 리졸버는 1.74의 Rust 버전을 가졌음에도 불구하고 4.5.20과 같이 호환되지 않는 버전을 선택하게 됩니다.</p>
<p>리졸버가 패키지의 의존성 버전을 선택할 때, 해당 버전에 최종적으로 전이적 의존성을 가질 모든 워크스페이스 구성원을 알 수 없으므로 해당 의존성과 관련된 Rust 버전만 고려할 수는 없습니다. 리졸버는 워크스페이스 구성원들이 서로 다른 Rust 버전을 가질 때 “충분히 좋은” 해결책을 찾기 위한 휴리스틱을 가집니다. 이는 Rust 버전이 없는 워크스페이스 내 패키지에도 적용됩니다.</p>
<p>워크스페이스 구성원들이 서로 다른 Rust 버전을 가질 때, 리졸버는 필요한 것보다 낮은 의존성 버전을 선택할 수 있습니다. 예를 들어, 다음과 같은 워크스페이스 구성원들이 있다고 합시다.</p>
<pre><code class="language-toml">[package]
name = "a"
rust-version = "1.62"

[package]
name = "b"

[dependencies]
clap = "4.2"  # 4.0.32로 해결됨 (패키지 a 때문)
</code></pre>
<p>패키지 <code>b</code> 는 Rust 버전이 없어 4.5.20과 같은 더 높은 버전을 사용할 수 있음에도 불구하고, 패키지 <code>a</code> 의 Rust 버전인 1.62 때문에 4.0.32가 선택될 것입니다.</p>
<p>또는 리졸버가 너무 높은 버전을 선택할 수도 있습니다. 예를 들어, 다음과 같은 워크스페이스 구성원들이 있다고 합시다.</p>
<pre><code class="language-toml">[package]
name = "a"
rust-version = "1.62"

[dependencies]
clap = "4.2"  # 4.5.20으로 해결됨

[package]
name = "b"

[dependencies]
clap = "4.5"  # 4.5.20으로 해결됨
</code></pre>
<p>각 패키지가 자신의 Rust 버전을 만족하는 <code>clap</code> 버전 요구 사항을 가지고 있더라도, <a href="reference/resolver.html#version-numbers">버전 통합</a> 때문에 리졸버는 두 경우 모두에서 작동하는 하나의 버전을 선택해야 하며, 그것은 4.5.20과 같은 버전이 될 것입니다.</p>
<h3 id="기능"><a class="header" href="#기능">기능</a></h3>
<p><code>Cargo.lock</code> 을 생성하기 위해, 리졸버는 모든 <a href="reference/workspaces.html">워크스페이스</a> 구성원의 모든 <a href="reference/features.html">기능(features)</a> 이 활성화된 것처럼 의존성 그래프를 빌드합니다. 이는 <a href="reference/features.html#command-line-feature-options"><code>--features</code> 명령줄 플래그</a> 를 통해 기능이 추가되거나 제거될 때 모든 선택적 의존성을 사용할 수 있고 나머지 그래프와 적절하게 해결되도록 보장합니다. 리졸버는 명령줄에서 선택된 기능을 기반으로 크레이트를 <em>컴파일</em> 할 때 실제로 사용되는 기능을 결정하기 위해 두 번째로 실행됩니다.</p>
<p>의존성은 활성화된 모든 기능의 합집합으로 해결됩니다. 예를 들어, 한 패키지가 <a href="https://github.com/bodil/im-rs/blob/v15.0.0/Cargo.toml#L46"><code>serde</code> 의존성</a> 이 활성화된 <a href="https://crates.io/crates/im"><code>im</code></a> 패키지에 의존하고 다른 패키지가 <a href="https://github.com/bodil/im-rs/blob/v15.0.0/Cargo.toml#L47"><code>rayon</code> 의존성</a> 이 활성화된 해당 패키지에 의존하는 경우, <code>im</code> 은 두 기능이 모두 활성화된 상태로 빌드되며 <code>serde</code> 및 <code>rayon</code> 크레이트가 해결 그래프에 포함됩니다. 해당 기능들을 가진 <code>im</code> 에 의존하는 패키지가 없으면 해당 선택적 의존성들은 무시되며 해결에 영향을 주지 않습니다.</p>
<p>워크스페이스에서 여러 패키지를 빌드할 때(예: <code>--workspace</code> 또는 여러 개의 <code>-p</code> 플래그 사용 시), 해당 패키지들의 모든 의존성 기능들이 통합됩니다. 서로 다른 워크스페이스 구성원에 대해 이러한 통합을 피하고 싶은 상황이라면, 별도의 <code>cargo</code> 호출을 통해 빌드해야 합니다.</p>
<p>리졸버는 필요한 기능이 누락된 패키지 버전을 건너뜁니다. 예를 들어, 한 패키지가 <a href="https://github.com/rust-lang/regex/blob/1.3.0/Cargo.toml#L56"><code>perf</code> 기능</a> 이 활성화된 <a href="https://crates.io/crates/regex"><code>regex</code></a> 의 <code>^1</code> 버전에 의존하는 경우, 그 이전 버전들에는 <code>perf</code> 기능이 포함되어 있지 않으므로 선택할 수 있는 가장 오래된 버전은 <code>1.3.0</code> 이 됩니다. 마찬가지로 새로운 릴리스에서 기능이 제거되면, 해당 기능을 요구하는 패키지들은 해당 기능이 포함된 이전 릴리스에 고정됩니다. SemVer 호환 릴리스에서 기능을 제거하는 것은 권장되지 않습니다. 선택적 의존성도 암시적 기능을 정의하므로, 선택적 의존성을 제거하거나 비선택적으로 만드는 것은 문제를 일으킬 수 있습니다. <a href="reference/semver.html#cargo-remove-opt-dep">선택적 의존성 제거</a> 를 참조하세요.</p>
<h4 id="기능-리졸버-버전-2"><a class="header" href="#기능-리졸버-버전-2">기능 리졸버 버전 2</a></h4>
<p><code>Cargo.toml</code> 에 <code>resolver = "2"</code> 가 지정되면 (아래 <a href="reference/resolver.html#resolver-versions">리졸버 버전</a> 참조), 기능 통합을 위해 다른 알고리즘을 사용하는 별도의 기능 리졸버가 사용됩니다. 버전 <code>"1"</code> 리졸버는 패키지가 어디에 지정되어 있든 관계없이 해당 패키지의 기능들을 통합합니다. 버전 <code>"2"</code> 리졸버는 다음과 같은 상황에서 기능 통합을 피합니다.</p>
<ul>
<li>
<p>현재 빌드 중인 타겟이 아닌 경우 타겟별 의존성의 기능은 활성화되지 않습니다. 예를 들어 다음과 같습니다.</p>
<pre><code class="language-toml">[dependencies.common]
version = "1.0"
features = ["f1"]

[target.'cfg(windows)'.dependencies.common]
version = "1.0"
features = ["f2"]
</code></pre>
<p>이 예제를 윈도우가 아닌 플랫폼용으로 빌드할 때, <code>f2</code> 기능은 활성화되지 <em>않습니다</em>.</p>
</li>
<li>
<p><a href="reference/specifying-dependencies.html#build-dependencies">빌드 의존성(build-dependencies)</a> 또는 절차적 매크로(proc-macro)에서 활성화된 기능들은 해당 의존성이 일반 의존성으로 사용될 때 통합되지 않습니다. 예를 들어 다음과 같습니다.</p>
<pre><code class="language-toml">[dependencies]
log = "0.4"

[build-dependencies]
log = {version = "0.4", features=['std']}
</code></pre>
<p>빌드 스크립트를 빌드할 때, <code>log</code> 크레이트는 <code>std</code> 기능이 활성화된 상태로 빌드됩니다. 사용자의 패키지 라이브러리를 빌드할 때는 해당 기능이 활성화되지 않습니다.</p>
</li>
<li>
<p><a href="reference/specifying-dependencies.html#development-dependencies">개발 의존성(dev-dependencies)</a> 에서 활성화된 기능들은 해당 의존성이 일반 의존성으로 사용될 때 통합되지 않습니다 (단, 해당 개발 의존성이 현재 빌드 중인 경우는 제외). 예를 들어 다음과 같습니다.</p>
<pre><code class="language-toml">[dependencies]
serde = {version = "1.0", default-features = false}

[dev-dependencies]
serde = {version = "1.0", features = ["std"]}
</code></pre>
<p>이 예시에서 라이브러리는 평소에는 <code>std</code> 기능 없이 <code>serde</code> 에 링크됩니다. 하지만 테스트나 예제로 빌드될 때는 <code>std</code> 기능이 포함됩니다. 예를 들어, <code>cargo test</code> 나 <code>cargo build --all-targets</code> 는 이러한 기능들을 통합합니다. 의존성 내의 개발 의존성은 항상 무시되며, 이는 최상위 패키지 또는 워크스페이스 구성원에게만 해당된다는 점에 유의하세요.</p>
</li>
</ul>
<h3 id="links"><a class="header" href="#links"><code>links</code></a></h3>
<p><a href="reference/manifest.html#the-links-field"><code>links</code> 필드</a> 는 네이티브 라이브러리의 단 한 개의 복사본만 바이너리에 링크되도록 보장하는 데 사용됩니다. 리졸버는 각 <code>links</code> 이름의 인스턴스가 하나만 존재하는 그래프를 찾으려고 시도합니다. 해당 제약 조건을 만족하는 그래프를 찾을 수 없는 경우 오류를 반환합니다.</p>
<p>예를 들어, 한 패키지가 <a href="https://crates.io/crates/libgit2-sys"><code>libgit2-sys</code></a> <code>0.11</code> 버전에 의존하고 다른 패키지가 <code>0.12</code> 에 의존하는 경우, Cargo가 이를 통합할 수 없으면서 둘 다 <code>git2</code> 네이티브 라이브러리에 링크하므로 오류가 발생합니다. 이러한 요구 사항 때문에, 라이브러리가 널리 사용되는 경우 <code>links</code> 필드를 사용하여 SemVer 비호환 릴리스를 만들 때 매우 주의할 것을 권장합니다.</p>
<h3 id="yank된-버전"><a class="header" href="#yank된-버전">Yank된 버전</a></h3>
<p><a href="reference/publishing.html#cargo-yank">Yank된 릴리스</a> 는 사용해서는 안 된다고 표시된 릴리스들입니다. 리졸버가 그래프를 빌드할 때, <code>Cargo.lock</code> 파일에 이미 존재하거나 <code>cargo update</code> 의 <a href="reference/../commands/cargo-update.html#option-cargo-update---precise"><code>--precise</code></a> 플래그(나이틀리 전용)에 의해 명시적으로 요청되지 않는 한 모든 yank된 릴리스를 무시합니다.</p>
<h2 id="의존성-업데이트"><a class="header" href="#의존성-업데이트">의존성 업데이트</a></h2>
<p>의존성 해결은 의존성 그래프를 알아야 하는 모든 Cargo 명령어에 의해 자동으로 수행됩니다. 예를 들어, <a href="reference/../commands/cargo-build.html"><code>cargo build</code></a> 는 빌드할 모든 의존성을 찾기 위해 리졸버를 실행합니다. 처음 실행된 후 결과는 <code>Cargo.lock</code> 파일에 저장됩니다. 이후의 명령어들은 <em>가능한 한</em> 의존성을 <code>Cargo.lock</code> 의 버전에 고정된 상태로 유지하며 리졸버를 실행합니다.</p>
<p><code>Cargo.toml</code> 의 의존성 목록이 수정된 경우(예: 의존성 버전을 <code>1.0</code> 에서 <code>2.0</code> 으로 변경), 리졸버는 새로운 요구 사항과 일치하는 해당 의존성의 새 버전을 선택합니다. 만약 그 새로운 의존성이 새로운 요구 사항을 도입한다면, 그러한 새로운 요구 사항들이 추가적인 업데이트를 유발할 수도 있습니다. <code>Cargo.lock</code> 파일은 새로운 결과로 업데이트됩니다. <code>--locked</code> 또는 <code>--frozen</code> 플래그를 사용하여 요구 사항이 변경될 때 자동 업데이트를 방지하고 대신 오류를 반환하도록 이 동작을 변경할 수 있습니다.</p>
<p>새 버전이 게시될 때 <a href="reference/../commands/cargo-update.html"><code>cargo update</code></a> 를 사용하여 <code>Cargo.lock</code> 의 항목들을 업데이트할 수 있습니다. 옵션 없이 실행하면 락 파일의 모든 패키지 업데이트를 시도합니다. <code>-p</code> 플래그를 사용하여 특정 패키지에 대한 업데이트를 대상으로 삼을 수 있으며, <code>--recursive</code> 또는 <code>--precise</code> 와 같은 다른 플래그들을 사용하여 버전 선택 방식을 제어할 수 있습니다.</p>
<h2 id="재정의overrides"><a class="header" href="#재정의overrides">재정의(Overrides)</a></h2>
<p>Cargo는 그래프 내의 의존성을 재정의하기 위한 여러 메커니즘을 가지고 있습니다. <a href="reference/overriding-dependencies.html">의존성 재정의</a> 장에서 재정의 사용 방법에 대해 자세히 다룹니다. 재정의는 레지스트리에 대한 오버레이로 나타나며, 패치된 버전을 새 항목으로 대체합니다. 그 외에는 해결 과정이 정상적으로 수행됩니다.</p>
<h2 id="의존성-종류"><a class="header" href="#의존성-종류">의존성 종류</a></h2>
<p>패키지에는 세 가지 종류의 의존성이 있습니다: 일반(normal), <a href="reference/specifying-dependencies.html#build-dependencies">빌드(build)</a>, <a href="reference/specifying-dependencies.html#development-dependencies">개발(dev)</a> 입니다. 리졸버의 관점에서는 대부분 이들 모두를 동일하게 취급합니다. 한 가지 차이점은 워크스페이스 구성원이 아닌 경우 개발 의존성은 항상 무시되며 해결에 영향을 주지 않는다는 것입니다.</p>
<p><code>[target]</code> 테이블을 사용하는 <a href="reference/specifying-dependencies.html#platform-specific-dependencies">플랫폼별 의존성</a> 은 모든 플랫폼이 활성화된 것처럼 해결됩니다. 즉, 리졸버는 플랫폼이나 <code>cfg</code> 식을 무시합니다.</p>
<h3 id="개발-의존성-순환"><a class="header" href="#개발-의존성-순환">개발 의존성 순환</a></h3>
<p>보통 리졸버는 그래프에서 순환(cycles)을 허용하지 않지만, <a href="reference/specifying-dependencies.html#development-dependencies">개발 의존성</a> 에 대해서는 허용합니다. 예를 들어, 프로젝트 “foo“가 “bar“를 개발 의존성으로 가지고 있고, “bar“가 “foo“를 일반 의존성(보통 “경로” 의존성으로)으로 가지고 있는 경우입니다. 이는 빌드 산출물 관점에서는 실제 순환이 아니므로 허용됩니다. 이 예에서 “foo” 라이브러리가 먼저 빌드되고(“bar“는 테스트용으로만 쓰이므로 빌드에 필요 없음), 그 다음 “foo“에 의존하는 “bar“가 빌드될 수 있으며, 마지막으로 “bar“를 링크하는 “foo” 테스트가 빌드될 수 있습니다.</p>
<p>이로 인해 혼란스러운 오류가 발생할 수 있음을 주의하세요. 라이브러리 단위 테스트를 빌드하는 경우, 최종 테스트 바이너리에는 실제로 두 개의 라이브러리 복사본이 링크됩니다: 하나는 “bar“와 링크된 것이고, 다른 하나는 단위 테스트를 포함하여 빌드된 것입니다. <a href="reference/resolver.html#version-incompatibility-hazards">버전 비호환성 위험</a> 섹션에서 강조된 문제와 유사하게, 이들 두 타입은 서로 호환되지 않습니다. 이 상황에서 “bar“에서 “foo“의 타입을 노출할 때 주의하십시오. “foo” 단위 테스트는 이를 로컬 타입과 동일하게 취급하지 않기 때문입니다.</p>
<p>가능하다면 패키지를 여러 패키지로 분할하고 구조를 재조정하여 엄격하게 비순환 상태를 유지하도록 하세요.</p>
<h2 id="리졸버-버전"><a class="header" href="#리졸버-버전">리졸버 버전</a></h2>
<p>다음과 같이 <code>Cargo.toml</code> 의 리졸버 버전을 통해 서로 다른 리졸버 동작을 지정할 수 있습니다.</p>
<pre><code class="language-toml">[package]
name = "my-package"
version = "1.0.0"
resolver = "2"
</code></pre>
<ul>
<li><code>"1"</code> (기본값)</li>
<li><code>"2"</code> (<a href="reference/manifest.html#the-edition-field"><code>edition = "2021"</code></a> 기본값): <a href="reference/resolver.html#features">기능 통합(feature unification)</a> 에 변화를 도입합니다. 자세한 내용은 <a href="reference/features.html#feature-resolver-version-2">기능(features) 장</a> 을 참조하세요.</li>
<li><code>"3"</code> (<a href="reference/manifest.html#the-edition-field"><code>edition = "2024"</code></a> 기본값, Rust 1.84 이상 필요): <a href="reference/config.html#resolverincompatible-rust-versions"><code>resolver.incompatible-rust-versions</code></a> 의 기본값을 <code>allow</code> 에서 <code>fallback</code> 으로 변경합니다.</li>
</ul>
<p>리졸버는 전체 워크스페이스에 영향을 미치는 전역 옵션입니다. 의존성 내의 <code>resolver</code> 버전은 무시되며, 최상위 패키지의 값만 사용됩니다. <a href="reference/workspaces.html#virtual-workspace">가상 워크스페이스</a> 를 사용하는 경우 <code>[workspace]</code> 테이블에 버전을 지정해야 합니다. 예를 들어 다음과 같습니다.</p>
<pre><code class="language-toml">[workspace]
members = ["member1", "member2"]
resolver = "2"
</code></pre>
<blockquote>
<p><strong>MSRV:</strong> 1.51 이상 필요</p>
</blockquote>
<h2 id="권장-사항"><a class="header" href="#권장-사항">권장 사항</a></h2>
<p>다음은 패키지 내 버전을 설정하고 의존성 요구 사항을 지정하기 위한 몇 가지 권장 사항입니다. 이는 일반적인 상황에 적용되어야 할 보편적인 지침이지만, 물론 일부 상황에서는 특이한 요구 사항을 지정해야 할 수도 있습니다.</p>
<ul>
<li>
<p>버전 번호를 업데이트하는 방법과 SemVer 비호환 버전 변경이 필요한지 여부를 결정할 때 <a href="reference/semver.html">SemVer 가이드라인</a> 을 따르세요.</p>
</li>
<li>
<p>대부분의 상황에서 의존성에 대해 <code>"1.2.3"</code> 과 같은 캐럿 요구 사항을 사용하세요. 이는 리졸버가 빌드 호환성을 유지하면서 버전을 선택할 때 최대한의 유연성을 가질 수 있도록 보장합니다.</p>
<ul>
<li>현재 사용 중인 버전의 세 가지 구성 요소를 모두 지정하세요. 이는 사용될 최소 버전을 설정하는 데 도움이 되며, 다른 사용자가 사용자의 패키지가 필요로 하는 무언가가 누락된 오래된 버전의 의존성을 사용하게 되는 일을 방지합니다.</li>
<li><code>*</code> 요구 사항은 <a href="https://crates.io/">crates.io</a> 에서 허용되지 않으며, 일반적인 <code>cargo update</code> 중에 SemVer 파괴적 변경을 가져올 수 있으므로 피하세요.</li>
<li>과도하게 넓은 버전 요구 사항을 피하세요. 예를 들어 <code>&gt;=2.0.0</code> 은 <code>5.0.0</code> 버전과 같은 모든 SemVer 비호환 버전을 가져올 수 있으며, 이는 나중에 빌드 오류를 초래할 수 있습니다.</li>
<li>가능하다면 과도하게 좁은 버전 요구 사항도 피하세요. 예를 들어 <code>bar="~1.3"</code> 과 같은 틸드 요구 사항을 지정하고 다른 패키지가 <code>bar="1.4"</code> 요구 사항을 지정한다면, 부 릴리스(minor releases) 간에 호환되어야 함에도 불구하고 해결에 실패하게 됩니다.</li>
</ul>
</li>
<li>
<p>의존성 버전을 라이브러리가 요구하는 실제 최소 버전으로 최신 상태로 유지하도록 노력하세요. 예를 들어 요구 사항이 <code>bar="1.0.12"</code> 인데 향후 릴리스에서 “bar“의 <code>1.1.0</code> 릴리스에 추가된 새로운 기능을 사용하기 시작했다면, 의존성 요구 사항을 <code>bar="1.1.0"</code> 으로 업데이트하세요.</p>
<p>이를 소홀히 하면, 일괄적인 <code>cargo update</code> 실행 시 Cargo가 기회주의적으로 최신 버전을 선택할 수 있기 때문에 즉시 드러나지 않을 수 있습니다. 그러나 다른 사용자가 사용자의 라이브러리에 의존하고 <code>cargo update your-library</code> 를 실행할 때, “bar“가 그들의 <code>Cargo.lock</code> 에 고정되어 있다면 자동으로 업데이트되지 <em>않습니다</em>. 그 상황에서 “bar“는 의존성 선언도 업데이트된 경우에만 업데이트됩니다. 그렇게 하지 않으면 <code>cargo update your-library</code> 를 사용하는 사용자에게 혼란스러운 빌드 오류가 발생할 수 있습니다.</p>
</li>
<li>
<p>두 패키지가 밀접하게 결합된 경우, <code>=</code> 의존성 요구 사항이 두 패키지의 동기화 상태를 유지하는 데 도움이 될 수 있습니다. 예를 들어, 동반 절차적 매크로(proc-macro) 라이브러리가 있는 라이브러리는 가끔 두 라이브러리 간에 가정을 하게 되는데, 두 라이브러리가 동기화되지 않으면 제대로 작동하지 않을 수 있습니다 (그리고 두 라이브러리를 독립적으로 사용하는 일은 결코 예상되지 않습니다). 부모 라이브러리는 절차적 매크로에 대해 <code>=</code> 요구 사항을 사용하고, 쉬운 접근을 위해 매크로를 재내보낼 수 있습니다.</p>
</li>
<li>
<p><code>0.0.x</code> 버전은 영구적으로 불안정한 패키지에 사용될 수 있습니다.</p>
</li>
</ul>
<p>일반적으로 의존성 요구 사항을 엄격하게 만들수록 리졸버가 실패할 가능성이 높아집니다. 반대로 요구 사항을 너무 느슨하게 사용하면, 빌드를 깨뜨리는 새 버전이 게시될 가능성이 있습니다.</p>
<h2 id="문제-해결"><a class="header" href="#문제-해결">문제 해결</a></h2>
<p>다음은 발생할 수 있는 몇 가지 문제와 가능한 해결책을 보여줍니다.</p>
<h3 id="의존성이-왜-포함되었나요"><a class="header" href="#의존성이-왜-포함되었나요">의존성이 왜 포함되었나요?</a></h3>
<p><code>cargo check</code> 출력에 <code>rand</code> 의존성이 표시되는데 이것이 필요하지 않다고 생각되어 왜 끌어와졌는지 이해하고 싶다고 합시다.</p>
<p>다음을 실행할 수 있습니다.</p>
<pre><code class="language-console">$ cargo tree --workspace --target all --all-features --invert rand
rand v0.8.5
└── ...

rand v0.8.5
└── ...
</code></pre>
<h3 id="이-의존성의-해당-기능이-왜-활성화되었나요"><a class="header" href="#이-의존성의-해당-기능이-왜-활성화되었나요">이 의존성의 해당 기능이 왜 활성화되었나요?</a></h3>
<p>활성화된 어떤 기능 때문에 <code>rand</code> 가 나타났다는 것을 알게 될 수도 있습니다. <strong>어떤 패키지가 그 기능을 활성화했는지 확인하려면 <code>--edges features</code> 를 추가하면 됩니다.</strong></p>
<pre><code class="language-console">$ cargo tree --workspace --target all --all-features --edges features --invert rand
rand v0.8.5
└── ...

rand v0.8.5
└── ...
</code></pre>
<h3 id="예기치-않은-의존성-중복"><a class="header" href="#예기치-않은-의존성-중복">예기치 않은 의존성 중복</a></h3>
<p>다음을 실행할 때 <code>rand</code> 인스턴스가 여러 개 표시되는 경우입니다.</p>
<pre><code class="language-console">$ cargo tree --workspace --target all --all-features --duplicates
rand v0.7.3
└── ...

rand v0.8.5
└── ...
</code></pre>
<p>리졸버 알고리즘이 하나면 충분한 의존성 복사본을 두 개 포함하는 해결책으로 수렴되었습니다. 예를 들어 다음과 같습니다.</p>
<pre><code class="language-toml"># 패키지 A
[dependencies]
rand = "0.7"

# 패키지 B
[dependencies]
rand = "&gt;=0.6"  # 참고: 이와 같이 열린 요구 사항은 권장되지 않습니다
</code></pre>
<p>이 예에서 <code>0.7.3</code> 버전의 단일 복사본이 모든 요구 사항을 충족함에도 불구하고, Cargo는 <code>rand</code> 크레이트 복사본 두 개를 빌드할 수 있습니다. 이는 리졸버 알고리즘이 패키지 B에 대해 현재 사용 가능한 최신 <code>rand</code> 버전(이 글을 쓰는 시점에는 <code>0.8.5</code>) 빌드를 선호하며, 이는 패키지 A의 명세와 호환되지 않기 때문입니다. 리졸버 알고리즘은 현재 이 상황에서 “중복 제거(deduplicate)“를 시도하지 않습니다.</p>
<p>Cargo에서는 <code>&gt;=0.6</code> 과 같은 개방형 버전 요구 사항의 사용을 권장하지 않습니다. 하지만 이런 상황에 처하게 된다면, <code>--precise</code> 플래그와 함께 <a href="reference/../commands/cargo-update.html"><code>cargo update</code></a> 명령어를 사용하여 이러한 중복을 수동으로 제거할 수 있습니다.</p>
<h3 id="왜-더-최신-버전이-선택되지-않았나요"><a class="header" href="#왜-더-최신-버전이-선택되지-않았나요">왜 더 최신 버전이 선택되지 않았나요?</a></h3>
<p>다음을 실행했을 때 의존성의 최신 버전이 선택되지 않은 것을 발견했다고 합시다.</p>
<pre><code class="language-console">$ cargo update
</code></pre>
<p>왜 이런 일이 발생했는지 확인하기 위해 몇 가지 추가 로깅을 활성화할 수 있습니다.</p>
<pre><code class="language-console">$ env CARGO_LOG=cargo::core::resolver=trace cargo update
</code></pre>
<p><strong>참고:</strong> Cargo 로그 타겟 및 레벨은 시간이 지남에 따라 변경될 수 있습니다.</p>
<h3 id="semver를-파괴하는-패치-릴리스가-빌드를-깨뜨림"><a class="header" href="#semver를-파괴하는-패치-릴리스가-빌드를-깨뜨림">SemVer를 파괴하는 패치 릴리스가 빌드를 깨뜨림</a></h3>
<p>때로는 프로젝트가 실수로 SemVer 파괴적 변경이 포함된 포인트 릴리스(point release)를 게시할 수 있습니다. 사용자가 <code>cargo update</code> 를 통해 업데이트하면 이 새로운 릴리스를 가져오게 되고 빌드가 깨질 수 있습니다. 이런 상황에서 해당 프로젝트는 릴리스를 <a href="reference/publishing.html#cargo-yank">yank</a> 하고, SemVer 파괴적 변경을 제거하거나 새로운 SemVer 주 버전(major version) 상향으로 게시할 것을 권장합니다.</p>
<p>만약 제삼자 프로젝트에서 변경이 발생했다면, 가능하다면 (정중하게!) 해당 프로젝트와 협력하여 문제를 해결해 보세요.</p>
<p>릴리스가 yank되기를 기다리는 동안, 상황에 따라 몇 가지 우회 방법이 있습니다.</p>
<ul>
<li>사용자의 프로젝트가 최종 제품(예: 바이너리 실행 파일)이라면, <code>Cargo.lock</code> 에서 문제가 되는 패키지를 업데이트하지 않도록 하세요. 이는 <a href="reference/../commands/cargo-update.html"><code>cargo update</code></a> 의 <code>--precise</code> 플래그를 통해 수행할 수 있습니다.</li>
<li><a href="https://crates.io/">crates.io</a> 에 바이너리를 게시하는 경우, 일시적으로 <code>=</code> 요구 사항을 추가하여 의존성을 특정 안정 버전으로 강제할 수 있습니다.
<ul>
<li>바이너리 프로젝트는 대안으로 사용자에게 <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> 시 <code>--locked</code> 플래그를 사용하여 알려진 안정 버전이 포함된 원래의 <code>Cargo.lock</code> 을 사용하도록 권장할 수 있습니다.</li>
</ul>
</li>
<li>라이브러리는 문제가 되는 의존성을 피하기 위해 더 엄격한 요구 사항을 가진 임시 새 릴리스 게시를 고려할 수 있습니다. 동일한 의존성을 사용하는 다른 패키지와 충돌할 수 있는 지나치게 엄격한 요구 사항을 피하기 위해 (<code>=</code> 대신) 범위 요구 사항 사용을 고려할 수도 있습니다. 문제가 해결되면 의존성을 다시 캐럿 요구 사항으로 완화하는 또 다른 포인트 릴리스를 게시할 수 있습니다.</li>
<li>제삼자 프로젝트가 릴리스를 yank할 수 없거나 의사가 없는 것으로 보인다면, 한 가지 옵션은 사용자의 코드를 변경 사항과 호환되도록 업데이트하고 의존성 요구 사항의 최소 버전을 새 릴리스로 업데이트하는 것입니다. 이때 의존성의 타입을 노출하는 등의 이유로 사용자의 라이브러리에도 SemVer 파괴적 변경이 발생하는지 여부도 고려해야 합니다.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="기능-1"><a class="header" href="#기능-1">기능</a></h1>
<p>Cargo “기능(features)“은 <a href="reference/../../reference/conditional-compilation.html">조건부 컴파일(conditional compilation)</a> 및 <a href="reference/features.html#optional-dependencies">선택적 의존성(optional dependencies)</a> 을 표현하기 위한 메커니즘을 제공합니다. 패키지는 <code>Cargo.toml</code> 의 <code>[features]</code> 테이블에 명명된 기능 세트를 정의하며, 각 기능은 활성화하거나 비활성화할 수 있습니다. 빌드되는 패키지의 기능은 <code>--features</code> 와 같은 플래그를 사용하여 명령줄에서 활성화할 수 있습니다. 의존성의 기능은 <code>Cargo.toml</code> 의 의존성 선언부에서 활성화할 수 있습니다.</p>
<blockquote>
<p><strong>참고</strong>: 이제 crates.io에 게시되는 새로운 크레이트나 버전은 최대 300개의 기능으로 제한됩니다. 예외는 사안별로 허용됩니다. 자세한 내용은 이 <a href="https://blog.rust-lang.org/2023/10/26/broken-badges-and-23k-keywords.html">블로그 포스트</a> 를 참조하세요. 해결 방안 논의에 대한 참여는 crates.io Zulip 스트림을 통해 권장됩니다.</p>
</blockquote>
<p>기능이 어떻게 사용될 수 있는지에 대한 몇 가지 예시는 <a href="reference/features-examples.html">기능 예제(Features Examples)</a> 장을 참조하세요.</p>
<h2 id="features-섹션"><a class="header" href="#features-섹션"><code>[features]</code> 섹션</a></h2>
<p>기능은 <code>Cargo.toml</code> 의 <code>[features]</code> 테이블에 정의됩니다. 각 기능은 해당 기능이 활성화할 다른 기능들이나 선택적 의존성들의 배열을 지정합니다. 다음 예시들은 서로 다른 이미지 형식 지원을 선택적으로 포함할 수 있는 2D 이미지 처리 라이브러리에서 기능이 어떻게 사용될 수 있는지 보여줍니다.</p>
<pre><code class="language-toml">[features]
# Defines a feature named `webp` that does not enable any other features.
webp = []
</code></pre>
<p>이 기능이 정의되면, 컴파일 타임에 요청된 기능을 지원하는 코드를 조건부로 포함하기 위해 <a href="reference/../../reference/conditional-compilation.html"><code>cfg</code> 식</a> 을 사용할 수 있습니다. 예를 들어, 패키지의 <code>lib.rs</code> 내부에 다음을 포함할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// WEBP 지원을 구현하는 모듈을 조건부로 포함합니다.
#[cfg(feature = "webp")]
pub mod webp;
<span class="boring">}</span></code></pre></pre>
<p>Cargo는 <code>rustc</code> <a href="reference/../../rustc/command-line-arguments.html#option-cfg"><code>--cfg</code> 플래그</a> 를 사용하여 패키지에 기능을 설정하며, 코드는 <a href="reference/../../reference/conditional-compilation.html#the-cfg-attribute"><code>cfg</code> 속성</a> 또는 <a href="reference/../../std/macro.cfg.html"><code>cfg</code> 매크로</a> 를 사용하여 기능의 존재 여부를 테스트할 수 있습니다.</p>
<p>기능은 활성화할 다른 기능들을 나열할 수 있습니다. 예를 들어, ICO 이미지 형식은 BMP 및 PNG 이미지를 포함할 수 있으므로, ICO 기능이 활성화될 때 해당 다른 기능들도 활성화되도록 해야 합니다.</p>
<pre><code class="language-toml">[features]
bmp = []
png = []
ico = ["bmp", "png"]
webp = []
</code></pre>
<p>기능 이름은 (대부분의 문자를 포함하는) <a href="https://unicode.org/reports/tr31/">Unicode XID 표준</a> 의 문자들을 포함할 수 있으며, 추가적으로 <code>_</code> 나 <code>0</code> 에서 <code>9</code> 까지의 숫자로 시작할 수 있고, 첫 번째 문자 이후에는 <code>-</code>, <code>+</code> 또는 <code>.</code> 을 포함할 수도 있습니다.</p>
<blockquote>
<p><strong>참고</strong>: <a href="https://crates.io/">crates.io</a> 는 기능 이름 구문에 대해 <a href="reference/../../std/primitive.char.html#method.is_ascii_alphanumeric">ASCII 영문자 및 숫자</a> 문자 또는 <code>_</code>, <code>-</code>, <code>+</code> 만 사용해야 한다는 추가 제약을 둡니다.</p>
</blockquote>
<h2 id="default-기능"><a class="header" href="#default-기능"><code>default</code> 기능</a></h2>
<p>기본적으로 모든 기능은 명시적으로 활성화되지 않는 한 비활성화됩니다. 이는 <code>default</code> 기능을 지정하여 변경할 수 있습니다.</p>
<pre><code class="language-toml">[features]
default = ["ico", "webp"]
bmp = []
png = []
ico = ["bmp", "png"]
webp = []
</code></pre>
<p>패키지가 빌드될 때 <code>default</code> 기능이 활성화되며, 이는 나열된 기능들을 차례로 활성화합니다. 이 동작은 다음과 같이 변경할 수 있습니다.</p>
<ul>
<li><code>--no-default-features</code> <a href="reference/features.html#command-line-feature-options">명령줄 플래그</a> 는 패키지의 기본 기능을 비활성화합니다.</li>
<li><code>default-features = false</code> 옵션을 <a href="reference/features.html#dependency-features">의존성 선언부</a> 에 지정할 수 있습니다.</li>
</ul>
<blockquote>
<p><strong>참고</strong>: 기본 기능 세트를 선택할 때 주의하세요. 기본 기능은 사용자가 일반적인 용도를 위해 어떤 기능을 활성화할지 신중하게 선택하도록 강요하지 않고 패키지를 더 쉽게 사용할 수 있게 해주는 편의성이지만, 몇 가지 단점이 있습니다. 의존성은 <code>default-features = false</code> 가 지정되지 않는 한 자동으로 기본 기능을 활성화합니다. 이는 특히 의존성 그래프에 여러 번 나타나는 의존성에 대해 기본 기능이 활성화되지 않도록 보장하는 것을 어렵게 만들 수 있습니다. 모든 패키지는 기본 기능이 활성화되는 것을 피하기 위해 <code>default-features = false</code> 가 지정되었는지 확인해야 합니다.</p>
<p>또 다른 문제는 기본 세트에서 기능을 제거하는 것이 <a href="reference/features.html#semver-compatibility">SemVer 비호환 변경</a> 이 될 수 있다는 것이므로, 해당 기능들을 계속 유지할 것인지 확신이 있어야 합니다.</p>
</blockquote>
<h2 id="선택적-의존성"><a class="header" href="#선택적-의존성">선택적 의존성</a></h2>
<p>의존성은 “선택적(optional)“으로 표시될 수 있으며, 이는 기본적으로 컴파일되지 않음을 의미합니다. 예를 들어, 우리의 2D 이미지 처리 라이브러리가 GIF 이미지를 처리하기 위해 외부 패키지를 사용한다고 가정해 봅시다. 이는 다음과 같이 표현될 수 있습니다.</p>
<pre><code class="language-toml">[dependencies]
gif = { version = "0.11.1", optional = true }
</code></pre>
<p>기본적으로, 이 선택적 의존성은 다음과 같은 기능을 암시적으로 정의합니다.</p>
<pre><code class="language-toml">[features]
gif = ["dep:gif"]
</code></pre>
<p>이는 <code>gif</code> 기능이 활성화된 경우에만 이 의존성이 포함됨을 의미합니다. 코드 내에서 동일한 <code>cfg(feature = "gif")</code> 구문을 사용할 수 있으며, 해당 의존성은 <code>--features gif</code> 와 같은 여타 기능들과 마찬가지로 활성화될 수 있습니다 (아래의 <a href="reference/features.html#command-line-feature-options">명령줄 기능 옵션</a> 참조).</p>
<p>경우에 따라 선택적 의존성과 동일한 이름을 가진 기능을 노출하고 싶지 않을 수도 있습니다. 예를 들어, 선택적 의존성이 내부 상세 구현이거나, 여러 선택적 의존성을 하나로 묶고 싶거나, 혹은 더 나은 이름을 사용하고 싶은 경우가 해당됩니다. <code>[features]</code> 테이블의 어느 곳에서든 <code>dep:</code> 접두사를 사용하여 선택적 의존성을 지정하면, 해당 암시적 기능이 비활성화됩니다.</p>
<blockquote>
<p><strong>참고</strong>: <code>dep:</code> 구문은 Rust 1.60부터 사용할 수 있습니다. 이전 버전에서는 암시적 기능 이름만 사용할 수 있습니다.</p>
</blockquote>
<p>예를 들어, AVIF 이미지 형식을 지원하기 위해 라이브러리에서 다른 두 의존성을 활성화해야 한다고 가정해 봅시다.</p>
<pre><code class="language-toml">[dependencies]
ravif = { version = "0.6.3", optional = true }
rgb = { version = "0.8.25", optional = true }

[features]
avif = ["dep:ravif", "dep:rgb"]
</code></pre>
<p>이 예시에서 <code>avif</code> 기능은 나열된 두 의존성을 활성화합니다. 또한 <code>ravif</code> 및 <code>rgb</code> 는 우리 크레이트의 내부 상세 구현이므로 사용자가 개별적으로 활성화하는 것을 원치 않기 때문에, 암시적 기능이 생성되는 것을 방지합니다.</p>
<blockquote>
<p><strong>참고</strong>: 의존성을 선택적으로 포함하는 또 다른 방법은 <a href="reference/specifying-dependencies.html#platform-specific-dependencies">플랫폼별 의존성</a> 을 사용하는 것입니다. 이는 기능을 사용하는 대신 대상 플랫폼에 따라 조건부로 적용됩니다.</p>
</blockquote>
<h2 id="의존성-기능"><a class="header" href="#의존성-기능">의존성 기능</a></h2>
<p>의존성의 기능은 의존성 선언 내에서 활성화할 수 있습니다. <code>features</code> 키는 어떤 기능을 활성화할지 나타냅니다.</p>
<pre><code class="language-toml">[dependencies]
# serde의 `derive` 기능을 활성화합니다.
serde = { version = "1.0.118", features = ["derive"] }
</code></pre>
<p><a href="reference/features.html#the-default-feature"><code>default</code></a> 기능은 <code>default-features = false</code> 를 사용하여 비활성화할 수 있습니다.</p>
<pre><code class="language-toml">[dependencies]
flate2 = { version = "1.0.3", default-features = false, features = ["zlib-rs"] }
</code></pre>
<blockquote>
<p><strong>참고</strong>: 이것만으로는 기본 기능이 비활성화되는 것을 보장하지 못할 수도 있습니다. 다른 의존성이 <code>default-features = false</code> 를 지정하지 않고 <code>flate2</code> 를 포함한다면, 기본 기능이 활성화됩니다. 자세한 내용은 아래의 <a href="reference/features.html#feature-unification">기능 통합(feature unification)</a> 을 참조하세요.</p>
</blockquote>
<p>의존성의 기능은 <code>[features]</code> 테이블에서도 활성화할 수 있습니다. 구문은 <code>"패키지-이름/기능-이름"</code> 입니다. 예를 들어 다음과 같습니다.</p>
<pre><code class="language-toml">[dependencies]
jpeg-decoder = { version = "0.1.20", default-features = false }

[features]
# jpeg-decoder의 "rayon" 기능을 활성화하여 병렬 처리 지원을 활성화합니다.
parallel = ["jpeg-decoder/rayon"]
</code></pre>
<p><code>"패키지-이름/기능-이름"</code> 구문은 <code>패키지-이름</code> 이 선택적 의존성인 경우 해당 패키지까지 활성화합니다. 대개의 경우 이는 의도한 바가 아닐 것입니다. <code>"패키지-이름?/기능-이름"</code> 과 같이 <code>?</code> 를 추가하면, 다른 누군가가 해당 선택적 의존성을 활성화했을 때만 지정된 기능을 활성화합니다.</p>
<blockquote>
<p><strong>참고</strong>: <code>?</code> 구문은 Rust 1.60부터 사용할 수 있습니다.</p>
</blockquote>
<p>예를 들어, 라이브러리에 직렬화(serialization) 지원을 추가했고, 일부 선택적 의존성에서도 그에 대응하는 기능을 활성화해야 한다고 가정해 봅시다. 다음과 같이 할 수 있습니다.</p>
<pre><code class="language-toml">[dependencies]
serde = { version = "1.0.133", optional = true }
rgb = { version = "0.8.25", optional = true }

[features]
serde = ["dep:serde", "rgb?/serde"]
</code></pre>
<p>이 예시에서 <code>serde</code> 기능을 활성화하면 <code>serde</code> 의존성이 활성화됩니다. 또한 <code>rgb</code> 의존성에 대해서도 <code>serde</code> 기능을 활성화하지만, 이는 다른 누군가가 <code>rgb</code> 의존성을 활성화했을 때만 해당됩니다.</p>
<h2 id="명령줄-기능-옵션"><a class="header" href="#명령줄-기능-옵션">명령줄 기능 옵션</a></h2>
<p>다음 명령줄 플래그를 사용하여 활성화할 기능을 제어할 수 있습니다.</p>
<ul>
<li><code>--features</code> <em>FEATURES</em>: 나열된 기능을 활성화합니다. 여러 기능은 쉼표나 공백으로 구분할 수 있습니다. 공백을 사용하는 경우, 셸에서 Cargo를 실행할 때 모든 기능 주위에 따옴표를 사용해야 합니다(예: <code>--features "foo bar"</code>). <a href="reference/workspaces.html">워크스페이스</a> 에서 여러 패키지를 빌드하는 경우, <code> 패키지-이름/기능-이름</code> 구문을 사용하여 특정 워크스페이스 구성원의 기능을 지정할 수 있습니다.</li>
<li><code>--all-features</code>: Activates all features of all packages selected on the command line.</li>
<li><code>--no-default-features</code>: 선택된 패키지의 <a href="reference/features.html#the-default-feature"><code>default</code></a> 기능을 활성화하지 않습니다.</li>
</ul>
<p><strong>NOTE</strong>: check the individual subcommand documentation for details. Not all flags are available for all subcommands.</p>
<h2 id="기능-통합"><a class="header" href="#기능-통합">기능 통합</a></h2>
<p>기능은 해당 기능을 정의하는 패키지에 고유합니다. 한 패키지에서 특정 기능을 활성화한다고 해서 다른 패키지에서 동일한 이름의 기능이 활성화되지는 않습니다.</p>
<p>여러 패키지에서 하나의 의존성을 사용하는 경우, Cargo는 해당 의존성을 빌드할 때 활성화된 모든 기능의 합집합을 사용합니다. 이는 의존성의 사본이 단 하나만 사용되도록 보장하는 데 도움이 됩니다. 자세한 내용은 리졸버 문서의 <a href="reference/resolver.html#features">기능 섹션</a> 을 참조하세요.</p>
<p>예를 들어, <a href="https://github.com/retep998/winapi-rs/blob/0.3.9/Cargo.toml#L25-L431">수많은 기능</a> 을 사용하는 <a href="https://crates.io/crates/winapi"><code>winapi</code></a> 패키지를 살펴봅시다. 사용자의 패키지가 <code>winapi</code> 의 “fileapi” 및 “handleapi” 기능을 활성화하는 <code>foo</code> 패키지에 의존하고, 또 다른 의존성인 <code>bar</code> 가 <code>winapi</code> 의 “std” 및 “winnt” 기능을 활성화한다면, <code>winapi</code> 는 이 네 가지 기능이 모두 활성화된 상태로 빌드됩니다.</p>
<p><img src="reference/../images/winapi-features.svg" alt="winapi 기능 예시" /></p>
<p>이러한 동작의 결과로 기능은 <em>가산적(additive)</em> 이어야 합니다. 즉, 기능을 활성화한다고 해서 기존 기능이 비활성화되어서는 안 되며, 어떤 기능의 조합이든 활성화해도 안전해야 합니다. 기능은 <a href="reference/features.html#semver-compatibility">SemVer 비호환 변경</a> 을 도입해서는 안 됩니다.</p>
<p>예를 들어, <a href="reference/../../reference/names/preludes.html#the-no_std-attribute"><code>no_std</code></a> 환경을 선택적으로 지원하고 싶다면 <code>no_std</code> 기능을 <strong>사용하지 마세요</strong>. 대신 <code>std</code> 를 <em>활성화하는</em> <code>std</code> 기능을 사용하세요. 예시:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![no_std]

<span class="boring">fn main() {
</span>#[cfg(feature = "std")]
extern crate std;

#[cfg(feature = "std")]
pub fn function_that_requires_std() {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<h3 id="상호-배타적-기능"><a class="header" href="#상호-배타적-기능">상호 배타적 기능</a></h3>
<p>드문 경우지만 기능들이 서로 호환되지 않을 수 있습니다. 이는 의존성 그래프 내에서 해당 패키지를 사용하는 모든 곳이 서로 협력하여 기능들을 동시에 활성화하지 않도록 조정해야 하므로, 가능하면 피해야 합니다. 만약 피할 수 없다면, 이러한 시나리오를 감지하기 위해 컴파일 오류를 추가하는 것을 고려해 보세요. 예시:</p>
<pre><code class="language-rust ignore">#[cfg(all(feature = "foo", feature = "bar"))]
compile_error!("feature \"foo\" and feature \"bar\" cannot be enabled at the same time");</code></pre>
<p>상호 배타적인 기능을 사용하는 대신 다음과 같은 다른 옵션들을 고려해 보세요.</p>
<ul>
<li>기능을 별도의 패키지로 분리합니다.</li>
<li>충돌이 발생할 경우, <a href="reference/features-examples.html#feature-precedence">하나의 기능을 다른 기능보다 우선시</a> 합니다. <a href="https://crates.io/crates/cfg-if"><code>cfg-if</code></a> 패키지를 사용하면 더 복잡한 <code>cfg</code> 식을 작성하는 데 도움이 될 수 있습니다.</li>
<li>기능들이 동시에 활성화될 수 있도록 코드를 설계하고, 어떤 기능을 사용할지 제어하기 위해 런타임 옵션을 사용합니다. 예를 들어, 설정 파일, 명령줄 인수 또는 환경 변수를 사용하여 활성화할 동작을 선택합니다.</li>
</ul>
<h3 id="해결된-기능-검사하기"><a class="header" href="#해결된-기능-검사하기">해결된 기능 검사하기</a></h3>
<p>복잡한 의존성 그래프에서는 여러 패키지에서 서로 다른 기능들이 어떻게 활성화되는지 파악하기 어려울 때가 있습니다. <a href="reference/../commands/cargo-tree.html"><code>cargo tree</code></a> 명령어는 어떤 기능들이 활성화되었는지 검사하고 시각화하는 데 도움이 되는 몇 가지 옵션을 제공합니다. 다음 옵션들을 시도해 보세요.</p>
<ul>
<li><code>cargo tree -e features</code>: 의존성 그래프에 기능을 표시합니다. 각 기능은 어떤 패키지가 이를 활성화했는지와 함께 나타납니다.</li>
<li><code>cargo tree -f "{p} {f}"</code>: 각 패키지에서 활성화된 기능들을 쉼표로 구분된 목록으로 보여주는 더 간결한 뷰입니다.</li>
<li><code>cargo tree -e features -i foo</code>: 트리를 반전시켜 지정된 패키지 “foo“로 기능들이 어떻게 유입되는지 보여줍니다. 전체 그래프를 보는 것이 너무 방대하고 복잡할 때 유용할 수 있습니다. 특정 패키지에 어떤 기능들이 왜 활성화되었는지 파악하려고 할 때 이 옵션을 사용하세요. 이를 읽는 방법에 대해서는 <a href="reference/../commands/cargo-tree.html"><code>cargo tree</code></a> 페이지 하단의 예시를 참조하세요.</li>
</ul>
<h2 id="기능-리졸버-버전-2-1"><a class="header" href="#기능-리졸버-버전-2-1">기능 리졸버 버전 2</a></h2>
<p>다음과 같이 <code>Cargo.toml</code> 의 <code>resolver</code> 필드를 사용하여 다른 기능 리졸버를 지정할 수 있습니다.</p>
<pre><code class="language-toml">[package]
name = "my-package"
version = "1.0.0"
resolver = "2"
</code></pre>
<p>리졸버 버전을 지정하는 방법에 대한 자세한 내용은 <a href="reference/resolver.html#resolver-versions">리졸버 버전</a> 섹션을 참조하세요.</p>
<p>버전 <code>"2"</code> 리졸버는 통합이 원치 않는 몇 가지 상황에서 기능 통합을 피합니다. 구체적인 상황은 <a href="reference/resolver.html#feature-resolver-version-2">리졸버 장</a> 에 설명되어 있지만, 요약하자면 다음과 같은 상황에서 통합을 피합니다.</p>
<ul>
<li>현재 빌드 중이 아닌 <a href="reference/../appendix/glossary.html#target">대상 아키텍처</a> 에 대한 타겟별 의존성 기능은 무시됩니다.</li>
<li><a href="reference/specifying-dependencies.html#build-dependencies">빌드 의존성</a> 및 절차적 매크로(proc-macro)는 일반 의존성과 기능을 공유하지 않습니다.</li>
<li><a href="reference/specifying-dependencies.html#development-dependencies">개발 의존성</a> 은 해당 기능이 필요한 <a href="reference/../appendix/glossary.html#target">Cargo 타겟</a> (테스트나 예제 등)을 빌드할 때만 기능을 활성화합니다.</li>
</ul>
<p>일부 상황에서는 통합을 피하는 것이 필요합니다. 예를 들어, 빌드 의존성이 <code>std</code> 기능을 활성화하는데 동일한 의존성이 <code>no_std</code> 환경을 위한 일반 의존성으로 사용되는 경우, <code>std</code> 를 활성화하면 빌드가 깨지게 됩니다.</p>
<p>하지만 단점은 의존성이 여러 번 빌드되기 때문에(각각 다른 기능으로) 빌드 시간이 늘어날 수 있다는 것입니다. 버전 <code>"2"</code> 리졸버를 사용할 때는 전체 빌드 시간을 단축하기 위해 여러 번 빌드되는 의존성이 있는지 확인하는 것이 좋습니다. 만약 해당 중복 패키지들을 별도의 기능으로 빌드할 <em>필요가 없다면</em>, 중복된 패키지들이 동일한 기능을 갖도록(따라서 Cargo가 한 번만 빌드하도록) <a href="reference/features.html#dependency-features">의존성 선언부</a> 의 <code>features</code> 목록에 기능을 추가하는 것을 고려해 보세요. 이러한 중복 의존성은 <a href="reference/../commands/cargo-tree.html"><code>cargo tree --duplicates</code></a> 명령어로 감지할 수 있습니다. 이 명령어는 여러 번 빌드된 패키지들을 보여주며, 동일한 버전으로 나열된 항목들을 찾으면 됩니다. 해결된 기능에 대한 정보를 가져오는 방법은 <a href="reference/features.html#inspecting-resolved-features">해결된 기능 검사하기</a> 를 참조하세요. 빌드 의존성의 경우, <code>--target</code> 플래그를 사용하여 교차 컴파일 중이라면 빌드 의존성은 항상 일반 의존성과 별도로 빌드되므로 이 작업이 필요하지 않습니다.</p>
<h3 id="리졸버-버전-2-명령줄-플래그"><a class="header" href="#리졸버-버전-2-명령줄-플래그">리졸버 버전 2 명령줄 플래그</a></h3>
<p><code>resolver = "2"</code> 설정은 <code>--features</code> 및 <code>--no-default-features</code> <a href="reference/features.html#command-line-feature-options">명령줄 옵션</a> 의 동작도 변경합니다.</p>
<p>버전 <code>"1"</code> 에서는 현재 작업 디렉토리에 있는 패키지의 기능만 활성화할 수 있습니다. 예를 들어, <code>foo</code> 와 <code>bar</code> 패키지가 있는 워크스페이스에서 <code>foo</code> 패키지 디렉토리에 있는 상태로 <code>cargo build -p bar --features bar-feat</code> 명령을 실행하면 실패합니다. <code>--features</code> 플래그가 <code>foo</code> 에 대한 기능 활성화만 허용했기 때문입니다.</p>
<p>버전 <code>"2"</code> 리졸버를 사용하면, 기능 플래그를 통해 <code>-p</code> 및 <code>--workspace</code> 플래그로 선택된 모든 패키지에 대해 기능을 활성화할 수 있습니다. 예를 들어 다음과 같습니다.</p>
<pre><code class="language-sh"># 이 명령은 현재 어느 디렉토리에 있든 관계없이 resolver = "2"에서 허용됩니다.
cargo build -p foo -p bar --features foo-feat,bar-feat

# 이 명시적인 동등한 명령은 모든 리졸버 버전에서 작동합니다.
cargo build -p foo -p bar --features foo/foo-feat,bar/bar-feat
</code></pre>
<p>또한, <code>resolver = "1"</code> 에서는 <code>--no-default-features</code> 플래그가 현재 디렉토리의 패키지에 대한 기본 기능만 비활성화합니다. 버전 “2“에서는 모든 워크스페이스 구성원에 대해 기본 기능을 비활성화합니다.</p>
<h2 id="빌드-스크립트"><a class="header" href="#빌드-스크립트">빌드 스크립트</a></h2>
<p><a href="reference/build-scripts.html">빌드 스크립트</a> 는 <code>CARGO_FEATURE_&lt;name&gt;</code> 환경 변수를 검사하여 패키지에 어떤 기능이 활성화되었는지 감지할 수 있습니다. 여기서 <code>&lt;name&gt;</code> 은 대문자로 변환되고 <code>-</code> 는 <code>_</code> 로 변환된 기능 이름입니다.</p>
<h2 id="필수-기능"><a class="header" href="#필수-기능">필수 기능</a></h2>
<p><a href="reference/cargo-targets.html#the-required-features-field"><code>required-features</code> 필드</a> 를 사용하면 특정 기능이 활성화되지 않은 경우 특정 <a href="reference/cargo-targets.html">Cargo 타겟</a> 을 비활성화할 수 있습니다. 자세한 내용은 링크된 문서를 참조하세요.</p>
<h2 id="semver-호환성-1"><a class="header" href="#semver-호환성-1">SemVer 호환성</a></h2>
<p>기능을 활성화해도 SemVer와 호환되지 않는 변경이 도입되어서는 안 됩니다. 예를 들어, 기능이 기존 사용을 깨뜨릴 수 있는 방식으로 기존 API를 변경해서는 안 됩니다. 어떤 변경이 호환되는지에 대한 자세한 내용은 <a href="reference/semver.html">SemVer 호환성 장</a> 에서 확인할 수 있습니다.</p>
<p>기능 정의 및 선택적 의존성을 추가하거나 제거할 때는 하위 호환성을 깨뜨리는 변경이 될 수 있으므로 주의해야 합니다. 자세한 내용은 SemVer 호환성 장의 <a href="reference/semver.html#cargo">Cargo 섹션</a> 에서 확인할 수 있습니다. 요약하자면 다음 규칙을 따르세요.</p>
<ul>
<li>부 버전(minor release)에서 다음 작업은 일반적으로 안전합니다.
<ul>
<li><a href="reference/semver.html#cargo-feature-add">새로운 기능</a> 또는 <a href="reference/semver.html#cargo-dep-add">선택적 의존성</a> 추가</li>
<li><a href="reference/semver.html#cargo-change-dep-feature">의존성에 사용된 기능 변경</a></li>
</ul>
</li>
<li>부 버전에서 다음 작업은 일반적으로 수행해서는 <strong>안 됩니다</strong>.
<ul>
<li><a href="reference/semver.html#cargo-feature-remove">기능 제거</a> 또는 <a href="reference/semver.html#cargo-remove-opt-dep">선택적 의존성 제거</a></li>
<li><a href="reference/semver.html#item-remove">기존 공개 코드를 기능 뒤로 이동(기능 게이트 적용)</a></li>
<li><a href="reference/semver.html#cargo-feature-remove-another">기능 목록에서 기능 제거</a></li>
</ul>
</li>
</ul>
<p>주의 사항 및 예시는 링크를 참조하세요.</p>
<h2 id="기능-문서화-및-탐색"><a class="header" href="#기능-문서화-및-탐색">기능 문서화 및 탐색</a></h2>
<p>패키지에서 어떤 기능들을 사용할 수 있는지 문서화할 것을 권장합니다. 이는 <code>lib.rs</code> 상단에 <a href="reference/../../rustdoc/how-to-write-documentation.html">독 커멘트(doc comments)</a> 를 추가하여 수행할 수 있습니다. 예시로 <a href="https://github.com/rust-lang/regex/blob/1.4.2/src/lib.rs#L488-L583">regex 크레이트 소스</a> 를 참조하세요. 렌더링된 결과는 <a href="https://docs.rs/regex/1.4.2/regex/#crate-features">docs.rs</a> 에서 확인할 수 있습니다. 사용자 가이드와 같은 다른 문서가 있다면 해당 문서에도 추가하는 것을 고려해 보세요 (예를 들어 <a href="https://serde.rs/feature-flags.html">serde.rs</a> 참조). 바이너리 프로젝트인 경우 README나 프로젝트의 다른 문서에 기능을 문서화하는 것을 고려해 보세요 (예를 들어 <a href="https://github.com/mozilla/sccache/blob/0.2.13/README.md#build-requirements">sccache</a> 참조).</p>
<p>기능을 명확하게 문서화하면 “불안정“하거나 다른 이유로 사용해서는 안 되는 기능들에 대한 기대치를 설정할 수 있습니다. 예를 들어, 선택적 의존성이 있지만 사용자가 해당 선택적 의존성을 기능으로 명시적으로 나열하는 것을 원치 않는다면, 문서화된 목록에서 제외하세요.</p>
<p><a href="https://docs.rs/">docs.rs</a> 에 게시되는 문서는 <code>Cargo.toml</code> 의 메타데이터를 사용하여 문서 빌드 시 어떤 기능을 활성화할지 제어할 수 있습니다. 자세한 내용은 <a href="https://docs.rs/about/metadata">docs.rs 메타데이터 문서</a> 를 참조하세요.</p>
<blockquote>
<p><strong>Note</strong>: Rustdoc has experimental support for annotating the documentation to indicate which features are required to use certain APIs. See the <code>doc_cfg</code> documentation for more details. An example is the <a href="https://docs.rs/syn/1.0.54/syn/#modules"><code>syn</code> documentation</a>, where you can see colored boxes which note which features are required to use it.</p>
</blockquote>
<h3 id="기능-탐색하기"><a class="header" href="#기능-탐색하기">기능 탐색하기</a></h3>
<p>라이브러리 API에 기능이 문서화되어 있으면 사용자가 어떤 기능을 사용할 수 있고 그 기능이 무엇을 하는지 더 쉽게 파악할 수 있습니다. 패키지의 기능 문서가 즉시 제공되지 않는 경우 <code>Cargo.toml</code> 파일을 살펴볼 수 있지만, 때로는 이를 찾아내기 어려울 수 있습니다. <a href="https://crates.io/">crates.io</a> 의 크레이트 페이지에는 사용 가능한 경우 소스 저장소에 대한 링크가 있습니다. <a href="reference/../commands/cargo-vendor.html"><code>cargo vendor</code></a> 또는 <a href="https://crates.io/crates/cargo-clone-crate">cargo-clone-crate</a> 와 같은 도구를 사용하여 소스를 다운로드하고 검사할 수 있습니다.</p>
<h2 id="기능-조합"><a class="header" href="#기능-조합">기능 조합</a></h2>
<p>기능은 조건부 컴파일의 한 형태이기 때문에, 100% 테스트하려면 기하급수적인 수의 구성과 테스트 케이스가 필요합니다. 기본적으로 테스트, 문서 및 <a href="https://github.com/rust-lang/rust-clippy">Clippy</a> 와 같은 다른 도구들은 기본 기능 세트만 사용하여 실행됩니다.</p>
<p>다양한 기능 조합에 관한 전략과 도구 사용을 고려해 보시기 바랍니다. 프로젝트마다 시간, 리소스, 특정 시나리오를 다루는 데 따른 비용 대비 효과 등 서로 다른 요구 사항이 있을 것입니다. 일반적인 구성으로는 기본 기능을 포함하거나 포함하지 않는 경우, 특정 기능들의 조합, 또는 모든 기능의 조합 등이 있을 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="기능-예제"><a class="header" href="#기능-예제">기능 예제</a></h1>
<p>다음은 실제 사례에서 기능이 어떻게 작동하는지 보여주는 몇 가지 예시입니다.</p>
<h2 id="빌드-시간-및-파일-크기-최소화"><a class="header" href="#빌드-시간-및-파일-크기-최소화">빌드 시간 및 파일 크기 최소화</a></h2>
<p>일부 패키지는 기능을 사용하여, 해당 기능이 활성화되지 않았을 때 크레이트의 크기를 줄이고 컴파일 시간을 단축합니다. 몇 가지 예시는 다음과 같습니다.</p>
<ul>
<li><a href="https://crates.io/crates/syn"><code>syn</code></a> 은 Rust 코드를 파싱하는 데 널리 사용되는 크레이트입니다. 매우 널리 사용되기 때문에, 많은 프로젝트에 영향을 미치므로 컴파일 시간을 줄이는 것이 도움이 됩니다. 포함되는 코드의 양을 최소화하는 데 사용할 수 있는 <a href="https://docs.rs/syn/1.0.54/syn/#optional-features">명확하게 문서화된 기능 목록</a> 을 제공합니다.</li>
<li><a href="https://crates.io/crates/regex"><code>regex</code></a> 는 <a href="https://docs.rs/regex/1.4.2/regex/#crate-features">문서화가 잘 된</a> <a href="https://github.com/rust-lang/regex/blob/1.4.2/Cargo.toml#L33-L101">여러 기능</a> 을 가지고 있습니다. 유니코드 지원을 제외하면 일부 거대한 테이블을 제거할 수 있어 결과 파일 크기를 줄일 수 있습니다.</li>
<li><a href="https://crates.io/crates/winapi"><code>winapi</code></a> 는 지원하는 Windows API 바인딩을 제한하는 <a href="https://github.com/retep998/winapi-rs/blob/0.3.9/Cargo.toml#L25-L431">수많은 기능</a> 을 가지고 있습니다.</li>
<li><a href="https://crates.io/crates/web-sys"><code>web-sys</code></a> 는 <code>winapi</code> 와 유사한 또 다른 예시로, 기능을 사용하여 제한할 수 있는 <a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/crates/web-sys/Cargo.toml#L32-L1395">방대한 범위</a> 의 API 바인딩을 제공합니다.</li>
</ul>
<h2 id="동작-확장"><a class="header" href="#동작-확장">동작 확장</a></h2>
<p><a href="https://crates.io/crates/serde_json"><code>serde_json</code></a> 패키지는 키가 삽입된 순서를 유지하도록 JSON 맵의 <a href="https://github.com/serde-rs/json/blob/v1.0.60/src/map.rs#L23-L26">동작을 변경</a> 하는 <a href="https://github.com/serde-rs/json/blob/v1.0.60/Cargo.toml#L53-L56"><code>preserve_order</code> 기능</a> 을 가지고 있습니다. 이 기능은 새로운 동작을 구현하기 위해 선택적 의존성인 <a href="https://crates.io/crates/indexmap"><code>indexmap</code></a> 을 활성화한다는 점에 주목하세요.</p>
<p>이와 같이 동작을 변경할 때는 해당 변경 사항이 <a href="reference/features.html#semver-compatibility">SemVer 호환(SemVer compatible)</a> 되는지 주의 깊게 확인해야 합니다. 즉, 기능을 활성화했을 때, 해당 기능이 꺼진 상태에서 정상적으로 빌드되던 코드가 깨져서는 안 됩니다.</p>
<h2 id="no_std-지원"><a class="header" href="#no_std-지원"><code>no_std</code> 지원</a></h2>
<p>일부 패키지는 <a href="reference/../../reference/names/preludes.html#the-no_std-attribute"><code>no_std</code></a> 와 <code>std</code> 환경을 모두 지원하고 싶어 합니다. 이는 임베디드 및 리소스가 제한된 플랫폼을 지원하면서도, 전체 표준 라이브러리를 지원하는 플랫폼에 대해서는 확장된 기능을 허용하는 데 유용합니다.</p>
<p><a href="https://crates.io/crates/wasm-bindgen"><code>wasm-bindgen</code></a> 패키지는 <a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L23">기본적으로 활성화</a> 되는 <a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L25"><code>std</code> 기능</a> 을 정의합니다. 라이브러리 상단에서 <a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L8">무조건적으로 <code>no_std</code> 속성을 활성화</a> 합니다. 이를 통해 <code>std</code> 와 <a href="reference/../../std/prelude/index.html"><code>std</code> 프렐류드(std prelude)</a> 가 자동으로 스코프에 들어오지 않도록 보장합니다. 그런 다음 코드의 여러 곳에서 <code>#[cfg(feature = "std")]</code> 속성을 사용하여 <code>std</code> 를 필요로 하는 추가 기능을 조건부로 활성화합니다.</p>
<h2 id="의존성-기능-재내보내기"><a class="header" href="#의존성-기능-재내보내기">의존성 기능 재내보내기</a></h2>
<p>의존성의 기능을 재내보내는 것이 편리할 때가 있습니다. 이를 통해 해당 크레이트에 의존하는 사용자가 의존성을 직접 지정하지 않고도 해당 기능들을 제어할 수 있게 됩니다. 예를 들어, <a href="https://crates.io/crates/regex"><code>regex</code></a> 는 <a href="https://github.com/rust-lang/regex/blob/1.4.2/regex-syntax/Cargo.toml#L17-L32"><code>regex_syntax</code></a> 패키지의 <a href="https://github.com/rust-lang/regex/blob/1.4.2/Cargo.toml#L65-L89">기능들을 재내보냅니다</a>. <code>regex</code> 사용자는 <code>regex_syntax</code> 패키지에 대해 알 필요가 없지만, 여전히 그 안에 포함된 기능들을 사용할 수 있습니다.</p>
<h2 id="c-라이브러리-벤더링"><a class="header" href="#c-라이브러리-벤더링">C 라이브러리 벤더링</a></h2>
<p>일부 패키지는 일반적인 C 라이브러리에 대한 바인딩을 제공합니다(가끔 <a href="reference/build-scripts.html#-sys-packages">“sys” 크레이트</a> 라고 불림). 이러한 패키지들은 시스템에 설치된 C 라이브러리를 사용할지, 아니면 소스에서 직접 빌드할지 선택권을 주기도 합니다. 예를 들어, <a href="https://crates.io/crates/openssl"><code>openssl</code></a> 패키지는 <a href="https://crates.io/crates/openssl-sys"><code>openssl-sys</code></a> 의 대응하는 <code>vendored</code> 기능을 활성화하는 <a href="https://github.com/sfackler/rust-openssl/blob/openssl-v0.10.31/openssl/Cargo.toml#L19"><code>vendored</code> 기능</a> 을 가지고 있습니다. <code>openssl-sys</code> 빌드 스크립트에는 시스템의 라이브러리를 사용하는 대신 로컬에 복사된 OpenSSL 소스 코드에서 빌드하도록 하는 <a href="https://github.com/sfackler/rust-openssl/blob/openssl-v0.10.31/openssl-sys/build/main.rs#L47-L54">조건부 로직</a> 이 포함되어 있습니다.</p>
<p><a href="https://crates.io/crates/curl-sys"><code>curl-sys</code></a> 패키지는 <a href="https://github.com/alexcrichton/curl-rust/blob/0.4.34/curl-sys/Cargo.toml#L49"><code>static-curl</code> 기능</a> 을 통해 libcurl을 소스에서 빌드하는 또 다른 예입니다. 또한 <a href="https://github.com/alexcrichton/curl-rust/blob/0.4.34/curl-sys/Cargo.toml#L52"><code>force-system-lib-on-osx</code></a> 기능을 통해 <code>static-curl</code> 설정을 무시하고 <a href="https://github.com/alexcrichton/curl-rust/blob/0.4.34/curl-sys/build.rs#L15-L20">시스템 libcurl을 사용</a> 하도록 강제할 수도 있습니다.</p>
<h2 id="기능-우선순위"><a class="header" href="#기능-우선순위">기능 우선순위</a></h2>
<p>일부 패키지는 상호 배타적인 기능을 가질 수 있습니다. 이를 처리하는 한 가지 방법은 한 기능을 다른 기능보다 우선시하는 것입니다. <a href="https://crates.io/crates/log"><code>log</code></a> 패키지가 그 예입니다. 이 패키지는 <a href="https://docs.rs/log/0.4.11/log/#compile-time-filters">여기에</a> 설명된 대로 컴파일 타임에 최대 로깅 레벨을 선택하기 위한 <a href="https://github.com/rust-lang/log/blob/0.4.11/Cargo.toml#L29-L42">여러 기능</a> 을 제공합니다. 이 패키지는 <a href="https://crates.io/crates/cfg-if"><code>cfg-if</code></a> 를 사용하여 <a href="https://github.com/rust-lang/log/blob/0.4.11/src/lib.rs#L1422-L1448">우선순위를 선택</a> 합니다. 여러 기능이 활성화된 경우, 더 높은 “최대(max)” 레벨이 낮은 레벨보다 우선 적용됩니다.</p>
<h2 id="절차적-매크로-동반-패키지"><a class="header" href="#절차적-매크로-동반-패키지">절차적 매크로 동반 패키지</a></h2>
<p>일부 패키지는 그와 밀접하게 연관된 절차적 매크로(proc-macro)를 가지고 있습니다. 하지만 모든 사용자가 해당 매크로를 사용할 필요는 없을 것입니다. 절차적 매크로를 선택적 의존성(optional-dependency)으로 만들면, 포함 여부를 편리하게 선택할 수 있게 됩니다. 이는 때때로 절차적 매크로의 버전이 부모 패키지와 동기화되어야 할 때 특히 유용한데, 사용자가 두 의존성을 모두 직접 지정하고 동기화 상태를 유지하도록 강요하고 싶지 않기 때문입니다.</p>
<p>한 예로 <a href="https://crates.io/crates/serde"><code>serde</code></a> 가 있는데, 이 패키지는 <a href="https://crates.io/crates/serde_derive"><code>serde_derive</code></a> 절차적 매크로를 활성화하는 <a href="https://github.com/serde-rs/serde/blob/v1.0.118/serde/Cargo.toml#L34-L35"><code>derive</code></a> 기능을 가지고 있습니다. <code>serde_derive</code> 크레이트는 <code>serde</code> 와 매우 긴밀하게 연결되어 있으므로, 서로의 동기화를 보장하기 위해 <a href="https://github.com/serde-rs/serde/blob/v1.0.118/serde/Cargo.toml#L17">일치 버전 요구 사항(equals version requirement)</a> 을 사용합니다.</p>
<h2 id="나이틀리-전용-기능"><a class="header" href="#나이틀리-전용-기능">나이틀리 전용 기능</a></h2>
<p>일부 패키지는 Rust <a href="reference/../../book/appendix-07-nightly-rust.html">나이틀리 채널</a> 에서만 사용 가능한 API나 언어 기능을 실험해보고 싶어 할 수 있습니다. 하지만 사용자들에게도 나이틀리 채널 사용을 강제하고 싶지는 않을 것입니다. 한 예로 <a href="https://crates.io/crates/wasm-bindgen"><code>wasm-bindgen</code></a> 이 있는데, 이 패키지는 이 글을 쓰는 시점에 나이틀리 채널에서만 사용 가능한 <a href="reference/../../std/marker/trait.Unsize.html"><code>Unsize</code></a> 마커 트레이트를 사용하는 <a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/closure.rs#L257-L269">확장 API</a> 를 활성화하는 <a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/Cargo.toml#L27"><code>nightly</code> 기능</a> 을 가지고 있습니다.</p>
<p>크레이트 루트에서 <a href="https://github.com/rustwasm/wasm-bindgen/blob/0.2.69/src/lib.rs#L11">나이틀리 기능을 활성화하기 위해 <code>cfg_attr</code> 을 사용함</a> 에 주목하세요. <a href="reference/../../unstable-book/index.html"><code>feature</code> 속성</a> 은 Cargo 기능과 무관하며, 실험적인 언어 기능을 사용하기 위해 명시적으로 선택하는 데 사용된다는 점을 기억하세요.</p>
<p><a href="https://crates.io/crates/rand"><code>rand</code></a> 패키지의 <a href="https://github.com/rust-random/rand/blob/0.7.3/Cargo.toml#L40"><code>simd_support</code> 기능</a> 은 나이틀리 채널에서만 빌드되는 의존성에 의존하는 또 다른 예입니다.</p>
<h2 id="실험적인-기능"><a class="header" href="#실험적인-기능">실험적인 기능</a></h2>
<p>일부 패키지는 해당 API의 안정성을 보장하지 않으면서 새로운 기능을 실험해보고 싶어 할 수 있습니다. 이러한 기능들은 보통 실험적이라고 문서화되며, 따라서 미래에(심지어 마이너 릴리스 중에도) 변경되거나 깨질 수 있습니다. 한 예로 <a href="https://crates.io/crates/async-std"><code>async-std</code></a> 패키지가 있는데, 이 패키지는 사람들이 선택하여 사용할 수 있지만 아직 완전히 신뢰하기에는 준비되지 않았을 수 있는 <a href="https://github.com/async-rs/async-std/blob/v1.8.0/src/macros.rs#L46">새로운 API들을 제한하는</a> <a href="https://github.com/async-rs/async-std/blob/v1.8.0/Cargo.toml#L38-L42"><code>unstable</code> 기능</a> 을 가지고 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="프로파일"><a class="header" href="#프로파일">프로파일</a></h1>
<p>프로파일은 컴파일러 설정을 변경하는 방법을 제공하여 최적화 및 디버깅 심볼과 같은 항목에 영향을 줍니다.</p>
<p>Cargo에는 <code>dev</code>, <code>release</code>, <code>test</code>, <code>bench</code> 라는 4개의 내장 프로파일이 있습니다. 명령줄에서 프로파일을 지정하지 않으면 실행 중인 명령에 따라 프로파일이 자동으로 선택됩니다. 내장 프로파일 외에도 사용자 정의 프로파일을 지정할 수 있습니다.</p>
<p>프로파일 설정은 <a href="reference/manifest.html"><code>Cargo.toml</code></a> 의 <code>[profile]</code> 테이블에서 변경할 수 있습니다. 명명된 각 프로파일 내에서 개별 설정은 다음과 같이 키/값 쌍으로 변경할 수 있습니다.</p>
<pre><code class="language-toml">[profile.dev]
opt-level = 1               # Use slightly better optimizations.
overflow-checks = false     # Disable integer overflow checks.
</code></pre>
<p>Cargo는 워크스페이스 루트의 <code>Cargo.toml</code> 매니페스트에 있는 프로파일 설정만 확인합니다. 의존성에 정의된 프로파일 설정은 무시됩니다.</p>
<p>또한 프로파일은 <a href="reference/config.html">config</a> 정의에서 재정의할 수 있습니다. 설정 파일이나 환경 변수에 프로파일을 지정하면 <code>Cargo.toml</code> 의 설정보다 우선 적용됩니다.</p>
<h2 id="프로파일-설정"><a class="header" href="#프로파일-설정">프로파일 설정</a></h2>
<p>다음은 프로파일에서 제어할 수 있는 설정 목록입니다.</p>
<h3 id="opt-level"><a class="header" href="#opt-level">opt-level</a></h3>
<p><code>opt-level</code> 설정은 최적화 수준을 제어하는 <a href="reference/../../rustc/codegen-options/index.html#opt-level"><code>-C opt-level</code> 플래그</a> 를 제어합니다. 최적화 수준이 높을수록 컴파일 시간은 길어지지만 더 빠른 런타임 코드를 생성할 수 있습니다. 높은 수준의 최적화는 컴파일된 코드를 변경하고 재배치하여 디버거와 함께 사용하기 어렵게 만들 수도 있습니다.</p>
<p>사용 가능한 옵션은 다음과 같습니다.</p>
<ul>
<li><code>0</code>: 최적화 없음</li>
<li><code>1</code>: 기본 최적화</li>
<li><code>2</code>: 일부 최적화</li>
<li><code>3</code>: 모든 최적화</li>
<li><code>"s"</code>: 바이너리 크기 최적화</li>
<li><code>"z"</code>: 바이너리 크기 최적화 및 루프 벡터화 비활성화</li>
</ul>
<p>프로젝트에 적합한 균형을 찾기 위해 다양한 수준을 실험해보는 것이 좋습니다. 레벨 <code>3</code> 이 <code>2</code> 보다 느리거나, <code>"s"</code> 와 <code>"z"</code> 레벨이 반드시 더 작지 않은 것과 같은 예상치 못한 결과가 나올 수 있습니다. 최신 버전의 <code>rustc</code> 가 최적화 동작을 변경함에 따라 시간이 지남에 따라 설정을 재평가하고 싶을 수도 있습니다.</p>
<p>더 발전된 최적화 기술에 대해서는 <a href="reference/../../rustc/profile-guided-optimization.html">프로파일 기반 최적화(Profile Guided Optimization)</a> 를 참조하세요.</p>
<h3 id="debug"><a class="header" href="#debug">debug</a></h3>
<p><code>debug</code> 설정은 컴파일된 바이너리에 포함되는 디버그 정보의 양을 제어하는 <a href="reference/../../rustc/codegen-options/index.html#debuginfo"><code>-C debuginfo</code> 플래그</a> 를 제어합니다.</p>
<p>사용 가능한 옵션은 다음과 같습니다.</p>
<ul>
<li><code>0</code>, <code>false</code>, 또는 <code>"none"</code>: 디버그 정보 없음, <a href="reference/profiles.html#release"><code>release</code></a> 의 기본값</li>
<li><code>"line-directives-only"</code>: 라인 정보 지시문만 포함. nvptx* 타겟의 경우 <a href="https://reviews.llvm.org/D46061">프로파일링</a> 을 활성화합니다. 다른 유스케이스의 경우 <code>line-tables-only</code> 가 더 나은 호환성을 제공하는 선택입니다.</li>
<li><code>"line-tables-only"</code>: 라인 테이블만 포함. 파일 이름/라인 번호 정보를 포함한 백트레이스를 위한 최소한의 디버그 정보만 생성하며, 변수나 함수 매개변수 정보 등은 포함하지 않습니다.</li>
<li><code>1</code> 또는 <code>"limited"</code>: 타입이나 변수 수준의 정보가 없는 디버그 정보. <code>line-tables-only</code> 보다 더 자세한 모듈 수준 정보를 생성합니다.</li>
<li><code>2</code>, <code>true</code>, 또는 <code>"full"</code>: 모든 디버그 정보 포함, <a href="reference/profiles.html#dev"><code>dev</code></a> 의 기본값</li>
</ul>
<p>각 옵션이 수행하는 작업에 대한 자세한 내용은 <code>rustc</code> 의 <a href="reference/../../rustc/codegen-options/index.html#debuginfo">debuginfo</a> 문서를 참조하세요.</p>
<p>필요에 따라 <a href="reference/profiles.html#split-debuginfo"><code>split-debuginfo</code></a> 옵션도 구성할 수 있습니다.</p>
<blockquote>
<p><strong>MSRV:</strong> <code>none</code>, <code>limited</code>, <code>full</code>, <code>line-directives-only</code>, <code>line-tables-only</code> 에는 1.71 버전이 필요합니다.</p>
</blockquote>
<h3 id="split-debuginfo"><a class="header" href="#split-debuginfo">split-debuginfo</a></h3>
<p><code>split-debuginfo</code> 설정은 생성된 디버그 정보를 실행 파일 자체에 배치할지 아니면 인접하게 배치할지를 제어하는 <a href="reference/../../rustc/codegen-options/index.html#split-debuginfo"><code>-C split-debuginfo</code> 플래그</a> 를 제어합니다.</p>
<p>이 옵션은 문자열이며 허용되는 값은 <a href="reference/../../rustc/codegen-options/index.html#split-debuginfo">컴파일러가 허용하는 값</a> 과 동일합니다. 이 옵션의 기본값은 디버그 정보가 활성화된 프로파일의 경우 macOS에서 <code>unpacked</code> 입니다. 그렇지 않은 경우 이 옵션의 기본값은 <a href="reference/../../rustc/codegen-options/index.html#split-debuginfo">rustc 문서</a> 에 명시되어 있으며 플랫폼에 따라 다릅니다. 일부 옵션은 <a href="reference/../../book/appendix-07-nightly-rust.html">나이틀리 채널</a> 에서만 사용할 수 있습니다. 더 많은 테스트가 수행되고 DWARF 지원이 안정화되면 향후 Cargo 기본값이 변경될 수 있습니다.</p>
<p>Cargo와 rustc는 이 옵션에 대해 서로 다른 기본값을 가질 수 있음에 유의하세요. 이 옵션은 Cargo가 다양한 플래그 조합을 실험하여 더 나은 디버깅 및 개발자 경험을 제공할 수 있도록 하기 위해 존재합니다.</p>
<h3 id="strip"><a class="header" href="#strip">strip</a></h3>
<p><code>strip</code> 옵션은 바이너리에서 심볼이나 디버그 정보를 제거하도록 rustc에 지시하는 <a href="reference/../../rustc/codegen-options/index.html#strip"><code>-C strip</code> 플래그</a> 를 제어합니다. 다음과 같이 활성화할 수 있습니다.</p>
<pre><code class="language-toml">[package]
# ...

[profile.release]
strip = "debuginfo"
</code></pre>
<p><code>strip</code> 에 가능한 문자열 값은 <code>"none"</code>, <code>"debuginfo"</code>, <code>"symbols"</code> 입니다. 기본값은 <code>"none"</code> 입니다.</p>
<p>이 옵션은 불리언 값인 <code>true</code> 또는 <code>false</code> 로도 구성할 수 있습니다. <code>strip = true</code> 는 <code>strip = "symbols"</code> 와 동일합니다. <code>strip = false</code> 는 <code>strip = "none"</code> 과 동일하며 <code>strip</code> 을 완전히 비활성화합니다.</p>
<h3 id="debug-assertions"><a class="header" href="#debug-assertions">debug-assertions</a></h3>
<p><code>debug-assertions</code> 설정은 <code>cfg(debug_assertions)</code> <a href="reference/../../reference/conditional-compilation.html#debug_assertions">조건부 컴파일</a> 을 켜거나 끄는 <a href="reference/../../rustc/codegen-options/index.html#debug-assertions"><code>-C debug-assertions</code> 플래그</a> 를 제어합니다. 디버그 어설션은 디버그/개발 빌드에서만 사용할 수 있는 런타임 유효성 검사를 포함하기 위한 것입니다. 이는 릴리스 빌드에서는 너무 비용이 많이 들거나 바람직하지 않은 작업일 수 있습니다. 디버그 어설션은 표준 라이브러리의 <a href="reference/../../std/macro.debug_assert.html"><code>debug_assert!</code> 매크로</a> 를 활성화합니다.</p>
<p>사용 가능한 옵션은 다음과 같습니다.</p>
<ul>
<li><code>true</code>: 활성화됨</li>
<li><code>false</code>: 비활성화됨</li>
</ul>
<h3 id="overflow-checks"><a class="header" href="#overflow-checks">overflow-checks</a></h3>
<p><code>overflow-checks</code> 설정은 <a href="reference/../../reference/expressions/operator-expr.html#overflow">런타임 정수 오버플로</a> 동작을 제어하는 <a href="reference/../../rustc/codegen-options/index.html#overflow-checks"><code>-C overflow-checks</code> 플래그</a> 를 제어합니다. 오버플로 검사가 활성화되면 오버플로 발생 시 패닉이 발생합니다.</p>
<p>사용 가능한 옵션은 다음과 같습니다.</p>
<ul>
<li><code>true</code>: 활성화됨</li>
<li><code>false</code>: 비활성화됨</li>
</ul>
<h3 id="lto"><a class="header" href="#lto">lto</a></h3>
<p><code>lto</code> 설정은 LLVM의 <a href="https://llvm.org/docs/LinkTimeOptimization.html">링크 타임 최적화(Link Time Optimization)</a> 를 제어하는 <code>rustc</code> 의 <a href="reference/../../rustc/codegen-options/index.html#lto"><code>-C lto</code></a>, <a href="reference/../../rustc/codegen-options/index.html#linker-plugin-lto"><code>-C linker-plugin-lto</code></a>, <a href="reference/../../rustc/codegen-options/index.html#embed-bitcode"><code>-C embed-bitcode</code></a> 옵션을 제어합니다. LTO는 전체 프로그램 분석을 사용하여 더 최적화된 코드를 생성할 수 있지만, 링크 시간이 더 길어집니다.</p>
<p>사용 가능한 옵션은 다음과 같습니다.</p>
<ul>
<li><code>true</code> 또는 <code>"fat"</code>: 의존성 그래프 내의 모든 크레이트에 대해 최적화를 시도하는 “fat” LTO를 수행합니다.</li>
<li><code>"thin"</code>: <a href="http://blog.llvm.org/2016/06/thinlto-scalable-and-incremental-lto.html">“thin” LTO</a> 를 수행합니다. 이는 “fat“과 유사하지만, 실행 시간이 상당히 단축되면서도 “fat“과 유사한 성능 이득을 얻을 수 있습니다.</li>
<li><code>false</code>: 로컬 크레이트의 <a href="reference/profiles.html#codegen-units">codegen units</a> 전체에 대해서만 “thin” LTO를 수행하는 “thin local LTO“를 수행합니다. codegen units가 1이거나 <a href="reference/profiles.html#opt-level">opt-level</a> 이 0인 경우 LTO는 수행되지 않습니다.</li>
<li><code>"off"</code>: LTO를 비활성화합니다.</li>
</ul>
<p>언어 간 LTO에 관심이 있다면 <a href="reference/../../rustc/linker-plugin-lto.html">linker-plugin-lto 장</a> 을 참조하세요. 이는 아직 Cargo에서 기본적으로 지원되지는 않지만, <code>RUSTFLAGS</code> 를 통해 수행할 수 있습니다.</p>
<h3 id="panic"><a class="header" href="#panic">panic</a></h3>
<p><code>panic</code> 설정은 어떤 패닉 전략을 사용할지 제어하는 <a href="reference/../../rustc/codegen-options/index.html#panic"><code>-C panic</code> 플래그</a> 를 제어합니다.</p>
<p>사용 가능한 옵션은 다음과 같습니다.</p>
<ul>
<li><code>"unwind"</code>: 패닉 발생 시 스택을 언와인드(unwind)합니다.</li>
<li><code>"abort"</code>: 패닉 발생 시 프로세스를 즉시 종료(abort)합니다.</li>
</ul>
<p><code>"unwind"</code> 로 설정된 경우, 실제 값은 대상 플랫폼의 기본값에 따라 달라집니다. 예를 들어, NVPTX 플랫폼은 언와인딩을 지원하지 않으므로 항상 <code>"abort"</code> 를 사용합니다.</p>
<p>테스트, 벤치마크, 빌드 스크립트 및 절차적 매크로는 <code>panic</code> 설정을 무시합니다. <code>rustc</code> 테스트 하네스는 현재 <code>unwind</code> 동작이 필요합니다. <code>abort</code> 동작을 활성화하는 <a href="reference/unstable.html#panic-abort-tests"><code>panic-abort-tests</code></a> 불안정 플래그를 참조하세요.</p>
<p>또한, <code>abort</code> 전략을 사용하면서 테스트를 빌드할 때는 모든 의존성도 강제로 <code>unwind</code> 전략으로 빌드됩니다.</p>
<h3 id="incremental"><a class="header" href="#incremental">incremental</a></h3>
<p><code>incremental</code> 설정은 증분 컴파일(incremental compilation) 활성화 여부를 제어하는 <a href="reference/../../rustc/codegen-options/index.html#incremental"><code>-C incremental</code> 플래그</a> 를 제어합니다. 증분 컴파일을 사용하면 <code>rustc</code> 가 디스크에 추가 정보를 저장하고 크레이트를 다시 컴파일할 때 이를 재사용하여 재컴파일 시간을 단축합니다. 이 추가 정보는 <code>target</code> 디렉토리에 저장됩니다.</p>
<p>사용 가능한 옵션은 다음과 같습니다.</p>
<ul>
<li><code>true</code>: 활성화됨</li>
<li><code>false</code>: 비활성화됨</li>
</ul>
<p>증분 컴파일은 워크스페이스 구성원 및 “경로(path)” 의존성에 대해서만 사용됩니다.</p>
<p>incremental 값은 <code>CARGO_INCREMENTAL</code> <a href="reference/environment-variables.html">환경 변수</a> 나 <a href="reference/config.html#buildincremental"><code>build.incremental</code></a> 설정 변수를 통해 전역적으로 재정의될 수 있습니다.</p>
<h3 id="codegen-units"><a class="header" href="#codegen-units">codegen-units</a></h3>
<p><code>codegen-units</code> 설정은 크레이트가 몇 개의 “코드 생성 단위(code generation units)“로 나뉠지를 제어하는 <a href="reference/../../rustc/codegen-options/index.html#codegen-units"><code>-C codegen-units</code> 플래그</a> 를 제어합니다. 코드 생성 단위가 많을수록 크레이트의 더 많은 부분을 병렬로 처리할 수 있어 컴파일 시간을 줄일 수 있지만, 생성된 코드의 속도가 느려질 수 있습니다.</p>
<p>이 옵션은 0보다 큰 정수 값을 가집니다.</p>
<p>기본값은 <a href="reference/profiles.html#incremental">증분(#incremental)</a> 빌드의 경우 256이고, 비증분 빌드의 경우 16입니다.</p>
<h3 id="rpath"><a class="header" href="#rpath">rpath</a></h3>
<p><code>rpath</code> 설정은 <a href="https://en.wikipedia.org/wiki/Rpath"><code>rpath</code></a> 활성화 여부를 제어하는 <a href="reference/../../rustc/codegen-options/index.html#rpath"><code>-C rpath</code> 플래그</a> 를 제어합니다.</p>
<h2 id="기본-프로파일"><a class="header" href="#기본-프로파일">기본 프로파일</a></h2>
<h3 id="dev"><a class="header" href="#dev">dev</a></h3>
<p><code>dev</code> 프로파일은 일반적인 개발 및 디버깅에 사용됩니다. <a href="reference/../commands/cargo-build.html"><code>cargo build</code></a> 와 같은 빌드 명령어의 기본값이며, <code>cargo install --debug</code> 에 사용됩니다.</p>
<p><code>dev</code> 프로파일의 기본 설정은 다음과 같습니다.</p>
<pre><code class="language-toml">[profile.dev]
opt-level = 0
debug = true
split-debuginfo = '...'  # 플랫폼별 상이
strip = "none"
debug-assertions = true
overflow-checks = true
lto = false
panic = 'unwind'
incremental = true
codegen-units = 256
rpath = false
</code></pre>
<h3 id="release"><a class="header" href="#release">release</a></h3>
<p><code>release</code> 프로파일은 릴리스 및 프로덕션에서 사용되는 최적화된 결과물을 위한 것입니다. <code>--release</code> 플래그를 사용할 때 사용되며, <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> 의 기본값입니다.</p>
<p><code>release</code> 프로파일의 기본 설정은 다음과 같습니다.</p>
<pre><code class="language-toml">[profile.release]
opt-level = 3
debug = false
split-debuginfo = '...'  # 플랫폼별 상이
strip = "none"
debug-assertions = false
overflow-checks = false
lto = false
panic = 'unwind'
incremental = false
codegen-units = 16
rpath = false
</code></pre>
<h3 id="test"><a class="header" href="#test">test</a></h3>
<p><code>test</code> 프로파일은 <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a> 에서 사용되는 기본 프로파일입니다. <code>test</code> 프로파일은 <a href="reference/profiles.html#dev"><code>dev</code></a> 프로파일의 설정을 상속합니다.</p>
<h3 id="bench"><a class="header" href="#bench">bench</a></h3>
<p><code>bench</code> 프로파일은 <a href="reference/../commands/cargo-bench.html"><code>cargo bench</code></a> 에서 사용되는 기본 프로파일입니다. <code>bench</code> 프로파일은 <a href="reference/profiles.html#release"><code>release</code></a> 프로파일의 설정을 상속합니다.</p>
<h3 id="빌드-의존성-1"><a class="header" href="#빌드-의존성-1">빌드 의존성</a></h3>
<p>빠른 컴파일을 위해 모든 프로파일은 기본적으로 빌드 의존성(빌드 스크립트, 절차적 매크로 및 그 의존성)을 최적화하지 않으며, 빌드 의존성이 런타임 의존성으로 사용되지 않는 한 디버그 정보를 계산하지 않습니다. 빌드 재정의에 대한 기본 설정은 다음과 같습니다.</p>
<pre><code class="language-toml">[profile.dev.build-override]
opt-level = 0
codegen-units = 256
debug = false # when possible

[profile.release.build-override]
opt-level = 0
codegen-units = 256
</code></pre>
<p>하지만 빌드 의존성을 실행하는 동안 오류가 발생하는 경우, 전체 디버그 정보를 활성화하면 백트레이스 정보가 개선되어 디버깅에 도움이 됩니다.</p>
<pre><code class="language-toml">debug = true
</code></pre>
<p>그 외의 경우 빌드 의존성은 <a href="reference/profiles.html#profile-selection">프로파일 선택</a> 에 설명된 대로 사용 중인 활성 프로파일의 설정을 상속합니다.</p>
<h2 id="사용자-정의-프로파일"><a class="header" href="#사용자-정의-프로파일">사용자 정의 프로파일</a></h2>
<p>내장 프로파일 외에도 추가적인 사용자 정의 프로파일을 정의할 수 있습니다. 이는 여러 워크플로나 빌드 모드를 설정할 때 유용할 수 있습니다. 사용자 정의 프로파일을 정의할 때는 설정이 지정되지 않았을 때 어떤 프로파일로부터 설정을 상속받을지 <code>inherits</code> 키를 사용하여 명시해야 합니다.</p>
<p>예를 들어, 일반적인 릴리스 빌드와 <a href="reference/profiles.html#lto">LTO</a> 최적화가 적용된 릴리스 빌드를 비교하고 싶다면 <code>Cargo.toml</code> 에 다음과 같이 지정할 수 있습니다.</p>
<pre><code class="language-toml">[profile.release-lto]
inherits = "release"
lto = true
</code></pre>
<p>그런 다음 <code>--profile</code> 플래그를 사용하여 이 사용자 정의 프로파일을 선택할 수 있습니다.</p>
<pre><code class="language-console">cargo build --profile release-lto
</code></pre>
<p>각 프로파일에 대한 출력은 <a href="reference/build-cache.html"><code>target</code> 디렉토리</a> 내의 프로파일 이름과 동일한 디렉토리에 배치됩니다. 위의 예시에서 출력은 <code>target/release-lto</code> 디렉토리에 저장됩니다.</p>
<h2 id="프로파일-선택"><a class="header" href="#프로파일-선택">프로파일 선택</a></h2>
<p>사용되는 프로파일은 명령어, <code>--release</code> 또는 <code>--profile</code> 과 같은 명령줄 플래그, 그리고 (의존성 <a href="reference/profiles.html#overrides">재정의(#overrides)</a> 의 경우) 패키지에 따라 달라집니다. 아무것도 지정되지 않았을 때의 기본 프로파일은 다음과 같습니다.</p>
<div class="table-wrapper"><table><thead><tr><th>명령어</th><th>기본 프로파일</th></tr></thead><tbody>
<tr><td><a href="reference/../commands/cargo-run.html"><code>cargo run</code></a>, <a href="reference/../commands/cargo-build.html"><code>cargo build</code></a>,<br><a href="reference/../commands/cargo-check.html"><code>cargo check</code></a>, <a href="reference/../commands/cargo-rustc.html"><code>cargo rustc</code></a></td><td><a href="reference/profiles.html#dev"><code>dev</code> 프로파일</a></td></tr>
<tr><td><a href="reference/../commands/cargo-test.html"><code>cargo test</code></a></td><td><a href="reference/profiles.html#test"><code>test</code> 프로파일</a></td></tr>
<tr><td><a href="reference/../commands/cargo-bench.html"><code>cargo bench</code></a></td><td><a href="reference/profiles.html#bench"><code>bench</code> 프로파일</a></td></tr>
<tr><td><a href="reference/../commands/cargo-install.html"><code>cargo install</code></a></td><td><a href="reference/profiles.html#release"><code>release</code> 프로파일</a></td></tr>
</tbody></table>
</div>
<p><code>--profile=NAME</code> 옵션을 사용하여 다른 프로파일로 전환할 수 있으며, 이 경우 지정된 프로파일이 사용됩니다. <code>--release</code> 플래그는 <code>--profile=release</code> 와 동일합니다.</p>
<p>선택된 프로파일은 <a href="reference/./cargo-targets.html#library">라이브러리</a>, <a href="reference/./cargo-targets.html#binaries">바이너리</a>, <a href="reference/./cargo-targets.html#examples">예제</a>, <a href="reference/./cargo-targets.html#tests">테스트</a>, <a href="reference/./cargo-targets.html#benchmarks">벤치마크</a> 를 포함한 모든 Cargo 타겟에 적용됩니다.</p>
<p>특정 패키지에 대한 프로파일은 아래에 설명된 <a href="reference/profiles.html#overrides">재정의(overrides)</a> 를 통해 지정할 수 있습니다.</p>
<h2 id="재정의overrides-1"><a class="header" href="#재정의overrides-1">재정의(Overrides)</a></h2>
<p>특정 패키지 및 빌드 시 크레이트에 대해 프로파일 설정을 재정의할 수 있습니다. 특정 패키지의 설정을 재정의하려면 <code>package</code> 테이블을 사용하여 해당 패키지의 설정을 변경하세요.</p>
<pre><code class="language-toml"># The `foo` package will use the -Copt-level=3 flag.
[profile.dev.package.foo]
opt-level = 3
</code></pre>
<p>패키지 이름은 실제로는 <a href="reference/pkgid-spec.html">패키지 ID 사양(Package ID Spec)</a> 이므로, <code>[profile.dev.package."foo:2.1.0"]</code> 과 같은 구문을 사용하여 패키지의 특정 버전을 대상으로 지정할 수 있습니다.</p>
<p>모든 의존성(워크스페이스 구성원 제외)에 대한 설정을 재정의하려면 <code>"*"</code> 패키지 이름을 사용하세요.</p>
<pre><code class="language-toml"># 의존성에 대한 기본값 설정
[profile.dev.package."*"]
opt-level = 2
</code></pre>
<p>빌드 스크립트, 절차적 매크로 및 그 의존성에 대한 설정을 재정의하려면 <code>build-override</code> 테이블을 사용하세요.</p>
<pre><code class="language-toml"># Set the settings for build scripts and proc-macros.
[profile.dev.build-override]
opt-level = 3
</code></pre>
<blockquote>
<p>참고: 의존성이 일반 의존성과 빌드 의존성 모두에 해당하는 경우, <code>--target</code> 이 지정되지 않았다면 Cargo는 이를 한 번만 빌드하려고 시도합니다. <code>build-override</code> 를 사용하면 의존성을 두 번 빌드해야 할 수도 있습니다 (한 번은 일반 의존성으로, 또 한 번은 재정의된 빌드 설정으로). 이로 인해 초기 빌드 시간이 늘어날 수 있습니다.</p>
</blockquote>
<p>어떤 값이 사용될지에 대한 우선순위는 다음 순서에 따릅니다 (가장 먼저 일치하는 항목 적용).</p>
<ol>
<li><code>[profile.dev.package.name]</code> — 지정된 이름의 패키지</li>
<li><code>[profile.dev.package."*"]</code> — 워크스페이스 구성원이 아닌 모든 패키지</li>
<li><code>[profile.dev.build-override]</code> — 빌드 스크립트, 절차적 매크로 및 그 의존성에만 해당</li>
<li><code>[profile.dev]</code> — <code>Cargo.toml</code> 의 설정</li>
<li>Cargo에 내장된 기본값</li>
</ol>
<p>재정의 설정에서는 <code>panic</code>, <code>lto</code>, <code>rpath</code> 설정을 지정할 수 없습니다.</p>
<h3 id="재정의와-제네릭"><a class="header" href="#재정의와-제네릭">재정의와 제네릭</a></h3>
<p>제네릭 코드가 인스턴스화되는 위치가 해당 제네릭 코드에 사용되는 최적화 설정에 영향을 미칩니다. 이로 인해 프로파일 재정의를 사용하여 특정 크레이트의 최적화 레벨을 변경할 때 미묘한 상호 작용이 발생할 수 있습니다. 제네릭 함수를 정의하는 의존성의 최적화 레벨을 높이려고 시도하더라도, 해당 제네릭 함수가 로컬 크레이트에서 사용될 때는 최적화되지 않을 수 있습니다. 이는 코드가 인스턴스화되는 크레이트에서 생성될 수 있으며, 따라서 해당 크레이트의 최적화 설정을 사용할 수 있기 때문입니다.</p>
<p>예를 들어, <a href="https://crates.io/crates/nalgebra">nalgebra</a> 는 제네릭 매개변수를 많이 사용하는 벡터와 행렬을 정의하는 라이브러리입니다. 로컬 코드에서 <code>Vector4&lt;f64&gt;</code> 와 같은 구체적인 nalgebra 타입을 정의하고 그 메서드들을 사용하는 경우, 해당 nalgebra 코드는 사용자의 크레이트 내에서 인스턴스화되고 빌드됩니다. 따라서 프로파일 재정의를 통해 <code>nalgebra</code> 의 최적화 레벨을 높이려고 시도하더라도, 실제 성능 향상으로 이어지지 않을 수 있습니다.</p>
<p>문제를 더 복잡하게 만드는 것은, <code>rustc</code> 가 크레이트 간에 단일화된(monomorphized) 제네릭을 공유하려는 최적화 기법을 가지고 있다는 점입니다. opt-level이 2 또는 3인 경우, 크레이트는 다른 크레이트의 단일화된 제네릭을 사용하지 않으며, 로컬에서 정의된 단일화된 아이템을 다른 크레이트와 공유하기 위해 내보내지도 않습니다. 개발 시 의존성 최적화를 실험할 때는 opt-level 1을 시도해 보는 것을 고려해 보세요. 이는 어느 정도의 최적화를 적용하면서도 단일화된 아이템의 공유를 허용합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="설정-1"><a class="header" href="#설정-1">설정</a></h1>
<p>이 문서는 Cargo의 설정(configuration) 시스템 작동 방식과 사용 가능한 키 또는 설정에 대해 설명합니다. 매니페스트를 통한 패키지 설정에 대해서는 <a href="reference/manifest.html">매니페스트 형식</a> 을 참조하세요.</p>
<h2 id="계층적-구조"><a class="header" href="#계층적-구조">계층적 구조</a></h2>
<p>Cargo는 특정 패키지에 대한 로컬 설정뿐만 아니라 전역 설정도 허용합니다. 현재 디렉토리와 모든 상위 디렉토리에서 설정 파일을 찾습니다. 예를 들어, Cargo가 <code>/projects/foo/bar/baz</code> 에서 호출되었다면 다음과 같은 설정 파일들을 찾아 이 순서대로 통합합니다.</p>
<ul>
<li><code>/projects/foo/bar/baz/.cargo/config.toml</code></li>
<li><code>/projects/foo/bar/.cargo/config.toml</code></li>
<li><code>/projects/foo/.cargo/config.toml</code></li>
<li><code>/projects/.cargo/config.toml</code></li>
<li><code>/.cargo/config.toml</code></li>
<li>기본값이 다음과 같은 <code>$CARGO_HOME/config.toml</code>:
<ul>
<li>Windows: <code>%USERPROFILE%\.cargo\config.toml</code></li>
<li>Unix: <code>$HOME/.cargo/config.toml</code></li>
</ul>
</li>
</ul>
<p>이러한 구조를 통해 패키지별로 설정을 지정할 수 있으며, 가능한 경우 버전 관리 시스템에 체크인할 수도 있습니다. 또한 홈 디렉토리에 있는 설정 파일을 사용하여 개인적인 기본값을 지정할 수도 있습니다.</p>
<p>여러 설정 파일에 동일한 키가 지정된 경우, 값들이 하나로 통합됩니다. 숫자, 문자열 및 불리언 값은 더 깊은 디렉토리에 있는 설정이 상위 디렉토리보다 우선하며, 홈 디렉토리의 우선순위가 가장 낮습니다. 배열은 서로 합쳐지며, 우선순위가 높은 항목이 통합된 배열의 뒤쪽에 배치됩니다.</p>
<p>현재로서, 워크스페이스에서 호출될 때 Cargo는 워크스페이스 내 크레이트들의 설정 파일을 읽지 않습니다. 즉, <code>/projects/foo/bar/baz/mylib</code> 와 <code>/projects/foo/bar/baz/mybin</code> 이라는 두 크레이트가 있고 각각에 설정 파일이 있더라도, 워크스페이스 루트(<code>/projects/foo/bar/baz/</code>)에서 호출되면 해당 설정 파일들을 읽지 않습니다.</p>
<blockquote>
<p><strong>참고:</strong> Cargo는 <code>.cargo/config</code> 와 같이 <code>.toml</code> 확장자가 없는 설정 파일도 읽습니다. <code>.toml</code> 확장자 지원은 1.39 버전에서 추가되었으며 권장되는 형식입니다. 두 파일이 모두 존재하는 경우 Cargo는 확장자가 없는 파일을 사용합니다.</p>
</blockquote>
<h2 id="설정-형식"><a class="header" href="#설정-형식">설정 형식</a></h2>
<p>설정 파일은 (매니페스트와 마찬가지로) <a href="https://toml.io/">TOML 형식</a> 으로 작성되며, 섹션(테이블) 내에 간단한 키-값 쌍이 포함됩니다. 다음은 모든 설정에 대한 요약이며, 자세한 설명은 아래에 나와 있습니다.</p>
<pre><code class="language-toml">paths = ["/path/to/override"] # path dependency overrides

[alias]     # command aliases
b = "build"
c = "check"
t = "test"
r = "run"
rr = "run --release"
recursive_example = "rr --example recursions"
space_example = ["run", "--release", "--", "\"command list\""]

[build]
jobs = 1                      # number of parallel jobs, defaults to # of CPUs
rustc = "rustc"               # the rust compiler tool
rustc-wrapper = "…"           # run this wrapper instead of `rustc`
rustc-workspace-wrapper = "…" # run this wrapper instead of `rustc` for workspace members
rustdoc = "rustdoc"           # the doc generator tool
target = "triple"             # build for the target triple (ignored by `cargo install`)
target-dir = "target"         # path of where to place generated artifacts
build-dir = "target"          # path of where to place intermediate build artifacts
rustflags = ["…", "…"]        # custom flags to pass to all compiler invocations
rustdocflags = ["…", "…"]     # custom flags to pass to rustdoc
incremental = true            # whether or not to enable incremental compilation
dep-info-basedir = "…"        # path for the base directory for targets in depfiles

[credential-alias]
# Provides a way to define aliases for credential providers.
my-alias = ["/usr/bin/cargo-credential-example", "--argument", "value", "--flag"]

[doc]
browser = "chromium"          # browser to use with `cargo doc --open`,
                              # overrides the `BROWSER` environment variable

[env]
# Set ENV_VAR_NAME=value for any process run by Cargo
ENV_VAR_NAME = "value"
# Set even if already present in environment
ENV_VAR_NAME_2 = { value = "value", force = true }
# `value` is relative to the parent of `.cargo/config.toml`, env var will be the full absolute path
ENV_VAR_NAME_3 = { value = "relative/path", relative = true }

[future-incompat-report]
frequency = 'always' # when to display a notification about a future incompat report

[cache]
auto-clean-frequency = "1 day"   # How often to perform automatic cache cleaning

[cargo-new]
vcs = "none"              # VCS to use ('git', 'hg', 'pijul', 'fossil', 'none')

[http]
debug = false               # HTTP debugging
proxy = "host:port"         # HTTP proxy in libcurl format
ssl-version = "tlsv1.3"     # TLS version to use
ssl-version.max = "tlsv1.3" # maximum TLS version
ssl-version.min = "tlsv1.1" # minimum TLS version
timeout = 30                # timeout for each HTTP request, in seconds
low-speed-limit = 10        # network timeout threshold (bytes/sec)
cainfo = "cert.pem"         # path to Certificate Authority (CA) bundle
proxy-cainfo = "cert.pem"   # path to proxy Certificate Authority (CA) bundle
check-revoke = true         # check for SSL certificate revocation
multiplexing = true         # HTTP/2 multiplexing
user-agent = "…"            # the user-agent header

[install]
root = "/some/path"         # `cargo install` destination directory

[net]
retry = 3                   # network retries
git-fetch-with-cli = true   # use the `git` executable for git operations
offline = true              # do not access the network

[net.ssh]
known-hosts = ["..."]       # known SSH host keys

[patch.&lt;registry&gt;]
# Same keys as for [patch] in Cargo.toml

[profile.&lt;name&gt;]         # Modify profile settings via config.
inherits = "dev"         # Inherits settings from [profile.dev].
opt-level = 0            # Optimization level.
debug = true             # Include debug info.
split-debuginfo = '...'  # Debug info splitting behavior.
strip = "none"           # Removes symbols or debuginfo.
debug-assertions = true  # Enables debug assertions.
overflow-checks = true   # Enables runtime integer overflow checks.
lto = false              # Sets link-time optimization.
panic = 'unwind'         # The panic strategy.
incremental = true       # Incremental compilation.
codegen-units = 16       # Number of code generation units.
rpath = false            # Sets the rpath linking option.
[profile.&lt;name&gt;.build-override]  # Overrides build-script settings.
# Same keys for a normal profile.
[profile.&lt;name&gt;.package.&lt;name&gt;]  # Override profile for a package.
# Same keys for a normal profile (minus `panic`, `lto`, and `rpath`).

[resolver]
incompatible-rust-versions = "allow"  # Specifies how resolver reacts to these

[registries.&lt;name&gt;]  # registries other than crates.io
index = "…"          # URL of the registry index
token = "…"          # authentication token for the registry
credential-provider = "cargo:token" # The credential provider for this registry.

[registries.crates-io]
protocol = "sparse"  # The protocol to use to access crates.io.

[registry]
default = "…"        # name of the default registry
token = "…"          # authentication token for crates.io
credential-provider = "cargo:token"           # The credential provider for crates.io.
global-credential-providers = ["cargo:token"] # The credential providers to use by default.

[source.&lt;name&gt;]      # source definition and replacement
replace-with = "…"   # replace this source with the given named source
directory = "…"      # path to a directory source
registry = "…"       # URL to a registry source
local-registry = "…" # path to a local registry source
git = "…"            # URL of a git repository source
branch = "…"         # branch name for the git repository
tag = "…"            # tag name for the git repository
rev = "…"            # revision for the git repository

[target.&lt;triple&gt;]
linker = "…"              # linker to use
runner = "…"              # wrapper to run executables
rustflags = ["…", "…"]    # custom flags for `rustc`
rustdocflags = ["…", "…"] # custom flags for `rustdoc`

[target.&lt;cfg&gt;]
linker = "…"            # linker to use
runner = "…"            # wrapper to run executables
rustflags = ["…", "…"]  # custom flags for `rustc`

[target.&lt;triple&gt;.&lt;links&gt;] # `links` build script override
rustc-link-lib = ["foo"]
rustc-link-search = ["/path/to/foo"]
rustc-flags = "-L /some/path"
rustc-cfg = ['key="value"']
rustc-env = {key = "value"}
rustc-cdylib-link-arg = ["…"]
metadata_key1 = "value"
metadata_key2 = "value"

[term]
quiet = false                    # whether cargo output is quiet
verbose = false                  # whether cargo provides verbose output
color = 'auto'                   # whether cargo colorizes output
hyperlinks = true                # whether cargo inserts links into output
unicode = true                   # whether cargo can render output using non-ASCII unicode characters
progress.when = 'auto'           # whether cargo shows progress bar
progress.width = 80              # width of progress bar
progress.term-integration = true # whether cargo reports progress to terminal emulator
</code></pre>
<h2 id="환경-변수"><a class="header" href="#환경-변수">환경 변수</a></h2>
<p>Cargo는 TOML 설정 파일 외에도 환경 변수를 통해 설정할 수 있습니다. <code>foo.bar</code> 형식의 각 설정 키에 대해 <code>CARGO_FOO_BAR</code> 환경 변수를 사용하여 값을 정의할 수 있습니다. 키는 대문자로 변환되며, 마침표와 대시는 밑줄로 변환됩니다. 예를 들어 <code>target.x86_64-unknown-linux-gnu.runner</code> 키는 <code>CARGO_TARGET_X86_64_UNKNOWN_LINUX_GNU_RUNNER</code> 환경 변수로 정의될 수 있습니다.</p>
<p>환경 변수는 TOML 설정 파일보다 우선합니다. 현재로서는 정수, 불리언, 문자열 및 일부 배열 값만 환경 변수로 정의할 수 있습니다. <a href="reference/config.html#configuration-keys">아래의 설명</a> 에서 어떤 키가 환경 변수를 지원하는지 확인할 수 있으며, 그렇지 않은 키는 <a href="https://github.com/rust-lang/cargo/issues/5416">기술적인 문제</a> 로 인해 지원되지 않습니다.</p>
<p>위의 시스템 외에도 Cargo는 몇 가지 다른 특정 <a href="reference/environment-variables.html">환경 변수</a> 를 인식합니다.</p>
<h2 id="명령줄-재정의"><a class="header" href="#명령줄-재정의">명령줄 재정의</a></h2>
<p>Cargo는 <code>--config</code> 명령줄 옵션을 통해 임의의 설정 재정의를 허용합니다. 인수는 <code>KEY=VALUE</code> 와 같은 TOML 구문이거나 추가 설정 파일의 경로여야 합니다.</p>
<pre><code class="language-console"># With `KEY=VALUE` in TOML syntax
cargo --config net.git-fetch-with-cli=true fetch

# With a path to a configuration file
cargo --config ./path/to/my/extra-config.toml fetch
</code></pre>
<p><code>--config</code> 옵션은 여러 번 지정될 수 있으며, 이 경우 여러 설정 파일이 적용될 때와 동일한 병합 로직을 사용하여 왼쪽에서 오른쪽 순서로 병합됩니다. 이 방식으로 지정된 설정 값은 환경 변수보다 우선하며, 환경 변수는 설정 파일보다 우선합니다.</p>
<p><code>--config</code> 옵션에 추가 설정 파일이 제공된 경우, 이 방식으로 로드된 설정 파일은 <code>--config</code> 로 직접 지정된 다른 옵션과 동일한 우선순위 규칙을 따릅니다.</p>
<p>Bourne 셸 구문을 사용한 몇 가지 예시는 다음과 같습니다.</p>
<pre><code class="language-console"># Most shells will require escaping.
cargo --config http.proxy=\"http://example.com\" …

# Spaces may be used.
cargo --config "net.git-fetch-with-cli = true" …

# TOML array example. Single quotes make it easier to read and write.
cargo --config 'build.rustdocflags = ["--html-in-header", "header.html"]' …

# Example of a complex TOML key.
cargo --config "target.'cfg(all(target_arch = \"arm\", target_os = \"none\"))'.runner = 'my-runner'" …

# Example of overriding a profile setting.
cargo --config profile.dev.package.image.opt-level=3 …
</code></pre>
<h2 id="including-extra-configuration-files"><a class="header" href="#including-extra-configuration-files">Including extra configuration files</a></h2>
<p>Configuration can include other configuration files using the top-level <code>include</code> key. This allows sharing configuration across multiple projects or splitting complex configurations into multiple files.</p>
<h3 id="include"><a class="header" href="#include"><code>include</code></a></h3>
<ul>
<li>Type: array of strings or tables</li>
<li>기본값: 없음</li>
<li>환경 변수: 지원되지 않음</li>
</ul>
<p>Loads additional configuration files. Paths are relative to the configuration file that includes them. Only paths ending with <code>.toml</code> are accepted.</p>
<p>Supports the following formats:</p>
<pre><code class="language-toml"># array of paths
include = [
    "frodo.toml",
    "samwise.toml",
]

# inline tables for more control
include = [
    { path = "required.toml" },
    { path = "optional.toml", optional = true },
]
</code></pre>
<blockquote>
<p><strong>Note:</strong> For better readability and to avoid confusion, it is recommended to:</p>
<ul>
<li>Place <code>include</code> at the top of the configuration file</li>
<li>Put one include per line for clearer version control diffs</li>
<li>Use inline table syntax when optional includes are needed</li>
</ul>
</blockquote>
<p>When using table syntax, the following fields are supported:</p>
<ul>
<li><code>path</code> (string, required): Path to the config file to include.</li>
<li><code>optional</code> (boolean, default: false): If <code>true</code>, missing files are silently skipped instead of causing an error.</li>
</ul>
<p>The merge behavior of <code>include</code> is different from other config values:</p>
<ol>
<li>Config values are first loaded from the <code>include</code> paths.
<ul>
<li>Included files are loaded left to right, with values from later files taking precedence over earlier ones.</li>
<li>This step recurses if included config files also contain <code>include</code> keys.</li>
</ul>
</li>
<li>Then, the config file’s own values are merged on top of the included config, taking highest precedence.</li>
</ol>
<h2 id="설정-파일-기준-상대-경로"><a class="header" href="#설정-파일-기준-상대-경로">설정 파일 기준 상대 경로</a></h2>
<p>설정 파일의 경로는 절대 경로, 상대 경로, 또는 경로 구분 기호가 없는 단순 이름일 수 있습니다. 경로 구분 기호가 없는 실행 파일 경로의 경우 <code>PATH</code> 환경 변수를 사용하여 실행 파일을 검색합니다. 실행 파일이 아닌 경우의 경로는 설정 값이 정의된 위치를 기준으로 하는 상대 경로입니다.</p>
<p>구체적인 규칙은 다음과 같습니다.</p>
<ul>
<li>환경 변수의 경우, 경로는 현재 작업 디렉토리를 기준으로 합니다.</li>
<li><a href="reference/config.html#command-line-overrides"><code>--config KEY=VALUE</code></a> 옵션에서 직접 로드된 설정 값의 경우, 경로는 현재 작업 디렉토리를 기준으로 합니다.</li>
<li>설정 파일의 경우, 해당 파일이 <a href="reference/config.html#hierarchical-structure">계층적 탐색</a> 을 통한 것이든 <a href="reference/config.html#command-line-overrides"><code>--config &lt;path&gt;</code></a> 옵션을 통한 것이든 관계없이, 경로는 설정 파일이 정의된 디렉토리의 부모 디렉토리를 기준으로 합니다.</li>
</ul>
<blockquote>
<p><strong>참고:</strong> 기존의 <code>.cargo/config.toml</code> 탐색 동작과 일관성을 유지하기 위해, <code>--config &lt;path&gt;</code> 를 통해 전달된 설정 파일의 경로도 설정 파일 자체에서 두 단계 상위 디렉토리를 기준으로 하도록 설계되었습니다.</p>
<p>예기치 않은 결과를 방지하기 위한 기본 원칙은 추가 설정 파일을 프로젝트에서 발견된 <code>.cargo/config.toml</code> 과 동일한 수준에 두는 것입니다. 예를 들어, 프로젝트가 <code>/my/project</code> 인 경우 설정 파일을 <code>/my/project/.cargo</code> 아래에 두거나 동일한 수준의 새 디렉토리(예: <code>/my/project/.config</code>)에 두는 것이 좋습니다.</p>
</blockquote>
<pre><code class="language-toml"># 예시: `/my/project/.cargo/config.toml` 이 있다면 결과는 `/my/project/vendor` 가 됩니다.
directory = "vendor"
</code></pre>
<h2 id="인수가-포함된-실행-파일-경로"><a class="header" href="#인수가-포함된-실행-파일-경로">인수가 포함된 실행 파일 경로</a></h2>
<p>일부 Cargo 명령어는 외부 프로그램을 호출하며, 이는 경로와 여러 인수로 구성할 수 있습니다.</p>
<p>값은 <code>['/path/to/program', 'somearg']</code> 와 같은 문자열 배열이거나 <code>'/path/to/program somearg'</code> 와 같이 공백으로 구분된 문자열일 수 있습니다. 실행 파일 경로에 공백이 포함된 경우 반드시 리스트 형식을 사용해야 합니다.</p>
<p>Cargo가 열기나 실행을 위한 경로와 같이 다른 인수를 프로그램에 전달하는 경우, 이러한 형식의 옵션 값에 지정된 마지막 인수 뒤에 전달됩니다. 지정된 프로그램에 경로 구분 기호가 없는 경우, Cargo는 <code>PATH</code> 에서 실행 파일을 검색합니다.</p>
<h2 id="자격-증명"><a class="header" href="#자격-증명">자격 증명</a></h2>
<p>민감한 정보가 포함된 설정 값은 <code>$CARGO_HOME/credentials.toml</code> 파일에 저장됩니다. 이 파일은 <a href="reference/registry-authentication.html#cargotoken"><code>cargo:token</code></a> 자격 증명 제공자를 사용할 때 <a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> 및 <a href="reference/../commands/cargo-logout.html"><code>cargo logout</code></a> 에 의해 자동으로 생성되고 업데이트됩니다.</p>
<p>토큰은 원격 레지스트리 인증을 위해 <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> 와 같은 일부 Cargo 명령어에서 사용됩니다. 토큰을 보호하고 비밀로 유지하도록 주의해야 합니다.</p>
<p>Cargo 설정 파일과 동일한 형식을 따릅니다.</p>
<pre><code class="language-toml">[registry]
token = "…"   # crates.io용 액세스 토큰

[registries.&lt;이름&gt;]
token = "…"   # 명명된 레지스트리용 액세스 토큰
</code></pre>
<p>다른 대부분의 설정 값과 마찬가지로, 토큰도 환경 변수로 지정할 수 있습니다. <a href="https://crates.io/">crates.io</a> 용 토큰은 <code>CARGO_REGISTRY_TOKEN</code> 환경 변수로 지정할 수 있습니다. 다른 레지스트리용 토큰은 <code>CARGO_REGISTRIES_&lt;이름&gt;_TOKEN</code> 형식의 환경 변수로 지정할 수 있으며, 여기서 <code>&lt;이름&gt;</code> 은 레지스트리 이름을 모두 대문자로 쓴 것입니다.</p>
<blockquote>
<p><strong>참고:</strong> Cargo는 <code>.cargo/credentials</code> 와 같이 <code>.toml</code> 확장자가 없는 자격 증명 파일도 읽고 씁니다. <code>.toml</code> 확장자 지원은 1.39 버전에서 추가되었습니다. 1.68 버전부터 Cargo는 기본적으로 확장자가 있는 파일에 씁니다. 하지만 하위 호환성을 위해 두 파일이 모두 존재하는 경우 Cargo는 확장자가 없는 파일을 읽고 씁니다.</p>
</blockquote>
<h2 id="설정-키"><a class="header" href="#설정-키">설정 키</a></h2>
<p>이 섹션은 모든 설정 키를 문서화합니다. 가변적인 부분이 있는 키에 대한 설명은 <code>target.&lt;triple&gt;</code> 과 같이 꺽쇠 괄호로 표시되며, 여기서 <code>&lt;triple&gt;</code> 부분은 <code>target.x86_64-pc-windows-msvc</code> 와 같은 모든 [타겟 트리플](../appendix/glossary.md#target “타겟 트리플” (용어집))이 될 수 있습니다.</p>
<h3 id="paths"><a class="header" href="#paths"><code>paths</code></a></h3>
<ul>
<li>타입: 문자열 배열 (경로)</li>
<li>기본값: 없음</li>
<li>환경 변수: 지원되지 않음</li>
</ul>
<p>의존성 재정의를 위해 사용될 로컬 패키지들의 경로 배열입니다. 자세한 내용은 <a href="reference/overriding-dependencies.html#paths-overrides">의존성 재정의 가이드</a> 를 참조하세요.</p>
<h3 id="alias"><a class="header" href="#alias"><code>[alias]</code></a></h3>
<ul>
<li>타입: 문자열 또는 문자열 배열</li>
<li>기본값: 아래 참조</li>
<li>환경 변수: <code>CARGO_ALIAS_&lt;name&gt;</code></li>
</ul>
<p><code>[alias]</code> 테이블은 CLI 명령의 별칭(alias)을 정의합니다. 예를 들어, <code>cargo b</code> 를 실행하는 것은 <code>cargo build</code> 를 실행하는 것의 별칭입니다. 테이블의 각 키는 하위 명령어가 되고, 값은 실제로 실행될 명령어가 됩니다. 값은 문자열 배열일 수 있으며, 이 경우 첫 번째 요소는 명령어이고 그 뒤의 요소들은 인수가 됩니다. 또한 문자열일 수도 있으며, 이 경우 공백을 기준으로 하위 명령어와 인수로 나뉩니다. 다음 별칭들은 Cargo에 내장되어 있습니다.</p>
<pre><code class="language-toml">[alias]
b = "build"
c = "check"
d = "doc"
t = "test"
r = "run"
rm = "remove"
</code></pre>
<p>별칭으로 기존의 내장 명령어를 재정의하는 것은 허용되지 않습니다.</p>
<p>별칭은 재귀적으로 작동합니다.</p>
<pre><code class="language-toml">[alias]
rr = "run --release"
recursive_example = "rr --example recursions"
</code></pre>
<h3 id="build"><a class="header" href="#build"><code>[build]</code></a></h3>
<p><code>[build]</code> 테이블은 빌드 타임 작업과 컴파일러 설정을 제어합니다.</p>
<h4 id="buildjobs"><a class="header" href="#buildjobs"><code>build.jobs</code></a></h4>
<ul>
<li>타입: 정수 또는 문자열</li>
<li>기본값: 논리 CPU 개수</li>
<li>환경 변수: <code>CARGO_BUILD_JOBS</code></li>
</ul>
<p>병렬로 실행할 컴파일러 프로세스의 최대 개수를 설정합니다. 음수이면 논리 CPU 개수에 해당 값을 더한 수로 설정됩니다. 0이어서는 안 됩니다. 문자열 <code>default</code> 가 제공되면 기본값으로 다시 설정됩니다.</p>
<p><code>--jobs</code> CLI 옵션으로 재정의할 수 있습니다.</p>
<h4 id="buildrustc"><a class="header" href="#buildrustc"><code>build.rustc</code></a></h4>
<ul>
<li>타입: 문자열 (프로그램 경로)</li>
<li>기본값: <code>"rustc"</code></li>
<li>환경 변수: <code>CARGO_BUILD_RUSTC</code> 또는 <code>RUSTC</code></li>
</ul>
<p><code>rustc</code> 에 사용할 실행 파일을 설정합니다.</p>
<h4 id="buildrustc-wrapper"><a class="header" href="#buildrustc-wrapper"><code>build.rustc-wrapper</code></a></h4>
<ul>
<li>타입: 문자열 (프로그램 경로)</li>
<li>기본값: 없음</li>
<li>환경 변수: <code>CARGO_BUILD_RUSTC_WRAPPER</code> 또는 <code>RUSTC_WRAPPER</code></li>
</ul>
<p><code>rustc</code> 대신 실행할 래퍼(wrapper)를 설정합니다. 래퍼에 전달되는 첫 번째 인수는 실제로 사용할 실행 파일의 경로입니다 (즉, <code>build.rustc</code> 가 설정되어 있으면 해당 값, 아니면 <code>"rustc"</code>).</p>
<h4 id="buildrustc-workspace-wrapper"><a class="header" href="#buildrustc-workspace-wrapper"><code>build.rustc-workspace-wrapper</code></a></h4>
<ul>
<li>타입: 문자열 (프로그램 경로)</li>
<li>기본값: 없음</li>
<li>환경 변수: <code>CARGO_BUILD_RUSTC_WORKSPACE_WRAPPER</code> 또는 <code>RUSTC_WORKSPACE_WRAPPER</code></li>
</ul>
<p>워크스페이스 구성원에 대해서만 <code>rustc</code> 대신 실행할 래퍼를 설정합니다. 워크스페이스가 없는 단일 패키지 프로젝트를 빌드할 때 해당 패키지는 워크스페이스로 간주됩니다. 래퍼에 전달되는 첫 번째 인수는 실제로 사용할 실행 파일의 경로입니다 (즉, <code>build.rustc</code> 가 설정되어 있으면 해당 값, 아니면 <code>"rustc"</code>). 이는 파일 이름 해시에 영향을 주어 래퍼에 의해 생성된 결과물이 별도로 캐시되도록 합니다.</p>
<p><code>rustc-wrapper</code> 와 <code>rustc-workspace-wrapper</code> 가 모두 설정된 경우 중첩됩니다. 최종 호출은 <code>$RUSTC_WRAPPER $RUSTC_WORKSPACE_WRAPPER $RUSTC</code> 가 됩니다.</p>
<h4 id="buildrustdoc"><a class="header" href="#buildrustdoc"><code>build.rustdoc</code></a></h4>
<ul>
<li>타입: 문자열 (프로그램 경로)</li>
<li>기본값: <code>"rustdoc"</code></li>
<li>환경 변수: <code>CARGO_BUILD_RUSTDOC</code> 또는 <code>RUSTDOC</code></li>
</ul>
<p><code>rustdoc</code> 에 사용할 실행 파일을 설정합니다.</p>
<h4 id="buildtarget"><a class="header" href="#buildtarget"><code>build.target</code></a></h4>
<ul>
<li>타입: 문자열 또는 문자열 배열</li>
<li>기본값: 호스트 플랫폼</li>
<li>환경 변수: <code>CARGO_BUILD_TARGET</code></li>
</ul>
<p>컴파일할 기본 [대상 플랫폼 트리플](../appendix/glossary.md#target “타겟” (용어집))입니다.</p>
<p>Possible values:</p>
<ul>
<li>Any supported target in <code>rustc --print target-list</code>.</li>
<li><code>"host-tuple"</code>, which will internally be substituted by the host’s target. This can be particularly useful if you’re cross-compiling some crates, and don’t want to specify your host’s machine as a target (for instance, an <code>xtask</code> in a shared project that may be worked on by many hosts).</li>
<li>A path to a custom target specification. See <a href="reference/../../rustc/targets/custom.html#custom-target-lookup-path">Custom Target Lookup Path</a> for more information.</li>
</ul>
<p><code>--target</code> CLI 옵션으로 재정의할 수 있습니다.</p>
<pre><code class="language-toml">[build]
target = ["x86_64-unknown-linux-gnu", "i686-unknown-linux-gnu"]
</code></pre>
<h4 id="buildtarget-dir"><a class="header" href="#buildtarget-dir"><code>build.target-dir</code></a></h4>
<ul>
<li>타입: 문자열 (경로)</li>
<li>기본값: <code>"target"</code></li>
<li>환경 변수: <code>CARGO_BUILD_TARGET_DIR</code> 또는 <code>CARGO_TARGET_DIR</code></li>
</ul>
<p>모든 컴파일러 출력이 배치될 경로입니다. 지정하지 않을 경우 기본값은 워크스페이스 루트에 있는 <code>target</code> 디렉토리입니다.</p>
<p><code>--target-dir</code> CLI 옵션으로 재정의할 수 있습니다.</p>
<p>For more information see the <a href="reference/../reference/build-cache.html">build cache documentation</a>.</p>
<h4 id="buildbuild-dir"><a class="header" href="#buildbuild-dir"><code>build.build-dir</code></a></h4>
<ul>
<li>타입: 문자열 (경로)</li>
<li>기본값: <code>build.target-dir</code> 값으로 기본 설정됨</li>
<li>환경 변수: <code>CARGO_BUILD_BUILD_DIR</code></li>
</ul>
<p>중간 빌드 결과물이 저장될 디렉토리입니다. 중간 결과물은 빌드 과정 중에 Rustc/Cargo에 의해 생성됩니다.</p>
<p>This option supports path templating.</p>
<p>Available template variables:</p>
<ul>
<li><code>{workspace-root}</code> resolves to root of the current workspace.</li>
<li><code>{cargo-cache-home}</code> resolves to <code>CARGO_HOME</code></li>
<li><code>{workspace-path-hash}</code> resolves to a hash of the manifest path</li>
</ul>
<p>For more information see the <a href="reference/../reference/build-cache.html">build cache documentation</a>.</p>
<h4 id="buildrustflags"><a class="header" href="#buildrustflags"><code>build.rustflags</code></a></h4>
<ul>
<li>타입: 문자열 또는 문자열 배열</li>
<li>기본값: 없음</li>
<li>환경 변수: <code>CARGO_BUILD_RUSTFLAGS</code> 또는 <code>CARGO_ENCODED_RUSTFLAGS</code> 또는 <code>RUSTFLAGS</code></li>
</ul>
<p><code>rustc</code> 에 전달할 추가 명령줄 플래그입니다. 값은 문자열 배열이거나 공백으로 구분된 문자열일 수 있습니다.</p>
<p>추가 플래그를 가져오는 상호 배타적인 네 가지 소스가 있습니다. 다음 순서대로 확인되며, 가장 먼저 발견된 소스가 사용됩니다.</p>
<ol>
<li><code>CARGO_ENCODED_RUSTFLAGS</code> 환경 변수</li>
<li><code>RUSTFLAGS</code> 환경 변수</li>
<li>일치하는 모든 <code>target.&lt;triple&gt;.rustflags</code> 및 <code>target.&lt;cfg&gt;.rustflags</code> 설정 항목들의 결합</li>
<li><code>build.rustflags</code> 설정 값</li>
</ol>
<p><a href="reference/../commands/cargo-rustc.html"><code>cargo rustc</code></a> 명령어를 통해 추가 플래그를 전달할 수도 있습니다.</p>
<p><code>--target</code> 플래그(또는 <a href="reference/config.html#buildtarget"><code>build.target</code></a>)가 사용되면, 플래그는 타겟용 컴파일러에만 전달됩니다. 빌드 스크립트나 절차적 매크로와 같이 호스트용으로 빌드되는 것들은 해당 인수를 받지 않습니다. <code>--target</code> 이 없으면 의존성이 공유되기 때문에 빌드 스크립트와 절차적 매크로를 포함한 모든 컴파일러 호출에 플래그가 전달됩니다. 빌드 스크립트나 절차적 매크로에 전달하고 싶지 않은 인수가 있고 호스트용으로 빌드 중이라면, <code>--target</code> 에 [호스트 트리플](../appendix/glossary.md#target “타겟” (용어집))을 지정하여 전달하세요.</p>
<p>Cargo가 보통 직접 관리하는 플래그를 전달하는 것은 권장되지 않습니다. 예를 들어, <a href="reference/profiles.html">프로파일(profiles)</a> 에 의해 결정되는 플래그들은 적절한 프로파일 설정을 통해 처리하는 것이 가장 좋습니다.</p>
<blockquote>
<p><strong>주의</strong>: 컴파일러에 직접 플래그를 전달하는 저수준 작업의 특성상, 향후 버전의 Cargo가 자체적으로 동일하거나 유사한 플래그를 사용하여 사용자가 지정한 플래그와 충돌을 일으킬 수 있습니다. 이 영역은 Cargo가 항상 하위 호환성을 보장하지 않을 수 있는 부분입니다.</p>
</blockquote>
<h4 id="buildrustdocflags"><a class="header" href="#buildrustdocflags"><code>build.rustdocflags</code></a></h4>
<ul>
<li>타입: 문자열 또는 문자열 배열</li>
<li>기본값: 없음</li>
<li>환경 변수: <code>CARGO_BUILD_RUSTDOCFLAGS</code> 또는 <code>CARGO_ENCODED_RUSTDOCFLAGS</code> 또는 <code>RUSTDOCFLAGS</code></li>
</ul>
<p><code>rustdoc</code> 에 전달할 추가 명령줄 플래그입니다. 값은 문자열 배열이거나 공백으로 구분된 문자열일 수 있습니다.</p>
<p>추가 플래그를 가져오는 상호 배타적인 네 가지 소스가 있습니다. 다음 순서대로 확인되며, 가장 먼저 발견된 소스가 사용됩니다.</p>
<ol>
<li><code>CARGO_ENCODED_RUSTDOCFLAGS</code> 환경 변수</li>
<li><code>RUSTDOCFLAGS</code> 환경 변수</li>
<li>일치하는 모든 <code>target.&lt;triple&gt;.rustdocflags</code> 설정 항목들의 결합</li>
<li><code>build.rustdocflags</code> 설정 값</li>
</ol>
<p><a href="reference/../commands/cargo-rustdoc.html"><code>cargo rustdoc</code></a> 명령어를 통해 추가 플래그를 전달할 수도 있습니다.</p>
<blockquote>
<p><strong>주의</strong>: 컴파일러에 직접 플래그를 전달하는 저수준 작업의 특성상, 향후 버전의 Cargo가 자체적으로 동일하거나 유사한 플래그를 사용하여 사용자가 지정한 플래그와 충돌을 일으킬 수 있습니다. 이 영역은 Cargo가 항상 하위 호환성을 보장하지 않을 수 있는 부분입니다.</p>
</blockquote>
<h4 id="buildincremental"><a class="header" href="#buildincremental"><code>build.incremental</code></a></h4>
<ul>
<li>타입: 불리언</li>
<li>기본값: 프로파일 설정을 따름</li>
<li>환경 변수: <code>CARGO_BUILD_INCREMENTAL</code> 또는 <code>CARGO_INCREMENTAL</code></li>
</ul>
<p><a href="reference/profiles.html#incremental">증분 컴파일(incremental compilation)</a> 수행 여부입니다. 설정하지 않을 경우 기본값은 <a href="reference/profiles.html#incremental">프로파일</a> 의 값을 사용하는 것입니다. 설정된 경우 모든 프로파일의 설정을 재정의합니다.</p>
<p><code>CARGO_INCREMENTAL</code> 환경 변수를 <code>1</code> 로 설정하여 모든 프로파일에 대해 증분 컴파일을 강제로 활성화하거나, <code>0</code> 으로 설정하여 비활성화할 수 있습니다. 이 환경 변수는 설정 파일의 설정을 재정의합니다.</p>
<h4 id="builddep-info-basedir"><a class="header" href="#builddep-info-basedir"><code>build.dep-info-basedir</code></a></h4>
<ul>
<li>타입: 문자열 (경로)</li>
<li>기본값: 없음</li>
<li>환경 변수: <code>CARGO_BUILD_DEP_INFO_BASEDIR</code></li>
</ul>
<p><a href="reference/../reference/build-cache.html#dep-info-files">의존성 정보(dep info)</a> 파일 경로에서 지정된 경로 접두사를 제거합니다. 이 설정은 상대 경로가 필요한 도구들을 위해 절대 경로를 상대 경로로 변환하려는 목적으로 제공됩니다.</p>
<p>설정값 자체는 설정 파일 기준 상대 경로입니다. 예를 들어 <code>"."</code> 이라는 값은 <code>.cargo</code> 디렉토리의 부모 디렉토리로 시작하는 모든 경로를 제거합니다.</p>
<h4 id="buildpipelining"><a class="header" href="#buildpipelining"><code>build.pipelining</code></a></h4>
<p>이 옵션은 사용이 중단되었으며 사용되지 않습니다. Cargo는 항상 파이프라이닝(pipelining)을 활성화합니다.</p>
<h3 id="credential-alias"><a class="header" href="#credential-alias"><code>[credential-alias]</code></a></h3>
<ul>
<li>타입: 문자열 또는 문자열 배열</li>
<li>기본값: 비어 있음</li>
<li>환경 변수: <code>CARGO_CREDENTIAL_ALIAS_&lt;name&gt;</code></li>
</ul>
<p><code>[credential-alias]</code> 테이블은 자격 증명 제공자(credential provider) 별칭을 정의합니다. 이러한 별칭은 <code>registry.global-credential-providers</code> 배열의 요소로 참조되거나, <code>registries.&lt;NAME&gt;.credential-provider</code> 아래의 특정 레지스트리에 대한 자격 증명 제공자로 참조될 수 있습니다.</p>
<p>문자열로 지정된 경우, 값은 공백을 기준으로 경로와 인수로 나뉩니다.</p>
<p>예를 들어, <code>my-alias</code> 라는 별칭을 정의하려면 다음과 같이 합니다.</p>
<pre><code class="language-toml">[credential-alias]
my-alias = ["/usr/bin/cargo-credential-example", "--argument", "value", "--flag"]
</code></pre>
<p>자세한 내용은 <a href="reference/registry-authentication.html">레지스트리 인증</a> 을 참조하세요.</p>
<h3 id="doc"><a class="header" href="#doc"><code>[doc]</code></a></h3>
<p><code>[doc]</code> 테이블은 <a href="reference/../commands/cargo-doc.html"><code>cargo doc</code></a> 명령어에 대한 옵션을 정의합니다.</p>
<h4 id="docbrowser"><a class="header" href="#docbrowser"><code>doc.browser</code></a></h4>
<ul>
<li>타입: 문자열 또는 문자열 배열 (<a href="reference/config.html#executable-paths-with-arguments">인수가 포함된 프로그램 경로</a>)</li>
<li>기본값: <code>BROWSER</code> 환경 변수. 환경 변수가 없으면 시스템별 방식으로 링크를 엽니다.</li>
</ul>
<p>이 옵션은 <a href="reference/../commands/cargo-doc.html"><code>cargo doc</code></a> 에서 사용할 브라우저를 설정하며, <code>--open</code> 옵션으로 문서를 열 때 <code>BROWSER</code> 환경 변수보다 우선합니다.</p>
<h3 id="cargo-new"><a class="header" href="#cargo-new"><code>[cargo-new]</code></a></h3>
<p><code>[cargo-new]</code> 테이블은 <a href="reference/../commands/cargo-new.html"><code>cargo new</code></a> 명령어에 대한 기본값을 정의합니다.</p>
<h4 id="cargo-newname"><a class="header" href="#cargo-newname"><code>cargo-new.name</code></a></h4>
<p>이 옵션은 사용이 중단되었으며 사용되지 않습니다.</p>
<h4 id="cargo-newemail"><a class="header" href="#cargo-newemail"><code>cargo-new.email</code></a></h4>
<p>이 옵션은 사용이 중단되었으며 사용되지 않습니다.</p>
<h4 id="cargo-newvcs"><a class="header" href="#cargo-newvcs"><code>cargo-new.vcs</code></a></h4>
<ul>
<li>타입: 문자열</li>
<li>기본값: <code>"git"</code> 또는 <code>"none"</code></li>
<li>환경 변수: <code>CARGO_CARGO_NEW_VCS</code></li>
</ul>
<p>새 저장소를 초기화할 때 사용할 소스 제어 시스템을 지정합니다. 유효한 값은 <code>git</code>, <code>hg</code> (Mercurial용), <code>pijul</code>, <code>fossil</code>, 또는 이 동작을 비활성화하는 <code>none</code> 입니다. 기본값은 <code>git</code> 이며, 이미 VCS 저장소 내부에 있는 경우 <code>none</code> 입니다. <code>--vcs</code> CLI 옵션으로 재정의할 수 있습니다.</p>
<h3 id="env"><a class="header" href="#env"><code>[env]</code></a></h3>
<p><code>[env]</code> 섹션을 사용하면 빌드 스크립트, rustc 호출, <code>cargo run</code> 및 <code>cargo build</code> 를 위한 추가 환경 변수를 설정할 수 있습니다.</p>
<pre><code class="language-toml">[env]
OPENSSL_DIR = "/opt/openssl"
</code></pre>
<p>기본적으로 지정된 변수는 환경에 이미 존재하는 값을 재정의하지 않습니다. 이 동작은 <code>force</code> 플래그를 설정하여 변경할 수 있습니다.</p>
<p><code>relative</code> 플래그를 설정하면 값을 설정 파일 기준 상대 경로로 평가합니다. 이는 <code>config.toml</code> 파일이 들어있는 <code>.cargo</code> 디렉토리의 부모 디렉토리를 기준으로 합니다. 환경 변수의 값은 전체 절대 경로가 됩니다.</p>
<pre><code class="language-toml">[env]
TMPDIR = { value = "/home/tmp", force = true }
OPENSSL_DIR = { value = "vendor/openssl", relative = true }
</code></pre>
<h3 id="future-incompat-report"><a class="header" href="#future-incompat-report"><code>[future-incompat-report]</code></a></h3>
<p><code>[future-incompat-report]</code> 테이블은 <a href="reference/future-incompat-report.html">미래 비호환성 보고(future incompat reporting)</a> 에 대한 설정을 제어합니다.</p>
<h4 id="future-incompat-reportfrequency"><a class="header" href="#future-incompat-reportfrequency"><code>future-incompat-report.frequency</code></a></h4>
<ul>
<li>타입: 문자열</li>
<li>기본값: <code>"always"</code></li>
<li>환경 변수: <code>CARGO_FUTURE_INCOMPAT_REPORT_FREQUENCY</code></li>
</ul>
<p>미래 비호환성 보고서가 있을 때 터미널에 알림을 표시하는 빈도를 제어합니다. 가능한 값은 다음과 같습니다.</p>
<ul>
<li><code>always</code> (기본값): 명령어(예: <code>cargo build</code>)가 미래 비호환성 보고서를 생성할 때 항상 알림을 표시합니다.</li>
<li><code>never</code>: 알림을 전혀 표시하지 않습니다.</li>
</ul>
<h3 id="cache"><a class="header" href="#cache"><code>[cache]</code></a></h3>
<p>The <code>[cache]</code> table defines settings for cargo’s caches.</p>
<h4 id="global-caches"><a class="header" href="#global-caches">Global caches</a></h4>
<p>When running <code>cargo</code> commands, Cargo will automatically track which files you are using within the global cache. Periodically, Cargo will delete files that have not been used for some period of time. It will delete files that have to be downloaded from the network if they have not been used in 3 months. Files that can be generated without network access will be deleted if they have not been used in 1 month.</p>
<p>The automatic deletion of files only occurs when running commands that are already doing a significant amount of work, such as all of the build commands (<code>cargo build</code>, <code>cargo test</code>, <code>cargo check</code>, etc.), and <code>cargo fetch</code>.</p>
<p>Automatic deletion is disabled if cargo is offline such as with <code>--offline</code> or <code>--frozen</code> to avoid deleting artifacts that may need to be used if you are offline for a long period of time.</p>
<blockquote>
<p><strong>Note</strong>: This tracking is currently only implemented for the global cache in Cargo’s home directory. This includes registry indexes and source files downloaded from registries and git dependencies. Support for tracking build artifacts is not yet implemented, and tracked in <a href="https://github.com/rust-lang/cargo/issues/13136">cargo#13136</a>.</p>
<p>Additionally, there is an unstable feature to support <em>manually</em> triggering cache cleaning, and to further customize the configuration options. See the <a href="reference/unstable.html#gc">Unstable chapter</a> for more information.</p>
</blockquote>
<h4 id="cacheauto-clean-frequency"><a class="header" href="#cacheauto-clean-frequency"><code>cache.auto-clean-frequency</code></a></h4>
<ul>
<li>타입: 문자열</li>
<li>Default: <code>"1 day"</code></li>
<li>Environment: <code>CARGO_CACHE_AUTO_CLEAN_FREQUENCY</code></li>
</ul>
<p>This option defines how often Cargo will automatically delete unused files in the global cache. This does <em>not</em> define how old the files must be, those thresholds are described <a href="reference/config.html#global-caches">above</a>.</p>
<p>It supports the following settings:</p>
<ul>
<li><code>"never"</code> — Never deletes old files.</li>
<li><code>"always"</code> — Checks to delete old files every time Cargo runs.</li>
<li>An integer followed by “seconds”, “minutes”, “hours”, “days”, “weeks”, or “months” — Checks to delete old files at most the given time frame.</li>
</ul>
<h3 id="http"><a class="header" href="#http"><code>[http]</code></a></h3>
<p><code>[http]</code> 테이블은 HTTP 동작에 대한 설정을 정의합니다. 여기에는 크레이트 의존성 가져오기 및 원격 git 저장소 액세스가 포함됩니다.</p>
<h4 id="httpdebug"><a class="header" href="#httpdebug"><code>http.debug</code></a></h4>
<ul>
<li>타입: 불리언</li>
<li>기본값: false</li>
<li>환경 변수: <code>CARGO_HTTP_DEBUG</code></li>
</ul>
<p><code>true</code> 인 경우, HTTP 요청 디버깅을 활성화합니다. 디버그 정보는 <code>CARGO_LOG=network=debug</code> 환경 변수를 설정하여 확인할 수 있습니다 (더 자세한 정보를 원하면 <code>network=trace</code> 를 사용하세요).</p>
<p>이 출력의 로그를 공개적인 장소에 게시할 때는 주의하세요. 출력물에는 유출되어서는 안 되는 인증 토큰이 포함된 헤더가 있을 수 있습니다! 로그를 게시하기 전에 반드시 내용을 검토하세요.</p>
<h4 id="httpproxy"><a class="header" href="#httpproxy"><code>http.proxy</code></a></h4>
<ul>
<li>타입: 문자열</li>
<li>기본값: 없음</li>
<li>환경 변수: <code>CARGO_HTTP_PROXY</code> 또는 <code>HTTPS_PROXY</code> 또는 <code>https_proxy</code> 또는 <code>http_proxy</code></li>
</ul>
<p>사용할 HTTP 및 HTTPS 프록시를 설정합니다. 형식은 <code>[protocol://]host[:port]</code> 와 같은 <a href="https://everything.curl.dev/transfers/conn/proxies#proxy-types">libcurl 형식</a> 입니다. 설정되지 않은 경우 Cargo는 전역 git 구성의 <code>http.proxy</code> 설정도 확인합니다. 둘 다 설정되지 않은 경우, <code>HTTPS_PROXY</code> 또는 <code>https_proxy</code> 환경 변수가 HTTPS 요청용 프록시를 설정하고, <code>http_proxy</code> 가 HTTP 요청용 프록시를 설정합니다.</p>
<h4 id="httptimeout"><a class="header" href="#httptimeout"><code>http.timeout</code></a></h4>
<ul>
<li>타입: 정수</li>
<li>기본값: 30</li>
<li>환경 변수: <code>CARGO_HTTP_TIMEOUT</code> 또는 <code>HTTP_TIMEOUT</code></li>
</ul>
<p>각 HTTP 요청에 대한 타임아웃을 초 단위로 설정합니다.</p>
<h4 id="httpcainfo"><a class="header" href="#httpcainfo"><code>http.cainfo</code></a></h4>
<ul>
<li>타입: 문자열 (경로)</li>
<li>기본값: 없음</li>
<li>환경 변수: <code>CARGO_HTTP_CAINFO</code></li>
</ul>
<p>TLS 인증서를 확인하는 데 사용되는 인증 기관(CA) 번들 파일의 경로입니다. 지정하지 않으면 Cargo는 시스템 인증서 사용을 시도합니다.</p>
<h4 id="httpproxy-cainfo"><a class="header" href="#httpproxy-cainfo"><code>http.proxy-cainfo</code></a></h4>
<ul>
<li>타입: 문자열 (경로)</li>
<li>Default: falls back to <code>http.cainfo</code> if not set</li>
<li>Environment: <code>CARGO_HTTP_PROXY_CAINFO</code></li>
</ul>
<p>Path to a Certificate Authority (CA) bundle file, used to verify proxy TLS certificates.</p>
<h4 id="httpcheck-revoke"><a class="header" href="#httpcheck-revoke"><code>http.check-revoke</code></a></h4>
<ul>
<li>타입: 불리언</li>
<li>기본값: true (Windows), false (기타 모든 운영체제)</li>
<li>환경 변수: <code>CARGO_HTTP_CHECK_REVOKE</code></li>
</ul>
<p>TLS 인증서 폐기(revocation) 확인을 수행할지 여부를 결정합니다. 이 기능은 윈도우에서만 작동합니다.</p>
<h4 id="httpssl-version"><a class="header" href="#httpssl-version"><code>http.ssl-version</code></a></h4>
<ul>
<li>타입: 문자열 또는 min/max 테이블</li>
<li>기본값: 없음</li>
<li>환경 변수: <code>CARGO_HTTP_SSL_VERSION</code></li>
</ul>
<p>사용할 최소 TLS 버전을 설정합니다. 문자열 값을 가지며, 가능한 값은 <code>"default"</code>, <code>"tlsv1"</code>, <code>"tlsv1.0"</code>, <code>"tlsv1.1"</code>, <code>"tlsv1.2"</code>, <code>"tlsv1.3"</code> 중 하나입니다.</p>
<p>대신 <code>min</code> 과 <code>max</code> 라는 두 개의 키가 있는 테이블을 가질 수도 있으며, 각 키는 사용할 TLS 버전의 최소 및 최대 범위를 지정하는 동일한 종류의 문자열 값을 가집니다.</p>
<p>기본값은 최소 버전 <code>"tlsv1.0"</code> 이며, 최대 버전은 사용자의 플랫폼에서 지원하는 최신 버전(일반적으로 <code>"tlsv1.3"</code>)입니다.</p>
<h4 id="httplow-speed-limit"><a class="header" href="#httplow-speed-limit"><code>http.low-speed-limit</code></a></h4>
<ul>
<li>타입: 정수</li>
<li>기본값: 10</li>
<li>환경 변수: <code>CARGO_HTTP_LOW_SPEED_LIMIT</code></li>
</ul>
<p>이 설정은 느린 연결에 대한 타임아웃 동작을 제어합니다. 초당 평균 전송 속도(바이트)가 <a href="reference/config.html#httptimeout"><code>http.timeout</code></a> 초(기본값 30초) 동안 지정된 값보다 낮으면 연결이 너무 느린 것으로 간주되어 Cargo가 중단하고 다시 시도합니다.</p>
<h4 id="httpmultiplexing"><a class="header" href="#httpmultiplexing"><code>http.multiplexing</code></a></h4>
<ul>
<li>타입: 불리언</li>
<li>기본값: true</li>
<li>환경 변수: <code>CARGO_HTTP_MULTIPLEXING</code></li>
</ul>
<p><code>true</code> 인 경우, Cargo는 멀티플렉싱이 포함된 HTTP2 프로토콜 사용을 시도합니다. 이를 통해 여러 요청이 동일한 연결을 사용할 수 있으며, 보통 여러 파일을 가져올 때 성능이 향상됩니다. <code>false</code> 인 경우, Cargo는 파이프라이닝이 없는 HTTP 1.1을 사용합니다.</p>
<h4 id="httpuser-agent"><a class="header" href="#httpuser-agent"><code>http.user-agent</code></a></h4>
<ul>
<li>타입: 문자열</li>
<li>기본값: Cargo 버전</li>
<li>환경 변수: <code>CARGO_HTTP_USER_AGENT</code></li>
</ul>
<p>사용할 사용자 정의 user-agent 헤더를 지정합니다. 지정하지 않을 경우 기본값은 Cargo 버전을 포함하는 문자열입니다.</p>
<h3 id="install"><a class="header" href="#install"><code>[install]</code></a></h3>
<p><code>[install]</code> 테이블은 <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> 명령어에 대한 기본값을 정의합니다.</p>
<h4 id="installroot"><a class="header" href="#installroot"><code>install.root</code></a></h4>
<ul>
<li>타입: 문자열 (경로)</li>
<li>기본값: Cargo 홈 디렉토리</li>
<li>환경 변수: <code>CARGO_INSTALL_ROOT</code></li>
</ul>
<p><a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> 을 통해 실행 파일을 설치할 루트 디렉토리의 경로를 설정합니다. 실행 파일은 루트 아래의 <code>bin</code> 디렉토리에 저장됩니다.</p>
<p>설치된 실행 파일의 정보를 추적하기 위해 <code>.crates.toml</code> 및 <code>.crates2.json</code> 과 같은 추가 파일도 이 루트 아래에 생성됩니다.</p>
<p>지정하지 않을 경우 기본값은 Cargo 홈 디렉토리(사용자 홈 디렉토리의 <code>.cargo</code>)입니다.</p>
<p><code>--root</code> 명령줄 옵션으로 재정의할 수 있습니다.</p>
<h3 id="net"><a class="header" href="#net"><code>[net]</code></a></h3>
<p><code>[net]</code> 테이블은 네트워크 구성을 제어합니다.</p>
<h4 id="netretry"><a class="header" href="#netretry"><code>net.retry</code></a></h4>
<ul>
<li>타입: 정수</li>
<li>기본값: 3</li>
<li>환경 변수: <code>CARGO_NET_RETRY</code></li>
</ul>
<p>일시적인 네트워크 오류 발생 시 재시도할 횟수입니다.</p>
<h4 id="netgit-fetch-with-cli"><a class="header" href="#netgit-fetch-with-cli"><code>net.git-fetch-with-cli</code></a></h4>
<ul>
<li>타입: 불리언</li>
<li>기본값: false</li>
<li>환경 변수: <code>CARGO_NET_GIT_FETCH_WITH_CLI</code></li>
</ul>
<p>이 값이 <code>true</code> 인 경우, Cargo는 <code>git</code> 실행 파일을 사용하여 레지스트리 인덱스 및 git 의존성을 가져옵니다. <code>false</code> 인 경우, 내장된 <code>git</code> 라이브러리를 사용합니다.</p>
<p>Cargo가 지원하지 않는 특수한 인증 요구 사항이 있는 경우 이 값을 <code>true</code> 로 설정하는 것이 도움이 될 수 있습니다. git 인증 설정에 대한 자세한 내용은 <a href="reference/../appendix/git-authentication.html">Git 인증</a> 을 참조하세요.</p>
<h4 id="netoffline"><a class="header" href="#netoffline"><code>net.offline</code></a></h4>
<ul>
<li>타입: 불리언</li>
<li>기본값: false</li>
<li>환경 변수: <code>CARGO_NET_OFFLINE</code></li>
</ul>
<p>이 값이 <code>true</code> 인 경우, Cargo는 네트워크 액세스를 피하고 로컬에 캐시된 데이터로 진행을 시도합니다. <code>false</code> 인 경우, Cargo는 필요에 따라 네트워크에 액세스하며 네트워크 오류가 발생하면 오류를 생성합니다.</p>
<p><code>--offline</code> 명령줄 옵션으로 재정의할 수 있습니다.</p>
<h4 id="netssh"><a class="header" href="#netssh"><code>net.ssh</code></a></h4>
<p><code>[net.ssh]</code> 테이블은 SSH 연결에 대한 설정을 포함합니다.</p>
<h4 id="netsshknown-hosts"><a class="header" href="#netsshknown-hosts"><code>net.ssh.known-hosts</code></a></h4>
<ul>
<li>타입: 문자열 배열</li>
<li>기본값: 설명 참조</li>
<li>환경 변수: 지원되지 않음</li>
</ul>
<p><code>known-hosts</code> 배열은 SSH 서버에 연결할 때(예: SSH git 의존성) 유효한 것으로 수락되어야 하는 SSH 호스트 키 목록을 포함합니다. 각 항목은 OpenSSH <code>known_hosts</code> 파일과 유사한 형식의 문자열이어야 합니다. 각 문자열은 쉼표로 구분된 하나 이상의 호스트 이름, 공백, 키 타입 이름, 공백, 그리고 base64로 인코딩된 키로 시작해야 합니다. 예를 들어 다음과 같습니다.</p>
<pre><code class="language-toml">[net.ssh]
known-hosts = [
    "example.com ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIFO4Q5T0UV0SQevair9PFwoxY9dl4pQl3u5phoqJH3cF"
</code></pre>
<p>Cargo는 OpenSSH에서 지원하는 일반적인 위치에서 알려진 호스트 키를 로드하려고 시도하며, 이를 Cargo 설정 파일에 나열된 키와 병합합니다. 일치하는 항목 중 올바른 키가 있으면 연결이 허용됩니다.</p>
<p>Cargo에는 <a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints">github.com</a> 의 호스트 키가 내장되어 있습니다. 이 키가 변경되는 경우 설정 파일이나 <code>known_hosts</code> 파일에 새 키를 추가할 수 있습니다.</p>
<p>자세한 내용은 <a href="reference/../appendix/git-authentication.html#ssh-known-hosts">Git 인증</a> 을 참조하세요.</p>
<h3 id="patch"><a class="header" href="#patch"><code>[patch]</code></a></h3>
<p><a href="reference/overriding-dependencies.html#the-patch-section"><code>Cargo.toml</code> 의 <code>[patch]</code></a>를 사용하여 의존성을 재정의할 수 있는 것처럼, Cargo 설정 파일에서도 의존성을 재정의하여 영향을 받는 모든 빌드에 해당 패치를 적용할 수 있습니다. 형식은 <code>Cargo.toml</code> 에서 사용하는 것과 동일합니다.</p>
<p><code>.cargo/config.toml</code> 파일은 보통 소스 제어 시스템에 체크인되지 않으므로, 다른 개발자들이 자신의 환경에서 크레이트를 컴파일할 수 있도록 가급적 <code>Cargo.toml</code> 을 사용하여 패치하는 것이 좋습니다. Cargo 설정 파일을 통한 패치는 일반적으로 패치 섹션이 외부 빌드 도구에 의해 자동으로 생성되는 경우에만 적합합니다.</p>
<p>특정 의존성이 Cargo 설정 파일과 <code>Cargo.toml</code> 파일 모두에서 패치된 경우, 설정 파일의 패치가 사용됩니다. 여러 설정 파일이 동일한 의존성을 패치하는 경우 표준 Cargo 설정 병합 규칙이 사용되며, 현재 디렉토리에 가장 가까운 곳에 정의된 값이 우선되고 <code>$HOME/.cargo/config.toml</code> 이 가장 낮은 우선순위를 갖습니다.</p>
<p>이러한 <code>[patch]</code> 섹션의 상대 <code>path</code> 의존성은 해당 설정 파일이 위치한 디렉토리를 기준으로 해결됩니다.</p>
<h3 id="profile"><a class="header" href="#profile"><code>[profile]</code></a></h3>
<p><code>[profile]</code> 테이블은 프로파일 설정을 전역적으로 변경하고 <code>Cargo.toml</code> 에 지정된 설정을 재정의하는 데 사용될 수 있습니다. <code>Cargo.toml</code> 에 지정된 프로파일과 동일한 구문 및 옵션을 가집니다. 옵션에 대한 자세한 내용은 <a href="reference/profiles.html">프로파일(Profiles) 장</a> 을 참조하세요.</p>
<h4 id="profilenamebuild-override"><a class="header" href="#profilenamebuild-override"><code>[profile.&lt;name&gt;.build-override]</code></a></h4>
<ul>
<li>환경 변수: <code>CARGO_PROFILE_&lt;name&gt;_BUILD_OVERRIDE_&lt;key&gt;</code></li>
</ul>
<p>build-override 테이블은 빌드 스크립트, 절차적 매크로 및 그 의존성에 대한 설정을 재정의합니다. 일반 프로파일과 동일한 키를 가집니다. 자세한 내용은 <a href="reference/profiles.html#overrides">재정의 섹션</a> 을 참조하세요.</p>
<h4 id="profilenamepackagename"><a class="header" href="#profilenamepackagename"><code>[profile.&lt;name&gt;.package.&lt;name&gt;]</code></a></h4>
<ul>
<li>환경 변수: 지원되지 않음</li>
</ul>
<p>package 테이블은 특정 패키지에 대한 설정을 재정의합니다. <code>panic</code>, <code>lto</code>, <code>rpath</code> 설정을 제외하고 일반 프로파일과 동일한 키를 가집니다. 자세한 내용은 <a href="reference/profiles.html#overrides">재정의 섹션</a> 을 참조하세요.</p>
<h4 id="profilenamecodegen-units"><a class="header" href="#profilenamecodegen-units"><code>profile.&lt;name&gt;.codegen-units</code></a></h4>
<ul>
<li>타입: 정수</li>
<li>기본값: 프로파일 문서 참조</li>
<li>환경 변수: <code>CARGO_PROFILE_&lt;name&gt;_CODEGEN_UNITS</code></li>
</ul>
<p><a href="reference/profiles.html#codegen-units">codegen-units</a> 를 참조하세요.</p>
<h4 id="profilenamedebug"><a class="header" href="#profilenamedebug"><code>profile.&lt;name&gt;.debug</code></a></h4>
<ul>
<li>타입: 정수 또는 불리언</li>
<li>기본값: 프로파일 문서 참조</li>
<li>환경 변수: <code>CARGO_PROFILE_&lt;name&gt;_DEBUG</code></li>
</ul>
<p><a href="reference/profiles.html#debug">debug</a> 를 참조하세요.</p>
<h4 id="profilenamesplit-debuginfo"><a class="header" href="#profilenamesplit-debuginfo"><code>profile.&lt;name&gt;.split-debuginfo</code></a></h4>
<ul>
<li>타입: 문자열</li>
<li>기본값: 프로파일 문서 참조</li>
<li>환경 변수: <code>CARGO_PROFILE_&lt;name&gt;_SPLIT_DEBUGINFO</code></li>
</ul>
<p><a href="reference/profiles.html#split-debuginfo">split-debuginfo</a> 를 참조하세요.</p>
<h4 id="profilenamedebug-assertions"><a class="header" href="#profilenamedebug-assertions"><code>profile.&lt;name&gt;.debug-assertions</code></a></h4>
<ul>
<li>타입: 불리언</li>
<li>기본값: 프로파일 문서 참조</li>
<li>환경 변수: <code>CARGO_PROFILE_&lt;name&gt;_DEBUG_ASSERTIONS</code></li>
</ul>
<p><a href="reference/profiles.html#debug-assertions">debug-assertions</a> 를 참조하세요.</p>
<h4 id="profilenameincremental"><a class="header" href="#profilenameincremental"><code>profile.&lt;name&gt;.incremental</code></a></h4>
<ul>
<li>타입: 불리언</li>
<li>기본값: 프로파일 문서 참조</li>
<li>환경 변수: <code>CARGO_PROFILE_&lt;name&gt;_INCREMENTAL</code></li>
</ul>
<p><a href="reference/profiles.html#incremental">incremental</a> 를 참조하세요.</p>
<h4 id="profilenamelto"><a class="header" href="#profilenamelto"><code>profile.&lt;name&gt;.lto</code></a></h4>
<ul>
<li>타입: 문자열 또는 불리언</li>
<li>기본값: 프로파일 문서 참조</li>
<li>환경 변수: <code>CARGO_PROFILE_&lt;name&gt;_LTO</code></li>
</ul>
<p><a href="reference/profiles.html#lto">lto</a> 를 참조하세요.</p>
<h4 id="profilenameoverflow-checks"><a class="header" href="#profilenameoverflow-checks"><code>profile.&lt;name&gt;.overflow-checks</code></a></h4>
<ul>
<li>타입: 불리언</li>
<li>기본값: 프로파일 문서 참조</li>
<li>환경 변수: <code>CARGO_PROFILE_&lt;name&gt;_OVERFLOW_CHECKS</code></li>
</ul>
<p><a href="reference/profiles.html#overflow-checks">overflow-checks</a> 를 참조하세요.</p>
<h4 id="profilenameopt-level"><a class="header" href="#profilenameopt-level"><code>profile.&lt;name&gt;.opt-level</code></a></h4>
<ul>
<li>타입: 정수 또는 문자열</li>
<li>기본값: 프로파일 문서 참조</li>
<li>환경 변수: <code>CARGO_PROFILE_&lt;name&gt;_OPT_LEVEL</code></li>
</ul>
<p><a href="reference/profiles.html#opt-level">opt-level</a> 을 참조하세요.</p>
<h4 id="profilenamepanic"><a class="header" href="#profilenamepanic"><code>profile.&lt;name&gt;.panic</code></a></h4>
<ul>
<li>타입: 문자열</li>
<li>기본값: 프로파일 문서 참조</li>
<li>환경 변수: <code>CARGO_PROFILE_&lt;name&gt;_PANIC</code></li>
</ul>
<p><a href="reference/profiles.html#panic">panic</a> 을 참조하세요.</p>
<h4 id="profilenamerpath"><a class="header" href="#profilenamerpath"><code>profile.&lt;name&gt;.rpath</code></a></h4>
<ul>
<li>타입: 불리언</li>
<li>기본값: 프로파일 문서 참조</li>
<li>환경 변수: <code>CARGO_PROFILE_&lt;name&gt;_RPATH</code></li>
</ul>
<p><a href="reference/profiles.html#rpath">rpath</a> 를 참조하세요.</p>
<h4 id="profilenamestrip"><a class="header" href="#profilenamestrip"><code>profile.&lt;name&gt;.strip</code></a></h4>
<ul>
<li>타입: 문자열 또는 불리언</li>
<li>기본값: 프로파일 문서 참조</li>
<li>환경 변수: <code>CARGO_PROFILE_&lt;name&gt;_STRIP</code></li>
</ul>
<p><a href="reference/profiles.html#strip">strip</a> 을 참조하세요.</p>
<h3 id="resolver"><a class="header" href="#resolver"><code>[resolver]</code></a></h3>
<p><code>[resolver]</code> 테이블은 로컬 개발을 위한 <a href="reference/resolver.html">의존성 해결 동작</a> 을 재정의합니다 (예: <code>cargo install</code> 은 제외됨).</p>
<h4 id="resolverincompatible-rust-versions"><a class="header" href="#resolverincompatible-rust-versions"><code>resolver.incompatible-rust-versions</code></a></h4>
<ul>
<li>타입: 문자열</li>
<li>기본값: <a href="reference/resolver.html#resolver-versions"><code>resolver</code></a> 문서 참조</li>
<li>환경 변수: <code>CARGO_RESOLVER_INCOMPATIBLE_RUST_VERSIONS</code></li>
</ul>
<p>어떤 버전의 의존성을 사용할지 해결할 때, <code>package.rust-version</code> 이 호환되지 않는 버전을 어떻게 처리할지 선택합니다. 가능한 값은 다음과 같습니다.</p>
<ul>
<li><code>allow</code>: <code>rust-version</code> 이 호환되지 않는 버전을 다른 버전과 동일하게 취급합니다.</li>
<li><code>fallback</code>: 일치하는 다른 버전이 없는 경우에만 <code>rust-version</code> 이 호환되지 않는 버전을 고려합니다.</li>
</ul>
<p>다음과 같은 방법으로 재정의할 수 있습니다.</p>
<ul>
<li><code>--ignore-rust-version</code> CLI 옵션 사용</li>
<li>의존성의 버전 요구 사항을 호환되는 <code>rust-version</code> 을 가진 어떤 버전보다 높게 설정하기</li>
<li><code>cargo update</code> 시 <code>--precise</code> 로 특정 버전을 명시하기</li>
</ul>
<p>자세한 내용은 <a href="reference/resolver.html#rust-version">리졸버(resolver)</a> 장을 참조하세요.</p>
<blockquote>
<p><strong>MSRV:</strong></p>
<ul>
<li><code>allow</code> 는 모든 버전에서 지원됩니다.</li>
<li><code>fallback</code> 은 1.84 버전부터 적용됩니다.</li>
</ul>
</blockquote>
<h3 id="registries"><a class="header" href="#registries"><code>[registries]</code></a></h3>
<p><code>[registries]</code> 테이블은 추가적인 <a href="reference/registries.html">레지스트리</a> 를 지정하는 데 사용됩니다. 명명된 각 레지스트리에 대한 하위 테이블로 구성됩니다.</p>
<h4 id="registriesnameindex"><a class="header" href="#registriesnameindex"><code>registries.&lt;name&gt;.index</code></a></h4>
<ul>
<li>타입: 문자열 (URL)</li>
<li>기본값: 없음</li>
<li>환경 변수: <code>CARGO_REGISTRIES_&lt;name&gt;_INDEX</code></li>
</ul>
<p>레지스트리의 인덱스 URL을 지정합니다.</p>
<h4 id="registriesnametoken"><a class="header" href="#registriesnametoken"><code>registries.&lt;name&gt;.token</code></a></h4>
<ul>
<li>타입: 문자열</li>
<li>기본값: 없음</li>
<li>환경 변수: <code>CARGO_REGISTRIES_&lt;name&gt;_TOKEN</code></li>
</ul>
<p>지정된 레지스트리에 대한 인증 토큰을 지정합니다. 이 값은 <a href="reference/config.html#credentials">자격 증명(#credentials)</a> 파일에만 나타나야 합니다. 이는 인증이 필요한 <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> 와 같은 레지스트리 명령어에 사용됩니다.</p>
<p><code>--token</code> 명령줄 옵션으로 재정의할 수 있습니다.</p>
<h4 id="registriesnamecredential-provider"><a class="header" href="#registriesnamecredential-provider"><code>registries.&lt;name&gt;.credential-provider</code></a></h4>
<ul>
<li>타입: 문자열 또는 경로와 인수의 배열</li>
<li>기본값: 없음</li>
<li>환경 변수: <code>CARGO_REGISTRIES_&lt;name&gt;_CREDENTIAL_PROVIDER</code></li>
</ul>
<p>지정된 레지스트리에 대한 자격 증명 제공자를 지정합니다. 설정하지 않으면 <a href="reference/config.html#registryglobal-credential-providers"><code>registry.global-credential-providers</code></a> 에 있는 제공자들이 사용됩니다.</p>
<p>문자열로 지정된 경우 경로와 인수는 공백을 기준으로 나뉩니다. 공백이 포함된 경로 또는 인수의 경우 배열을 사용하세요.</p>
<p>값이 <a href="reference/config.html#credential-alias"><code>[credential-alias]</code></a> 테이블에 존재하면 해당 별칭이 사용됩니다.</p>
<p>자세한 내용은 <a href="reference/registry-authentication.html">레지스트리 인증</a> 을 참조하세요.</p>
<h4 id="registriescrates-ioprotocol"><a class="header" href="#registriescrates-ioprotocol"><code>registries.crates-io.protocol</code></a></h4>
<ul>
<li>타입: 문자열</li>
<li>기본값: <code>"sparse"</code></li>
<li>환경 변수: <code>CARGO_REGISTRIES_CRATES_IO_PROTOCOL</code></li>
</ul>
<p>crates.io에 접속할 때 사용할 프로토콜을 지정합니다. 허용되는 값은 <code>git</code> 또는 <code>sparse</code> 입니다.</p>
<p><code>git</code> 을 사용하면 Cargo가 <a href="https://github.com/rust-lang/crates.io-index/">https://github.com/rust-lang/crates.io-index/</a>에서 <a href="https://crates.io/">crates.io</a> 에 게시된 모든 패키지의 전체 인덱스를 복제합니다. 이는 인덱스의 크기 때문에 성능에 영향을 미칠 수 있습니다. <code>sparse</code> 는 <a href="https://index.crates.io/">https://index.crates.io/</a>에서 필요한 것만 다운로드하기 위해 HTTPS를 사용하는 최신 프로토콜입니다. 이는 대부분의 상황에서 새로운 의존성을 해결할 때 상당한 성능 향상을 가져올 수 있습니다.</p>
<p>레지스트리 프로토콜에 대한 자세한 내용은 <a href="reference/registries.html">레지스트리(Registries) 장</a> 에서 확인할 수 있습니다.</p>
<h3 id="registry"><a class="header" href="#registry"><code>[registry]</code></a></h3>
<p><code>[registry]</code> 테이블은 레지스트리가 지정되지 않았을 때 사용되는 기본 레지스트리를 제어합니다.</p>
<h4 id="registryindex"><a class="header" href="#registryindex"><code>registry.index</code></a></h4>
<p>이 값은 더 이상 허용되지 않으며 사용해서는 안 됩니다.</p>
<h4 id="registrydefault"><a class="header" href="#registrydefault"><code>registry.default</code></a></h4>
<ul>
<li>타입: 문자열</li>
<li>기본값: <code>"crates-io"</code></li>
<li>환경 변수: <code>CARGO_REGISTRY_DEFAULT</code></li>
</ul>
<p><a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> 와 같은 레지스트리 명령어에 기본적으로 사용할 레지스트리 이름(<a href="reference/config.html#registries"><code>registries</code> 테이블</a> 에서 정의됨)입니다.</p>
<p><code>--registry</code> 명령줄 옵션으로 재정의할 수 있습니다.</p>
<h4 id="registrycredential-provider"><a class="header" href="#registrycredential-provider"><code>registry.credential-provider</code></a></h4>
<ul>
<li>타입: 문자열 또는 경로와 인수의 배열</li>
<li>기본값: 없음</li>
<li>환경 변수: <code>CARGO_REGISTRY_CREDENTIAL_PROVIDER</code></li>
</ul>
<p><a href="https://crates.io/">crates.io</a> 에 대한 자격 증명 제공자를 지정합니다. 설정하지 않으면 <a href="reference/config.html#registryglobal-credential-providers"><code>registry.global-credential-providers</code></a> 에 있는 제공자들이 사용됩니다.</p>
<p>문자열로 지정된 경우 경로와 인수는 공백을 기준으로 나뉩니다. 공백이 포함된 경로 또는 인수의 경우 배열을 사용하세요.</p>
<p>값이 <code>[credential-alias]</code> 테이블에 존재하면 해당 별칭이 사용됩니다.</p>
<p>자세한 내용은 <a href="reference/registry-authentication.html">레지스트리 인증</a> 을 참조하세요.</p>
<h4 id="registrytoken"><a class="header" href="#registrytoken"><code>registry.token</code></a></h4>
<ul>
<li>타입: 문자열</li>
<li>기본값: 없음</li>
<li>환경 변수: <code>CARGO_REGISTRY_TOKEN</code></li>
</ul>
<p><a href="https://crates.io/">crates.io</a> 에 대한 인증 토큰을 지정합니다. 이 값은 <a href="reference/config.html#credentials">자격 증명(#credentials)</a> 파일에만 나타나야 합니다. 이는 인증이 필요한 <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> 와 같은 레지스트리 명령어에 사용됩니다.</p>
<p><code>--token</code> 명령줄 옵션으로 재정의할 수 있습니다.</p>
<h4 id="registryglobal-credential-providers"><a class="header" href="#registryglobal-credential-providers"><code>registry.global-credential-providers</code></a></h4>
<ul>
<li>타입: 배열</li>
<li>기본값: <code>["cargo:token"]</code></li>
<li>환경 변수: <code>CARGO_REGISTRY_GLOBAL_CREDENTIAL_PROVIDERS</code></li>
</ul>
<p>전역 자격 증명 제공자 목록을 지정합니다. <code>registries.&lt;name&gt;.credential-provider</code> 를 사용하여 특정 레지스트리에 대해 자격 증명 제공자가 설정되지 않은 경우, Cargo는 이 목록에 있는 자격 증명 제공자를 사용합니다. 목록의 뒤쪽에 있는 제공자가 우선순위를 갖습니다.</p>
<p>경로와 인수는 공백을 기준으로 나뉩니다. 경로 또는 인수에 공백이 포함된 경우, 자격 증명 제공자를 <a href="reference/config.html#credential-alias"><code>[credential-alias]</code></a> 테이블에 정의하고 여기에서 그 별칭으로 참조해야 합니다.</p>
<p>자세한 내용은 <a href="reference/registry-authentication.html">레지스트리 인증</a> 을 참조하세요.</p>
<h3 id="source"><a class="header" href="#source"><code>[source]</code></a></h3>
<p><code>[source]</code> 테이블은 사용 가능한 레지스트리 소스를 정의합니다. 자세한 내용은 <a href="reference/source-replacement.html">소스 대체(Source Replacement)</a> 를 참조하세요. 명명된 각 소스에 대한 하위 테이블로 구성됩니다. 하나의 소스는 한 가지 종류(directory, registry, local-registry, 또는 git)만 정의해야 합니다.</p>
<h4 id="sourcenamereplace-with"><a class="header" href="#sourcenamereplace-with"><code>source.&lt;name&gt;.replace-with</code></a></h4>
<ul>
<li>타입: 문자열</li>
<li>기본값: 없음</li>
<li>환경 변수: 지원되지 않음</li>
</ul>
<p>설정된 경우, 이 소스를 지정된 이름의 소스 또는 레지스트리로 대체합니다.</p>
<h4 id="sourcenamedirectory"><a class="header" href="#sourcenamedirectory"><code>source.&lt;name&gt;.directory</code></a></h4>
<ul>
<li>타입: 문자열 (경로)</li>
<li>기본값: 없음</li>
<li>환경 변수: 지원되지 않음</li>
</ul>
<p>디렉토리 소스로 사용할 디렉토리의 경로를 설정합니다.</p>
<h4 id="sourcenameregistry"><a class="header" href="#sourcenameregistry"><code>source.&lt;name&gt;.registry</code></a></h4>
<ul>
<li>타입: 문자열 (URL)</li>
<li>기본값: 없음</li>
<li>환경 변수: 지원되지 않음</li>
</ul>
<p>레지스트리 소스로 사용할 URL을 설정합니다.</p>
<h4 id="sourcenamelocal-registry"><a class="header" href="#sourcenamelocal-registry"><code>source.&lt;name&gt;.local-registry</code></a></h4>
<ul>
<li>타입: 문자열 (경로)</li>
<li>기본값: 없음</li>
<li>환경 변수: 지원되지 않음</li>
</ul>
<p>로컬 레지스트리 소스로 사용할 디렉토리의 경로를 설정합니다.</p>
<h4 id="sourcenamegit"><a class="header" href="#sourcenamegit"><code>source.&lt;name&gt;.git</code></a></h4>
<ul>
<li>타입: 문자열 (URL)</li>
<li>기본값: 없음</li>
<li>환경 변수: 지원되지 않음</li>
</ul>
<p>git 저장소 소스로 사용할 URL을 설정합니다.</p>
<h4 id="sourcenamebranch"><a class="header" href="#sourcenamebranch"><code>source.&lt;name&gt;.branch</code></a></h4>
<ul>
<li>타입: 문자열</li>
<li>기본값: 없음</li>
<li>환경 변수: 지원되지 않음</li>
</ul>
<p>git 저장소에 사용할 브랜치 이름을 설정합니다.</p>
<p><code>branch</code>, <code>tag</code>, <code>rev</code> 중 어느 것도 설정되지 않은 경우 기본값은 <code>master</code> 브랜치입니다.</p>
<h4 id="sourcenametag"><a class="header" href="#sourcenametag"><code>source.&lt;name&gt;.tag</code></a></h4>
<ul>
<li>타입: 문자열</li>
<li>기본값: 없음</li>
<li>환경 변수: 지원되지 않음</li>
</ul>
<p>git 저장소에 사용할 태그 이름을 설정합니다.</p>
<p><code>branch</code>, <code>tag</code>, <code>rev</code> 중 어느 것도 설정되지 않은 경우 기본값은 <code>master</code> 브랜치입니다.</p>
<h4 id="sourcenamerev"><a class="header" href="#sourcenamerev"><code>source.&lt;name&gt;.rev</code></a></h4>
<ul>
<li>타입: 문자열</li>
<li>기본값: 없음</li>
<li>환경 변수: 지원되지 않음</li>
</ul>
<p>git 저장소에 사용할 <a href="https://git-scm.com/docs/gitrevisions">리비전(revision)</a> 을 설정합니다.</p>
<p><code>branch</code>, <code>tag</code>, <code>rev</code> 중 어느 것도 설정되지 않은 경우 기본값은 <code>master</code> 브랜치입니다.</p>
<h3 id="target"><a class="header" href="#target"><code>[target]</code></a></h3>
<p><code>[target]</code> 테이블은 특정 플랫폼 타겟에 대한 설정을 지정하는 데 사용됩니다. 이는 [플랫폼 트리플](../appendix/glossary.md#target “타겟” (용어집)) 또는 <a href="reference/../../reference/conditional-compilation.html"><code>cfg()</code> 식</a> 인 하위 테이블로 구성됩니다. 대상 플랫폼이 <code>&lt;triple&gt;</code> 값이나 <code>&lt;cfg&gt;</code> 식과 일치하면 지정된 값이 사용됩니다.</p>
<pre><code class="language-toml">[target.thumbv7m-none-eabi]
linker = "arm-none-eabi-gcc"
runner = "my-emulator"
rustflags = ["…", "…"]

[target.'cfg(all(target_arch = "arm", target_os = "none"))']
runner = "my-arm-wrapper"
rustflags = ["…", "…"]
</code></pre>
<p><code>cfg</code> 값은 컴파일러에 내장된 값(<code>rustc --print=cfg</code> 명령으로 확인 가능)과 <code>rustc</code> 에 전달된 추가적인 <code>--cfg</code> 플래그(<code>RUSTFLAGS</code> 에 정의된 것 등)에서 가져옵니다. <code>debug_assertions</code>, <code>test</code>, Cargo 기능(예: <code>feature="foo"</code>), 또는 <a href="reference/build-scripts.html">빌드 스크립트</a> 에 의해 설정된 값과 일치시키려 하지 마세요.</p>
<p>타겟 사양 JSON 파일을 사용하는 경우, [<code>&lt;triple&gt;</code>](../appendix/glossary.md#target “타겟” (용어집)) 값은 파일 이름의 몸체(stem)가 됩니다. 예를 들어 <code>--target foo/bar.json</code> 은 <code>[target.bar]</code> 와 일치합니다.</p>
<h4 id="targettriplear"><a class="header" href="#targettriplear"><code>target.&lt;triple&gt;.ar</code></a></h4>
<p>이 옵션은 사용이 중단되었으며 사용되지 않습니다.</p>
<h4 id="targettriplelinker"><a class="header" href="#targettriplelinker"><code>target.&lt;triple&gt;.linker</code></a></h4>
<ul>
<li>타입: 문자열 (프로그램 경로)</li>
<li>기본값: 없음</li>
<li>환경 변수: <code>CARGO_TARGET_&lt;triple&gt;_LINKER</code></li>
</ul>
<p>해당 [<code>&lt;triple&gt;</code>](../appendix/glossary.md#target “타겟” (용어집))용으로 컴파일할 때 <code>rustc</code> 에 (<a href="reference/../../rustc/codegen-options/index.html#linker"><code>-C linker</code></a> 를 통해) 전달될 링커를 지정합니다. 기본적으로 링커는 재정의되지 않습니다.</p>
<h4 id="targetcfglinker"><a class="header" href="#targetcfglinker"><code>target.&lt;cfg&gt;.linker</code></a></h4>
<p>이것은 <a href="reference/config.html#targettriplelinker">타겟 링커</a> 와 유사하지만, <a href="reference/../../reference/conditional-compilation.html"><code>cfg()</code> 식</a> 을 사용합니다. [<code>&lt;triple&gt;</code>](../appendix/glossary.md#target “타겟” (용어집))과 <code>&lt;cfg&gt;</code> 러너가 모두 일치하는 경우 <code>&lt;triple&gt;</code> 이 우선합니다. 현재 타겟과 일치하는 <code>&lt;cfg&gt;</code> 러너가 두 개 이상이면 오류가 발생합니다.</p>
<h4 id="targettriplerunner"><a class="header" href="#targettriplerunner"><code>target.&lt;triple&gt;.runner</code></a></h4>
<ul>
<li>타입: 문자열 또는 문자열 배열 (<a href="reference/config.html#executable-paths-with-arguments">인수가 포함된 프로그램 경로</a>)</li>
<li>기본값: 없음</li>
<li>환경 변수: <code>CARGO_TARGET_&lt;triple&gt;_RUNNER</code></li>
</ul>
<p>러너가 제공된 경우, 해당 타겟 [<code>&lt;triple&gt;</code>](../appendix/glossary.md#target “타겟” (용어집))에 대한 실행 파일은 실제 실행 파일을 인수로 전달하여 지정된 러너를 호출함으로써 실행됩니다. 이는 <a href="reference/../commands/cargo-run.html"><code>cargo run</code></a>, <a href="reference/../commands/cargo-test.html"><code>cargo test</code></a>, <a href="reference/../commands/cargo-bench.html"><code>cargo bench</code></a> 명령어에 적용됩니다. 기본적으로 컴파일된 실행 파일은 직접 실행됩니다.</p>
<h4 id="targetcfgrunner"><a class="header" href="#targetcfgrunner"><code>target.&lt;cfg&gt;.runner</code></a></h4>
<p>이것은 <a href="reference/config.html#targettriplerunner">타겟 러너</a> 와 유사하지만, <a href="reference/../../reference/conditional-compilation.html"><code>cfg()</code> 식</a> 을 사용합니다. [<code>&lt;triple&gt;</code>](../appendix/glossary.md#target “타겟” (용어집))과 <code>&lt;cfg&gt;</code> 러너가 모두 일치하는 경우 <code>&lt;triple&gt;</code> 이 우선합니다. 현재 타겟과 일치하는 <code>&lt;cfg&gt;</code> 러너가 두 개 이상이면 오류가 발생합니다.</p>
<h4 id="targettriplerustflags"><a class="header" href="#targettriplerustflags"><code>target.&lt;triple&gt;.rustflags</code></a></h4>
<ul>
<li>타입: 문자열 또는 문자열 배열</li>
<li>기본값: 없음</li>
<li>Environment: <code>CARGO_TARGET_&lt;triple&gt;_RUSTFLAGS</code></li>
</ul>
<p>이 [<code>&lt;triple&gt;</code>](../appendix/glossary.md#target “타겟” (용어집))에 대해 컴파일러에 전달할 사용자 정의 플래그 세트입니다. 값은 문자열 배열이거나 공백으로 구분된 문자열일 수 있습니다.</p>
<p>추가 플래그를 지정하는 다양한 방법에 대한 자세한 내용은 <a href="reference/config.html#buildrustflags"><code>build.rustflags</code></a> 를 참조하세요.</p>
<h4 id="targetcfgrustflags"><a class="header" href="#targetcfgrustflags"><code>target.&lt;cfg&gt;.rustflags</code></a></h4>
<p>이것은 <a href="reference/config.html#targettriplerustflags">타겟 rustflags</a> 와 유사하지만, <a href="reference/../../reference/conditional-compilation.html"><code>cfg()</code> 식</a> 을 사용합니다. 여러 <code>&lt;cfg&gt;</code> 및 [<code>&lt;triple&gt;</code>](../appendix/glossary.md#target “타겟” (용어집)) 항목이 현재 타겟과 일치하면 플래그들이 하나로 결합됩니다.</p>
<h4 id="targettriplerustdocflags"><a class="header" href="#targettriplerustdocflags"><code>target.&lt;triple&gt;.rustdocflags</code></a></h4>
<ul>
<li>타입: 문자열 또는 문자열 배열</li>
<li>기본값: 없음</li>
<li>환경 변수: <code>CARGO_TARGET_&lt;triple&gt;_RUSTDOCFLAGS</code></li>
</ul>
<p>이 [<code>&lt;triple&gt;</code>](../appendix/glossary.md#target “타겟” (용어집))에 대해 컴파일러에 전달할 사용자 정의 플래그 세트입니다. 값은 문자열 배열이거나 공백으로 구분된 문자열일 수 있습니다.</p>
<p>추가 플래그를 지정하는 다양한 방법에 대한 자세한 내용은 <a href="reference/config.html#buildrustdocflags"><code>build.rustdocflags</code></a> 를 참조하세요.</p>
<h4 id="targettriplelinks"><a class="header" href="#targettriplelinks"><code>target.&lt;triple&gt;.&lt;links&gt;</code></a></h4>
<p>links 하위 테이블은 <a href="reference/build-scripts.html#overriding-build-scripts">빌드 스크립트를 재정의</a> 하는 방법을 제공합니다. 이를 지정하면 해당 <code>links</code> 라이브러리에 대한 빌드 스크립트가 실행되지 않으며, 대신 지정된 값들이 사용됩니다.</p>
<pre><code class="language-toml">[target.x86_64-unknown-linux-gnu.foo]
rustc-link-lib = ["foo"]
rustc-link-search = ["/path/to/foo"]
rustc-flags = "-L /some/path"
rustc-cfg = ['key="value"']
rustc-env = {key = "value"}
rustc-cdylib-link-arg = ["…"]
metadata_key1 = "value"
metadata_key2 = "value"
</code></pre>
<h3 id="term"><a class="header" href="#term"><code>[term]</code></a></h3>
<p><code>[term]</code> 테이블은 터미널 출력 및 상호 작용을 제어합니다.</p>
<h4 id="termquiet"><a class="header" href="#termquiet"><code>term.quiet</code></a></h4>
<ul>
<li>타입: 불리언</li>
<li>기본값: false</li>
<li>환경 변수: <code>CARGO_TERM_QUIET</code></li>
</ul>
<p>Cargo가 로그 메시지를 표시할지 여부를 제어합니다.</p>
<p><code>--quiet</code> 플래그를 지정하면 설정을 재정의하여 강제로 출력을 하지 않게 됩니다. <code>--verbose</code> 플래그를 지정하면 설정을 재정의하여 출력을 하지 않는 기능을 비활성화합니다.</p>
<h4 id="termverbose"><a class="header" href="#termverbose"><code>term.verbose</code></a></h4>
<ul>
<li>타입: 불리언</li>
<li>기본값: false</li>
<li>환경 변수: <code>CARGO_TERM_VERBOSE</code></li>
</ul>
<p>Cargo가 추가적인 상세 메시지를 표시할지 여부를 제어합니다.</p>
<p><code>--quiet</code> 플래그를 지정하면 설정을 재정의하여 상세 출력을 비활성화합니다. <code>--verbose</code> 플래그를 지정하면 설정을 재정의하여 상세 출력을 강제합니다.</p>
<h4 id="termcolor"><a class="header" href="#termcolor"><code>term.color</code></a></h4>
<ul>
<li>타입: 문자열</li>
<li>기본값: <code>"auto"</code></li>
<li>환경 변수: <code>CARGO_TERM_COLOR</code></li>
</ul>
<p>터미널에서 색상 출력을 사용할지 여부를 제어합니다. 가능한 값은 다음과 같습니다.</p>
<ul>
<li><code>auto</code> (기본값): 터미널의 색상 지원 여부를 자동으로 감지합니다.</li>
<li><code>always</code>: 항상 색상을 표시합니다.</li>
<li><code>never</code>: 색상을 절대 표시하지 않습니다.</li>
</ul>
<p><code>--color</code> 명령줄 옵션으로 재정의할 수 있습니다.</p>
<h4 id="termhyperlinks"><a class="header" href="#termhyperlinks"><code>term.hyperlinks</code></a></h4>
<ul>
<li>타입: 불리언</li>
<li>기본값: 자동 감지</li>
<li>환경 변수: <code>CARGO_TERM_HYPERLINKS</code></li>
</ul>
<p>터미널에서 하이퍼링크를 사용할지 여부를 제어합니다.</p>
<h4 id="termunicode"><a class="header" href="#termunicode"><code>term.unicode</code></a></h4>
<ul>
<li>타입: 불리언</li>
<li>기본값: 자동 감지</li>
<li>환경 변수: <code>CARGO_TERM_UNICODE</code></li>
</ul>
<p>ASCII가 아닌 유니코드 문자를 사용하여 출력을 렌더링할 수 있는지 여부를 제어합니다.</p>
<h4 id="termprogresswhen"><a class="header" href="#termprogresswhen"><code>term.progress.when</code></a></h4>
<ul>
<li>타입: 문자열</li>
<li>기본값: <code>"auto"</code></li>
<li>환경 변수: <code>CARGO_TERM_PROGRESS_WHEN</code></li>
</ul>
<p>터미널에 진행률 표시줄을 표시할지 여부를 제어합니다. 가능한 값은 다음과 같습니다.</p>
<ul>
<li><code>auto</code> (기본값): 진행률 표시줄을 표시할지 여부를 지능적으로 판단합니다.</li>
<li><code>always</code>: 항상 진행률 표시줄을 표시합니다.</li>
<li><code>never</code>: 진행률 표시줄을 절대 표시하지 않습니다.</li>
</ul>
<h4 id="termprogresswidth"><a class="header" href="#termprogresswidth"><code>term.progress.width</code></a></h4>
<ul>
<li>타입: 정수</li>
<li>기본값: 없음</li>
<li>환경 변수: <code>CARGO_TERM_PROGRESS_WIDTH</code></li>
</ul>
<p>진행률 표시줄의 너비를 설정합니다.</p>
<h4 id="termprogressterm-integration"><a class="header" href="#termprogressterm-integration"><code>term.progress.term-integration</code></a></h4>
<ul>
<li>타입: 불리언</li>
<li>기본값: 자동 감지</li>
<li>Environment: <code>CARGO_TERM_PROGRESS_TERM_INTEGRATION</code></li>
</ul>
<p>Report progress to the terminal emulator for display in places like the task bar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="환경-변수-1"><a class="header" href="#환경-변수-1">환경 변수</a></h1>
<p>Cargo는 사용자의 코드가 감지하거나 재정의할 수 있는 여러 환경 변수를 설정하고 읽습니다. 다음은 Cargo가 설정하는 변수 목록이며, 상호 작용 시점에 따라 정리되어 있습니다.</p>
<h2 id="cargo가-읽는-환경-변수"><a class="header" href="#cargo가-읽는-환경-변수">Cargo가 읽는 환경 변수</a></h2>
<p>시스템에서 Cargo의 동작을 변경하기 위해 다음 환경 변수들을 재정의할 수 있습니다.</p>
<ul>
<li><code>CARGO_LOG</code> — Cargo는 디버그 로그 메시지를 표시하기 위해 <a href="https://docs.rs/tracing"><code>tracing</code></a> 크레이트를 사용합니다. <code>CARGO_LOG</code> 환경 변수를 <code>trace</code>, <code>debug</code>, <code>warn</code> 과 같은 값으로 설정하여 디버그 로깅을 활성화할 수 있습니다. 일반적으로 디버깅 중에만 사용됩니다. 자세한 내용은 <a href="https://doc.crates.io/contrib/implementation/debugging.html#logging">디버그 로깅(Debug logging)</a> 을 참조하세요.</li>
<li><code>CARGO_HOME</code> — Cargo는 레지스트리 인덱스와 크레이트의 git 체크아웃에 대한 로컬 캐시를 유지합니다. 기본적으로 <code>$HOME/.cargo</code>(윈도우의 경우 <code>%USERPROFILE%\.cargo</code>)에 저장되지만, 이 변수를 통해 해당 디렉토리의 위치를 재정의할 수 있습니다. 한 번 캐시된 크레이트는 clean 명령어로 제거되지 않습니다. 자세한 내용은 <a href="reference/../guide/cargo-home.html">가이드</a> 를 참조하세요.</li>
<li><code>CARGO_TARGET_DIR</code> — 생성된 모든 결과물을 배치할 위치로, 현재 작업 디렉토리에 대한 상대 경로입니다. 설정을 통해 지정하려면 <a href="reference/config.html#buildtarget-dir"><code>build.target-dir</code></a> 을 참조하세요.</li>
<li><code>CARGO</code> — 이 변수가 설정되면, Cargo는 크레이트를 빌드하거나 빌드 스크립트 및 외부 하위 명령어를 실행할 때 자동으로 감지된 자체 경로 대신 이 값을 전달합니다. 이 값은 Cargo에 의해 직접 실행되지 않으며, 사용자가 기대하는 대로 항상 <code>cargo</code> 와 똑같이 동작하는 명령을 가리켜야 합니다.</li>
<li><code>RUSTC</code> — Cargo는 <code>rustc</code> 를 직접 실행하는 대신 이 변수에 지정된 컴파일러를 실행합니다. 설정을 통해 지정하려면 <a href="reference/config.html#buildrustc"><code>build.rustc</code></a> 를 참조하세요.</li>
<li><code>RUSTC_WRAPPER</code> — Cargo는 단순히 <code>rustc</code> 를 실행하는 대신 이 변수에 지정된 래퍼를 실행합니다. 이때 rustc 호출 명령이 명령줄 인수로 전달되며, 첫 번째 인수는 실제 rustc의 경로가 됩니다. <code>sccache</code> 와 같은 빌드 캐시 도구를 설정할 때 유용합니다. 설정을 통해 지정하려면 <a href="reference/config.html#buildrustc-wrapper"><code>build.rustc-wrapper</code></a> 를 참조하세요. 이 값을 빈 문자열로 설정하면 설정을 덮어쓰고 래퍼를 사용하지 않도록 초기화합니다.</li>
<li><code>RUSTC_WORKSPACE_WRAPPER</code> — Cargo는 단순히 <code>rustc</code> 를 실행하는 대신, 워크스페이스 구성원에 대해 이 변수에 지정된 래퍼를 실행합니다. 이때 rustc 호출 명령이 명령줄 인수로 전달되며, 첫 번째 인수는 실제 rustc의 경로가 됩니다. 워크스페이스가 없는 단일 패키지 프로젝트를 빌드할 때 해당 패키지는 워크스페이스로 간주됩니다. 이는 파일 이름 해시에 영향을 주어 래퍼에 의해 생성된 결과물이 별도로 캐시되도록 합니다. 설정을 통해 지정하려면 <a href="reference/config.html#buildrustc-workspace-wrapper"><code>build.rustc-workspace-wrapper</code></a> 를 참조하세요. 이 값을 빈 문자열로 설정하면 설정을 덮어쓰고 워크스페이스 구성원에 대해 래퍼를 사용하지 않도록 초기화합니다. <code>RUSTC_WRAPPER</code> 와 <code>RUSTC_WORKSPACE_WRAPPER</code> 가 모두 설정된 경우 중첩됩니다. 최종 호출은 <code>$RUSTC_WRAPPER $RUSTC_WORKSPACE_WRAPPER $RUSTC</code> 가 됩니다.</li>
<li><code>RUSTDOC</code> — Cargo는 <code>rustdoc</code> 을 실행하는 대신 이 변수에 지정된 <code>rustdoc</code> 인스턴스를 실행합니다. 설정을 통해 지정하려면 <a href="reference/config.html#buildrustdoc"><code>build.rustdoc</code></a> 을 참조하세요.</li>
<li><code>RUSTDOCFLAGS</code> — Cargo가 수행하는 모든 <code>rustdoc</code> 호출에 전달할 공백으로 구분된 사용자 정의 플래그 목록입니다. <a href="reference/../commands/cargo-rustdoc.html"><code>cargo rustdoc</code></a> 과 달리, 이는 <em>모든</em> <code>rustdoc</code> 인스턴스에 플래그를 전달할 때 유용합니다. 플래그를 설정하는 다른 방법은 <a href="reference/config.html#buildrustdocflags"><code>build.rustdocflags</code></a> 를 참조하세요. 이 문자열은 공백으로 나뉩니다. 여러 인수를 더 안정적으로 인코딩하려면 <code>CARGO_ENCODED_RUSTDOCFLAGS</code> 를 참조하세요.</li>
<li><code>CARGO_ENCODED_RUSTDOCFLAGS</code> — Cargo가 수행하는 모든 <code>rustdoc</code> 호출에 전달할 <code>0x1f</code>(ASCII Unit Separator)로 구분된 사용자 정의 플래그 목록입니다.</li>
<li><code>RUSTFLAGS</code> — Cargo가 수행하는 모든 컴파일러 호출에 전달할 공백으로 구분된 사용자 정의 플래그 목록입니다. <a href="reference/../commands/cargo-rustc.html"><code>cargo rustc</code></a> 와 달리, 이는 <em>모든</em> 컴파일러 인스턴스에 플래그를 전달할 때 유용합니다. 플래그를 설정하는 다른 방법은 <a href="reference/config.html#buildrustflags"><code>build.rustflags</code></a> 를 참조하세요. 이 문자열은 공백으로 나뉩니다. 여러 인수를 더 안정적으로 인코딩하려면 <code>CARGO_ENCODED_RUSTFLAGS</code> 를 참조하세요.</li>
<li><code>CARGO_ENCODED_RUSTFLAGS</code> — Cargo가 수행하는 모든 컴파일러 호출에 전달할 <code>0x1f</code>(ASCII Unit Separator)로 구분된 사용자 정의 플래그 목록입니다.</li>
<li><code>CARGO_INCREMENTAL</code> — 이 값이 1로 설정되면 Cargo는 현재 컴파일에 대해 <a href="reference/profiles.html#incremental">증분 컴파일(incremental compilation)</a> 을 강제로 활성화하고, 0으로 설정되면 강제로 비활성화합니다. 이 환경 변수가 없으면 Cargo의 기본값이 사용됩니다. <a href="reference/config.html#buildincremental"><code>build.incremental</code></a> 설정 값도 참조하세요.</li>
<li><code>CARGO_CACHE_RUSTC_INFO</code> — 이 값이 0으로 설정되면 Cargo는 컴파일러 버전 정보 캐싱을 시도하지 않습니다.</li>
<li><code>HTTPS_PROXY</code> 또는 <code>https_proxy</code> 또는 <code>http_proxy</code> — 사용할 HTTP 프록시입니다. 자세한 내용은 <a href="reference/config.html#httpproxy"><code>http.proxy</code></a> 를 참조하세요.</li>
<li><code>HTTP_TIMEOUT</code> — HTTP 타임아웃(초 단위)입니다. 자세한 내용은 <a href="reference/config.html#httptimeout"><code>http.timeout</code></a> 을 참조하세요.</li>
<li><code>TERM</code> — 이 값이 <code>dumb</code> 로 설정되면 진행률 표시줄이 비활성화됩니다.</li>
<li><code>BROWSER</code> — The web browser to execute to open documentation with <a href="reference/../commands/cargo-doc.html"><code>cargo doc</code></a>’s <code>--open</code> flag, see <a href="reference/config.html#docbrowser"><code>doc.browser</code></a> for more details.</li>
<li><code>RUSTFMT</code> — <a href="https://github.com/rust-lang/rustfmt"><code>cargo fmt</code></a> 은 <code>rustfmt</code> 을 직접 실행하는 대신 이 변수에 지정된 <code>rustfmt</code> 인스턴스를 실행합니다.</li>
</ul>
<h3 id="설정-관련-환경-변수"><a class="header" href="#설정-관련-환경-변수">설정 관련 환경 변수</a></h3>
<p>Cargo는 일부 설정 값을 환경 변수에서 읽습니다. 자세한 내용은 <a href="reference/config.html#environment-variables">설정(Configuration) 장</a> 을 참조하세요. 요약하자면, 지원되는 환경 변수는 다음과 같습니다.</p>
<ul>
<li><code>CARGO_ALIAS_&lt;이름&gt;</code> — 명령 별칭. <a href="reference/config.html#alias"><code>alias</code></a> 를 참조하세요.</li>
<li><code>CARGO_BUILD_JOBS</code> — 병렬 작업 수. <a href="reference/config.html#buildjobs"><code>build.jobs</code></a> 를 참조하세요.</li>
<li><code>CARGO_BUILD_RUSTC</code> — <code>rustc</code> 실행 파일. <a href="reference/config.html#buildrustc"><code>build.rustc</code></a> 를 참조하세요.</li>
<li><code>CARGO_BUILD_RUSTC_WRAPPER</code> — <code>rustc</code> 래퍼. <a href="reference/config.html#buildrustc-wrapper"><code>build.rustc-wrapper</code></a> 를 참조하세요.</li>
<li><code>CARGO_BUILD_RUSTC_WORKSPACE_WRAPPER</code> — 워크스페이스 구성원 전용 <code>rustc</code> 래퍼. <a href="reference/config.html#buildrustc-workspace-wrapper"><code>build.rustc-workspace-wrapper</code></a> 를 참조하세요.</li>
<li><code>CARGO_BUILD_RUSTDOC</code> — <code>rustdoc</code> 실행 파일. <a href="reference/config.html#buildrustdoc"><code>build.rustdoc</code></a> 를 참조하세요.</li>
<li><code>CARGO_BUILD_TARGET</code> — 기본 타겟 플랫폼. <a href="reference/config.html#buildtarget"><code>build.target</code></a> 를 참조하세요.</li>
<li><code>CARGO_BUILD_TARGET_DIR</code> — 기본 출력 디렉토리. <a href="reference/config.html#buildtarget-dir"><code>build.target-dir</code></a> 를 참조하세요.</li>
<li><code>CARGO_BUILD_BUILD_DIR</code> — The default build directory, see <a href="reference/config.html#buildbuild-dir"><code>build.build-dir</code></a>.</li>
<li><code>CARGO_BUILD_RUSTFLAGS</code> — 추가 <code>rustc</code> 플래그. <a href="reference/config.html#buildrustflags"><code>build.rustflags</code></a> 를 참조하세요.</li>
<li><code>CARGO_BUILD_RUSTDOCFLAGS</code> — 추가 <code>rustdoc</code> 플래그. <a href="reference/config.html#buildrustdocflags"><code>build.rustdocflags</code></a> 를 참조하세요.</li>
<li><code>CARGO_BUILD_INCREMENTAL</code> — 증분 컴파일. <a href="reference/config.html#buildincremental"><code>build.incremental</code></a> 를 참조하세요.</li>
<li><code>CARGO_BUILD_DEP_INFO_BASEDIR</code> — 의존성 정보 상대 디렉토리. <a href="reference/config.html#builddep-info-basedir"><code>build.dep-info-basedir</code></a> 를 참조하세요.</li>
<li><code>CARGO_CACHE_AUTO_CLEAN_FREQUENCY</code> — Configures how often automatic cache cleaning runs, see <a href="reference/config.html#cacheauto-clean-frequency"><code>cache.auto-clean-frequency</code></a>.</li>
<li><code>CARGO_CARGO_NEW_VCS</code> — <a href="reference/../commands/cargo-new.html"><code>cargo new</code></a> 사용 시 기본 소스 제어 시스템. <a href="reference/config.html#cargo-newvcs"><code>cargo-new.vcs</code></a> 를 참조하세요.</li>
<li><code>CARGO_FUTURE_INCOMPAT_REPORT_FREQUENCY</code> — 미래 비호환성 보고서 알림 생성 빈도. <a href="reference/config.html#future-incompat-reportfrequency"><code>future-incompat-report.frequency</code></a> 를 참조하세요.</li>
<li><code>CARGO_HTTP_DEBUG</code> — HTTP 디버깅 활성화. <a href="reference/config.html#httpdebug"><code>http.debug</code></a> 를 참조하세요.</li>
<li><code>CARGO_HTTP_PROXY</code> — HTTP 프록시 활성화. <a href="reference/config.html#httpproxy"><code>http.proxy</code></a> 를 참조하세요.</li>
<li><code>CARGO_HTTP_TIMEOUT</code> — HTTP 타임아웃. <a href="reference/config.html#httptimeout"><code>http.timeout</code></a> 을 참조하세요.</li>
<li><code>CARGO_HTTP_CAINFO</code> — TLS 인증서 인증 기관(CA) 파일. <a href="reference/config.html#httpcainfo"><code>http.cainfo</code></a> 를 참조하세요.</li>
<li><code>CARGO_HTTP_PROXY_CAINFO</code> — The proxy TLS certificate Certificate Authority file, see <a href="reference/config.html#httpproxy-cainfo"><code>http.proxy-cainfo</code></a>.</li>
<li><code>CARGO_HTTP_CHECK_REVOKE</code> — TLS 인증서 폐기 확인 비활성화. <a href="reference/config.html#httpcheck-revoke"><code>http.check-revoke</code></a> 를 참조하세요.</li>
<li><code>CARGO_HTTP_SSL_VERSION</code> — 사용할 TLS 버전. <a href="reference/config.html#httpssl-version"><code>http.ssl-version</code></a> 을 참조하세요.</li>
<li><code>CARGO_HTTP_LOW_SPEED_LIMIT</code> — HTTP 최저 속도 제한. <a href="reference/config.html#httplow-speed-limit"><code>http.low-speed-limit</code></a> 을 참조하세요.</li>
<li><code>CARGO_HTTP_MULTIPLEXING</code> — HTTP/2 멀티플렉싱 사용 여부. <a href="reference/config.html#httpmultiplexing"><code>http.multiplexing</code></a> 을 참조하세요.</li>
<li><code>CARGO_HTTP_USER_AGENT</code> — HTTP user-agent 헤더. <a href="reference/config.html#httpuser-agent"><code>http.user-agent</code></a> 를 참조하세요.</li>
<li><code>CARGO_INSTALL_ROOT</code> — <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> 의 기본 디렉토리. <a href="reference/config.html#installroot"><code>install.root</code></a> 를 참조하세요.</li>
<li><code>CARGO_NET_RETRY</code> — 네트워크 오류 발생 시 재시도 횟수. <a href="reference/config.html#netretry"><code>net.retry</code></a> 를 참조하세요.</li>
<li><code>CARGO_NET_GIT_FETCH_WITH_CLI</code> — 가져오기를 위해 <code>git</code> 실행 파일 사용 활성화. <a href="reference/config.html#netgit-fetch-with-cli"><code>net.git-fetch-with-cli</code></a> 를 참조하세요.</li>
<li><code>CARGO_NET_OFFLINE</code> — 오프라인 모드. <a href="reference/config.html#netoffline"><code>net.offline</code></a> 을 참조하세요.</li>
<li><code>CARGO_PROFILE_&lt;이름&gt;_BUILD_OVERRIDE_&lt;키&gt;</code> — 빌드 스크립트 프로파일 재정의. <a href="reference/config.html#profilenamebuild-override"><code>profile.&lt;name&gt;.build-override</code></a> 를 참조하세요.</li>
<li><code>CARGO_PROFILE_&lt;이름&gt;_CODEGEN_UNITS</code> — 코드 생성 단위 설정. <a href="reference/config.html#profilenamecodegen-units"><code>profile.&lt;name&gt;.codegen-units</code></a> 를 참조하세요.</li>
<li><code>CARGO_PROFILE_&lt;이름&gt;_DEBUG</code> — 포함할 디버그 정보 종류. <a href="reference/config.html#profilenamedebug"><code>profile.&lt;name&gt;.debug</code></a> 를 참조하세요.</li>
<li><code>CARGO_PROFILE_&lt;이름&gt;_DEBUG_ASSERTIONS</code> — 디버그 어설션 활성화/비활성화. <a href="reference/config.html#profilenamedebug-assertions"><code>profile.&lt;name&gt;.debug-assertions</code></a> 를 참조하세요.</li>
<li><code>CARGO_PROFILE_&lt;이름&gt;_INCREMENTAL</code> — 증분 컴파일 활성화/비활성화. <a href="reference/config.html#profilenameincremental"><code>profile.&lt;name&gt;.incremental</code></a> 를 참조하세요.</li>
<li><code>CARGO_PROFILE_&lt;이름&gt;_LTO</code> — 링크 타임 최적화(LTO). <a href="reference/config.html#profilenamelto"><code>profile.&lt;name&gt;.lto</code></a> 를 참조하세요.</li>
<li><code>CARGO_PROFILE_&lt;이름&gt;_OVERFLOW_CHECKS</code> — 오버플로 검사 활성화/비활성화. <a href="reference/config.html#profilenameoverflow-checks"><code>profile.&lt;name&gt;.overflow-checks</code></a> 를 참조하세요.</li>
<li><code>CARGO_PROFILE_&lt;이름&gt;_OPT_LEVEL</code> — 최적화 레벨 설정. <a href="reference/config.html#profilenameopt-level"><code>profile.&lt;name&gt;.opt-level</code></a> 를 참조하세요.</li>
<li><code>CARGO_PROFILE_&lt;이름&gt;_PANIC</code> — 사용할 패닉 전략. <a href="reference/config.html#profilenamepanic"><code>profile.&lt;name&gt;.panic</code></a> 을 참조하세요.</li>
<li><code>CARGO_PROFILE_&lt;이름&gt;_RPATH</code> — rpath 링크 옵션. <a href="reference/config.html#profilenamerpath"><code>profile.&lt;name&gt;.rpath</code></a> 를 참조하세요.</li>
<li><code>CARGO_PROFILE_&lt;이름&gt;_SPLIT_DEBUGINFO</code> — 디버그 파일 출력 동작 제어. <a href="reference/config.html#profilenamesplit-debuginfo"><code>profile.&lt;name&gt;.split-debuginfo</code></a> 를 참조하세요.</li>
<li><code>CARGO_PROFILE_&lt;이름&gt;_STRIP</code> — 심볼 및 디버그 정보 제거 제어. <a href="reference/config.html#profilenamestrip"><code>profile.&lt;name&gt;.strip</code></a> 을 참조하세요.</li>
<li><code>CARGO_REGISTRIES_&lt;이름&gt;_CREDENTIAL_PROVIDER</code> — 레지스트리용 자격 증명 제공자. <a href="reference/config.html#registriesnamecredential-provider"><code>registries.&lt;name&gt;.credential-provider</code></a> 를 참조하세요.</li>
<li><code>CARGO_REGISTRIES_&lt;이름&gt;_INDEX</code> — 레지스트리 인덱스 URL. <a href="reference/config.html#registriesnameindex"><code>registries.&lt;name&gt;.index</code></a> 를 참조하세요.</li>
<li><code>CARGO_REGISTRIES_&lt;이름&gt;_TOKEN</code> — 레지스트리 인증 토큰. <a href="reference/config.html#registriesnametoken"><code>registries.&lt;name&gt;.token</code></a> 을 참조하세요.</li>
<li><code>CARGO_REGISTRY_CREDENTIAL_PROVIDER</code> — <a href="https://crates.io/">crates.io</a> 용 자격 증명 제공자. <a href="reference/config.html#registrycredential-provider"><code>registry.credential-provider</code></a> 를 참조하세요.</li>
<li><code>CARGO_REGISTRY_DEFAULT</code> — <code>--registry</code> 플래그의 기본 레지스트리. <a href="reference/config.html#registrydefault"><code>registry.default</code></a> 를 참조하세요.</li>
<li><code>CARGO_REGISTRY_GLOBAL_CREDENTIAL_PROVIDERS</code> — 특정 제공자가 정의되지 않은 레지스트리들을 위한 자격 증명 제공자 목록. <a href="reference/config.html#registryglobal-credential-providers"><code>registry.global-credential-providers</code></a> 를 참조하세요.</li>
<li><code>CARGO_REGISTRY_TOKEN</code> — <a href="https://crates.io/">crates.io</a> 용 인증 토큰. <a href="reference/config.html#registrytoken"><code>registry.token</code></a> 을 참조하세요.</li>
<li><code>CARGO_TARGET_&lt;triple&gt;_LINKER</code> — 사용할 링커. <a href="reference/config.html#targettriplelinker"><code>target.&lt;triple&gt;.linker</code></a> 를 참조하세요. 트리플(triple)은 <a href="reference/config.html#environment-variables">대문자와 밑줄로 변환</a> 되어야 합니다.</li>
<li><code>CARGO_TARGET_&lt;triple&gt;_RUNNER</code> — 실행 파일 러너. <a href="reference/config.html#targettriplerunner"><code>target.&lt;triple&gt;.runner</code></a> 를 참조하세요.</li>
<li><code>CARGO_TARGET_&lt;triple&gt;_RUSTFLAGS</code> — 타겟용 추가 <code>rustc</code> 플래그. <a href="reference/config.html#targettriplerustflags"><code>target.&lt;triple&gt;.rustflags</code></a> 를 참조하세요.</li>
<li><code>CARGO_TERM_QUIET</code> — 저소음(quiet) 모드. <a href="reference/config.html#termquiet"><code>term.quiet</code></a> 를 참조하세요.</li>
<li><code>CARGO_TERM_VERBOSE</code> — 기본 터미널 상세 수준. <a href="reference/config.html#termverbose"><code>term.verbose</code></a> 를 참조하세요.</li>
<li><code>CARGO_TERM_COLOR</code> — 기본 색상 모드. <a href="reference/config.html#termcolor"><code>term.color</code></a> 를 참조하세요.</li>
<li><code>CARGO_TERM_PROGRESS_WHEN</code> — 기본 진행률 표시줄 모드. <a href="reference/config.html#termprogresswhen"><code>term.progress.when</code></a> 을 참조하세요.</li>
<li><code>CARGO_TERM_PROGRESS_WIDTH</code> — 기본 진행률 표시줄 너비. <a href="reference/config.html#termprogresswidth"><code>term.progress.width</code></a> 를 참조하세요.</li>
</ul>
<h2 id="cargo가-크레이트를-위해-설정하는-환경-변수"><a class="header" href="#cargo가-크레이트를-위해-설정하는-환경-변수">Cargo가 크레이트를 위해 설정하는 환경 변수</a></h2>
<p>Cargo는 크레이트 컴파일 시 다음과 같은 환경 변수들을 노출합니다. 이는 <code>cargo run</code> 및 <code>cargo test</code> 로 바이너리를 실행할 때도 적용됩니다. Rust 프로그램에서 이러한 변수 값을 가져오려면 다음과 같이 하세요.</p>
<pre><code class="language-rust ignore">let version = env!("CARGO_PKG_VERSION");</code></pre>
<p>이제 <code>version</code> 변수에 <code>CARGO_PKG_VERSION</code> 의 값이 포함됩니다.</p>
<p>매니페스트에 이러한 값 중 하나가 제공되지 않으면, 해당 환경 변수는 빈 문자열(<code>""</code>)로 설정됩니다.</p>
<ul>
<li><code>CARGO</code> — 빌드를 수행하는 <code>cargo</code> 바이너리의 경로입니다.</li>
<li><code>CARGO_MANIFEST_DIR</code> — 패키지의 매니페스트 파일이 들어있는 디렉토리입니다.</li>
<li><code>CARGO_MANIFEST_PATH</code> — 패키지의 매니페스트 파일 경로입니다.</li>
<li><code>CARGO_PKG_VERSION</code> — 패키지의 전체 버전입니다.</li>
<li><code>CARGO_PKG_VERSION_MAJOR</code> — 패키지의 메이저(major) 버전입니다.</li>
<li><code>CARGO_PKG_VERSION_MINOR</code> — 패키지의 마이너(minor) 버전입니다.</li>
<li><code>CARGO_PKG_VERSION_PATCH</code> — 패키지의 패치(patch) 버전입니다.</li>
<li><code>CARGO_PKG_VERSION_PRE</code> — 패키지의 프리릴리스(pre-release) 버전입니다.</li>
<li><code>CARGO_PKG_AUTHORS</code> — 패키지 매니페스트에 기재된 저자 목록(콜론으로 구분됨)입니다.</li>
<li><code>CARGO_PKG_NAME</code> — 패키지의 이름입니다.</li>
<li><code>CARGO_PKG_DESCRIPTION</code> — 패키지 매니페스트에 기재된 설명입니다.</li>
<li><code>CARGO_PKG_HOMEPAGE</code> — 패키지 매니페스트에 기재된 홈페이지 주소입니다.</li>
<li><code>CARGO_PKG_REPOSITORY</code> — 패키지 매니페스트에 기재된 저장소(repository) 주소입니다.</li>
<li><code>CARGO_PKG_LICENSE</code> — 패키지 매니페스트에 기재된 라이선스입니다.</li>
<li><code>CARGO_PKG_LICENSE_FILE</code> — 패키지 매니페스트에 기재된 라이선스 파일 경로입니다.</li>
<li><code>CARGO_PKG_RUST_VERSION</code> — 패키지 매니페스트에 기재된 Rust 버전입니다. 이는 현재 실행 중인 Rust 버전이 아니라 패키지가 지원하는 최소 Rust 버전임에 유의하세요.</li>
<li><code>CARGO_PKG_README</code> — 패키지의 README 파일 경로입니다.</li>
<li><code>CARGO_CRATE_NAME</code> — 현재 컴파일 중인 크레이트의 이름입니다. 라이브러리, 바이너리, 예제, 통합 테스트 또는 벤치마크와 같은 <a href="reference/cargo-targets.html">Cargo 타겟</a> 의 이름에서 <code>-</code> 가 <code>_</code> 로 변환된 형태입니다.</li>
<li><code>CARGO_BIN_NAME</code> — 현재 컴파일 중인 바이너리의 이름입니다. <a href="reference/cargo-targets.html#binaries">바이너리</a> 또는 바이너리 <a href="reference/cargo-targets.html#examples">예제</a> 에 대해서만 설정됩니다. 이 이름에는 <code>.exe</code> 와 같은 파일 확장자가 포함되지 않습니다.</li>
<li><code>OUT_DIR</code> — If the package has a build script, this is set to the folder where the build script should place its output. See below for more information. (Only set during compilation.) Cargo does not guarantee that this directory is empty, and it is not cleaned between builds.</li>
<li><code>CARGO_BIN_EXE_&lt;name&gt;</code> — 바이너리 타겟 실행 파일의 절대 경로입니다. 이는 오직 <a href="reference/cargo-targets.html#integration-tests">통합 테스트</a> 또는 벤치마크를 빌드할 때만 설정됩니다. 테스트 목적으로 실행할 파일을 찾기 위해 <a href="reference/../../std/macro.env.html"><code>env</code> 매크로</a> 와 함께 사용될 수 있습니다. <code>&lt;name&gt;</code> 은 바이너리 타겟의 이름 그대로를 사용합니다. 예를 들어 이름이 <code>my-program</code> 인 바이너리의 경우 <code>CARGO_BIN_EXE_my-program</code> 이 됩니다. 테스트 빌드 시 바이너리도 자동으로 빌드되지만, 바이너리에 필요한 기능이 활성화되지 않은 경우는 제외됩니다.</li>
<li><code>CARGO_PRIMARY_PACKAGE</code> — 빌드 중인 패키지가 ’주요 패키지(primary package)’인 경우 이 환경 변수가 설정됩니다. 주요 패키지란 사용자가 <code>-p</code> 플래그로 명령줄에서 선택했거나, 현재 디렉토리 및 기본 워크스페이스 구성원을 바탕으로 기본 선택된 패키지를 의미합니다. 의존성을 빌드할 때는 이 변수가 설정되지 않지만, 해당 의존성이 명령줄에서 함께 선택된 워크스페이스 구성원인 경우는 예외입니다. 이는 패키지 컴파일 시에만 설정됩니다 (바이너리나 테스트 실행 시에는 설정되지 않음).</li>
<li><code>CARGO_TARGET_TMPDIR</code> — 오직 <a href="reference/cargo-targets.html#integration-tests">통합 테스트</a> 또는 벤치마크 코드를 빌드할 때만 설정됩니다. 이는 타겟 디렉토리 내부의 경로로, 통합 테스트나 벤치마크에서 필요한 데이터를 자유롭게 보관할 수 있는 공간입니다. Cargo는 처음에 이 디렉토리를 생성만 할 뿐 그 내용을 관리하지는 않으며, 관리 책임은 테스트 코드에 있습니다.</li>
</ul>
<h3 id="동적-라이브러리-경로"><a class="header" href="#동적-라이브러리-경로">동적 라이브러리 경로</a></h3>
<p>Cargo는 <code>cargo run</code> 이나 <code>cargo test</code> 와 같은 명령으로 바이너리를 컴파일하고 실행할 때 동적 라이브러리 경로를 설정합니다. 이는 빌드 프로세스의 일부인 공유 라이브러리를 찾는 데 도움이 됩니다. 변수 이름은 플랫폼에 따라 다릅니다.</p>
<ul>
<li>Windows: <code>PATH</code></li>
<li>macOS: <code>DYLD_FALLBACK_LIBRARY_PATH</code></li>
<li>Unix: <code>LD_LIBRARY_PATH</code></li>
<li>AIX: <code>LIBPATH</code></li>
</ul>
<p>값은 Cargo가 시작될 때 기존 값에 덧붙여집니다. macOS의 경우 <code>DYLD_FALLBACK_LIBRARY_PATH</code> 가 설정되어 있지 않으면 기본값인 <code>$HOME/lib:/usr/local/lib:/usr/lib</code> 가 추가되는 특수한 처리가 있습니다.</p>
<p>Cargo는 다음 경로들을 포함합니다.</p>
<ul>
<li>빌드 스크립트에서 <a href="reference/build-scripts.html#rustc-link-search"><code>rustc-link-search</code> 지시문</a> 을 통해 포함된 검색 경로들입니다. <code>target</code> 디렉토리 외부의 경로는 제거됩니다. 시스템상의 추가 라이브러리가 검색 경로에 필요한 경우 환경을 적절히 설정하는 것은 Cargo를 실행하는 사용자의 책임입니다.</li>
<li><code>target/debug</code> 와 같은 기본 출력 디렉토리 및 “deps” 디렉토리입니다. 이는 주로 절차적 매크로를 지원하기 위함입니다.</li>
<li>rustc sysroot 라이브러리 경로입니다. 이는 일반적으로 대부분의 사용자에게 중요하지 않습니다.</li>
</ul>
<h2 id="cargo가-빌드-스크립트를-위해-설정하는-환경-변수"><a class="header" href="#cargo가-빌드-스크립트를-위해-설정하는-환경-변수">Cargo가 빌드 스크립트를 위해 설정하는 환경 변수</a></h2>
<p>Cargo는 빌드 스크립트가 실행될 때 여러 환경 변수를 설정합니다. 이 변수들은 빌드 스크립트가 컴파일될 때는 아직 설정되지 않으므로, 앞서 본 <code>env!</code> 를 사용하는 예제는 작동하지 않습니다. 대신 빌드 스크립트가 실행될 때 값을 가져와야 합니다.</p>
<pre><code class="language-rust ignore">use std::env;
let out_dir = env::var("OUT_DIR").unwrap();</code></pre>
<p>이제 <code>out_dir</code> 변수에 <code>OUT_DIR</code> 의 값이 포함됩니다.</p>
<ul>
<li>
<p><code>CARGO</code> — 빌드를 수행하는 <code>cargo</code> 바이너리의 경로입니다.</p>
</li>
<li>
<p><code>CARGO_MANIFEST_DIR</code> — 빌드 중인 패키지(빌드 스크립트를 포함하는 패키지)의 매니페스트가 있는 디렉토리입니다. 또한 이는 빌드 스크립트가 시작될 때의 현재 작업 디렉토리 값이기도 합니다.</p>
</li>
<li>
<p><code>CARGO_MANIFEST_PATH</code> — 패키지의 매니페스트 파일 경로입니다.</p>
</li>
<li>
<p><code>CARGO_MANIFEST_LINKS</code> — 매니페스트의 <code>links</code> 값입니다.</p>
</li>
<li>
<p><code>CARGO_MAKEFLAGS</code> — 하위 프로세스를 병렬화하기 위한 Cargo의 <a href="https://www.gnu.org/software/make/manual/html_node/Job-Slots.html">jobserver</a> 구현에 필요한 매개변수를 포함합니다. build.rs에서 실행되는 rustc 또는 cargo 호출은 이미 <code>CARGO_MAKEFLAGS</code> 를 읽을 수 있지만, GNU Make는 플래그를 인수로 직접 지정하거나 <code>MAKEFLAGS</code> 환경 변수를 통해 지정해야 합니다. 현재 Cargo는 <code>MAKEFLAGS</code> 변수를 직접 설정하지 않지만, GNU Make를 호출하는 빌드 스크립트에서 이 변수를 <code>CARGO_MAKEFLAGS</code> 의 내용으로 자유롭게 설정할 수 있습니다.</p>
</li>
<li>
<p><code>CARGO_FEATURE_&lt;이름&gt;</code> — 빌드 중인 패키지의 각 활성화된 기능에 대해 이 환경 변수가 생성됩니다. 여기서 <code>&lt;이름&gt;</code> 은 기능 이름을 대문자로 바꾸고 <code>-</code> 를 <code>_</code> 로 변환한 것입니다.</p>
</li>
<li>
<p><code>CARGO_CFG_&lt;cfg&gt;</code> — 빌드 중인 패키지의 각 <a href="reference/../../reference/conditional-compilation.html">설정 옵션</a> 에 대해, 이 환경 변수는 해당 설정 값을 포함합니다. 여기서 <code>&lt;cfg&gt;</code> 는 설정 이름을 대문자로 바꾸고 <code>-</code> 를 <code>_</code> 로 변환한 것입니다. 불리언 설정은 설정된 경우에만 존재합니다. 여러 값을 갖는 설정은 <code>,</code> 로 구분되어 하나의 변수로 결합됩니다. 여기에는 컴파일러에 내장된 값(<code>rustc --print=cfg</code> 로 확인 가능), 빌드 스크립트에 의해 설정된 값, 그리고 <code>rustc</code> 에 전달된 추가 플래그(<code>RUSTFLAGS</code> 등)가 포함됩니다. 몇 가지 예시는 다음과 같습니다.</p>
<ul>
<li><code>CARGO_CFG_FEATURE</code> — 빌드 중인 패키지의 각 활성화된 기능입니다.</li>
<li><code>CARGO_CFG_UNIX</code> — <a href="reference/../../reference/conditional-compilation.html#unix-and-windows">유닉스 계열 플랫폼</a> 에서 설정됩니다.</li>
<li><code>CARGO_CFG_WINDOWS</code> — <a href="reference/../../reference/conditional-compilation.html#unix-and-windows">윈도우 계열 플랫폼</a> 에서 설정됩니다.</li>
<li><code>CARGO_CFG_TARGET_FAMILY=unix,wasm</code> — <a href="reference/../../reference/conditional-compilation.html#target_family">타겟 패밀리(target family)</a> 입니다.</li>
<li><code>CARGO_CFG_TARGET_OS=macos</code> — <a href="reference/../../reference/conditional-compilation.html#target_os">타겟 운영체제</a> 입니다.</li>
<li><code>CARGO_CFG_TARGET_ARCH=x86_64</code> — CPU <a href="reference/../../reference/conditional-compilation.html#target_arch">타겟 아키텍처</a> 입니다.</li>
<li><code>CARGO_CFG_TARGET_VENDOR=apple</code> — <a href="reference/../../reference/conditional-compilation.html#target_vendor">타겟 벤더</a> 입니다.</li>
<li><code>CARGO_CFG_TARGET_ENV=gnu</code> — <a href="reference/../../reference/conditional-compilation.html#target_env">타겟 환경</a> ABI입니다.</li>
<li><code>CARGO_CFG_TARGET_ABI=eabihf</code> — The <a href="reference/../../reference/conditional-compilation.html#target_abi">target ABI</a>.</li>
<li><code>CARGO_CFG_TARGET_POINTER_WIDTH=64</code> — CPU <a href="reference/../../reference/conditional-compilation.html#target_pointer_width">포인터 너비</a> 입니다.</li>
<li><code>CARGO_CFG_TARGET_ENDIAN=little</code> — CPU <a href="reference/../../reference/conditional-compilation.html#target_endian">타겟 엔디언(endianness)</a> 입니다.</li>
<li><code>CARGO_CFG_TARGET_FEATURE=mmx,sse</code> — 활성화된 CPU <a href="reference/../../reference/conditional-compilation.html#target_feature">타겟 기능</a> 목록입니다.</li>
</ul>
<blockquote>
<p><a href="reference/../appendix/glossary.html#target">타겟 트리플</a> 마다 서로 다른 <code>cfg</code> 값 세트를 가지므로, 특정 타겟 트리플에 존재하는 변수가 다른 트리플에서는 사용 불가능할 수도 있습니다.</p>
<p>Some cfg values like <code>test</code> are not available.</p>
</blockquote>
</li>
<li>
<p><code>OUT_DIR</code> — the folder in which all output and intermediate artifacts should be placed. This folder is inside the build directory for the package being built, and it is unique for the package in question. Cargo does not clean or reset this directory between builds, and its contents may persist across rebuilds. Build scripts should not assume that <code>OUT_DIR</code> is empty, and are responsible for managing or cleaning up any files they create.</p>
</li>
<li>
<p><code>TARGET</code> — 컴파일 대상인 타겟 트리플입니다. 네이티브 코드는 이 트리플에 맞춰 컴파일되어야 합니다. 자세한 내용은 <a href="reference/../appendix/glossary.html#target">타겟 트리플</a> 설명을 참조하세요.</p>
</li>
<li>
<p><code>HOST</code> — Rust 컴파일러의 호스트 트리플입니다.</p>
</li>
<li>
<p><code>NUM_JOBS</code> — 최상위 수준에서 지정된 병렬 처리 수준입니다. 이는 <code>make</code> 와 같은 시스템에 <code>-j</code> 매개변수를 전달할 때 유용할 수 있습니다. 다만, 이 환경 변수를 해석할 때는 주의가 필요합니다. 역사적인 이유로 여전히 제공되지만, 최신 버전의 Cargo는 <code>make -j</code> 를 실행할 필요가 없으며, 대신 <code>MAKEFLAGS</code> 환경 변수를 <code>CARGO_MAKEFLAGS</code> 내용으로 설정하여 하위 make 호출에 대해 Cargo의 GNU Make 호환 <a href="https://www.gnu.org/software/make/manual/html_node/Job-Slots.html">jobserver</a> 를 활성화할 수 있습니다.</p>
</li>
<li>
<p><code>DEBUG</code> — <code>true</code> if any <a href="reference/profiles.html#debug"><code>debug</code></a> information will be generated and <code>false</code> otherwise.</p>
</li>
<li>
<p><code>OPT_LEVEL</code> — values of the corresponding <a href="reference/profiles.html#opt-level"><code>opt-level</code></a> variable for the profile currently being built.</p>
</li>
<li>
<p><code>PROFILE</code> — 릴리스 빌드의 경우 <code>release</code>, 그 외 빌드의 경우 <code>debug</code> 입니다. 이는 <a href="reference/profiles.html">프로파일</a> 이 <a href="reference/profiles.html#dev"><code>dev</code></a> 를 상속하는지 <a href="reference/profiles.html#release"><code>release</code></a> 를 상속하는지에 따라 결정됩니다. 이 환경 변수를 사용하는 것은 권장되지 않습니다. <code>OPT_LEVEL</code> 과 같은 다른 환경 변수를 사용하는 것이 실제 사용 중인 설정에 대한 더 정확한 정보를 제공합니다.</p>
</li>
<li>
<p><code>DEP_&lt;links&gt;_&lt;key&gt;</code> — For more information about this set of environment variables, see build script documentation about <a href="reference/build-scripts.html#the-links-manifest-key"><code>links</code></a>.</p>
</li>
<li>
<p><code>RUSTC</code>, <code>RUSTDOC</code> — Cargo가 사용하기로 결정한 컴파일러 및 문서 생성기입니다. 빌드 스크립트에서도 사용할 수 있도록 전달됩니다.</p>
</li>
<li>
<p><code>RUSTC_WRAPPER</code> — Cargo가 사용 중인 <code>rustc</code> 래퍼(있는 경우)입니다. <a href="reference/config.html#buildrustc-wrapper"><code>build.rustc-wrapper</code></a> 를 참조하세요.</p>
</li>
<li>
<p><code>RUSTC_WORKSPACE_WRAPPER</code> — Cargo가 워크스페이스 구성원을 위해 사용 중인 <code>rustc</code> 래퍼(있는 경우)입니다. <a href="reference/config.html#buildrustc-workspace-wrapper"><code>build.rustc-workspace-wrapper</code></a> 를 참조하세요.</p>
</li>
<li>
<p><code>RUSTC_LINKER</code> — (지정된 경우) 현재 타겟에 대해 Cargo가 사용하기로 결정한 링커 바이너리의 경로입니다. 링커는 <code>.cargo/config.toml</code> 을 편집하여 변경할 수 있습니다. 자세한 내용은 <a href="reference/config.html">Cargo 설정(Configuration)</a> 문서를 참조하세요.</p>
</li>
<li>
<p><code>CARGO_ENCODED_RUSTFLAGS</code> — Cargo가 <code>rustc</code> 를 호출할 때 사용하는 추가 플래그들로, <code>0x1f</code>(ASCII Unit Separator) 문자로 구분됩니다. <a href="reference/config.html#buildrustflags"><code>build.rustflags</code></a> 를 참조하세요. Rust 1.55부터 <code>RUSTFLAGS</code> 는 환경 변수에서 제거되었으므로, 스크립트에서는 대신 <code>CARGO_ENCODED_RUSTFLAGS</code> 를 사용해야 합니다.</p>
</li>
<li>
<p><code>CARGO_PKG_&lt;변수&gt;</code> — 패키지 정보 변수들로, <a href="reference/environment-variables.html#environment-variables-cargo-sets-for-crates">크레이트 빌드 시 제공되는 것들</a> 과 이름 및 값이 동일합니다.</p>
</li>
</ul>
<h2 id="environment-variables-cargo-sets-for-cargo-test"><a class="header" href="#environment-variables-cargo-sets-for-cargo-test">Environment variables Cargo sets for <code>cargo test</code></a></h2>
<p>Cargo sets several environment variables when tests are run. You can retrieve the values when the tests are run:</p>
<pre><code class="language-rust ignore">use std::env;
let out_dir = env::var("CARGO_BIN_EXE_foo").unwrap();</code></pre>
<ul>
<li><code>CARGO_BIN_EXE_&lt;name&gt;</code> — The absolute path to a binary target’s executable. This is only set when running an <a href="reference/cargo-targets.html#integration-tests">integration test</a> or benchmark. The <code>&lt;name&gt;</code> is the name of the binary target, exactly as-is. For example, <code>CARGO_BIN_EXE_my-program</code> for a binary named <code>my-program</code>. Binaries are automatically built when the test is built, unless the binary has required features that are not enabled.</li>
</ul>
<h2 id="cargo가-제3자-하위-명령어를-위해-설정하는-환경-변수"><a class="header" href="#cargo가-제3자-하위-명령어를-위해-설정하는-환경-변수">Cargo가 제3자 하위 명령어를 위해 설정하는 환경 변수</a></h2>
<p>Cargo는 제3자 하위 명령어(즉, <code>$PATH</code> 에 있는 <code>cargo-foobar</code> 와 같은 이름의 프로그램)에 다음과 같은 환경 변수를 노출합니다.</p>
<ul>
<li><code>CARGO</code> — 빌드를 수행하는 <code>cargo</code> 바이너리의 경로입니다.</li>
<li><code>CARGO_MAKEFLAGS</code> — 하위 프로세스를 병렬화하기 위한 Cargo의 <a href="https://www.gnu.org/software/make/manual/html_node/Job-Slots.html">jobserver</a> 구현에 필요한 매개변수를 포함합니다. 이 변수는 Cargo가 jobserver의 존재를 감지했을 때만 설정됩니다.</li>
</ul>
<p>환경에 대한 더 자세한 정보를 얻으려면 <code>cargo metadata</code> 를 실행해 보세요.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="빌드-스크립트-1"><a class="header" href="#빌드-스크립트-1">빌드 스크립트</a></h1>
<p>일부 패키지는 C 라이브러리와 같은 제3자 비 Rust 코드를 컴파일해야 할 필요가 있습니다. 어떤 패키지는 시스템에 있거나 소스에서 직접 빌드해야 하는 C 라이브러리에 링크해야 할 수도 있습니다. 또 어떤 패키지는 빌드 전 코드 생성(예: 파서 생성기)과 같은 기능이 필요할 수 있습니다.</p>
<p>Cargo의 목표는 이러한 작업에 최적화된 다른 도구들을 대체하는 것이 아니라, 사용자 정의 빌드 스크립트를 통해 해당 도구들과 통합하는 것입니다. 패키지 루트에 <code>build.rs</code> 라는 이름의 파일을 두면, Cargo는 해당 스크립트를 컴파일하고 패키지를 빌드하기 직전에 이를 실행합니다.</p>
<pre><code class="language-rust ignore">// 사용자 정의 빌드 스크립트 예제
fn main() {
    // 지정된 파일이 변경되면 이 빌드 스크립트를 다시 실행하도록 Cargo에 알립니다.
    println!("cargo::rerun-if-changed=src/hello.c");
    // `cc` 크레이트를 사용하여 C 파일을 빌드하고 정적으로 링크합니다.
    cc::Build::new()
        .file("src/hello.c")
        .compile("hello");
}</code></pre>
<p>빌드 스크립트의 몇 가지 사용 예는 다음과 같습니다.</p>
<ul>
<li>번들된 C 라이브러리 빌드.</li>
<li>호스트 시스템에서 C 라이브러리 찾기.</li>
<li>명세(specification)로부터 Rust 모듈 생성.</li>
<li>크레이트에 필요한 플랫폼별 설정 수행.</li>
</ul>
<p>아래 섹션들에서는 빌드 스크립트의 작동 방식을 설명하며, <a href="reference/build-script-examples.html">예제 장</a> 에서는 스크립트 작성 방법에 대한 다양한 예제를 보여줍니다.</p>
<blockquote>
<p>참고: <a href="reference/manifest.html#the-build-field"><code>package.build</code> 매니페스트 키</a> 를 사용하여 빌드 스크립트의 이름을 변경하거나 완전히 비활성화할 수 있습니다.</p>
</blockquote>
<h2 id="빌드-스크립트의-생명-주기"><a class="header" href="#빌드-스크립트의-생명-주기">빌드 스크립트의 생명 주기</a></h2>
<p>패키지가 빌드되기 직전에 Cargo는 빌드 스크립트를 실행 파일로 컴파일합니다 (이미 빌드되어 있지 않은 경우). 그 후 스크립트를 실행하며, 스크립트는 임의의 작업을 수행할 수 있습니다. 스크립트는 <code>cargo::</code> 접두사가 붙은 특수한 형식의 명령을 표준 출력(stdout)으로 출력하여 Cargo와 통신할 수 있습니다.</p>
<p>빌드 스크립트의 소스 파일이나 의존성이 변경되면 빌드 스크립트가 다시 빌드됩니다.</p>
<p>기본적으로 Cargo는 패키지의 파일 중 하나라도 변경되면 빌드 스크립트를 다시 실행합니다. 일반적으로 아래의 <a href="reference/build-scripts.html#change-detection">변경 감지(#change-detection)</a> 섹션에 설명된 <code>rerun-if</code> 명령을 사용하여 빌드 스크립트 재실행을 트리거하는 대상을 좁히는 것이 가장 좋습니다.</p>
<p>빌드 스크립트가 성공적으로 실행을 마치면 패키지의 나머지 부분이 컴파일됩니다. 오류가 발생한 경우 스크립트는 0이 아닌 종료 코드를 반환하여 빌드를 중단해야 하며, 이 경우 빌드 스크립트의 출력이 터미널에 표시됩니다.</p>
<h2 id="빌드-스크립트의-입력"><a class="header" href="#빌드-스크립트의-입력">빌드 스크립트의 입력</a></h2>
<p>빌드 스크립트가 실행될 때 여러 입력이 제공되며, 이들은 모두 <a href="reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">환경 변수</a> 형태로 전달됩니다.</p>
<p>환경 변수 외에도, 빌드 스크립트의 현재 디렉토리는 해당 빌드 스크립트가 속한 패키지의 소스 디렉토리입니다.</p>
<h2 id="빌드-스크립트의-출력"><a class="header" href="#빌드-스크립트의-출력">빌드 스크립트의 출력</a></h2>
<p>빌드 스크립트는 모든 결과물 파일이나 중간 산출물을 <a href="reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts"><code>OUT_DIR</code> 환경 변수</a> 에 지정된 디렉토리에 저장할 수 있습니다. 스크립트는 해당 디렉토리 외부의 어떤 파일도 수정해서는 안 됩니다.</p>
<blockquote>
<p><strong>Note:</strong> Cargo does not clean or reset <code>OUT_DIR</code> between builds. The contents of this directory may persist across rebuilds, even if the build script is re-run. This behavior is intentional to support incremental builds, such as native code compilation.</p>
<p>Build scripts should not rely on <code>OUT_DIR</code> being empty, as its contents may persist across rebuilds. If a script requires a clean directory, it is currently responsible for managing or cleaning up any files or subdirectories it creates. Future improvements in this area are being discussed (see <a href="https://github.com/rust-lang/cargo/issues/16427">#16427</a> and <a href="https://github.com/rust-lang/cargo/issues/9661">#9661</a>).</p>
</blockquote>
<p>빌드 스크립트는 표준 출력(stdout)에 내용을 인쇄하여 Cargo와 통신합니다. Cargo는 <code>cargo::</code> 로 시작하는 각 줄을 패키지 컴파일에 영향을 주는 지시문으로 해석합니다. 그 외의 모든 줄은 무시됩니다.</p>
<blockquote>
<p>빌드 스크립트에서 출력되는 <code>cargo::</code> 지시문의 순서는 <code>cargo</code> 가 <code>rustc</code> 에 전달하는 인수의 순서에 영향을 줄 <em>수도</em> 있습니다. 결과적으로 <code>rustc</code> 에 전달되는 인수의 순서는 링커에 전달되는 인수의 순서에 영향을 줄 수 있습니다. 따라서 빌드 스크립트 지시문의 순서에 주의를 기울여야 합니다. 예를 들어, 객체 <code>foo</code> 가 라이브러리 <code>bar</code> 에 링크되어야 한다면, 라이브러리 <code>bar</code> 를 위한 <a href="reference/build-scripts.html#rustc-link-lib"><code>cargo::rustc-link-lib</code></a> 지시문이 객체 <code>foo</code> 를 링크하는 지시문 <em>뒤</em> 에 나타나도록 해야 할 수도 있습니다.</p>
</blockquote>
<p>스크립트의 출력은 일반적인 컴파일 도중에는 터미널에 표시되지 않습니다. 터미널에서 출력을 직접 보고 싶다면 <code>-vv</code> 플래그를 사용하여 Cargo를 “매우 상세(very verbose)” 모드로 실행하세요. 이는 빌드 스크립트가 실제로 실행될 때만 발생합니다. Cargo가 변경 사항이 없다고 판단하여 스크립트를 다시 실행하지 않는 경우에는 출력되지 않습니다. 자세한 내용은 아래의 <a href="reference/build-scripts.html#change-detection">변경 감지(#change-detection)</a> 를 참조하세요.</p>
<p>빌드 스크립트가 표준 출력으로 내보낸 모든 줄은 <code>target/debug/build/&lt;pkg&gt;/output</code> 과 같은 파일에 기록됩니다 (정확한 위치는 설정에 따라 다를 수 있습니다). 표준 에러(stderr) 출력도 같은 디렉토리에 저장됩니다.</p>
<p>다음은 Cargo가 인식하는 지시문들의 요약이며, 각 지시문에 대한 자세한 설명은 아래에 나와 있습니다.</p>
<ul>
<li>
<p><a href="reference/build-scripts.html#rerun-if-changed"><code>cargo::rerun-if-changed=PATH</code></a> — 언제 스크립트를 다시 실행할지 Cargo에 알립니다.</p>
</li>
<li>
<p><a href="reference/build-scripts.html#rerun-if-env-changed"><code>cargo::rerun-if-env-changed=VAR</code></a> — 언제 스크립트를 다시 실행할지 Cargo에 알립니다.</p>
</li>
<li>
<p><a href="reference/build-scripts.html#rustc-link-arg"><code>cargo::rustc-link-arg=FLAG</code></a> — 벤치마크, 바이너리, <code>cdylib</code> 크레이트, 예제 및 테스트를 위해 링커에 사용자 정의 플래그를 전달합니다.</p>
</li>
<li>
<p><a href="reference/build-scripts.html#rustc-cdylib-link-arg"><code>cargo::rustc-link-arg-cdylib=FLAG</code></a> — Passes custom flags to a linker for cdylib crates.</p>
</li>
<li>
<p><a href="reference/build-scripts.html#rustc-link-arg-bin"><code>cargo::rustc-link-arg-bin=BIN=FLAG</code></a> — 바이너리 <code>BIN</code> 을 위해 링커에 사용자 정의 플래그를 전달합니다.</p>
</li>
<li>
<p><a href="reference/build-scripts.html#rustc-link-arg-bins"><code>cargo::rustc-link-arg-bins=FLAG</code></a> — 바이너리들을 위해 링커에 사용자 정의 플래그를 전달합니다.</p>
</li>
<li>
<p><a href="reference/build-scripts.html#rustc-link-arg-tests"><code>cargo::rustc-link-arg-tests=FLAG</code></a> — 테스트들을 위해 링커에 사용자 정의 플래그를 전달합니다.</p>
</li>
<li>
<p><a href="reference/build-scripts.html#rustc-link-arg-examples"><code>cargo::rustc-link-arg-examples=FLAG</code></a> — 예제들을 위해 링커에 사용자 정의 플래그를 전달합니다.</p>
</li>
<li>
<p><a href="reference/build-scripts.html#rustc-link-arg-benches"><code>cargo::rustc-link-arg-benches=FLAG</code></a> — 벤치마크들을 위해 링커에 사용자 정의 플래그를 전달합니다.</p>
</li>
<li>
<p><a href="reference/build-scripts.html#rustc-link-lib"><code>cargo::rustc-link-lib=LIB</code></a> — 링크할 라이브러리를 추가합니다.</p>
</li>
<li>
<p><a href="reference/build-scripts.html#rustc-link-search"><code>cargo::rustc-link-search=[KIND=]PATH</code></a> — 라이브러리 검색 경로를 추가합니다.</p>
</li>
<li>
<p><a href="reference/build-scripts.html#rustc-flags"><code>cargo::rustc-flags=FLAGS</code></a> — 컴파일러에 특정 플래그를 전달합니다.</p>
</li>
<li>
<p><a href="reference/build-scripts.html#rustc-cfg"><code>cargo::rustc-cfg=KEY[="VALUE"]</code></a> — 컴파일 타임 <code>cfg</code> 설정을 활성화합니다.</p>
</li>
<li>
<p><a href="reference/build-scripts.html#rustc-check-cfg"><code>cargo::rustc-check-cfg=CHECK_CFG</code></a> – 컴파일 타임 설정 확인을 위해 예상되는 사용자 정의 <code>cfg</code> 들을 등록합니다.</p>
</li>
<li>
<p><a href="reference/build-scripts.html#rustc-env"><code>cargo::rustc-env=VAR=VALUE</code></a> — 환경 변수를 설정합니다.</p>
</li>
<li>
<p><a href="reference/build-scripts.html#cargo-error"><code>cargo::error=MESSAGE</code></a> — 터미널에 오류 메시지를 표시합니다.</p>
</li>
<li>
<p><a href="reference/build-scripts.html#cargo-warning"><code>cargo::warning=MESSAGE</code></a> — 터미널에 경고 메시지를 표시합니다.</p>
</li>
<li>
<p><a href="reference/build-scripts.html#the-links-manifest-key"><code>cargo::metadata=KEY=VALUE</code></a> — <code>links</code> 스크립트에서 사용되는 메타데이터입니다.</p>
</li>
</ul>
<blockquote>
<p><strong>MSRV:</strong> <code>cargo::KEY=VALUE</code> 구문에는 1.77 버전이 필요합니다. 이전 버전을 지원하려면 <code>cargo:KEY=VALUE</code> 구문을 사용하세요.</p>
</blockquote>
<h3 id="rustc-link-arg"><a class="header" href="#rustc-link-arg"><code>cargo::rustc-link-arg=FLAG</code></a></h3>
<p><code>rustc-link-arg</code> 지시문은 지원되는 타겟(벤치마크, 바이너리, <code>cdylib</code> 크레이트, 예제 및 테스트)을 빌드할 때만 컴파일러에 <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> 옵션</a> 을 전달하도록 Cargo에 알립니다. 이 지시문의 사용은 플랫폼에 따라 매우 다르며, 공유 라이브러리 버전이나 링커 스크립트를 설정할 때 유용합니다.</p>
<h3 id="rustc-cdylib-link-arg"><a class="header" href="#rustc-cdylib-link-arg"><code>cargo::rustc-link-arg-cdylib=FLAG</code></a></h3>
<p>The <code>rustc-link-arg-cdylib</code> instruction tells Cargo to pass the <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> option</a> to the compiler, but only when building a <code>cdylib</code> library target. Its usage is highly platform specific. It is useful to set the shared library version or the runtime-path.</p>
<p>For historical reasons, the <code>cargo::rustc-cdylib-link-arg</code> form is an alias for <code>cargo::rustc-link-arg-cdylib</code>, and has the same meaning.</p>
<h3 id="rustc-link-arg-bin"><a class="header" href="#rustc-link-arg-bin"><code>cargo::rustc-link-arg-bin=BIN=FLAG</code></a></h3>
<p><code>rustc-link-arg-bin</code> 지시문은 이름이 <code>BIN</code> 인 바이너리 타겟을 빌드할 때만 컴파일러에 <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> 옵션</a> 을 전달하도록 Cargo에 알립니다. 이 지시문의 사용은 플랫폼에 따라 매우 다르며, 링커 스크립트나 기타 링커 옵션을 설정할 때 유용합니다.</p>
<h3 id="rustc-link-arg-bins"><a class="header" href="#rustc-link-arg-bins"><code>cargo::rustc-link-arg-bins=FLAG</code></a></h3>
<p><code>rustc-link-arg-bins</code> 지시문은 바이너리 타겟을 빌드할 때만 컴파일러에 <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> 옵션</a> 을 전달하도록 Cargo에 알립니다. 이 지시문의 사용은 플랫폼에 따라 매우 다르며, 링커 스크립트나 기타 링커 옵션을 설정할 때 유용합니다.</p>
<h3 id="rustc-link-arg-tests"><a class="header" href="#rustc-link-arg-tests"><code>cargo::rustc-link-arg-tests=FLAG</code></a></h3>
<p><code>rustc-link-arg-tests</code> 지시문은 테스트 타겟을 빌드할 때만 컴파일러에 <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> 옵션</a> 을 전달하도록 Cargo에 알립니다.</p>
<h3 id="rustc-link-arg-examples"><a class="header" href="#rustc-link-arg-examples"><code>cargo::rustc-link-arg-examples=FLAG</code></a></h3>
<p><code>rustc-link-arg-examples</code> 지시문은 예제 타겟을 빌드할 때만 컴파일러에 <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> 옵션</a> 을 전달하도록 Cargo에 알립니다.</p>
<h3 id="rustc-link-arg-benches"><a class="header" href="#rustc-link-arg-benches"><code>cargo::rustc-link-arg-benches=FLAG</code></a></h3>
<p><code>rustc-link-arg-benches</code> 지시문은 벤치마크 타겟을 빌드할 때만 컴파일러에 <a href="reference/../../rustc/codegen-options/index.html#link-arg"><code>-C link-arg=FLAG</code> 옵션</a> 을 전달하도록 Cargo에 알립니다.</p>
<h3 id="rustc-link-lib"><a class="header" href="#rustc-link-lib"><code>cargo::rustc-link-lib=LIB</code></a></h3>
<p><code>rustc-link-lib</code> 지시문은 컴파일러의 <a href="reference/../../rustc/command-line-arguments.html#option-l-link-lib"><code>-l</code> 플래그</a> 를 사용하여 지정된 라이브러리를 링크하도록 Cargo에 알립니다. 이는 일반적으로 <a href="reference/../../nomicon/ffi.html">FFI</a> 를 사용하여 네이티브 라이브러리를 링크할 때 사용됩니다.</p>
<p><code>LIB</code> 문자열은 rustc에 직접 전달되므로 <code>-l</code> 이 지원하는 모든 구문을 지원합니다. 현재 <code>LIB</code> 에 대해 완전히 지원되는 구문은 <code>[KIND[:MODIFIERS]=]NAME[:RENAME]</code> 입니다.</p>
<p>패키지에 라이브러리 타겟이 있는 경우 <code>-l</code> 플래그는 해당 라이브러리 타겟에만 전달되며, 라이브러리 타겟이 없는 경우에만 모든 타겟에 전달됩니다. 이는 다른 모든 타겟이 라이브러리 타겟에 암시적으로 의존하고 있으며, 링크할 라이브러리는 한 번만 포함되어야 하기 때문입니다. 즉, 패키지에 라이브러리와 바이너리 타겟이 모두 있는 경우, <em>라이브러리</em> 는 해당 lib의 심볼에 접근할 수 있고, 바이너리는 라이브러리 타겟의 공개 API를 통해 접근해야 합니다.</p>
<p>선택적 요소인 <code>KIND</code> 는 <code>dylib</code>, <code>static</code>, <code>framework</code> 중 하나일 수 있습니다. 자세한 내용은 <a href="reference/../../rustc/command-line-arguments.html#option-l-link-lib">rustc 북</a> 을 참조하세요.</p>
<h3 id="rustc-link-search"><a class="header" href="#rustc-link-search"><code>cargo::rustc-link-search=[KIND=]PATH</code></a></h3>
<p><code>rustc-link-search</code> 지시문은 컴파일러에 <a href="reference/../../rustc/command-line-arguments.html#option-l-search-path"><code>-L</code> 플래그</a> 를 전달하여 라이브러리 검색 경로에 디렉토리를 추가하도록 Cargo에 알립니다.</p>
<p>선택적 요소인 <code>KIND</code> 는 <code>dependency</code>, <code>crate</code>, <code>native</code>, <code>framework</code>, <code>all</code> 중 하나일 수 있습니다. 자세한 내용은 <a href="reference/../../rustc/command-line-arguments.html#option-l-search-path">rustc 북</a> 을 참조하세요.</p>
<p>이 경로들이 <code>OUT_DIR</code> 내에 있는 경우 <a href="reference/environment-variables.html#dynamic-library-paths">동적 라이브러리 검색 경로 환경 변수</a> 에도 추가됩니다. 이러한 동작에 의존하는 것은 결과 바이너리 사용을 어렵게 만들 수 있으므로 권장되지 않습니다. 일반적으로 빌드 스크립트에서 동적 라이브러리를 생성하는 것은 피하는 것이 좋으며, 기존 시스템 라이브러리를 사용하는 것은 괜찮습니다.</p>
<h3 id="rustc-flags"><a class="header" href="#rustc-flags"><code>cargo::rustc-flags=FLAGS</code></a></h3>
<p><code>rustc-flags</code> 지시문은 지정된 공백으로 구분된 플래그들을 컴파일러에 전달하도록 Cargo에 알립니다. 이 지시문은 <code>-l</code> 및 <code>-L</code> 플래그만 허용하며, <a href="reference/build-scripts.html#rustc-link-lib"><code>rustc-link-lib</code></a> 및 <a href="reference/build-scripts.html#rustc-link-search"><code>rustc-link-search</code></a> 를 사용하는 것과 동일합니다.</p>
<h3 id="rustc-cfg"><a class="header" href="#rustc-cfg"><code>cargo::rustc-cfg=KEY[="VALUE"]</code></a></h3>
<p><code>rustc-cfg</code> 지시문은 컴파일러의 <a href="reference/../../rustc/command-line-arguments.html#option-cfg"><code>--cfg</code> 플래그</a> 에 지정된 값을 전달하도록 Cargo에 알립니다. 이는 <a href="reference/../../reference/conditional-compilation.html">조건부 컴파일</a> 을 활성화하기 위해 컴파일 타임에 기능을 감지하는 데 사용될 수 있습니다. 사용자 정의 cfg는 <a href="reference/build-scripts.html#rustc-check-cfg"><code>cargo::rustc-check-cfg</code></a> 지시문을 사용하여 예상되는 값으로 등록하거나, 예기치 않은 cfg 경고를 피하기 위해 <a href="reference/../../rustc/lints/listing/warn-by-default.html#unexpected-cfgs"><code>unexpected_cfgs</code></a> 린트(lint)를 허용해야 합니다.</p>
<p>이는 Cargo의 의존성 해결(dependency resolution)에는 영향을 주지 <em>않음</em> 에 유의하세요. 이를 통해 선택적 의존성이나 다른 Cargo 기능을 활성화할 수는 없습니다.</p>
<p><a href="reference/features.html">Cargo 기능(features)</a> 은 <code>feature="foo"</code> 형식을 사용한다는 점에 유의하세요. 이 플래그와 함께 전달되는 <code>cfg</code> 값은 해당 형식으로 제한되지 않으며, 단일 식별자나 임의의 키/값 쌍을 제공할 수 있습니다. 예를 들어 <code>cargo::rustc-cfg=abc</code> 를 출력하면 코드에서 <code>#[cfg(abc)]</code> 를 사용할 수 있게 됩니다 (<code>feature=</code> 가 없음에 주의). 또는 <code>cargo::rustc-cfg=my_component="foo"</code> 와 같이 <code>=</code> 기호를 사용하여 임의의 키/값 쌍을 사용할 수 있습니다. 키는 Rust 식별자여야 하고, 값은 문자열이어야 합니다.</p>
<h3 id="rustc-check-cfg"><a class="header" href="#rustc-check-cfg"><code>cargo::rustc-check-cfg=CHECK_CFG</code></a></h3>
<p><a href="reference/../../rustc/lints/listing/warn-by-default.html#unexpected-cfgs"><code>unexpected_cfgs</code></a> 린트를 사용하여 <em>도달 가능한</em> cfg 식을 확인할 때 사용할 예상 설정 이름 및 값 목록에 추가합니다.</p>
<p><code>CHECK_CFG</code> 의 구문은 <code>rustc</code> 의 <a href="reference/../../rustc/command-line-arguments.html#option-check-cfg"><code>--check-cfg</code> 플래그</a> 와 동일합니다. 자세한 내용은 <a href="reference/../../rustc/check-cfg.html">조건부 설정 확인</a> 을 참조하세요.</p>
<p>이 지시문은 다음과 같이 사용할 수 있습니다.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// build.rs
println!("cargo::rustc-check-cfg=cfg(foo, values(\"bar\"))");
if foo_bar_condition {
    println!("cargo::rustc-cfg=foo=\"bar\"");
}
<span class="boring">}</span></code></pre></pre>
<p>현재 활성화된 cfg가 무엇인지와 관계없이 가능한 모든 cfg를 정의해야 한다는 점에 유의하세요. 여기에는 지정된 cfg 이름의 가능한 모든 값이 포함됩니다.</p>
<p>오타, 누락된 check-cfg, 오래된 cfg 등을 방지하기 위해 <code>cargo::rustc-check-cfg</code> 와 <a href="reference/../../rustc/command-line-arguments.html#option-cfg"><code>cargo::rustc-cfg</code></a> 지시문을 가능한 한 가깝게 그룹화하는 것이 권장됩니다.</p>
<p><a href="reference/build-script-examples.html#conditional-compilation">조건부 컴파일</a> 예제도 참조하세요.</p>
<blockquote>
<p><strong>MSRV:</strong> 1.80 버전부터 적용됩니다.</p>
</blockquote>
<h3 id="rustc-env"><a class="header" href="#rustc-env"><code>cargo::rustc-env=VAR=VALUE</code></a></h3>
<p><code>rustc-env</code> 지시문은 패키지 컴파일 시 지정된 환경 변수를 설정하도록 Cargo에 알립니다. 설정된 값은 컴파일된 크레이트 내에서 <a href="reference/../../std/macro.env.html"><code>env!</code> 매크로</a> 를 통해 가져올 수 있습니다. 이는 git HEAD의 해시값이나 지속적 통합(CI) 서버의 고유 식별자와 같은 추가 메타데이터를 크레이트 코드에 삽입할 때 유용합니다.</p>
<p><a href="reference/environment-variables.html#environment-variables-cargo-sets-for-crates">Cargo에 의해 자동으로 포함되는 환경 변수</a> 도 참조하세요.</p>
<blockquote>
<p><strong>참고</strong>: 이러한 환경 변수들은 <code>cargo run</code> 이나 <code>cargo test</code> 로 실행 파일을 실행할 때도 설정됩니다. 하지만 이는 실행 파일을 Cargo의 실행 환경에 종속시키므로 권장되지 않습니다. 일반적으로 이러한 환경 변수들은 <code>env!</code> 매크로를 사용하여 컴파일 타임에만 확인해야 합니다.</p>
</blockquote>
<h3 id="cargo-error"><a class="header" href="#cargo-error"><code>cargo::error=MESSAGE</code></a></h3>
<p><code>error</code> 지시문은 빌드 스크립트 실행이 끝난 후 오류를 표시하고 빌드를 실패시키도록 Cargo에 알립니다.</p>
<blockquote>
<p>참고: 빌드 스크립트 라이브러리는 <code>cargo::error</code> 를 직접 사용할지 아니면 <code>Result</code> 를 반환할지 신중히 고려해야 합니다. <code>Result</code> 를 반환하여 호출자가 해당 오류가 치명적인지 여부를 결정하게 하는 것이 더 나을 수 있습니다. 그 후 호출자는 <code>cargo::error</code> 를 사용하여 해당 오류를 표시할지 말지를 결정할 수 있습니다.</p>
</blockquote>
<blockquote>
<p><strong>MSRV:</strong> 1.84 버전부터 적용됩니다.</p>
</blockquote>
<h3 id="cargo-warning"><a class="header" href="#cargo-warning"><code>cargo::warning=MESSAGE</code></a></h3>
<p>The <code>warning</code> instruction tells Cargo to display a warning after the build script has finished running. Warnings are only shown for <code>path</code> dependencies (that is, those you’re working on locally), so for example warnings printed out in <a href="https://crates.io/">crates.io</a> crates are not emitted by default, unless the build fails. The <code>-vv</code> “very verbose” flag may be used to have Cargo display warnings for all crates.</p>
<h2 id="빌드-의존성-2"><a class="header" href="#빌드-의존성-2">빌드 의존성</a></h2>
<p>빌드 스크립트도 다른 Cargo 기반 크레이트에 의존성을 가질 수 있습니다. 의존성은 매니페스트의 <code>build-dependencies</code> 섹션을 통해 선언됩니다.</p>
<pre><code class="language-toml">[build-dependencies]
cc = "1.0.46"
</code></pre>
<p>빌드 스크립트는 <code>dependencies</code> 또는 <code>dev-dependencies</code> 섹션에 나열된 의존성에 접근할 수 없습니다 (아직 빌드되지 않았기 때문입니다!). 또한, 빌드 의존성은 <code>[dependencies]</code> 테이블에 명시적으로 추가되지 않는 한 패키지 자체에서 사용할 수 없습니다.</p>
<p>컴파일 시간, 라이선스, 유지 관리 등에 미치는 영향을 고려하여 각 의존성을 신중하게 선택하는 것이 좋습니다. Cargo는 빌드 의존성과 일반 의존성 간에 공유되는 의존성이 있으면 재사용을 시도합니다. 그러나 교차 컴파일(cross-compiling) 시와 같이 항상 가능한 것은 아니므로 컴파일 시간에 미치는 영향을 고려해야 합니다.</p>
<h2 id="변경-감지"><a class="header" href="#변경-감지">변경 감지</a></h2>
<p>패키지를 다시 빌드할 때, Cargo가 반드시 빌드 스크립트를 다시 실행해야 하는지 여부를 항상 아는 것은 아닙니다. 기본적으로 Cargo는 패키지 내의 파일이 하나라도 변경되면(또는 <a href="reference/manifest.html#the-exclude-and-include-fields"><code>exclude</code> 및 <code>include</code> 필드</a> 로 제어되는 파일 목록이 변경되면) 항상 빌드 스크립트를 다시 실행하는 보수적인 방식을 취합니다. 대부분의 경우 이는 좋은 선택이 아니므로, 모든 빌드 스크립트는 적어도 하나 이상의 <code>rerun-if</code> 지시문(아래 설명 참조)을 내보내는 것이 권장됩니다. 이 지시문들이 내보내지면, Cargo는 지정된 값이 변경된 경우에만 스크립트를 다시 실행합니다. 만약 Cargo가 본인의 크레이트나 의존성의 빌드 스크립트를 계속 다시 실행하는데 그 이유를 모르겠다면, FAQ의 <a href="reference/../faq.html#why-is-cargo-rebuilding-my-code">“왜 Cargo가 내 코드를 다시 빌드하나요?”</a> 를 참조하세요.</p>
<h3 id="rerun-if-changed"><a class="header" href="#rerun-if-changed"><code>cargo::rerun-if-changed=PATH</code></a></h3>
<p><code>rerun-if-changed</code> 지시문은 지정된 경로의 파일이 변경된 경우 빌드 스크립트를 다시 실행하도록 Cargo에 알립니다. 현재 Cargo는 파일의 변경 여부를 판단하기 위해 파일 시스템의 최종 수정 시간인 “mtime” 타임스탬프만 사용합니다. 이는 빌드 스크립트가 마지막으로 실행되었을 때의 내부적으로 캐시된 타임스탬프와 비교됩니다.</p>
<p>경로가 디렉토리를 가리키는 경우, 해당 디렉토리 전체에서 수정 사항이 있는지 스캔합니다.</p>
<p>만약 빌드 스크립트가 어떤 상황에서도 다시 실행될 필요가 없다면, <code>cargo::rerun-if-changed=build.rs</code> 를 내보내는 것이 재실행을 방지하는 간단한 방법입니다 (그렇지 않고 <code>rerun-if</code> 지시문이 전혀 없으면 기본적으로 패키지 디렉토리 전체를 스캔하여 변경 사항을 확인합니다). Cargo는 스크립트 자체가 재컴파일되어야 하는지 여부를 자동으로 처리하며, 당연히 재컴파일된 후에는 스크립트가 다시 실행됩니다. 그렇지 않은 경우 <code>build.rs</code> 를 지정하는 것은 불필요하고 중복된 작업입니다.</p>
<h3 id="rerun-if-env-changed"><a class="header" href="#rerun-if-env-changed"><code>cargo::rerun-if-env-changed=NAME</code></a></h3>
<p><code>rerun-if-env-changed</code> 지시문은 지정된 이름의 환경 변수 값이 변경된 경우 빌드 스크립트를 다시 실행하도록 Cargo에 알립니다.</p>
<p>여기서의 환경 변수는 <code>CC</code> 와 같은 전역 환경 변수를 위한 것이며, <a href="reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">Cargo가 빌드 스크립트를 위해 설정하는</a> <code>TARGET</code> 과 같은 환경 변수에는 사용할 수 없습니다. 사용되는 환경 변수는 빌드 스크립트의 실행 파일이 받는 것이 아니라, <code>cargo</code> 명령 호출 시 받는 것들입니다.</p>
<p>1.46 버전부터 소스 코드에서 <a href="reference/../../std/macro.env.html"><code>env!</code></a> 와 <a href="reference/../../std/macro.option_env.html"><code>option_env!</code></a> 를 사용하면 자동으로 변경 사항을 감지하고 재빌드를 트리거합니다. 이러한 매크로에 의해 이미 참조되는 변수들에 대해서는 <code>rerun-if-env-changed</code> 가 더 이상 필요하지 않습니다.</p>
<h2 id="links-매니페스트-키"><a class="header" href="#links-매니페스트-키"><code>links</code> 매니페스트 키</a></h2>
<p><code>package.links</code> 키를 <code>Cargo.toml</code> 매니페스트에 설정하여 패키지가 지정된 네이티브 라이브러리와 링크됨을 선언할 수 있습니다. 이 매니페스트 키의 목적은 Cargo가 패키지가 가진 네이티브 의존성 세트를 이해하도록 돕고, 패키지 빌드 스크립트 간에 메타데이터를 전달하는 체계적인 시스템을 제공하는 것입니다.</p>
<pre><code class="language-toml">[package]
# ...
links = "foo"
</code></pre>
<p>이 매니페스트는 패키지가 <code>libfoo</code> 네이티브 라이브러리에 링크됨을 나타냅니다. <code>links</code> 키를 사용할 때 패키지는 반드시 빌드 스크립트를 가져야 하며, 빌드 스크립트는 라이브러리를 링크하기 위해 <a href="reference/build-scripts.html#rustc-link-lib"><code>rustc-link-lib</code> 지시문</a> 을 사용해야 합니다.</p>
<p>기본적으로 Cargo는 <code>links</code> 값 하나당 최대 하나의 패키지만 허용합니다. 즉, 두 개의 패키지가 동일한 네이티브 라이브러리에 링크되는 것은 금지됩니다. 이는 크레이트 간의 심볼 중복을 방지하는 데 도움이 됩니다. 다만, 이를 완화하기 위한 <a href="reference/build-scripts.html#-sys-packages">관례</a> 가 존재합니다.</p>
<p>빌드 스크립트는 키-값 쌍 형태의 임의의 메타데이터 세트를 생성할 수 있습니다. 이 메타데이터는 <code>cargo::metadata=KEY=VALUE</code> 지시문을 사용하여 설정합니다.</p>
<p>The metadata is passed to the build scripts of <strong>dependent</strong> packages. For example, if the package <code>foo</code> depends on <code>bar</code>, which links <code>baz</code>, then if <code>bar</code> generates <code>key=value</code> as part of its build script metadata, then the build script of <code>foo</code> will have the environment variables <code>DEP_BAZ_KEY=value</code> (note that the value of the <code>links</code> key is used and the case change for <code>key</code>). See the <a href="reference/build-script-examples.html#using-another-sys-crate">“Using another <code>sys</code> crate”</a> for an example of how this can be used.</p>
<p>메타데이터는 직속 의존 패키지(immediate dependents)에게만 전달되며, 전이적 의존 패키지(transitive dependents)에게는 전달되지 않음에 유의하세요.</p>
<blockquote>
<p><strong>MSRV:</strong> 1.77 is required for <code>cargo::metadata=KEY=VALUE</code>. To support older versions, use <code>cargo:KEY=VALUE</code> (unsupported directives are assumed to be metadata keys).</p>
</blockquote>
<h2 id="-sys-패키지"><a class="header" href="#-sys-패키지"><code>*-sys</code> 패키지</a></h2>
<p>시스템 라이브러리에 링크하는 일부 Cargo 패키지들은 이름 뒤에 <code>-sys</code> 접미사를 붙이는 명명 관례가 있습니다. <code>foo-sys</code> 라는 이름의 패키지는 다음과 같은 두 가지 주요 기능을 제공해야 합니다.</p>
<ul>
<li>라이브러리 크레이트는 네이티브 라이브러리 <code>libfoo</code> 에 링크되어야 합니다. 이는 종종 소스에서 직접 빌드하기 전에 현재 시스템에서 <code>libfoo</code> 를 탐색하는 과정을 거칩니다.</li>
<li>라이브러리 크레이트는 <code>libfoo</code> 의 타입과 함수에 대한 <strong>선언(declarations)</strong> 을 제공해야 하며, 고수준의 추상화는 제공하지 <strong>않아야</strong> 합니다.</li>
</ul>
<p><code>*-sys</code> 패키지 세트는 네이티브 라이브러리 링크를 위한 공통 의존성 세트를 제공합니다. 이러한 네이티브 라이브러리 관련 패키지 관례를 통해 얻을 수 있는 이점은 다음과 같습니다.</p>
<ul>
<li><code>foo-sys</code> 에 대한 공통 의존성을 통해 <code>links</code> 값당 하나의 패키지만 허용된다는 규칙의 제약을 완화할 수 있습니다.</li>
<li>Other <code>-sys</code> packages can take advantage of the <code>DEP_LINKS_KEY=value</code> environment variables to better integrate with other packages. See the <a href="reference/build-script-examples.html#using-another-sys-crate">“Using another <code>sys</code> crate”</a> example.</li>
<li>공통 의존성을 사용하면 <code>libfoo</code> 자체를 찾거나 소스에서 빌드하는 로직을 중앙 집중화할 수 있습니다.</li>
<li>이러한 의존성들은 쉽게 <a href="reference/build-scripts.html#overriding-build-scripts">재정의 가능</a> 합니다.</li>
</ul>
<p>sys 패키지 위에 안전하고 고수준의 추상화를 제공하는, <code>-sys</code> 접미사가 없는 동반 패키지를 두는 것이 일반적입니다. 예를 들어, <a href="https://crates.io/crates/git2"><code>git2</code> 크레이트</a> 는 <a href="https://crates.io/crates/libgit2-sys"><code>libgit2-sys</code> 크레이트</a> 에 대한 고수준 인터페이스를 제공합니다.</p>
<h2 id="빌드-스크립트-재정의"><a class="header" href="#빌드-스크립트-재정의">빌드 스크립트 재정의</a></h2>
<p>매니페스트에 <code>links</code> 키가 포함된 경우, Cargo는 지정된 빌드 스크립트를 사용자 정의 라이브러리로 재정의하는 기능을 지원합니다. 이 기능의 목적은 해당 빌드 스크립트의 실행을 완전히 방지하고 대신 메타데이터를 미리 제공하는 것입니다.</p>
<p>빌드 스크립트를 재정의하려면 허용되는 임의의 <a href="reference/config.html"><code>config.toml</code></a> 파일에 다음과 같은 설정을 추가하세요.</p>
<pre><code class="language-toml">[target.x86_64-unknown-linux-gnu.foo]
rustc-link-lib = ["foo"]
rustc-link-search = ["/path/to/foo"]
rustc-flags = "-L /some/path"
rustc-cfg = ['key="value"']
rustc-env = {key = "value"}
rustc-cdylib-link-arg = ["…"]
metadata_key1 = "value"
metadata_key2 = "value"
</code></pre>
<p>이 설정을 사용하면, 패키지가 <code>foo</code> 에 링크된다고 선언하더라도 빌드 스크립트는 컴파일되거나 실행되지 <strong>않으며</strong>, 대신 지정된 메타데이터가 사용됩니다.</p>
<p><code>warning</code>, <code>rerun-if-changed</code>, <code>rerun-if-env-changed</code> 키는 사용해서는 안 되며 무시됩니다.</p>
<h2 id="잡서버jobserver"><a class="header" href="#잡서버jobserver">잡서버(Jobserver)</a></h2>
<p>Cargo와 <code>rustc</code> 는 프로세스 간의 병렬 처리를 조율하기 위해 GNU make용으로 개발된 <a href="http://make.mad-scientist.net/papers/jobserver-implementation/">잡서버 프로토콜</a> 을 사용합니다. 이는 본질적으로 동시에 실행되는 작업 수를 제어하는 세마포어입니다. 병렬 처리 수준은 <code>--jobs</code> 플래그로 설정할 수 있으며, 기본값은 논리 CPU 개수입니다.</p>
<p>각 빌드 스크립트는 Cargo로부터 하나의 작업 슬롯을 상속받으며, 실행되는 동안 하나의 CPU만 사용하도록 노력해야 합니다. 스크립트가 더 많은 CPU를 병렬로 사용하려면 <a href="https://crates.io/crates/jobserver"><code>jobserver</code> 크레이트</a> 를 사용하여 Cargo와 조율해야 합니다.</p>
<p>예를 들어, <a href="https://crates.io/crates/cc"><code>cc</code> 크레이트</a> 는 선택적인 <code>parallel</code> 기능을 활성화하여 잡서버 프로토콜을 사용해 여러 C 파일을 동시에 빌드하도록 시도할 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="빌드-스크립트-예제"><a class="header" href="#빌드-스크립트-예제">빌드 스크립트 예제</a></h1>
<p>다음 섹션들에서는 빌드 스크립트 작성의 몇 가지 예시를 보여줍니다.</p>
<p>일반적인 빌드 스크립트 기능들은 <a href="https://crates.io/">crates.io</a> 의 크레이트들을 통해 찾을 수 있습니다. <a href="https://crates.io/keywords/build-dependencies"><code>build-dependencies</code> 키워드</a> 를 확인하여 어떤 것들이 있는지 살펴보세요. 다음은 널리 사용되는 몇 가지 크레이트의 예시입니다 <sup class="footnote-reference"><a href="#†">1</a></sup>.</p>
<ul>
<li><a href="https://crates.io/crates/bindgen"><code>bindgen</code></a> — C 라이브러리에 대한 Rust FFI 바인딩을 자동으로 생성합니다.</li>
<li><a href="https://crates.io/crates/cc"><code>cc</code></a> — C/C++/어셈블리 코드를 컴파일합니다.</li>
<li><a href="https://crates.io/crates/pkg-config"><code>pkg-config</code></a> — <code>pkg-config</code> 유틸리티를 사용하여 시스템 라이브러리를 감지합니다.</li>
<li><a href="https://crates.io/crates/cmake"><code>cmake</code></a> — <code>cmake</code> 빌드 도구를 실행하여 네이티브 라이브러리를 빌드합니다.</li>
<li><a href="https://crates.io/crates/autocfg"><code>autocfg</code></a>, <a href="https://crates.io/crates/rustc_version"><code>rustc_version</code></a>, <a href="https://crates.io/crates/version_check"><code>version_check</code></a> — 이 크레이트들은 컴파일러 버전과 같은 현재 <code>rustc</code> 상태에 따라 조건부 컴파일을 구현하는 방법들을 제공합니다.</li>
</ul>
<div class="footnote-definition" id="†"><sup class="footnote-definition-label">1</sup>
<p>이 목록이 특정 크레이트를 추천하는 것은 아닙니다. 프로젝트에 적합한 의존성이 무엇인지 직접 평가해 보세요.</p>
</div>
<h2 id="코드-생성"><a class="header" href="#코드-생성">코드 생성</a></h2>
<p>일부 Cargo 패키지는 여러 가지 이유로 컴파일 직전에 코드를 생성해야 할 필요가 있습니다. 여기서는 빌드 스크립트의 일부로 라이브러리 호출을 생성하는 간단한 예제를 살펴보겠습니다.</p>
<p>먼저, 이 패키지의 디렉토리 구조를 살펴보겠습니다.</p>
<pre><code class="language-text">.
├── Cargo.toml
├── build.rs
└── src
    └── main.rs

1 directory, 3 files
</code></pre>
<p>여기에는 <code>build.rs</code> 빌드 스크립트가 있고 <code>main.rs</code> 에 바이너리 코드가 있습니다. 이 패키지의 기본적인 매니페스트는 다음과 같습니다.</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = "hello-from-generated-code"
version = "0.1.0"
edition = "2024"
</code></pre>
<p>빌드 스크립트 내부를 살펴보겠습니다.</p>
<pre><pre class="playground"><code class="language-rust no_run">// build.rs

use std::env;
use std::fs;
use std::path::Path;

fn main() {
    let out_dir = env::var_os("OUT_DIR").unwrap();
    let dest_path = Path::new(&amp;out_dir).join("hello.rs");
    fs::write(
        &amp;dest_path,
        "pub fn message() -&gt; &amp;'static str {
            \"Hello, World!\"
        }
        "
    ).unwrap();
    println!("cargo::rerun-if-changed=build.rs");
}</code></pre></pre>
<p>여기서 몇 가지 주목할 점이 있습니다.</p>
<ul>
<li>스크립트는 출력 파일이 위치할 곳을 찾기 위해 <code>OUT_DIR</code> 환경 변수를 사용합니다. 입력 파일이 위치할 곳을 찾기 위해 프로세스의 현재 작업 디렉토리를 사용할 수 있지만, 이 예제에서는 입력 파일이 없습니다.</li>
<li>일반적으로 빌드 스크립트는 <code>OUT_DIR</code> 외부의 파일을 수정해서는 안 됩니다. 언뜻 보기에는 괜찮아 보일 수 있지만, 해당 크레이트를 의존성으로 사용할 때 문제가 발생합니다. 왜냐하면 <code>.cargo/registry</code> 에 있는 소스는 변경 불가능(immutable)해야 한다는 암묵적인 규칙이 있기 때문입니다. <code>cargo</code> 는 패키징 시 이러한 스크립트를 허용하지 않습니다.
<ul>
<li>Sometimes, projects want to check in a generated file, and treat it as source code. However, in this case, the file shouldn’t be generated from <code>build.rs</code>. Instead, have a test or similar which checks that the file precisely matches the generated version <em>and fails if the result doesn’t match</em>, and run that test as part of your CI. (The test can generate a temporary file to compare to, and if you want to update the generated file, you can replace the checked-in file with that temporary file.)</li>
</ul>
</li>
<li>이 스크립트는 작은 파일을 하나 생성하는 비교적 간단한 것입니다. 예를 들어 C 헤더 파일이나 다른 언어 정의로부터 Rust 모듈을 생성하는 것과 같은 더 복잡한 작업이 수행될 수도 있음을 상상할 수 있습니다.</li>
<li><a href="reference/build-scripts.html#rerun-if-changed"><code>rerun-if-changed</code> 지시문</a> 은 빌드 스크립트 자체가 변경될 때만 다시 실행되어야 함을 Cargo에 알립니다. 이 줄이 없으면 Cargo는 패키지의 파일 중 하나라도 변경되면 자동으로 빌드 스크립트를 실행합니다. 만약 코드 생성 과정에서 입력 파일을 사용한다면, 이 부분에 해당 파일들의 목록을 출력하면 됩니다.</li>
</ul>
<p>다음으로 라이브러리 자체를 살펴보겠습니다.</p>
<pre><code class="language-rust ignore">// src/main.rs

include!(concat!(env!("OUT_DIR"), "/hello.rs"));

fn main() {
    println!("{}", message());
}</code></pre>
<p>이것이 진정한 마법이 일어나는 부분입니다. 라이브러리는 rustc에 정의된 <a href="reference/../../std/macro.include.html"><code>include!</code> 매크로</a> 를 <a href="reference/../../std/macro.concat.html"><code>concat!</code></a> 및 <a href="reference/../../std/macro.env.html"><code>env!</code></a> 매크로와 조합하여 생성된 파일(<code>hello.rs</code>)을 크레이트 컴파일 과정에 포함시킵니다.</p>
<p>여기서 보여준 구조를 사용하면, 크레이트는 빌드 스크립트가 생성한 파일을 몇 개든 포함할 수 있습니다.</p>
<h2 id="네이티브-라이브러리-빌드"><a class="header" href="#네이티브-라이브러리-빌드">네이티브 라이브러리 빌드</a></h2>
<p>때로는 패키지의 일부로 네이티브 C 또는 C++ 코드를 빌드해야 할 필요가 있습니다. 이는 Rust 크레이트 자체를 빌드하기 전에 네이티브 라이브러리를 빌드하기 위해 빌드 스크립트를 활용하는 또 다른 훌륭한 사례입니다. 예제로, C 코드를 호출하여 “Hello, World!”를 출력하는 Rust 라이브러리를 만들어 보겠습니다.</p>
<p>위에서와 같이, 먼저 패키지 레이아웃을 살펴보겠습니다.</p>
<pre><code class="language-text">.
├── Cargo.toml
├── build.rs
└── src
    ├── hello.c
    └── main.rs

1 directory, 4 files
</code></pre>
<p>이전과 꽤 비슷합니다! 다음은 매니페스트입니다.</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = "hello-world-from-c"
version = "0.1.0"
edition = "2024"
</code></pre>
<p>지금은 빌드 의존성을 사용하지 않을 것이므로, 이제 빌드 스크립트를 살펴보겠습니다.</p>
<pre><pre class="playground"><code class="language-rust no_run">// build.rs

use std::process::Command;
use std::env;
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();

    // 이 접근 방식에는 몇 가지 단점이 있습니다. 아래 주석에서
    // 이 명령들의 이식성을 개선하는 방법을 자세히 설명합니다.
    Command::new("gcc").args(&amp;["src/hello.c", "-c", "-fPIC", "-o"])
                       .arg(&amp;format!("{}/hello.o", out_dir))
                       .status().unwrap();
    Command::new("ar").args(&amp;["crus", "libhello.a", "hello.o"])
                      .current_dir(&amp;Path::new(&amp;out_dir))
                      .status().unwrap();

    println!("cargo::rustc-link-search=native={}", out_dir);
    println!("cargo::rustc-link-lib=static=hello");
    println!("cargo::rerun-if-changed=src/hello.c");
}</code></pre></pre>
<p>이 빌드 스크립트는 (<code>gcc</code> 를 호출하여) C 파일을 목적 파일(object file)로 컴파일하고, (<code>ar</code> 을 호출하여) 이 목적 파일을 정적 라이브러리로 변환하는 것으로 시작합니다. 마지막 단계는 Cargo에 결과물이 <code>out_dir</code> 에 있으며, 컴파일러가 <code>-l static=hello</code> 플래그를 통해 크레이트를 <code>libhello.a</code> 에 정적으로 링크해야 한다고 알리는 것입니다.</p>
<p>이러한 하드코딩 방식에는 몇 가지 단점이 있습니다.</p>
<ul>
<li><code>gcc</code> 명령 자체가 플랫폼 간에 이식성이 없습니다. 예를 들어 윈도우 플랫폼에는 <code>gcc</code> 가 없을 가능성이 높고, 모든 유닉스 플랫폼에 <code>gcc</code> 가 있는 것도 아닙니다. <code>ar</code> 명령도 비슷한 상황입니다.</li>
<li>이러한 명령들은 교차 컴파일을 고려하지 않습니다. 안드로이드와 같은 플랫폼을 위해 교차 컴파일하는 경우, <code>gcc</code> 가 ARM 실행 파일을 생성할 가능성은 낮습니다.</li>
</ul>
<p>하지만 걱정 마세요. 이럴 때 <code>build-dependencies</code> 항목이 도움이 됩니다! Cargo 에코시스템에는 이런 작업을 훨씬 쉽고 이식성 있게, 그리고 표준화된 방식으로 만들어주는 많은 패키지가 있습니다. <a href="https://crates.io/">crates.io</a>의 <a href="https://crates.io/crates/cc"><code>cc</code> 크레이트</a> 를 사용해 봅시다. 먼저 <code>Cargo.toml</code> 의 <code>build-dependencies</code> 에 추가하세요.</p>
<pre><code class="language-toml">[build-dependencies]
cc = "1.0"
</code></pre>
<p>그리고 이 크레이트를 사용하도록 빌드 스크립트를 다시 작성합니다.</p>
<pre><code class="language-rust ignore">// build.rs

fn main() {
    cc::Build::new()
        .file("src/hello.c")
        .compile("hello");
    println!("cargo::rerun-if-changed=src/hello.c");
}</code></pre>
<p><a href="https://crates.io/crates/cc"><code>cc</code> 크레이트</a> 는 C 코드에 대한 다양한 빌드 스크립트 요구 사항을 추상화합니다.</p>
<ul>
<li>적절한 컴파일러(윈도우의 경우 MSVC, MinGW의 경우 <code>gcc</code>, 유닉스 플랫폼의 경우 <code>cc</code> 등)를 호출합니다.</li>
<li>사용 중인 컴파일러에 적절한 플래그를 전달함으로써 <code>TARGET</code> 변수를 고려합니다.</li>
<li><code>OPT_LEVEL</code>, <code>DEBUG</code> 등과 같은 다른 환경 변수들도 모두 자동으로 처리됩니다.</li>
<li>표준 출력(stdout) 및 <code>OUT_DIR</code> 위치도 <code>cc</code> 라이브러리에 의해 처리됩니다.</li>
</ul>
<p>여기서 모든 빌드 스크립트에 로직을 중복해서 작성하는 대신, 가능한 한 많은 기능을 공통 빌드 의존성에 맡기는 것의 큰 이점을 확인할 수 있습니다!</p>
<p>다시 사례 연구로 돌아가서, <code>src</code> 디렉토리의 내용을 간단히 살펴보겠습니다.</p>
<pre><code class="language-c">// src/hello.c

#include &lt;stdio.h&gt;

void hello() {
    printf("Hello, World!\n");
}
</code></pre>
<pre><code class="language-rust ignore">// src/main.rs

// `#[link]` 속성이 없음에 주목하세요. 무엇을 링크할지 선택하는 책임을
// 소스 파일에 하드코딩하는 대신 빌드 스크립트에 위임하고 있습니다.
unsafe extern { fn hello(); }

fn main() {
    unsafe { hello(); }
}</code></pre>
<p>됐습니다! 이것으로 빌드 스크립트를 사용하여 Cargo 패키지에서 C 코드를 빌드하는 예제를 마칩니다. 또한 많은 상황에서 빌드 의존성을 사용하는 것이 얼마나 중요하며, 심지어 얼마나 더 간결해지는지도 보여줍니다!</p>
<p>또한 빌드 스크립트가 런타임이 아닌 순수하게 빌드 프로세스만을 위해 크레이트를 의존성으로 사용하는 방법에 대한 간단한 예제도 살펴보았습니다.</p>
<h2 id="시스템-라이브러리-링크하기"><a class="header" href="#시스템-라이브러리-링크하기">시스템 라이브러리 링크하기</a></h2>
<p>이 예제는 시스템 라이브러리를 링크하는 방법과 이 유스케이스를 지원하기 위해 빌드 스크립트가 어떻게 사용되는지 보여줍니다.</p>
<p>Rust 크레이트가 기능을 바인딩하거나 단순히 구현 세부 사항의 일부로 사용하기 위해 시스템에서 제공하는 네이티브 라이브러리에 링크하려는 경우가 꽤 빈번합니다. 이를 플랫폼에 구애받지 않는 방식으로 수행하는 것은 꽤 까다로운 문제입니다. 가능하다면 이러한 작업의 상당 부분을 외부 도구에 맡겨 사용자가 최대한 쉽게 사용할 수 있게 하는 것이 좋습니다.</p>
<p>이 예제에서는 시스템의 zlib 라이브러리에 대한 바인딩을 만들어 보겠습니다. zlib은 데이터 압축 기능을 제공하며 대부분의 유닉스 계열 시스템에서 흔히 볼 수 있는 라이브러리입니다. 이미 <a href="https://crates.io/crates/libz-sys"><code>libz-sys</code> 크레이트</a>에 잘 정리되어 있지만, 이 예제에서는 극도로 단순화된 버전을 만들어 보겠습니다. 전체 예제는 <a href="https://github.com/rust-lang/libz-sys">소스 코드</a> 를 확인하세요.</p>
<p>라이브러리의 위치를 쉽게 찾기 위해 <a href="https://crates.io/crates/pkg-config"><code>pkg-config</code> 크레이트</a> 를 사용하겠습니다. 이 크레이트는 시스템의 <code>pkg-config</code> 유틸리티를 사용하여 라이브러리에 대한 정보를 찾습니다. 그리고 라이브러리 링크에 필요한 정보를 Cargo에 자동으로 알려줍니다. 이 방식은 <code>pkg-config</code> 가 설치된 유닉스 계열 시스템에서만 작동할 가능성이 높습니다. 먼저 매니페스트를 설정해 봅시다.</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = "libz-sys"
version = "0.1.0"
edition = "2024"
links = "z"

[build-dependencies]
pkg-config = "0.3.16"
</code></pre>
<p><code>package</code> 테이블에 <code>links</code> 키를 포함했음에 주목하세요. 이는 우리가 <code>libz</code> 라이브러리에 링크하고 있음을 Cargo에 알려줍니다. 이를 활용하는 예제는 <a href="reference/build-script-examples.html#using-another-sys-crate">“다른 sys 크레이트 사용하기”</a> 를 참조하세요.</p>
<p>빌드 스크립트는 꽤 간단합니다.</p>
<pre><code class="language-rust ignore">// build.rs

fn main() {
    pkg_config::Config::new().probe("zlib").unwrap();
    println!("cargo::rerun-if-changed=build.rs");
}</code></pre>
<p>기본적인 FFI 바인딩으로 예제를 마무리해 봅시다.</p>
<pre><code class="language-rust ignore">// src/lib.rs

use std::os::raw::{c_uint, c_ulong};

unsafe extern "C" {
    pub fn crc32(crc: c_ulong, buf: *const u8, len: c_uint) -&gt; c_ulong;
}

#[test]
fn test_crc32() {
    let s = "hello";
    unsafe {
        assert_eq!(crc32(0, s.as_ptr(), s.len() as c_uint), 0x3610a686);
    }
}</code></pre>
<p><code>cargo build -vv</code> 를 실행하여 빌드 스크립트의 출력을 확인하세요. <code>libz</code> 가 이미 설치된 시스템에서는 다음과 같이 보일 것입니다.</p>
<pre><code class="language-text">[libz-sys 0.1.0] cargo::rustc-link-search=native=/usr/lib
[libz-sys 0.1.0] cargo::rustc-link-lib=z
[libz-sys 0.1.0] cargo::rerun-if-changed=build.rs
</code></pre>
<p>좋습니다! <code>pkg-config</code> 가 라이브러리를 찾고 Cargo에 그 위치를 알려주는 모든 작업을 수행했습니다.</p>
<p>패키지가 라이브러리 소스를 포함하고, 시스템에서 라이브러리를 찾을 수 없거나 특정 기능(feature) 또는 환경 변수가 설정된 경우 정적으로 빌드하는 것은 흔한 일입니다. 예를 들어, 실제 <a href="https://crates.io/crates/libz-sys"><code>libz-sys</code> 크레이트</a>는 시스템 라이브러리를 사용하는 대신 소스에서 빌드하기 위해 <code>LIBZ_SYS_STATIC</code> 환경 변수나 <code>static</code> 기능을 확인합니다. 더 완전한 예제는 <a href="https://github.com/rust-lang/libz-sys">소스</a> 를 확인해 보세요.</p>
<h2 id="다른-sys-크레이트-사용하기"><a class="header" href="#다른-sys-크레이트-사용하기">다른 <code>sys</code> 크레이트 사용하기</a></h2>
<p><code>links</code> 키를 사용할 때, 크레이트는 자신을 의존하는 다른 크레이트들이 읽을 수 있는 메타데이터를 설정할 수 있습니다. 이는 크레이트 간에 정보를 주고받는 메커니즘을 제공합니다. 이 예제에서는 실제 <a href="https://crates.io/crates/libz-sys"><code>libz-sys</code> 크레이트</a>의 zlib을 사용하는 C 라이브러리를 만들어 보겠습니다.</p>
<p>zlib에 의존하는 C 라이브러리가 있다면, <a href="https://crates.io/crates/libz-sys"><code>libz-sys</code> 크레이트</a> 를 활용하여 자동으로 찾거나 빌드할 수 있습니다. 이는 zlib이 보통 설치되지 않는 윈도우와 같은 환경에서 교차 플랫폼을 지원할 때 매우 유용합니다. <code>libz-sys</code> 는 다른 패키지들에게 zlib 헤더 파일의 위치를 알려주기 위해 <a href="https://github.com/rust-lang/libz-sys/blob/3c594e677c79584500da673f918c4d2101ac97a1/build.rs#L156"><code>include</code> 메타데이터를 설정</a>합니다. 우리의 빌드 스크립트는 <code>DEP_Z_INCLUDE</code> 환경 변수를 통해 해당 메타데이터를 읽을 수 있습니다. 다음은 그 예시입니다.</p>
<pre><code class="language-toml"># Cargo.toml

[package]
name = "z_user"
version = "0.1.0"
edition = "2024"

[dependencies]
libz-sys = "1.0.25"

[build-dependencies]
cc = "1.0.46"
</code></pre>
<p>여기서는 <code>libz-sys</code> 를 포함시켰는데, 이는 최종 라이브러리에서 단 하나의 <code>libz</code> 만 사용되도록 보장하며, 우리 빌드 스크립트에서 해당 라이브러리에 접근할 수 있게 해줍니다.</p>
<pre><code class="language-rust ignore">// build.rs

fn main() {
    let mut cfg = cc::Build::new();
    cfg.file("src/z_user.c");
    if let Some(include) = std::env::var_os("DEP_Z_INCLUDE") {
        cfg.include(include);
    }
    cfg.compile("z_user");
    println!("cargo::rerun-if-changed=src/z_user.c");
}</code></pre>
<p><code>libz-sys</code> 가 모든 어려운 작업을 처리해 주므로, 이제 C 소스 코드에서 zlib 헤더를 포함할 수 있으며, 시스템에 미리 설치되어 있지 않더라도 헤더를 찾을 수 있습니다.</p>
<pre><code class="language-c">// src/z_user.c

#include "zlib.h"

// … zlib을 사용하는 나머지 코드들
</code></pre>
<h2 id="조건부-컴파일"><a class="header" href="#조건부-컴파일">조건부 컴파일</a></h2>
<p>빌드 스크립트는 컴파일 타임에 확인할 수 있는 조건을 활성화하는 <a href="reference/build-scripts.html#rustc-cfg"><code>rustc-cfg</code> 지시문</a>을 내보낼 수 있습니다. 이 예제에서는 <a href="https://crates.io/crates/openssl"><code>openssl</code> 크레이트</a> 가 이를 어떻게 사용하여 여러 버전의 OpenSSL 라이브러리를 지원하는지 살펴보겠습니다.</p>
<p><a href="https://crates.io/crates/openssl-sys"><code>openssl-sys</code> 크레이트</a> 는 OpenSSL 라이브러리를 빌드하고 링크하는 기능을 구현합니다. 이 크레이트는 여러 다양한 구현체(LibreSSL 등)와 여러 버전을 지원합니다. <code>links</code> 키를 사용하여 다른 빌드 스크립트에 정보를 전달할 수 있도록 되어 있습니다. 전달하는 정보 중 하나는 감지된 OpenSSL 버전인 <code>version_number</code> 키입니다. 빌드 스크립트의 코드는 <a href="https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl-sys/build/main.rs#L216">이런 식</a>으로 되어 있습니다.</p>
<pre><code class="language-rust ignore">println!("cargo::metadata=version_number={openssl_version:x}");</code></pre>
<p>이 지시문은 <code>openssl-sys</code> 에 직접 의존하는 모든 크레이트에 <code>DEP_OPENSSL_VERSION_NUMBER</code> 환경 변수가 설정되도록 합니다.</p>
<p>고수준 인터페이스를 제공하는 <code>openssl</code> 크레이트는 <code>openssl-sys</code> 를 의존성으로 지정합니다. <code>openssl</code> 빌드 스크립트는 <code>DEP_OPENSSL_VERSION_NUMBER</code> 환경 변수를 통해 <code>openssl-sys</code> 빌드 스크립트가 생성한 버전 정보를 읽을 수 있습니다. 이를 사용하여 다음과 같이 몇 가지 <a href="https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl/build.rs#L18-L36"><code>cfg</code> 값</a>을 생성합니다.</p>
<pre><code class="language-rust ignore">// (build.rs의 일부)

println!("cargo::rustc-check-cfg=cfg(ossl101,ossl102)");
println!("cargo::rustc-check-cfg=cfg(ossl110,ossl110g,ossl111)");

if let Ok(version) = env::var("DEP_OPENSSL_VERSION_NUMBER") {
    let version = u64::from_str_radix(&amp;version, 16).unwrap();

    if version &gt;= 0x1_00_01_00_0 {
        println!("cargo::rustc-cfg=ossl101");
    }
    if version &gt;= 0x1_00_02_00_0 {
        println!("cargo::rustc-cfg=ossl102");
    }
    if version &gt;= 0x1_01_00_00_0 {
        println!("cargo::rustc-cfg=ossl110");
    }
    if version &gt;= 0x1_01_00_07_0 {
        println!("cargo::rustc-cfg=ossl110g");
    }
    if version &gt;= 0x1_01_01_00_0 {
        println!("cargo::rustc-cfg=ossl111");
    }
}</code></pre>
<p>이러한 <code>cfg</code> 값들은 <a href="reference/../../reference/conditional-compilation.html#the-cfg-attribute"><code>cfg</code> 속성</a> 이나 <a href="reference/../../std/macro.cfg.html"><code>cfg</code> 매크로</a> 와 함께 사용하여 코드를 조건부로 포함할 수 있습니다. 예를 들어, SHA3 지원은 OpenSSL 1.1.1에서 추가되었으므로, 이전 버전에서는 <a href="https://github.com/sfackler/rust-openssl/blob/dc72a8e2c429e46c275e528b61a733a66e7877fc/openssl/src/hash.rs#L67-L85">조건부로 제외</a>됩니다.</p>
<pre><code class="language-rust ignore">// (openssl 크레이트의 일부)

#[cfg(ossl111)]
pub fn sha3_224() -&gt; MessageDigest {
    unsafe { MessageDigest(ffi::EVP_sha3_224()) }
}</code></pre>
<p>물론, 이 기능을 사용할 때는 주의해야 합니다. 결과 바이너리가 빌드 환경에 더욱 종속되기 때문입니다. 이 예시에서 바이너리가 다른 시스템으로 배포될 경우, 정확히 동일한 공유 라이브러리가 없을 수 있어 문제가 발생할 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="빌드-캐시"><a class="header" href="#빌드-캐시">빌드 캐시</a></h1>
<p>Cargo stores the output of a build into the “target” and “build” directories. By default, both directories point to a directory named <code>target</code> in the root of your <a href="reference/../appendix/glossary.html#workspace" title="&quot;workspace&quot; (glossary entry)"><em>workspace</em></a>. To change the location of the target-dir, you can set the <code>CARGO_TARGET_DIR</code> <a href="reference/../reference/environment-variables.html">environment variable</a>, the <a href="reference/../reference/config.html#buildtarget-dir"><code>build.target-dir</code></a> config value, or the <code>--target-dir</code> command-line flag. To change the location of the build-dir, you can set the <code>CARGO_BUILD_BUILD_DIR</code> <a href="reference/../reference/environment-variables.html">environment variable</a> or the <a href="reference/../reference/config.html#buildbuild-dir"><code>build.build-dir</code></a> config value.</p>
<p>Artifacts are split in two categories:</p>
<ul>
<li>Final build artifacts
<ul>
<li>Final build artifacts are output meant for end users of Cargo</li>
<li>e.g. binaries for bin crates, output of <code>cargo doc</code>, Cargo <code>--timings</code> reports</li>
<li>Stored in the target-dir</li>
</ul>
</li>
<li>Intermediate build artifacts
<ul>
<li>Intermediate build artifacts are internal to Cargo and the Rust compiler</li>
<li>End users will generally not need to interact with intermediate build artifacts</li>
<li>Stored in the Cargo build-dir</li>
</ul>
</li>
</ul>
<p>디렉토리 레이아웃은 특정 플랫폼을 위해 빌드하기 위해 <code>--target</code> 플래그를 사용하는지 여부에 따라 달라집니다. <code>--target</code> 이 지정되지 않으면 Cargo는 호스트 아키텍처용으로 빌드하는 모드로 실행됩니다. 출력물은 타겟 디렉토리의 루트로 이동하며, 각 <a href="reference/../reference/profiles.html">프로파일</a> 은 별도의 하위 디렉토리에 저장됩니다.</p>
<div class="table-wrapper"><table><thead><tr><th>디렉토리</th><th>설명</th></tr></thead><tbody>
<tr><td><code style="white-space: nowrap">target/debug/</code></td><td><code>dev</code> 프로파일의 결과물을 포함합니다.</td></tr>
<tr><td><code style="white-space: nowrap">target/release/</code></td><td><code>release</code> 프로파일(<code>--release</code> 옵션 사용 시)의 결과물을 포함합니다.</td></tr>
<tr><td><code style="white-space: nowrap">target/foo/</code></td><td><code>foo</code> 프로파일(<code>--profile=foo</code> 옵션 사용 시)의 빌드 결과물을 포함합니다.</td></tr>
</tbody></table>
</div>
<p>역사적인 이유로 <code>dev</code> 및 <code>test</code> 프로파일은 <code>debug</code> 디렉토리에 저장되고, <code>release</code> 및 <code>bench</code> 프로파일은 <code>release</code> 디렉토리에 저장됩니다. 사용자 정의 프로파일은 프로파일 이름과 동일한 디렉토리에 저장됩니다.</p>
<p><code>--target</code> 을 사용하여 다른 타겟을 위해 빌드할 때, 결과물은 해당 <a href="reference/../appendix/glossary.html#target" title="&quot;타겟&quot; (용어집 항목)">타겟</a>의 이름을 딴 디렉토리에 배치됩니다.</p>
<div class="table-wrapper"><table><thead><tr><th>디렉토리</th><th>예제</th></tr></thead><tbody>
<tr><td><code style="white-space: nowrap">target/&lt;triple&gt;/debug/</code></td><td><code style="white-space: nowrap">target/thumbv7em-none-eabihf/debug/</code></td></tr>
<tr><td><code style="white-space: nowrap">target/&lt;triple&gt;/release/</code></td><td><code style="white-space: nowrap">target/thumbv7em-none-eabihf/release/</code></td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>참고</strong>: <code>--target</code> 을 사용하지 않을 경우, Cargo는 의존성을 빌드 스크립트 및 절차적 매크로와 공유하게 됩니다. <a href="reference/../reference/config.html#buildrustflags"><code>RUSTFLAGS</code></a> 는 모든 <code>rustc</code> 호출에서 공유됩니다. <code>--target</code> 플래그를 사용하면, 빌드 스크립트와 절차적 매크로는 (호스트 아키텍처용으로) 별도로 빌드되며 <code>RUSTFLAGS</code> 를 공유하지 않습니다.</p>
</blockquote>
<p>프로파일 디렉토리(<code>debug</code> 또는 <code>release</code> 등) 내에서, 결과물은 다음 디렉토리들에 배치됩니다.</p>
<div class="table-wrapper"><table><thead><tr><th>디렉토리</th><th>설명</th></tr></thead><tbody>
<tr><td><code style="white-space: nowrap">target/debug/</code></td><td>빌드 중인 패키지의 출력물(<a href="reference/../reference/cargo-targets.html#binaries">바이너리 실행 파일</a> 및 <a href="reference/../reference/cargo-targets.html#library">라이브러리 타겟</a>)을 포함합니다.</td></tr>
<tr><td><code style="white-space: nowrap">target/debug/examples/</code></td><td><a href="reference/../reference/cargo-targets.html#examples">예제 타겟</a> 을 포함합니다.</td></tr>
</tbody></table>
</div>
<p>일부 명령어는 <code>target</code> 디렉토리의 최상위 수준에 있는 전용 디렉토리에 결과물을 배치합니다.</p>
<div class="table-wrapper"><table><thead><tr><th>디렉토리</th><th>설명</th></tr></thead><tbody>
<tr><td><code style="white-space: nowrap">target/doc/</code></td><td>rustdoc 문서(<a href="reference/../commands/cargo-doc.html"><code>cargo doc</code></a>)를 포함합니다.</td></tr>
<tr><td><code style="white-space: nowrap">target/package/</code></td><td>Contains the output of the <a href="reference/../commands/cargo-package.html"><code>cargo package</code></a>.</td></tr>
</tbody></table>
</div>
<p>Cargo also creates several other directories and files in the build-dir needed for the build process. The build-dir layout is considered internal to Cargo, and is subject to change. Some of these directories are:</p>
<div class="table-wrapper"><table><thead><tr><th>디렉토리</th><th>설명</th></tr></thead><tbody>
<tr><td><code style="white-space: nowrap">&lt;build-dir&gt;/debug/deps/</code></td><td>의존성 및 기타 결과물입니다.</td></tr>
<tr><td><code style="white-space: nowrap">&lt;build-dir&gt;/debug/incremental/</code></td><td><code>rustc</code> <a href="reference/../reference/profiles.html#incremental">증분 출력</a> 으로, 이후 빌드 속도를 높이는 데 사용되는 캐시입니다.</td></tr>
<tr><td><code style="white-space: nowrap">&lt;build-dir&gt;/debug/build/</code></td><td><a href="reference/../reference/build-scripts.html">빌드 스크립트</a> 의 출력물입니다.</td></tr>
</tbody></table>
</div>
<h2 id="의존성-정보dep-info-파일"><a class="header" href="#의존성-정보dep-info-파일">의존성 정보(Dep-info) 파일</a></h2>
<p>컴파일된 각 결과물 옆에는 <code>.d</code> 접미사가 붙은 “의존성 정보(dep info)“라는 파일이 있습니다. 이 파일은 결과물을 다시 빌드하는 데 필요한 모든 파일 의존성을 나타내는 Makefile과 유사한 구문을 사용합니다. 이는 외부 빌드 시스템에서 Cargo를 다시 실행해야 하는지 감지할 수 있도록 하기 위한 것입니다. 파일 내의 경로는 기본적으로 절대 경로입니다. 상대 경로를 사용하려면 <a href="reference/../reference/config.html#builddep-info-basedir"><code>build.dep-info-basedir</code></a> 설정 옵션을 참조하세요.</p>
<pre><code class="language-Makefile"># target/debug/foo.d에서 발견된 의존성 정보 파일 예시
/path/to/myproj/target/debug/foo: /path/to/myproj/src/lib.rs /path/to/myproj/src/main.rs
</code></pre>
<h2 id="공유-캐시"><a class="header" href="#공유-캐시">공유 캐시</a></h2>
<p>제3자 도구인 <a href="https://github.com/mozilla/sccache">sccache</a> 를 사용하면 서로 다른 워크스페이스 간에 빌드된 의존성을 공유할 수 있습니다.</p>
<p>To setup <code>sccache</code>, install it with <code>cargo install sccache</code> and set <code>RUSTC_WRAPPER</code> environment variable to <code>sccache</code> before invoking Cargo. If you use bash, it makes sense to add <code>export RUSTC_WRAPPER=sccache</code> to <code>.bashrc</code>. Alternatively, you can set <a href="reference/../reference/config.html#buildrustc-wrapper"><code>build.rustc-wrapper</code></a> in the <a href="reference/../reference/config.html">Cargo configuration</a>. Refer to sccache documentation for more details.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="패키지-id-명세"><a class="header" href="#패키지-id-명세">패키지 ID 명세</a></h1>
<h2 id="패키지-id-사양package-id-specifications"><a class="header" href="#패키지-id-사양package-id-specifications">패키지 ID 사양(Package ID specifications)</a></h2>
<p>Cargo의 하위 명령어들은 업데이트, 삭제, 빌드 등 다양한 작업을 위해 의존성 그래프 내의 특정 패키지를 지칭해야 할 때가 많습니다. 이 문제를 해결하기 위해 Cargo는 <em>패키지 ID 사양(Package ID Specifications)</em> 을 지원합니다. 사양은 패키지 그래프 내에서 하나의 패키지를 고유하게 지칭하는 데 사용되는 문자열입니다.</p>
<p>The specification may be fully qualified, such as <code>registry+https://github.com/rust-lang/crates.io-index#regex@1.4.3</code> or it may be abbreviated, such as <code>regex</code>. The abbreviated form may be used as long as it uniquely identifies a single package in the dependency graph. If there is ambiguity, additional qualifiers can be added to make it unique. For example, if there are two versions of the <code>regex</code> package in the graph, then it can be qualified with a version to make it unique, such as <code>regex@1.4.3</code>.</p>
<p>Package ID specifications output by cargo, for example in <a href="reference/../commands/cargo-metadata.html">cargo metadata</a> output, are fully qualified.</p>
<h3 id="사양-문법"><a class="header" href="#사양-문법">사양 문법</a></h3>
<p>패키지 ID 사양의 공식 문법은 다음과 같습니다.</p>
<pre><code class="language-notrust">spec := pkgname |
        [ kind "+" ] proto "://" hostname-and-path [ "?" query] [ "#" ( pkgname | semver ) ]
query = ( "branch" | "tag" | "rev" ) "=" ref
pkgname := name [ ("@" | ":" ) semver ]
semver := digits [ "." digits [ "." digits [ "-" prerelease ] [ "+" build ]]]

kind = "registry" | "git" | "path"
proto := "http" | "git" | "file" | ...
</code></pre>
<p>여기서 대괄호(<code>[]</code>)는 해당 내용이 선택 사항임을 나타냅니다.</p>
<p>URL 형태는 git 의존성에 사용하거나, 서로 다른 레지스트리와 같이 출처가 다른 패키지들을 구분하는 데 사용할 수 있습니다.</p>
<h3 id="사양-예시"><a class="header" href="#사양-예시">사양 예시</a></h3>
<p>다음은 <code>crates.io</code> 에 있는 <code>regex</code> 패키지에 대한 참조 예시입니다.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">사양(Spec)</th><th style="text-align: center">이름</th><th style="text-align: center">버전</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>regex</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>*</code></td></tr>
<tr><td style="text-align: left"><code>regex@1.4</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>1.4.*</code></td></tr>
<tr><td style="text-align: left"><code>regex@1.4.3</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>1.4.3</code></td></tr>
<tr><td style="text-align: left"><code>https://github.com/rust-lang/crates.io-index#regex</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>*</code></td></tr>
<tr><td style="text-align: left"><code>https://github.com/rust-lang/crates.io-index#regex@1.4.3</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>1.4.3</code></td></tr>
<tr><td style="text-align: left"><code>registry+https://github.com/rust-lang/crates.io-index#regex@1.4.3</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>1.4.3</code></td></tr>
</tbody></table>
</div>
<p>다음은 여러 가지 git 의존성에 대한 사양 예시입니다.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">사양(Spec)</th><th style="text-align: center">이름</th><th style="text-align: center">버전</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>https://github.com/rust-lang/cargo#0.52.0</code></td><td style="text-align: center"><code>cargo</code></td><td style="text-align: center"><code>0.52.0</code></td></tr>
<tr><td style="text-align: left"><code>https://github.com/rust-lang/cargo#cargo-platform@0.1.2</code></td><td style="text-align: center"><nobr><code>cargo-platform</code></nobr></td><td style="text-align: center"><code>0.1.2</code></td></tr>
<tr><td style="text-align: left"><code>ssh://git@github.com/rust-lang/regex.git#regex@1.4.3</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>1.4.3</code></td></tr>
<tr><td style="text-align: left"><code>git+ssh://git@github.com/rust-lang/regex.git#regex@1.4.3</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>1.4.3</code></td></tr>
<tr><td style="text-align: left"><code>git+ssh://git@github.com/rust-lang/regex.git?branch=dev#regex@1.4.3</code></td><td style="text-align: center"><code>regex</code></td><td style="text-align: center"><code>1.4.3</code></td></tr>
</tbody></table>
</div>
<p>파일 시스템의 로컬 패키지는 <code>file://</code> URL을 사용하여 참조할 수 있습니다.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">사양(Spec)</th><th style="text-align: center">이름</th><th style="text-align: center">버전</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>file:///path/to/my/project/foo</code></td><td style="text-align: center"><code>foo</code></td><td style="text-align: center"><code>*</code></td></tr>
<tr><td style="text-align: left"><code>file:///path/to/my/project/foo#1.1.8</code></td><td style="text-align: center"><code>foo</code></td><td style="text-align: center"><code>1.1.8</code></td></tr>
<tr><td style="text-align: left"><code>path+file:///path/to/my/project/foo#1.1.8</code></td><td style="text-align: center"><code>foo</code></td><td style="text-align: center"><code>1.1.8</code></td></tr>
</tbody></table>
</div>
<h3 id="사양의-간결성"><a class="header" href="#사양의-간결성">사양의 간결성</a></h3>
<p>이 기능의 목표는 의존성 그래프의 패키지를 지칭하기 위해 간결하면서도 완벽한 구문을 모두 사용할 수 있게 하는 것입니다. 모호한 참조는 하나 이상의 패키지를 가리킬 수 있습니다. 대부분의 명령어는 동일한 사양으로 둘 이상의 패키지가 참조될 수 있는 경우 에러를 발생시킵니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="외부-도구"><a class="header" href="#외부-도구">외부 도구</a></h1>
<p>Cargo의 목표 중 하나는 IDE나 다른 빌드 시스템과 같은 제3자 도구와 간단하게 통합되는 것입니다. 통합을 더 쉽게 만들기 위해 Cargo는 몇 가지 기능을 제공합니다.</p>
<ul>
<li>
<p>패키지 구조와 의존성 정보를 JSON으로 출력하는 <a href="reference/../commands/cargo-metadata.html"><code>cargo metadata</code></a> 명령어,</p>
</li>
<li>
<p>특정 빌드에 대한 정보를 출력하는 <code>--message-format</code> 플래그, 그리고</p>
</li>
<li>
<p>사용자 정의 하위 명령어 지원.</p>
</li>
</ul>
<h2 id="패키지-구조-정보"><a class="header" href="#패키지-구조-정보">패키지 구조 정보</a></h2>
<p><a href="reference/../commands/cargo-metadata.html"><code>cargo metadata</code></a> 명령어를 사용하여 패키지 구조와 의존성 정보를 얻을 수 있습니다. 출력 형식에 대한 자세한 내용은 <a href="reference/../commands/cargo-metadata.html"><code>cargo metadata</code></a> 문서를 참조하세요.</p>
<p>이 형식은 안정적이며 버전이 관리됩니다. <code>cargo metadata</code> 를 호출할 때, 향후 호환성 문제를 피하기 위해 <code>--format-version</code> 플래그를 명시적으로 전달해야 합니다.</p>
<p>Rust를 사용 중이라면, <a href="https://crates.io/crates/cargo_metadata">cargo_metadata</a> 크레이트를 사용하여 출력을 파싱할 수 있습니다.</p>
<h2 id="json-메시지"><a class="header" href="#json-메시지">JSON 메시지</a></h2>
<p><code>--message-format=json</code> 을 전달하면, Cargo는 빌드 중에 다음과 같은 정보를 출력합니다.</p>
<ul>
<li>
<p>컴파일러 에러 및 경고,</p>
</li>
<li>
<p>생성된 결과물,</p>
</li>
<li>
<p>빌드 스크립트의 결과 (예: 네이티브 의존성).</p>
</li>
</ul>
<p>출력은 표준 출력(stdout)으로 줄당 하나의 JSON 객체 형식으로 나갑니다. <code>reason</code> 필드는 메시지의 종류를 구분합니다. <code>package_id</code> 필드는 패키지를 참조하기 위한 고유 식별자이며, 많은 명령어에서 <code>--package</code> 인자로 사용됩니다. 구문 문법은 <a href="reference/./pkgid-spec.html">패키지 ID 사양</a> 장에서 찾을 수 있습니다.</p>
<blockquote>
<p><strong>참고:</strong> <code>--message-format=json</code> 은 오직 Cargo와 Rustc의 출력만을 제어합니다. <code>cargo run --message-format=json</code>과 같은 다른 도구의 출력이나 프로시저럴 매크로의 임의 출력은 제어할 수 없습니다. 이러한 상황에서의 가능한 해결책은 줄이 <code>{</code> 로 시작하는 경우에만 JSON으로 해석하는 것입니다.</p>
</blockquote>
<p><code>--message-format</code> 옵션은 JSON 메시지가 계산되고 렌더링되는 방식을 변경하는 추가적인 포맷팅 값을 가질 수도 있습니다. 자세한 내용은 <a href="reference/../commands/cargo-build.html">빌드 명령어 문서</a> 의 <code>--message-format</code> 옵션 설명을 참조하세요.</p>
<p>Rust를 사용 중이라면, <a href="https://crates.io/crates/cargo_metadata">cargo_metadata</a> 크레이트를 사용하여 이 메시지들을 파싱할 수 있습니다.</p>
<blockquote>
<p><strong>MSRV:</strong> <code>package_id</code> 가 패키지 ID 사양이 되려면 1.77 버전이 필요합니다. 그 이전에는 불투명한(opaque) 값이었습니다.</p>
</blockquote>
<h3 id="컴파일러-메시지"><a class="header" href="#컴파일러-메시지">컴파일러 메시지</a></h3>
<p>“compiler-message” 메시지는 경고나 에러와 같은 컴파일러의 출력물을 포함합니다. <code>rustc</code> 의 메시지 형식에 대한 자세한 내용은 <a href="reference/../../rustc/json.html">rustc JSON 장</a> 을 참조하세요. 이 형식은 다음과 같은 구조로 포함됩니다.</p>
<pre><code class="language-javascript">{
    /* "reason"은 메시지의 종류를 나타냅니다. */
    "reason": "compiler-message",
    /* 패키지 ID는 패키지를 참조하기 위한 고유 식별자입니다. */
    "package_id": "file:///path/to/my-package#0.1.0",
    /* 패키지 매니페스트의 절대 경로입니다. */
    "manifest_path": "/path/to/my-package/Cargo.toml",
    /* 메시지를 생성한 Cargo 타겟(lib, bin, 예시 등)입니다. */
    "target": {
        /* 타겟 종류의 배열입니다.
           - lib 타겟은 매니페스트의 `crate-type` 값들(예: "lib", "rlib", "dylib", "proc-macro" 등)을 나열합니다. (기본값 ["lib"])
           - 바이너리는 ["bin"] 입니다.
           - 예시는 ["example"] 입니다.
           - 통합 테스트는 ["test"] 입니다.
           - 벤치마크는 ["bench"] 입니다.
           - 빌드 스크립트는 ["custom-build"] 입니다.
        */
        "kind": [
            "lib"
        ],
        /* 크레이트 타입의 배열입니다.
           - lib 및 예시 라이브러리는 매니페스트의 `crate-type` 값들(예: "lib", "rlib", "dylib", "proc-macro" 등)을 나열합니다. (기본값 ["lib"])
           - 그 외 모든 타겟 종류는 ["bin"] 입니다.
        */
        "crate_types": [
            "lib"
        ],
        /* 타겟의 이름입니다.
           lib 타겟의 경우 하이픈(-)은 밑줄(_)로 대체됩니다.
        */
        "name": "my_package",
        /* 타겟의 루트 소스 파일에 대한 절대 경로입니다. */
        "src_path": "/path/to/my-package/src/lib.rs",
        /* 타겟의 Rust 에디션입니다.
           기본값은 패키지 에디션입니다.
        */
        "edition": "2018",
        /* 필수 기능(feature)의 배열입니다.
           설정된 필수 기능이 없으면 이 속성은 포함되지 않습니다.
        */
        "required-features": ["feat1"],
        /* `cargo doc` 에 의해 문서화되어야 하는 타겟인지 여부입니다. */
        "doc": true,
        /* 이 타겟에 문서 테스트(doc test)가 활성화되어 있는지, 그리고
           타겟이 문서 테스트와 호환되는지 여부입니다.
        */
        "doctest": true
        /* 이 타겟을 `--test` 와 함께 빌드하고 실행해야 하는지 여부입니다. */
        "test": true
    },
    /* 컴파일러가 내보낸 메시지입니다.

    자세한 내용은 https://doc.rust-lang.org/rustc/json.html을 참조하세요.
    */
    "message": {
        /* ... */
    }
}
</code></pre>
<h3 id="결과물artifact-메시지"><a class="header" href="#결과물artifact-메시지">결과물(Artifact) 메시지</a></h3>
<p>모든 컴파일 단계에 대해, 다음과 같은 구조의 “compiler-artifact” 메시지가 내보내집니다.</p>
<pre><code class="language-javascript">{
    /* "reason"은 메시지의 종류를 나타냅니다. */
    "reason": "compiler-artifact",
    /* 패키지 ID는 패키지를 참조하기 위한 고유 식별자입니다. */
    "package_id": "file:///path/to/my-package#0.1.0",
    /* 패키지 매니페스트의 절대 경로입니다. */
    "manifest_path": "/path/to/my-package/Cargo.toml",
    /* 결과물을 생성한 Cargo 타겟(lib, bin, 예시 등)입니다.
       자세한 내용은 위의 `compiler-message` 정의를 참조하세요.
    */
    "target": {
        "kind": [
            "lib"
        ],
        "crate_types": [
            "lib"
        ],
        "name": "my_package",
        "src_path": "/path/to/my-package/src/lib.rs",
        "edition": "2018",
        "doc": true,
        "doctest": true,
        "test": true
    },
    /* 프로필은 어떤 컴파일러 설정이 사용되었는지 나타냅니다. */
    "profile": {
        /* 최적화 레벨입니다. */
        "opt_level": "0",
        /* 디버그 레벨입니다. 0, 1, 2 중 하나의 정수이거나 "line-directives-only" 또는 "line-tables-only" 문자열입니다. `null` 인 경우 rustc의 기본값인 0을 의미합니다. */
        "debuginfo": 2,
        /* 디버그 어설션(debug assertion)의 활성화 여부입니다. */
        "debug_assertions": true,
        /* 오버플로우 검사의 활성화 여부입니다. */
        "overflow_checks": true,
        /* `--test` 플래그 사용 여부입니다. */
        "test": false
    },
    /* 활성화된 기능(feature)의 배열입니다. */
    "features": ["feat1", "feat2"],
    /* 이 단계에서 생성된 파일들의 배열입니다. */
    "filenames": [
        "/path/to/my-package/target/debug/libmy_package.rlib",
        "/path/to/my-package/target/debug/deps/libmy_package-be9f3faac0a26ef0.rmeta"
    ],
    /* 생성된 실행 파일의 경로 문자열입니다. 이 단계에서 실행 파일이 생성되지 않은 경우 null입니다.
    */
    "executable": null,
    /* 이 단계가 실제로 실행되었는지 여부입니다.
       `true` 인 경우, 기존의 결과물들이 최신 상태여서 `rustc` 가 실행되지 않았음을 의미합니다.
       `false` 인 경우, 결과물을 생성하기 위해 `rustc` 가 실행되었음을 의미합니다.
    */
    "fresh": true
}

</code></pre>
<h3 id="빌드-스크립트-출력"><a class="header" href="#빌드-스크립트-출력">빌드 스크립트 출력</a></h3>
<p>“build-script-executed” 메시지는 빌드 스크립트의 파싱된 출력물을 포함합니다. 빌드 스크립트가 실행되지 않더라도 이 메시지가 내보내질 수 있음에 유의하세요. 이 경우 이전에 캐시된 값을 표시합니다. 빌드 스크립트 출력에 대한 자세한 내용은 <a href="reference/build-scripts.html">빌드 스크립트 장</a> 에서 찾을 수 있습니다.</p>
<pre><code class="language-javascript">{
    /* "reason"은 메시지의 종류를 나타냅니다. */
    "reason": "build-script-executed",
    /* 패키지 ID는 패키지를 참조하기 위한 고유 식별자입니다. */
    "package_id": "file:///path/to/my-package#0.1.0",
    /* `cargo::rustc-link-lib` 지시문에 의해 지시된, 링크할 라이브러리들의 배열입니다.
       문자열에 라이브러리 종류를 나타내는 "KIND=" 접두사가 포함될 수 있음에 유의하세요.
    */
    "linked_libs": ["foo", "static=bar"],
    /* `cargo::rustc-link-search` 지시문에 의해 지시된, 라이브러리 검색 경로에 포함할 경로들의 배열입니다.
       문자열에 라이브러리 종류를 나타내는 "KIND=" 접두사가 포함될 수 있음에 유의하세요.
    */
    "linked_paths": ["/some/path", "native=/another/path"],
    /* `cargo::rustc-cfg` 지시문에 의해 지시된, 활성화할 cfg 값들의 배열입니다. */
    "cfgs": ["cfg1", "cfg2=\"string\""],
    /* `cargo::rustc-env` 지시문에 의해 지시된, 설정할 환경 변수들의 [KEY, VALUE] 배열의 배열입니다.
    */
    "env": [
        ["SOME_KEY", "some value"],
        ["ANOTHER_KEY", "another value"]
    ],
    /* 현재 패키지를 컴파일할 때 `OUT_DIR` 환경 변수의 값으로 사용되는 절대 경로입니다.
    */
    "out_dir": "/some/path/in/target/dir"
}
</code></pre>
<h3 id="빌드-종료"><a class="header" href="#빌드-종료">빌드 종료</a></h3>
<p>“build-finished” 메시지는 빌드가 끝날 때 내보내집니다.</p>
<pre><code class="language-javascript">{
    /* "reason"은 메시지의 종류를 나타냅니다. */
    "reason": "build-finished",
    /* 빌드가 성공적으로 종료되었는지 여부입니다. */
    "success": true,
}
</code></pre>
<p>이 메시지는 도구들이 언제 JSON 메시지 읽기를 중단해야 할지 아는 데 도움이 될 수 있습니다. <code>cargo test</code> 나 <code>cargo run</code> 과 같은 명령어는 빌드가 끝난 후에도 추가적인 출력을 생성할 수 있습니다. 이 메시지는 Cargo가 더 이상 추가적인 JSON 메시지를 생성하지 않을 것임을 도구에 알려주지만, 그 이후에도 추가적인 출력(예: <code>cargo run</code> 에 의해 실행된 프로그램이 생성하는 출력)이 발생할 수 있습니다.</p>
<blockquote>
<p>참고: 테스트에 대한 JSON 출력은 실험적인 nightly 전용 기능이므로, 해당 기능이 활성화된 경우 “build-finished” 메시지 이후에도 테스트 관련 추가 JSON 메시지가 도착할 수 있습니다.</p>
</blockquote>
<h2 id="사용자-정의-하위-명령어"><a class="header" href="#사용자-정의-하위-명령어">사용자 정의 하위 명령어</a></h2>
<p>Cargo는 Cargo 자체를 수정하지 않고도 새로운 하위 명령어로 확장할 수 있도록 설계되었습니다. 이는 <code>cargo (?&lt;command&gt;[^ ]+)</code> 형식의 cargo 호출을 <code>cargo-${command}</code> 라는 외부 도구의 호출로 변환함으로써 이루어집니다. 해당 외부 도구는 사용자의 <code>$PATH</code> 디렉토리 중 하나에 존재해야 합니다.</p>
<blockquote>
<p><strong>참고</strong>: Cargo는 기본적으로 <code>$PATH</code> 보다 <code>$CARGO_HOME/bin</code> 에 있는 외부 도구의 우선순위를 높게 잡습니다. 사용자는 <code>$PATH</code> 에 <code>$CARGO_HOME/bin</code> 을 추가함으로써 이 우선순위를 덮어쓸 수 있습니다.</p>
</blockquote>
<p>Cargo가 사용자 정의 하위 명령어를 호출할 때, 하위 명령어의 첫 번째 인자는 평소와 같이 해당 하위 명령어의 파일 이름이 됩니다. 두 번째 인자는 하위 명령어 이름 자체가 됩니다. 예를 들어, <code>cargo-${command}</code> 를 호출할 때 두 번째 인자는 <code>${command}</code> 가 됩니다. 커맨드 라인의 추가적인 인자들은 변경 없이 그대로 전달됩니다.</p>
<p>Cargo는 또한 <code>cargo help ${command}</code> 를 통해 사용자 정의 하위 명령어의 도움말을 표시할 수 있습니다. Cargo는 하위 명령어의 세 번째 인자가 <code>--help</code> 인 경우 도움말 메시지를 출력할 것이라고 가정합니다. 따라서 <code>cargo help ${command}</code>는 <code>cargo-${command} ${command} --help</code> 를 호출하게 됩니다.</p>
<p>사용자 정의 하위 명령어는 <code>CARGO</code> 환경 변수를 사용하여 Cargo를 다시 호출할 수 있습니다. 또는 <code>cargo</code> 크레이트를 라이브러리로 링크할 수도 있지만, 이 방식은 다음과 같은 단점이 있습니다.</p>
<ul>
<li>라이브러리로서의 Cargo는 불안정합니다. API가 예고 없이 변경될 수 있습니다.</li>
<li>링크된 Cargo 라이브러리의 버전이 Cargo 바이너리의 버전과 다를 수 있습니다.</li>
</ul>
<p>대신, CLI 인터페이스를 사용하여 Cargo를 구동하는 것이 권장됩니다. <a href="reference/../commands/cargo-metadata.html"><code>cargo metadata</code></a> 명령어를 사용하여 현재 프로젝트에 대한 정보를 얻을 수 있습니다. (<a href="https://crates.io/crates/cargo_metadata"><code>cargo_metadata</code></a> 크레이트는 이 명령어에 대한 Rust 인터페이스를 제공합니다.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레지스트리"><a class="header" href="#레지스트리">레지스트리</a></h1>
<p>Cargo는 “레지스트리“로부터 크레이트를 설치하고 의존성을 가져옵니다. 기본 레지스트리는 <a href="https://crates.io/">crates.io</a>입니다. 레지스트리는 사용 가능한 크레이트의 검색 가능한 목록인 “인덱스“를 포함합니다. 또한 레지스트리는 Cargo에서 직접 새로운 크레이트를 배포할 수 있도록 웹 API를 제공할 수도 있습니다.</p>
<blockquote>
<p>참고: 기존 레지스트리를 미러링하거나 벤더링(vendoring)하는 데 관심이 있다면 <a href="reference/source-replacement.html">소스 대체(Source Replacement)</a>를 살펴보세요.</p>
</blockquote>
<p>레지스트리 서버를 구현하는 경우, Cargo와 레지스트리 사이의 프로토콜에 대한 자세한 내용은 <a href="reference/running-a-registry.html">레지스트리 운영(Running a Registry)</a>을 참조하세요.</p>
<p>인증이 필요한 레지스트리를 사용하는 경우 <a href="reference/registry-authentication.html">레지스트리 인증(Registry Authentication)</a>을 참조하세요. 자격 증명 제공자(credential provider)를 구현하는 경우 자세한 내용은 <a href="reference/credential-provider-protocol.html">자격 증명 제공자 프로토콜(Credential Provider Protocol)</a> 을 참조하세요.</p>
<h2 id="대체-레지스트리-사용하기"><a class="header" href="#대체-레지스트리-사용하기">대체 레지스트리 사용하기</a></h2>
<p><a href="https://crates.io/">crates.io</a> 이외의 레지스트리를 사용하려면, 레지스트리의 이름과 인덱스 URL을 <a href="reference/config.html"><code>.cargo/config.toml</code> 파일</a> 에 추가해야 합니다. <code>registries</code> 테이블은 각 레지스트리에 대한 키를 가집니다. 예시는 다음과 같습니다.</p>
<pre><code class="language-toml">[registries]
my-registry = { index = "https://my-intranet:8080/git/index" }
</code></pre>
<p><code>index</code> 키는 레지스트리 인덱스가 포함된 git 저장소의 URL이거나, <code>sparse+</code> 접두사가 붙은 Cargo sparse 레지스트리 URL이어야 합니다.</p>
<p>그러면 크레이트는 <code>Cargo.toml</code> 의 의존성 항목에 <code>registry</code> 키와 해당 레지스트리의 이름을 지정하여 다른 레지스트리의 크레이트에 의존할 수 있습니다.</p>
<pre><code class="language-toml"># Sample Cargo.toml
[package]
name = "my-project"
version = "0.1.0"
edition = "2024"

[dependencies]
other-crate = { version = "1.0", registry = "my-registry" }
</code></pre>
<p>대부분의 설정값과 마찬가지로, 인덱스는 설정 파일 대신 환경 변수로 지정할 수 있습니다. 예를 들어, 다음과 같은 환경 변수를 설정하는 것은 설정 파일을 정의하는 것과 동일한 효과를 냅니다.</p>
<pre><code class="language-ignore">CARGO_REGISTRIES_MY_REGISTRY_INDEX=https://my-intranet:8080/git/index
</code></pre>
<blockquote>
<p>참고: <a href="https://crates.io/">crates.io</a> 는 다른 레지스트리의 크레이트에 의존하는 패키지를 허용하지 않습니다.</p>
</blockquote>
<h2 id="대체-레지스트리에-배포하기"><a class="header" href="#대체-레지스트리에-배포하기">대체 레지스트리에 배포하기</a></h2>
<p>레지스트리가 웹 API 접근을 지원한다면, Cargo를 통해 패키지를 레지스트리에 직접 배포할 수 있습니다. <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a> 와 같은 몇몇 Cargo 명령어는 사용할 레지스트리를 지정하기 위해 <code>--registry</code> 커맨드 라인 플래그를 받습니다. 예를 들어, 현재 디렉토리의 패키지를 배포하려면 다음과 같이 합니다.</p>
<ol>
<li>
<p><code>cargo login --registry=my-registry</code></p>
<p>이는 한 번만 수행하면 됩니다. 레지스트리 웹사이트에서 가져온 비밀 API 토큰을 입력해야 합니다. 또는 <code>--token</code> 커맨드 라인 플래그를 사용해 <code>publish</code> 명령어에 토큰을 직접 전달하거나, <code>CARGO_REGISTRIES_MY_REGISTRY_TOKEN</code> 과 같이 레지스트리 이름이 포함된 환경 변수를 사용할 수도 있습니다.</p>
</li>
<li>
<p><code>cargo publish --registry=my-registry</code></p>
</li>
</ol>
<p>매번 <code>--registry</code> 커맨드 라인 옵션을 전달하는 대신, <a href="reference/config.html"><code>.cargo/config.toml</code></a> 의 <code>registry.default</code> 키를 사용하여 기본 레지스트리를 설정할 수 있습니다. 예를 들면 다음과 같습니다.</p>
<pre><code class="language-toml">[registry]
default = "my-registry"
</code></pre>
<p><code>Cargo.toml</code> 매니페스트에서 <code>package.publish</code> 키를 설정하면 패키지를 배포할 수 있는 레지스트리를 제한할 수 있습니다. 이는 소스코드가 공개되지 않은 패키지를 실수로 <a href="https://crates.io/">crates.io</a> 에 배포하는 것을 방지하는 데 유용합니다. 값은 레지스트리 이름의 리스트가 될 수 있습니다. 예시는 다음과 같습니다.</p>
<pre><code class="language-toml">[package]
# ...
publish = ["my-registry"]
</code></pre>
<p><code>publish</code> 값을 <code>false</code> 로 설정하면 모든 배포가 제한되며, 이는 빈 리스트를 지정하는 것과 같습니다.</p>
<p><a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> 에 의해 저장된 인증 정보는 Cargo 홈 디렉토리(기본값 <code>$HOME/.cargo</code>)의 <code>credentials.toml</code> 파일에 저장됩니다. 각 레지스트리별로 별도의 테이블을 가집니다. 예시는 다음과 같습니다.</p>
<pre><code class="language-toml">[registries.my-registry]
token = "854DvwSlUwEHtIo3kWy6x7UCPKHfzCmy"
</code></pre>
<h2 id="레지스트리-프로토콜"><a class="header" href="#레지스트리-프로토콜">레지스트리 프로토콜</a></h2>
<p>Cargo는 <code>git</code> 과 <code>sparse</code> 두 가지 원격 레지스트리 프로토콜을 지원합니다. 레지스트리 인덱스 URL이 <code>sparse+</code> 로 시작하면 Cargo는 sparse 프로토콜을 사용합니다. 그렇지 않으면 Cargo는 <code>git</code> 프로토콜을 사용합니다.</p>
<p><code>git</code> 프로토콜은 인덱스 메타데이터를 git 저장소에 저장하며, Cargo가 전체 저장소를 복제(clone)해야 합니다.</p>
<p><code>sparse</code> 프로토콜은 일반 HTTP 요청을 사용하여 개별 메타데이터 파일을 가져옵니다. Cargo는 관련 있는 크레이트의 메타데이터만 다운로드하므로, <code>sparse</code> 프로토콜은 시간과 대역폭을 크게 절약할 수 있습니다.</p>
<p><a href="https://crates.io/">crates.io</a> 레지스트리는 두 프로토콜을 모두 지원합니다. crates.io에 대한 프로토콜은 <a href="reference/config.html#registriescrates-ioprotocol"><code>registries.crates-io.protocol</code></a> 설정 키를 통해 제어됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레지스트리-인증"><a class="header" href="#레지스트리-인증">레지스트리 인증</a></h1>
<p>Cargo는 자격 증명 제공자(credential provider)를 통해 레지스트리에 인증합니다. 이 자격 증명 제공자들은 Cargo가 자격 증명을 저장하고 검색하는 데 사용하는 외부 실행 파일 또는 내장 제공자입니다.</p>
<p>인증이 필요한 대체 레지스트리를 사용하려면, 암호화되지 않은 자격 증명이 디스크에 저장되는 것을 방지하기 위해 자격 증명 제공자를 반드시 설정해야 합니다. 역사적인 이유로 공개(비인증) 레지스트리는 자격 증명 제공자 설정을 요구하지 않으며, 설정된 제공자가 없는 경우 <code>cargo:token</code> 제공자가 사용됩니다.</p>
<p>Cargo는 또한 운영 체제를 사용하여 토큰을 안전하게 저장하는 플랫폼별 제공자들을 포함하고 있습니다. <a href="reference/config.html#credentials">credentials</a> 파일에 암호화되지 않은 평문으로 자격 증명을 저장하는 <code>cargo:token</code> 제공자도 포함되어 있습니다.</p>
<h2 id="권장-설정"><a class="header" href="#권장-설정">권장 설정</a></h2>
<p><code>$CARGO_HOME/config.toml</code> 에 전역 자격 증명 제공자 리스트를 설정하는 것이 권장되며, 기본값은 다음과 같습니다.</p>
<ul>
<li>Windows: <code>%USERPROFILE%\.cargo\config.toml</code></li>
<li>Unix: <code>~/.cargo/config.toml</code></li>
</ul>
<p>이 권장 설정은 운영 체제 제공자를 사용하며, 실패할 경우 Cargo의 <a href="reference/config.html#credentials">credentials</a> 파일이나 환경 변수를 확인하는 <code>cargo:token</code> 으로 폴백(fallback)합니다.</p>
<pre><code class="language-toml"># ~/.cargo/config.toml
[registry]
global-credential-providers = ["cargo:token", "cargo:libsecret", "cargo:macos-keychain", "cargo:wincred"]
</code></pre>
<p><em>뒤에 있는 항목일수록 우선순위가 높음에 유의하세요. 자세한 내용은 <a href="reference/config.html#registryglobal-credential-providers"><code>registry.global-credential-providers</code></a>를 참조하세요.</em></p>
<p>일부 프라이빗 레지스트리는 레지스트리 전용 자격 증명 제공자를 권장할 수도 있습니다. 사용하는 레지스트리의 문서를 확인하여 해당되는지 살펴보세요.</p>
<h2 id="내장-제공자"><a class="header" href="#내장-제공자">내장 제공자</a></h2>
<p>Cargo는 여러 가지 내장 자격 증명 제공자를 포함하고 있습니다. 사용 가능한 내장 제공자는 향후 Cargo 릴리스에서 변경될 수 있습니다 (현재로서는 변경 계획이 없습니다).</p>
<h3 id="cargotoken"><a class="header" href="#cargotoken"><code>cargo:token</code></a></h3>
<p>Cargo의 <a href="reference/config.html#credentials">credentials</a> 파일을 사용하여 토큰을 암호화되지 않은 평문으로 저장합니다. 토큰을 검색할 때 <code>CARGO_REGISTRIES_&lt;NAME&gt;_TOKEN</code> 환경 변수를 확인합니다. 이 자격 증명 제공자가 리스트에 없으면 <code>*_TOKEN</code> 환경 변수는 작동하지 않습니다.</p>
<h3 id="cargowincred"><a class="header" href="#cargowincred"><code>cargo:wincred</code></a></h3>
<p>Windows 자격 증명 관리자(Credential Manager)를 사용하여 토큰을 저장합니다.</p>
<p>자격 증명은 자격 증명 관리자의 “Windows 자격 증명” 아래에 <code>cargo-registry:&lt;index-url&gt;</code> 로 저장됩니다.</p>
<h3 id="cargomacos-keychain"><a class="header" href="#cargomacos-keychain"><code>cargo:macos-keychain</code></a></h3>
<p>macOS 키체인을 사용하여 토큰을 저장합니다.</p>
<p>키체인 접근(Keychain Access) 앱을 사용하여 저장된 토큰을 볼 수 있습니다.</p>
<h3 id="cargolibsecret"><a class="header" href="#cargolibsecret"><code>cargo:libsecret</code></a></h3>
<p><a href="https://wiki.gnome.org/Projects/Libsecret">libsecret</a> 를 사용하여 토큰을 저장합니다.</p>
<p>libsecret을 지원하는 모든 비밀번호 관리자를 사용하여 저장된 토큰을 볼 수 있습니다. 다음은 몇 가지 예시입니다 (전체 목록은 아님):</p>
<ul>
<li><a href="https://wiki.gnome.org/Projects/GnomeKeyring">그놈 키링(GNOME Keyring)</a></li>
<li><a href="https://apps.kde.org/kwalletmanager5/">KDE 지갑 관리자(KDE Wallet Manager)</a> (KDE Frameworks 5.97.0부터)</li>
<li><a href="https://keepassxc.org/">KeePassXC</a> (2.5.0부터)</li>
</ul>
<h3 id="cargotoken-from-stdout-command-args"><a class="header" href="#cargotoken-from-stdout-command-args"><code>cargo:token-from-stdout &lt;command&gt; &lt;args&gt;</code></a></h3>
<p>표준 출력(stdout)으로 토큰을 반환하는 하위 프로세스를 실행합니다. 줄바꿈 문자는 제거됩니다.</p>
<ul>
<li>프로세스는 사용자의 표준 입력(stdin)과 표준 에러(stderr)를 상속받습니다.</li>
<li>성공 시 0을 반환하고 종료해야 하며, 에러 발생 시 0이 아닌 값을 반환해야 합니다.</li>
<li><a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> 및 <a href="reference/../commands/cargo-logout.html"><code>cargo logout</code></a>은 지원되지 않으며 사용 시 에러를 반환합니다.</li>
</ul>
<p>실행되는 명령어에는 다음과 같은 환경 변수들이 제공됩니다.</p>
<ul>
<li><code>CARGO</code> — 명령어를 실행 중인 <code>cargo</code> 바이너리의 경로입니다.</li>
<li><code>CARGO_REGISTRY_INDEX_URL</code> — 레지스트리 인덱스의 URL입니다.</li>
<li><code>CARGO_REGISTRY_NAME_OPT</code> — (선택 사항) 레지스트리의 이름입니다. 검색 키(lookup key)로 사용되어서는 안 됩니다.</li>
</ul>
<p>인자들은 하위 명령어로 그대로 전달됩니다.</p>
<h2 id="자격-증명-플러그인"><a class="header" href="#자격-증명-플러그인">자격 증명 플러그인</a></h2>
<p>Cargo의 <a href="reference/credential-provider-protocol.html">자격 증명 제공자 프로토콜(credential provider protocol)</a>을 따르는 자격 증명 제공자 플러그인의 경우, 설정값은 실행 파일의 경로(또는 <code>PATH</code> 에 있는 경우 실행 파일 이름) 문자열이어야 합니다.</p>
<p>예를 들어, crates.io에서 <a href="https://crates.io/crates/cargo-credential-1password">cargo-credential-1password</a>를 설치하려면 다음과 같이 하세요.</p>
<p><code>cargo install cargo-credential-1password</code> 명령어로 제공자를 설치합니다.</p>
<p>설정 파일에서 <code>registry.global-credential-providers</code> 에 다음을 추가(또는 생성)합니다.</p>
<pre><code class="language-toml">[registry]
global-credential-providers = ["cargo:token", "cargo-credential-1password --account my.1password.com"]
</code></pre>
<p><code>global-credential-providers</code> 에 들어가는 값들은 공백을 기준으로 경로와 커맨드 라인 인자로 나뉩니다. 경로 혹은 인자에 공백이 포함된 전역 자격 증명 제공자를 정의하려면, <a href="reference/config.html#credential-alias"><code>[credential-alias]</code> 테이블</a>을 사용하세요.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="자격-증명-제공자-프로토콜"><a class="header" href="#자격-증명-제공자-프로토콜">자격 증명 제공자 프로토콜</a></h1>
<p>이 문서는 Cargo 자격 증명 제공자(credential provider)를 빌드하기 위한 정보를 설명합니다. 자격 증명 제공자를 설정하거나 사용하는 방법에 대한 정보는 <a href="reference/registry-authentication.html">레지스트리 인증(Registry Authentication)</a>을 참조하세요.</p>
<p>외부 자격 증명 제공자를 사용할 때, Cargo는 한 줄의 JSON으로 전달되는 stdin/stdout 메시지를 사용하여 자격 증명 제공자와 통신합니다.</p>
<p>Cargo는 항상 자격 증명 제공자를 <code>--cargo-plugin</code> 인자와 함께 실행합니다. 이를 통해 자격 증명 제공자 실행 파일이 Cargo가 필요로 하는 것 이상의 추가 기능을 가질 수 있습니다. 추가 인자들은 JSON의 <code>args</code> 필드를 통해 포함됩니다.</p>
<h2 id="json-메시지-1"><a class="header" href="#json-메시지-1">JSON 메시지</a></h2>
<p>이 문서의 JSON 메시지에는 가독성을 위해 줄바꿈이 추가되었습니다. 실제 메시지에는 줄바꿈이 포함되어서는 안 됩니다.</p>
<h3 id="자격-증명-헬로credential-hello"><a class="header" href="#자격-증명-헬로credential-hello">자격 증명 헬로(Credential hello)</a></h3>
<ul>
<li>보낸 사람: 자격 증명 제공자</li>
<li>용도: 프로세스 시작 시 지원되는 프로토콜을 식별하는 데 사용됨</li>
</ul>
<pre><code class="language-javascript">{
    "v":[1]
}
</code></pre>
<p>Cargo가 보내는 요청에는 여기에 나열된 버전 중 하나로 설정된 <code>v</code> 필드가 포함됩니다. 만약 Cargo가 자격 증명 제공자가 제안한 버전 중 어느 것도 지원하지 않는다면, 에러를 발생시키고 자격 증명 프로세스를 종료합니다.</p>
<h3 id="레지스트리-정보"><a class="header" href="#레지스트리-정보">레지스트리 정보</a></h3>
<ul>
<li>보낸 사람: Cargo. 그 자체로 하나의 메시지는 아닙니다. Cargo가 보내는 모든 메시지에 <code>registry</code> 필드로 포함됩니다.</li>
</ul>
<pre><code class="language-javascript">{
    // 레지스트리의 인덱스 URL
    "index-url":"https://github.com/rust-lang/crates.io-index",
    // 설정에서의 레지스트리 이름 (선택 사항)
    "name": "crates-io",
    // 인증이 필요한 레지스트리에 접근을 시도하며 받은 HTTP 헤더 (선택 사항)
    "headers": ["WWW-Authenticate: cargo"]
}
</code></pre>
<h3 id="로그인-요청"><a class="header" href="#로그인-요청">로그인 요청</a></h3>
<ul>
<li>보낸 사람: Cargo</li>
<li>용도: 자격 증명 수집 및 저장</li>
</ul>
<pre><code class="language-javascript">{
    // 프로토콜 버전
    "v":1,
    // 수행할 작업: 로그인
    "kind":"login",
    // 레지스트리 정보 (레지스트리 정보 참조)
    "registry":{"index-url":"sparse+https://registry-url/index/", "name": "my-registry"},
    // 표준 입력 혹은 커맨드 라인에서 사용자가 지정한 토큰 (선택 사항)
    "token": "&lt;토큰 값&gt;",
    // 사용자가 토큰을 받기 위해 방문할 수 있는 URL (선택 사항)
    "login-url": "http://registry-url/login",
    // 추가적인 커맨드 라인 인자 (선택 사항)
    "args":[]
}
</code></pre>
<p><code>token</code> 필드가 설정되어 있다면, 자격 증명 제공자는 제공된 토큰을 사용해야 합니다. <code>token</code> 이 설정되어 있지 않다면, 자격 증명 제공자는 사용자에게 토큰 입력을 요청해야 합니다.</p>
<p>설정에 따라 자격 증명 제공자에게 전달될 수 있는 인자 외에도, <code>cargo login</code> 은 <code>cargo login -- &lt;추가 인자&gt;</code> 를 통해 추가적인 커맨드 라인 인자를 전달하는 것을 지원합니다. 이러한 추가 인자들은 Cargo 설정에 있는 인자들 뒤에 JSON의 <code>args</code> 필드에 포함됩니다.</p>
<h3 id="읽기-요청"><a class="header" href="#읽기-요청">읽기 요청</a></h3>
<ul>
<li>보낸 사람: Cargo</li>
<li>용도: 크레이트 정보를 읽기 위한 자격 증명 가져오기</li>
</ul>
<pre><code class="language-javascript">{
    // 프로토콜 버전
    "v":1,
    // 요청 종류: 자격 증명 가져오기
    "kind":"get",
    // 수행할 작업: 크레이트 정보 읽기
    "operation":"read",
    // 레지스트리 정보 (레지스트리 정보 참조)
    "registry":{"index-url":"sparse+https://registry-url/index/", "name": "my-registry"},
    // 추가적인 커맨드 라인 인자 (선택 사항)
    "args":[]
}
</code></pre>
<h3 id="배포-요청"><a class="header" href="#배포-요청">배포 요청</a></h3>
<ul>
<li>보낸 사람: Cargo</li>
<li>용도: 크레이트 배포를 위한 자격 증명 가져오기</li>
</ul>
<pre><code class="language-javascript">{
    // 프로토콜 버전
    "v":1,
    // 요청 종류: 자격 증명 가져오기
    "kind":"get",
    // 수행할 작업: 크레이트 배포
    "operation":"publish",
    // 크레이트 이름
    "name":"sample",
    // 크레이트 버전
    "vers":"0.1.0",
    // 크레이트 체크섬
    "cksum":"...",
    // 레지스트리 정보 (레지스트리 정보 참조)
    "registry":{"index-url":"sparse+https://registry-url/index/", "name": "my-registry"},
    // 추가적인 커맨드 라인 인자 (선택 사항)
    "args":[]
}
</code></pre>
<h3 id="get-성공-응답"><a class="header" href="#get-성공-응답">Get 성공 응답</a></h3>
<ul>
<li>보낸 사람: 자격 증명 제공자</li>
<li>용도: Cargo에 자격 증명 제공</li>
</ul>
<pre><code class="language-javascript">{"Ok":{
    // 응답 종류: get 요청에 대한 응답임
    "kind":"get",
    // 레지스트리로 보낼 토큰
    "token":"...",
    // 캐시 제어. 다음 중 하나일 수 있습니다:
    // * "never": 캐시하지 않음
    // * "session": 현재 cargo 세션 동안 캐시
    // * "expires": 만료될 때까지 현재 cargo 세션 동안 캐시
    "cache":"expires",
    // 유닉스 타임스탬프 ("cache": "expires"인 경우에만 해당)
    "expiration":1693942857,
    // 토큰이 작업에 독립적인가요?
    "operation_independent":true
}}
</code></pre>
<p><code>token</code> 은 <code>Authorization</code> HTTP 헤더의 값으로 레지스트리에 전송됩니다.</p>
<p><code>operation_independent</code> 는 토큰이 서로 다른 작업(예: 배포 혹은 가져오기) 간에 캐시될 수 있는지 여부를 나타냅니다. 일반적으로 제공자가 특정 작업으로 범위가 한정된 토큰을 생성하려는 것이 아니라면 이는 <code>true</code> 여야 합니다.</p>
<h3 id="로그인-성공-응답"><a class="header" href="#로그인-성공-응답">로그인 성공 응답</a></h3>
<ul>
<li>보낸 사람: 자격 증명 제공자</li>
<li>용도: 로그인이 성공했음을 나타냄</li>
</ul>
<pre><code class="language-javascript">{"Ok":{
    // 응답 종류: 로그인 요청에 대한 응답임
    "kind":"login"
}}
</code></pre>
<h3 id="로그아웃-성공-응답"><a class="header" href="#로그아웃-성공-응답">로그아웃 성공 응답</a></h3>
<ul>
<li>보낸 사람: 자격 증명 제공자</li>
<li>용도: 로그아웃이 성공했음을 나타냄</li>
</ul>
<pre><code class="language-javascript">{"Ok":{
    // 응답 종류: 로그아웃 요청에 대한 응답임
    "kind":"logout"
}}
</code></pre>
<h3 id="실패-응답-url-미지원"><a class="header" href="#실패-응답-url-미지원">실패 응답 (URL 미지원)</a></h3>
<ul>
<li>보낸 사람: 자격 증명 제공자</li>
<li>용도: Cargo에 에러 정보 제공</li>
</ul>
<pre><code class="language-javascript">{"Err":{
    "kind":"url-not-supported"
}}
</code></pre>
<p>자격 증명 제공자가 특정 레지스트리 URL만 처리하도록 설계되었으나 주어진 URL을 지원하지 않는 경우 전송됩니다. Cargo는 가능한 경우 다른 제공자를 시도합니다.</p>
<h3 id="실패-응답-찾을-수-없음"><a class="header" href="#실패-응답-찾을-수-없음">실패 응답 (찾을 수 없음)</a></h3>
<ul>
<li>보낸 사람: 자격 증명 제공자</li>
<li>용도: Cargo에 에러 정보 제공</li>
</ul>
<pre><code class="language-javascript">{"Err":{
    // 에러: 제공자에서 자격 증명을 찾을 수 없습니다.
    "kind":"not-found"
}}
</code></pre>
<p>자격 증명을 찾을 수 없을 때 전송됩니다. 자격 증명을 사용할 수 없는 <code>get</code> 요청이나, 삭제할 항목을 찾을 수 없는 <code>logout</code> 요청 시에 발생할 수 있는 정상적인 응답입니다.</p>
<h3 id="실패-응답-지원되지-않는-작업"><a class="header" href="#실패-응답-지원되지-않는-작업">실패 응답 (지원되지 않는 작업)</a></h3>
<ul>
<li>보낸 사람: 자격 증명 제공자</li>
<li>용도: Cargo에 에러 정보 제공</li>
</ul>
<pre><code class="language-javascript">{"Err":{
    // 에러: 제공자에서 자격 증명을 찾을 수 없습니다.
    "kind":"operation-not-supported"
}}
</code></pre>
<p>자격 증명 제공자가 요청된 작업을 지원하지 않을 때 전송됩니다. 예를 들어 제공자가 <code>get</code> 만 지원하는데 <code>login</code> 이 요청된 경우, 제공자는 이 에러로 응답해야 합니다.</p>
<h3 id="실패-응답-기타"><a class="header" href="#실패-응답-기타">실패 응답 (기타)</a></h3>
<ul>
<li>보낸 사람: 자격 증명 제공자</li>
<li>용도: Cargo에 에러 정보 제공</li>
</ul>
<pre><code class="language-javascript">{"Err":{
    // 에러: 다른 이유로 실패했습니다.
    "kind":"other",
    // 표시될 에러 메시지 문자열
    "message": "자유 형식의 에러 메시지 문자열",
    // 에러에 대한 상세 원인 체인 (선택 사항)
    "caused-by": ["원인 1", "원인 2"]
}}
</code></pre>
<h2 id="읽기-작업을-위한-토큰-요청-시의-통신-예시"><a class="header" href="#읽기-작업을-위한-토큰-요청-시의-통신-예시">읽기 작업을 위한 토큰 요청 시의 통신 예시:</a></h2>
<ol>
<li>
<p>Cargo가 자격 증명 프로세스를 생성하고 표준 입력 및 출력을 캡처합니다.</p>
</li>
<li>
<p>자격 증명 프로세스가 Cargo에 Hello 메시지를 보냅니다.</p>
<pre><code class="language-javascript">{ "v": [1] }
</code></pre>
</li>
<li>
<p>Cargo가 자격 증명 프로세스에 CredentialRequest 메시지를 보냅니다 (가독성을 위해 줄바꿈이 추가됨).</p>
<pre><code class="language-javascript">{
    "v": 1,
    "kind": "get",
    "operation": "read",
    "registry":{"index-url":"sparse+https://registry-url/index/"}
}
</code></pre>
</li>
<li>
<p>자격 증명 프로세스가 Cargo에 CredentialResponse를 보냅니다 (가독성을 위해 줄바꿈이 추가됨).</p>
<pre><code class="language-javascript">{
    "token": "...",
    "cache": "session",
    "operation_independent": true
}
</code></pre>
</li>
<li>
<p>Cargo가 자격 증명 제공자와의 stdin 파이프를 닫고 프로세스가 종료됩니다.</p>
</li>
<li>
<p>Cargo는 이 레지스트리와 상호작용할 때 세션이 끝날 때까지(Cargo가 종료될 때까지) 이 토큰을 사용합니다.</p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="레지스트리-운영하기"><a class="header" href="#레지스트리-운영하기">레지스트리 운영하기</a></h1>
<p>최소한의 기능을 갖춘 레지스트리는 인덱스를 포함하는 git 저장소와 <a href="reference/../commands/cargo-package.html"><code>cargo package</code></a>에 의해 생성된 압축된 <code>.crate</code> 파일들을 가진 서버만으로 구현할 수 있습니다. 사용자가 Cargo를 사용해 해당 레지스트리에 패키지를 배포할 수는 없지만, 폐쇄된 환경에서는 이것으로 충분할 수 있습니다. 인덱스 형식은 <a href="reference/registry-index.html">레지스트리 인덱스(Registry Index)</a>에 설명되어 있습니다.</p>
<p>배포를 지원하는 모든 기능을 갖춘 레지스트리는 추가적으로 Cargo에서 사용하는 API를 따르는 웹 API 서비스가 필요합니다. 웹 API는 <a href="reference/registry-web-api.html">레지스트리 웹 API(Registry Web API)</a> 에 설명되어 있습니다.</p>
<p>레지스트리를 구축하고 운영하기 위한 상용 및 커뮤니티 프로젝트들이 존재합니다. 사용 가능한 프로젝트 목록은 <a href="https://github.com/rust-lang/cargo/wiki/Third-party-registries">https://github.com/rust-lang/cargo/wiki/Third-party-registries</a>에서 확인할 수 있습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="인덱스-형식"><a class="header" href="#인덱스-형식">인덱스 형식</a></h1>
<p>다음은 인덱스의 형식을 정의합니다. 새로운 기능이 가끔 추가되는데, 이는 해당 기능을 도입한 Cargo 버전부터 이해할 수 있습니다. 오래된 버전의 Cargo는 새로운 기능을 사용하는 패키지를 사용하지 못할 수도 있습니다. 하지만 오래된 패키지에 대한 형식은 변경되지 않아야 하며, 따라서 오래된 버전의 Cargo도 이를 사용할 수 있어야 합니다.</p>
<h2 id="인덱스-설정"><a class="header" href="#인덱스-설정">인덱스 설정</a></h2>
<p>인덱스의 루트에는 Cargo가 레지스트리에 접근할 때 사용하는 JSON 정보가 포함된 <code>config.json</code> 파일이 있습니다. 다음은 <a href="https://crates.io/">crates.io</a> 설정 파일의 예시입니다.</p>
<pre><code class="language-javascript">{
    "dl": "https://crates.io/api/v1/crates",
    "api": "https://crates.io"
}
</code></pre>
<p>키는 다음과 같습니다.</p>
<ul>
<li>
<p><code>dl</code>: 인덱스에 나열된 크레이트를 다운로드하기 위한 URL입니다. 이 값은 대응하는 값으로 대체될 다음과 같은 마커들을 가질 수 있습니다.</p>
<ul>
<li><code>{crate}</code>: 크레이트의 이름입니다.</li>
<li><code>{version}</code>: 크레이트 버전입니다.</li>
<li><code>{prefix}</code>: 크레이트 이름으로부터 계산된 디렉토리 접두사입니다. 예를 들어, 이름이 <code>cargo</code> 인 크레이트는 <code>ca/rg</code> 라는 접두사를 가집니다. 자세한 내용은 아래를 참조하세요.</li>
<li><code>{lowerprefix}</code>: <code>{prefix}</code> 의 소문자 형태입니다.</li>
<li><code>{sha256-checksum}</code>: 크레이트의 sha256 체크섬입니다.
마커가 하나도 없는 경우, 값 끝에 <code>/{crate}/{version}/download</code> 가 추가됩니다.</li>
</ul>
</li>
<li>
<p><code>api</code>: 웹 API의 기본 URL입니다. 이 키는 선택 사항이지만, 지정하지 않으면 <a href="reference/../commands/cargo-publish.html"><code>cargo publish</code></a>와 같은 명령어가 작동하지 않습니다. 웹 API는 아래에 설명되어 있습니다.</p>
</li>
<li>
<p><code>auth-required</code>: API 요청, 크레이트 다운로드, sparse 인덱스 업데이트를 포함한 모든 작업에 인증이 필요한 프라이빗 레지스트리인지 여부를 나타냅니다.</p>
</li>
</ul>
<h2 id="다운로드-엔드포인트"><a class="header" href="#다운로드-엔드포인트">다운로드 엔드포인트</a></h2>
<p>다운로드 엔드포인트는 요청된 패키지의 <code>.crate</code> 파일을 전송해야 합니다. Cargo는 https, http, file URL 및 HTTP 리다이렉트, HTTP1, HTTP2를 지원합니다. TLS 지원에 대한 구체적인 사항은 Cargo가 실행 중인 플랫폼, Cargo 버전 및 컴파일 방식에 따라 달라집니다.</p>
<p><code>config.json</code> 에 <code>auth-required: true</code> 가 설정된 경우, http(s) 다운로드 요청에 <code>Authorization</code> 헤더가 포함됩니다.</p>
<h2 id="인덱스-파일"><a class="header" href="#인덱스-파일">인덱스 파일</a></h2>
<p>인덱스 저장소의 나머지 부분에는 각 패키지당 하나의 파일이 포함되어 있으며, 파일 이름은 소문자로 된 패키지 이름입니다. 패키지의 각 버전은 파일 내에서 별도의 줄을 차지합니다. 파일들은 계층 구조의 디렉토리에 정리됩니다.</p>
<ul>
<li>이름이 1글자인 패키지들은 <code>1</code> 이라는 이름의 디렉토리에 위치합니다.</li>
<li>이름이 2글자인 패키지들은 <code>2</code> 라는 이름의 디렉토리에 위치합니다.</li>
<li>이름이 3글자인 패키지들은 <code>3/{첫-글자}</code> 디렉토리에 위치하며, 여기서 <code>{첫-글자}</code> 는 패키지 이름의 첫 번째 글자입니다.</li>
<li>그 외 모든 패키지는 <code>{앞-두-글자}/{다음-두-글자}</code> 라는 이름의 디렉토리에 저장됩니다. 상위 디렉토리는 패키지 이름의 처음 두 글자이고, 다음 하위 디렉토리는 패키지 이름의 세 번째와 네 번째 글자입니다. 예를 들어, <code>cargo</code> 는 <code>ca/rg/cargo</code> 라는 파일에 저장됩니다.</li>
</ul>
<blockquote>
<p>참고: 인덱스 파일 이름은 소문자이지만, <code>Cargo.toml</code> 및 인덱스 JSON 데이터의 패키지 이름 필드는 대소문자를 구분하며 대문자와 소문자를 모두 포함할 수 있습니다.</p>
</blockquote>
<p>위의 디렉토리 이름은 소문자로 변환된 패키지 이름을 기반으로 계산되며, 마커 <code>{lowerprefix}</code> 로 표현됩니다. 대소문자 변환 없이 원래 패키지 이름을 사용하는 경우, 결과 디렉토리 이름은 마커 <code>{prefix}</code> 로 표현됩니다. 예를 들어, <code>MyCrate</code> 패키지는 <code>My/Cr</code> 이라는 <code>{prefix}</code> 와 <code>my/cr</code> 이라는 <code>{lowerprefix}</code> 를 가집니다. 일반적으로 <code>{lowerprefix}</code> 보다 <code>{prefix}</code> 를 사용하는 것이 권장되지만, 각 선택에는 장단점이 있습니다. 대소문자를 구분하지 않는 파일 시스템에서 <code>{prefix}</code> 를 사용하면 (해롭지는 않지만 우아하지 않은) 디렉토리 별칭(aliasing)이 발생합니다. 예를 들어, <code>crate</code> 와 <code>CrateTwo</code> 는 각각 <code>cr/at</code> 및 <code>Cr/at</code> 라는 <code>{prefix}</code> 값을 가집니다. 이들은 유닉스 머신에서는 서로 다르지만 윈도우에서는 동일한 디렉토리로 별칭 처리됩니다. 정규화된 대소문자를 사용하는 디렉토리를 쓰면 별칭 문제를 피할 수 있지만, 대소문자를 구분하는 파일 시스템에서는 <code>{prefix}</code>/<code>{lowerprefix}</code> 기능이 없는 이전 버전의 Cargo를 지원하기가 더 어렵습니다. 예를 들어, nginx 리라이트 규칙은 <code>{prefix}</code> 를 쉽게 생성할 수 있지만 소문자 변환을 수행하여 <code>{lowerprefix}</code> 를 생성할 수는 없습니다.</p>
<h2 id="이름-제한"><a class="header" href="#이름-제한">이름 제한</a></h2>
<p>레지스트리는 인덱스에 추가되는 패키지 이름에 대한 제한을 두는 것을 고려해야 합니다. Cargo 자체는 모든 <a href="reference/../../std/primitive.char.html#method.is_alphanumeric">영문자 및 숫자</a>, <code>-</code>, <code>_</code> 문자를 포함한 이름을 허용합니다. <a href="https://crates.io/">crates.io</a> 는 다음과 같은 자체 제한 사항을 두고 있습니다.</p>
<ul>
<li>ASCII 문자만 허용합니다.</li>
<li>영문자 및 숫자, <code>-</code>, <code>_</code> 문자만 허용합니다.</li>
<li>첫 번째 문자는 반드시 알파벳이어야 합니다.</li>
<li>대소문자를 구분하지 않는 충돌 감지를 수행합니다.</li>
<li><code>-</code> 와 <code>_</code> 의 차이로 인한 혼동을 방지합니다.</li>
<li>특정 길이(최대 64자) 미만이어야 합니다.</li>
<li>“nul“과 같은 윈도우 특수 파일 이름 등의 예약된 이름은 거부합니다.</li>
</ul>
<p>레지스트리는 이와 유사한 제한 사항을 적용하는 것을 고려해야 하며, <a href="https://en.wikipedia.org/wiki/IDN_homograph_attack">IDN 호모그래프 공격(IDN homograph attacks)</a> 및 <a href="https://www.unicode.org/reports/tr36/">UTR36</a>과 <a href="https://www.unicode.org/reports/tr39/">UTS39</a> 에서 다루는 다른 보안 문제들도 고려해야 합니다.</p>
<h2 id="버전-유일성"><a class="header" href="#버전-유일성">버전 유일성</a></h2>
<p>인덱스는 각 패키지에 대해 각 버전이 단 한 번만 나타나도록 보장 <em>해야 합니다</em>. 여기에는 SemVer 빌드 메타데이터를 무시하는 것도 포함됩니다. 예를 들어, 인덱스는 버전 <code>1.0.7</code> 과 <code>1.0.7+extra</code> 를 가진 두 개의 항목을 포함해서는 <em>안 됩니다</em>.</p>
<h2 id="json-스키마"><a class="header" href="#json-스키마">JSON 스키마</a></h2>
<p>패키지 파일의 각 줄에는 배포된 패키지 버전을 설명하는 JSON 객체가 포함되어 있습니다. 다음은 항목의 형식을 설명하는 주석이 포함된 예시입니다.</p>
<pre><code class="language-javascript">{
    // 패키지의 이름입니다.
    // 영문자 및 숫자, `-`, `_` 문자만 포함해야 합니다.
    "name": "foo",
    // 이 행이 설명하는 패키지의 버전입니다.
    // https://semver.org/의 유의적 버전(Semantic Versioning) 2.0.0 사양에 따른 유효한 버전 번호여야 합니다.
    "vers": "0.1.0",
    // 패키지의 직접적인 의존성 배열입니다.
    "deps": [
        {
            // 의존성의 이름입니다.
            // 만약 의존성이 원래 패키지 이름에서 변경되었다면, 이것이 새 이름이 됩니다.
            // 원래 패키지 이름은 `package` 필드에 저장됩니다.
            "name": "rand",
            // 이 의존성에 대한 SemVer 요구 사항입니다.
            // 이는 https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html 에 정의된
            // 유효한 버전 요구 사항이어야 합니다.
            "req": "^0.6",
            // Array of features (as strings) enabled for this dependency.
            // Since Cargo 1.84, defaults to `[]` if not specified.
            "features": ["i128_support"],
            // 이것이 선택적 의존성인지 여부를 나타내는 불리언 값입니다.
            // Cargo 1.84부터는 지정되지 않은 경우 기본값이 `false` 입니다.
            "optional": false,
            // 기본 기능(default features)이 활성화되었는지 여부를 나타내는 불리언 값입니다.
            // Cargo 1.84부터는 지정되지 않은 경우 기본값이 `true` 입니다.
            "default_features": true,
            // 의존성에 대한 타겟 플랫폼입니다.
            // 지정되지 않았거나 `null` 인 경우, 타겟 의존성이 아닙니다.
            // 그 외의 경우, "cfg(windows)"와 같은 문자열입니다.
            "target": null,
            // 의존성 종류입니다.
            // "dev", "build", 혹은 "normal"입니다.
            // 지정되지 않았거나 `null` 인 경우 기본값은 "normal"입니다.
            "kind": "normal",
            // 이 의존성의 출처인 레지스트리의 인덱스 URL 문자열입니다.
            // 지정되지 않았거나 `null` 인 경우, 의존성이 현재 레지스트리에 있는 것으로 간주됩니다.
            "registry": null,
            // If the dependency is renamed, this is a string of the actual
            // package name. If not specified or `null`, this dependency is not
            // renamed.
            "package": null,
        }
    ],
    // `.crate` 파일의 SHA256 체크섬입니다.
    "cksum": "d867001db0e2b6e0496f9fac96930e2d42233ecd3ca0413e0753d4c7695d289c",
    // Set of features defined for the package.
    // Each feature maps to an array of features or dependencies it enables.
    // Since Cargo 1.84, defaults to `{}` if not specified.
    "features": {
        "extras": ["rand/simd_support"]
    },
    // 이 버전이 철회(yank)되었는지 여부를 나타내는 불리언 값입니다.
    "yanked": false,
    // 패키지 매니페스트의 `links` 문자열 값이거나, 지정되지 않은 경우 null입니다.
    // 이 필드는 선택 사항이며 기본값은 null입니다.
    "links": null,
    // 이 항목의 스키마 버전을 나타내는 부호 없는 32비트 정수 값입니다.
//
// 지정되지 않은 경우 기본값인 1로 해석해야 합니다.
//
// Cargo(버전 1.51부터)는 인식하지 못하는 버전을 무시합니다. 이는 인덱스 항목에 변경 사항을 안전하게 도입하고,
// 이전 버전의 cargo가 이해하지 못하는 새로운 항목을 무시할 수 있도록 하는 방법을 제공합니다. 1.51보다 오래된
// 버전은 이 필드를 무시하므로 인덱스 항목의 의미를 잘못 해석할 수 있습니다.
//
// 현재 값은 다음과 같습니다:
//
// * 1: 여기에 문서화된 스키마이며, 최신 추가 사항은 포함하지 않습니다.
//      이 값은 Rust 버전 1.51 이상에서 존중됩니다.
// * 2: `features2` 필드가 추가되었습니다.
//      이 값은 Rust 버전 1.60 이상에서 존중됩니다.
"v": 2,
    // 이 선택적 필드는 새로운 확장 구문을 사용하는 기능(feature)들을 포함합니다.
    // 구체적으로는 네임스페이스 기능(`dep:`) 및 약한 의존성(`pkg?/feat`)입니다.
    //
    // 이 필드가 `features` 와 분리된 이유는 1.19보다 오래된 버전의 경우 `Cargo.lock` 파일이 있더라도
    // 새 구문을 파싱하지 못해 로드에 실패하기 때문입니다.
    //
    // Cargo는 여기에 나열된 모든 값을 "features" 필드와 병합합니다.
    //
    // 이 필드가 포함된 경우, "v" 필드는 최소 2로 설정되어야 합니다.
    //
    // 레지스트리가 확장 기능 구문을 위해 반드시 이 필드를 사용해야 하는 것은 아니며, "features" 필드에
    // 이를 포함하는 것도 허용됩니다. 이 필드를 사용하는 것은 오직 1.19 이전 버전의 cargo를 지원하고자 하는
    // 경우에만 필요하며, 실제로는 crates.io만이 해당됩니다 (오래된 버전들은 다른 레지스트리를 지원하지 않기 때문입니다).
    "features2": {
        "serde": ["dep:serde", "chrono?/serde"]
    }
    // 최소 지원 Rust 버전 (선택 사항)
    // 연산자(예: `=`)가 없는 유효한 버전 요구 사항이어야 합니다.
    "rust_version": "1.60",
    // The publish time of this package version (optional).
    //
    // The format is a subset of ISO8601:
    // - `yyyy-mm-ddThh:mm:ssZ`
    // - no fractional seconds
    // - always `Z` for UTC timezone, no timezone offsets supported
    // - fields are 0-padded
    //
    // Example: 2025-11-12T19:30:12Z
    //
    // This should be the original publish time and not changed on any status changes,
    // like `yanked`.
    "pubtime": "2025-11-12T19:30:12Z"
}
</code></pre>
<p>JSON 객체는 추가된 이후에 수정되어서는 안 됩니다. 다만 <code>yanked</code> 필드는 언제든지 값이 변경될 수 있습니다.</p>
<blockquote>
<p><strong>참고</strong>: 인덱스 JSON 형식은 <a href="reference/registry-web-api.html#publish">배포 API(Publish API)</a> 및 <a href="reference/../commands/cargo-metadata.html"><code>cargo metadata</code></a> 의 JSON 형식과 미세한 차이가 있습니다. 만약 이들 중 하나를 소스로 사용하여 인덱스 항목을 생성하려는 경우, 문서상에 기술된 차이점을 주의 깊게 확인하는 것이 좋습니다.</p>
<p><a href="reference/registry-web-api.html#publish">배포 API</a> 와의 차이점은 다음과 같습니다.</p>
<ul>
<li><code>deps</code>
<ul>
<li><code>name</code> — 의존성이 <code>Cargo.toml</code> 에서 <a href="reference/specifying-dependencies.html#renaming-dependencies-in-cargotoml">이름 변경(renamed)</a>된 경우, 배포 API는 원래 패키지 이름을 <code>name</code> 필드에, 별칭 이름을 <code>explicit_name_in_toml</code> 필드에 넣습니다. 인덱스는 별칭 이름을 <code>name</code> 필드에, 원래 패키지 이름을 <code>package</code> 필드에 넣습니다.</li>
<li><code>req</code> — 배포 API 필드 이름은 <code>version_req</code> 입니다.</li>
</ul>
</li>
<li><code>cksum</code> — 배포 API는 체크섬을 지정하지 않으며, 인덱스에 추가하기 전에 레지스트리에서 직접 계산해야 합니다.</li>
<li><code>features</code> — 일부 기능은 <code>features2</code> 필드에 위치할 수 있습니다. 참고: 이는 <a href="https://crates.io/">crates.io</a>를 위한 레거시 요구 사항일 뿐이며, 다른 레지스트리는 기능 맵을 수정할 필요가 없습니다. <code>v</code> 필드는 <code>features2</code> 필드의 존재 여부를 나타냅니다.</li>
<li>배포 API는 <code>description</code> 및 <code>readme</code> 와 같이 인덱스에는 나타나지 않는 여러 다른 필드를 포함합니다. 이는 레지스트리가 <code>.crate</code> 파일을 압축 해제하고 파싱할 필요 없이 웹사이트에 표시할 크레이트 메타데이터를 쉽게 얻을 수 있도록 하기 위함입니다. 이 추가 정보는 일반적으로 레지스트리 서버의 데이터베이스에 추가됩니다.</li>
<li><code>rust_version</code> 이 여기에 포함되어 있더라도, <a href="https://crates.io/">crates.io</a> 는 이 필드를 무시하고 대신 <code>.crate</code> 파일에 포함된 <code>Cargo.toml</code> 에서 이를 읽습니다.</li>
</ul>
<p><a href="reference/../commands/cargo-metadata.html"><code>cargo metadata</code></a> 와의 차이점은 다음과 같습니다.</p>
<ul>
<li><code>vers</code> — <code>cargo metadata</code> 필드 이름은 <code>version</code> 입니다.</li>
<li><code>deps</code>
<ul>
<li><code>name</code> — 의존성이 <code>Cargo.toml</code> 에서 <a href="reference/specifying-dependencies.html#renaming-dependencies-in-cargotoml">이름 변경(renamed)</a>된 경우, <code>cargo metadata</code> 는 원래 패키지 이름을 <code>name</code> 필드에, 별칭 이름을 <code>rename</code> 필드에 넣습니다. 인덱스는 별칭 이름을 <code>name</code> 필드에, 원래 패키지 이름을 <code>package</code> 필드에 넣습니다.</li>
<li><code>default_features</code> — <code>cargo metadata</code> 필드 이름은 <code>uses_default_features</code> 입니다.</li>
<li><code>registry</code> — <code>cargo metadata</code> 는 의존성이 <a href="https://crates.io/">crates.io</a> 에서 왔음을 나타내기 위해 <code>null</code> 값을 사용합니다. 인덱스는 의존성이 인덱스와 동일한 레지스트리에서 왔음을 나타내기 위해 <code>null</code> 값을 사용합니다. 인덱스 항목을 생성할 때 <a href="https://crates.io/">crates.io</a> 가 아닌 레지스트리는 <code>null</code> 값을 <code>https://github.com/rust-lang/crates.io-index</code> 로 변환해야 하며, 현재 인덱스와 일치하는 URL은 <code>null</code> 로 변환해야 합니다.</li>
<li><code>cargo metadata</code> 는 <code>source</code> 및 <code>path</code> 와 같은 몇 가지 추가 필드를 포함합니다.</li>
</ul>
</li>
<li>인덱스는 <code>yanked</code>, <code>cksum</code>, <code>v</code> 와 같은 추가 필드를 포함합니다.</li>
</ul>
</blockquote>
<h2 id="인덱스-프로토콜"><a class="header" href="#인덱스-프로토콜">인덱스 프로토콜</a></h2>
<p>Cargo는 <code>git</code> 과 <code>sparse</code> 두 가지 원격 레지스트리 프로토콜을 지원합니다. <code>git</code> 프로토콜은 인덱스 파일들을 git 저장소에 저장하며, <code>sparse</code> 프로토콜은 HTTP를 통해 개별 파일들을 가져옵니다.</p>
<h3 id="git-프로토콜"><a class="header" href="#git-프로토콜">Git 프로토콜</a></h3>
<p>git 프로토콜은 인덱스 URL에 별도의 프로토콜 접두사가 없습니다. 예를 들어 <a href="https://crates.io/">crates.io</a> 의 git 인덱스 URL은 <code>https://github.com/rust-lang/crates.io-index</code> 입니다.</p>
<p>Cargo는 업데이트를 효율적으로 증분해서 가져올 수 있도록 디스크에 git 저장소를 캐시합니다.</p>
<h3 id="sparse-프로토콜"><a class="header" href="#sparse-프로토콜">Sparse 프로토콜</a></h3>
<p>sparse 프로토콜은 레지스트리 URL에 <code>sparse+</code> 프로토콜 접두사를 사용합니다. 예를 들어 <a href="https://crates.io/">crates.io</a>의 sparse 인덱스 URL은 <code>sparse+https://index.crates.io/</code> 입니다.</p>
<p>sparse 프로토콜은 각 인덱스 파일을 개별 HTTP 요청으로 다운로드합니다. 이로 인해 수많은 작은 HTTP 요청이 발생하므로, 파이프라이닝과 HTTP/2를 지원하는 서버를 사용하면 성능이 크게 향상됩니다.</p>
<h4 id="sparse-인증"><a class="header" href="#sparse-인증">Sparse 인증</a></h4>
<p>Cargo는 다른 파일을 가져오기 전에 <code>config.json</code> 파일을 먼저 가져오려고 시도합니다. 서버가 HTTP 401로 응답하면, Cargo는 레지스트리가 인증을 필요로 한다고 가정하고 인증 토큰을 포함하여 <code>config.json</code> 요청을 다시 시도합니다.</p>
<p>인증 실패(또는 인증 토큰 누락) 시, 서버는 사용자가 토큰을 받을 수 있는 위치를 나타내기 위해 <code>Cargo login_url="&lt;URL&gt;"</code> 챌린지가 포함된 <code>www-authenticate</code> 헤더를 포함할 수 있습니다.</p>
<p>인증이 필요한 레지스트리는 <code>config.json</code> 에 <code>auth-required: true</code> 를 설정해야 합니다.</p>
<h4 id="캐싱"><a class="header" href="#캐싱">캐싱</a></h4>
<p>Cargo는 크레이트 메타데이터 파일을 캐시하며, 각 항목에 대해 서버로부터 <code>ETag</code> 혹은 <code>Last-Modified</code> HTTP 헤더를 캡처합니다. 크레이트 메타데이터를 갱신할 때, Cargo는 <code>If-None-Match</code> 혹은 <code>If-Modified-Since</code> 헤더를 전송하여 로컬 캐시가 유효한 경우 서버가 HTTP 304 “Not Modified“로 응답할 수 있도록 하여 시간과 대역폭을 절약합니다. <code>ETag</code> 와 <code>Last-Modified</code> 헤더가 모두 존재하는 경우, Cargo는 <code>ETag</code> 만 사용합니다.</p>
<h4 id="캐시-무효화"><a class="header" href="#캐시-무효화">캐시 무효화</a></h4>
<p>레지스트리가 인덱스 파일 접근을 캐시하는 CDN이나 프록시 종류를 사용하고 있다면, 파일이 업데이트될 때 어떤 형태로든 캐시 무효화를 구현하는 것이 권장됩니다. 이러한 캐시가 업데이트되지 않으면 사용자는 캐시가 만료될 때까지 새로운 크레이트에 접근하지 못할 수 있습니다.</p>
<h4 id="존재하지-않는-크레이트"><a class="header" href="#존재하지-않는-크레이트">존재하지 않는 크레이트</a></h4>
<p>존재하지 않는 크레이트에 대해, 레지스트리는 404 “Not Found”, 410 “Gone”, 혹은 451 “Unavailable For Legal Reasons” 코드로 응답해야 합니다.</p>
<h4 id="sparse-제한-사항"><a class="header" href="#sparse-제한-사항">Sparse 제한 사항</a></h4>
<p>레지스트리 URL이 락파일(lockfile)에 저장되기 때문에, 한 레지스트리에 대해 두 프로토콜을 모두 제공하는 것은 권장되지 않습니다. 전환 계획에 대한 논의는 이슈 <a href="https://github.com/rust-lang/cargo/issues/10964">#10964</a> 에서 진행 중입니다. <a href="https://crates.io/">crates.io</a> 레지스트리는 예외인데, Cargo가 sparse 프로토콜 사용 시 내부적으로 그에 상응하는 git URL로 대체하기 때문입니다.</p>
<p>만약 레지스트리가 두 프로토콜을 모두 제공한다면, 현재로서는 하나를 정식 프로토콜로 선택하고 다른 하나에 대해서는 <a href="reference/../reference/source-replacement.html">소스 대체(source replacement)</a>를 사용하도록 하는 것이 권장됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="웹-api"><a class="header" href="#웹-api">웹 API</a></h1>
<p>레지스트리는 아래 나열된 작업들을 지원하기 위해 <code>config.json</code> 에 정의된 위치에서 웹 API를 호스팅할 수 있습니다.</p>
<p>Cargo는 인증이 필요한 요청에 <code>Authorization</code> 헤더를 포함합니다. 헤더 값은 API 토큰입니다. 토큰이 유효하지 않은 경우 서버는 403 응답 코드로 응답해야 합니다. 사용자는 레지스트리 웹사이트를 방문하여 토큰을 얻을 수 있으며, Cargo는 <a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> 명령어를 사용하거나 커맨드 라인에서 토큰을 전달받아 저장할 수 있습니다.</p>
<p>Responses use a 2xx response code for success. Errors should use an appropriate response code, such as 404. Failure responses should have a JSON object with the following structure:</p>
<pre><code class="language-javascript">{
    // 사용자에게 표시할 에러 배열입니다.
    "errors": [
        {
            // 문자열 형태의 에러 메시지입니다.
            "detail": "에러 메시지 텍스트"
        }
    ]
}
</code></pre>
<p>응답이 이 구조를 가지고 있다면, Cargo는 응답 코드가 200이라 하더라도 상세 메시지를 사용자에게 표시합니다. 응답 코드가 에러를 나타내지만 내용이 이 구조를 가지고 있지 않다면, Cargo는 서버 에러 디버깅을 돕기 위한 메시지를 사용자에게 표시합니다. 서버가 <code>errors</code> 객체를 반환하면 레지스트리가 더 상세하거나 사용자 중심적인 에러 메시지를 제공할 수 있게 됩니다.</p>
<p>하위 호환성을 위해, 서버는 예상치 못한 쿼리 파라미터나 JSON 필드를 무시해야 합니다. JSON 필드가 누락된 경우 null로 간주해야 합니다. 엔드포인트는 경로의 <code>v1</code> 부분을 통해 버전이 관리되며, 향후 하위 호환성 폴백이 필요한 경우 그 처리는 Cargo의 책임입니다.</p>
<p>Cargo는 모든 요청에 대해 다음과 같은 헤더를 설정합니다.</p>
<ul>
<li><code>Content-Type</code>: <code>application/json</code> (바디 페이로드가 있는 요청의 경우)</li>
<li><code>Accept</code>: <code>application/json</code></li>
<li><code>User-Agent</code>: <code>cargo/1.32.0 (8610973aa 2019-01-02)</code> 와 같은 Cargo 버전 정보입니다. 사용자가 설정값을 통해 이를 수정할 수 있습니다. 1.29 버전에서 추가되었습니다.</li>
</ul>
<h2 id="배포publish"><a class="header" href="#배포publish">배포(Publish)</a></h2>
<ul>
<li>엔드포인트: <code>/api/v1/crates/new</code></li>
<li>메서드: PUT</li>
<li>인증(Authorization): 포함됨</li>
</ul>
<p>배포(publish) 엔드포인트는 크레이트의 새 버전을 배포하는 데 사용됩니다. 서버는 크레이트를 검증하고, 다운로드 가능하게 만들며, 인덱스에 추가해야 합니다.</p>
<p>성공 응답을 보내기 전에 인덱스가 반드시 업데이트되어야 할 필요는 없습니다. 성공 응답을 받은 후 Cargo는 짧은 시간 동안 인덱스를 폴링하여 새 크레이트가 추가되었는지 확인합니다. 일정 시간 후에도 크레이트가 인덱스에 나타나지 않으면 Cargo는 사용자에게 새 크레이트를 아직 사용할 수 없다는 경고를 표시합니다.</p>
<p>Cargo가 보내는 데이터 본문은 다음과 같습니다.</p>
<ul>
<li>JSON 데이터의 길이를 나타내는 32비트 부호 없는 리틀 엔디언 정수.</li>
<li>JSON 객체 형태의 패키지 메타데이터.</li>
<li><code>.crate</code> 파일의 길이를 나타내는 32비트 부호 없는 리틀 엔디언 정수.</li>
<li><code>.crate</code> 파일.</li>
</ul>
<p>다음은 주석이 달린 JSON 객체의 예시입니다. <a href="https://crates.io/">crates.io</a> 에서 부과하는 일부 제한 사항에 대한 참고 사항은 수행될 수 있는 검증 유형의 예시를 보여주기 위해 포함된 것이며, <a href="https://crates.io/">crates.io</a> 가 부과하는 모든 제한 사항 목록으로 간주되어서는 안 됩니다.</p>
<pre><code class="language-javascript">{
    // 패키지의 이름입니다.
    "name": "foo",
    // 배포 중인 패키지의 버전입니다.
    "vers": "0.1.0",
    // 패키지의 직접적인 의존성 배열입니다.
    "deps": [
        {
            // 의존성의 이름입니다.
            // 의존성 이름이 원래 패키지 이름에서 변경된 경우, 이는 원래 이름입니다.
            // 새로운 패키지 이름은 `explicit_name_in_toml` 필드에 저장됩니다.
            "name": "rand",
            // 이 의존성에 대한 semver 요구 사항입니다.
            "version_req": "^0.6",
            // 이 의존성에 대해 활성화된 기능(feature)들의 배열(문자열)입니다.
            "features": ["i128_support"],
            // 이것이 선택적 의존성인지 여부를 나타내는 불리언 값입니다.
            "optional": false,
            // 기본 기능(default features)이 활성화되었는지 여부를 나타내는 불리언 값입니다.
            "default_features": true,
            // 의존성에 대한 타겟 플랫폼입니다.
            // 타겟 의존성이 아닌 경우 null입니다.
            // 그 외의 경우, "cfg(windows)"와 같은 문자열입니다.
            "target": null,
            // 의존성 종류입니다.
            // "dev", "build", 혹은 "normal"입니다.
            "kind": "normal",
            // 이 의존성의 출처인 레지스트리의 인덱스 URL 문자열입니다.
            // 지정되지 않았거나 null인 경우, 의존성이 현재 레지스트리에 있는 것으로 간주됩니다.
            "registry": null,
            // 의존성 이름이 변경된 경우, 이는 새로운 패키지 이름 문자열입니다.
            // 지정되지 않았거나 null인 경우, 의존성 이름이 변경되지 않은 것입니다.
            "explicit_name_in_toml": null,
        }
    ],
    // 패키지에 정의된 기능(feature)들의 집합입니다.
    // 각 기능은 그것이 활성화하는 기능들이나 의존성들의 배열에 매핑됩니다.
    // Cargo는 기능 이름에 제한을 두지 않지만, crates.io는 영문자 및 숫자 ASCII, `_`, `-` 문자를 요구합니다.
    "features": {
        "extras": ["rand/simd_support"]
    },
    // 저자들의 문자열 리스트입니다.
    // 비어 있을 수 있습니다.
    "authors": ["Alice &lt;a@example.com&gt;"],
    // 매니페스트의 설명(description) 필드입니다.
    // null일 수 있습니다. crates.io는 최소한의 내용을 요구합니다.
    "description": null,
    // 이 패키지의 문서 웹사이트 URL 문자열입니다.
    // null일 수 있습니다.
    "documentation": null,
    // 이 패키지의 홈페이지 URL 문자열입니다.
    // null일 수 있습니다.
    "homepage": null,
    // README 파일의 내용 문자열입니다.
    // null일 수 있습니다.
    "readme": null,
    // 크레이트 내 README 파일의 상대 경로 문자열입니다.
    // null일 수 있습니다.
    "readme_file": null,
    // 패키지의 키워드 문자열 배열입니다.
    "keywords": [],
    // 패키지의 카테고리 문자열 배열입니다.
    "categories": [],
    // 패키지의 라이선스 문자열입니다.
    // null일 수 있습니다. crates.io는 `license` 혹은 `license_file` 중 하나가 설정되어야 합니다.
    "license": null,
    // 크레이트 내 라이선스 파일의 상대 경로 문자열입니다.
    // null일 수 있습니다.
    "license_file": null,
    // 이 패키지의 소스 저장소 웹사이트 URL 문자열입니다.
    // null일 수 있습니다.
    "repository": null,
    // "상태(status)" 배지의 선택적 객체입니다. 각 값은 임의의 문자열 대 문자열 매핑 객체입니다.
    // crates.io는 배지의 형식에 대해 특별한 해석 방식을 가지고 있습니다.
    "badges": {
        "travis-ci": {
            "branch": "master",
            "repository": "rust-lang/cargo"
        }
    },
    // 패키지 매니페스트의 `links` 문자열 값이거나, 지정되지 않은 경우 null입니다.
    // 이 필드는 선택 사항이며 기본값은 null입니다.
    "links": null,
    // 최소 지원 Rust 버전 (선택 사항)
    // 연산자(예: `=`)가 없는 유효한 버전 요구 사항이어야 합니다.
    "rust_version": null
}
</code></pre>
<p>성공적인 응답은 다음과 같은 JSON 객체를 포함합니다.</p>
<pre><code class="language-javascript">{
    // 사용자에게 표시할 경고의 선택적 객체입니다.
    "warnings": {
        // 유효하지 않아 무시된 카테고리 문자열 배열입니다.
        "invalid_categories": [],
        // 유효하지 않아 무시된 배지 이름 문자열 배열입니다.
        "invalid_badges": [],
        // 사용자에게 표시할 임의의 경고 문자열 배열입니다.
        "other": []
    }
}
</code></pre>
<h2 id="철회yank"><a class="header" href="#철회yank">철회(Yank)</a></h2>
<ul>
<li>엔드포인트: <code>/api/v1/crates/{crate_name}/{version}/yank</code></li>
<li>메서드: DELETE</li>
<li>인증(Authorization): 포함됨</li>
</ul>
<p>철회 엔드포인트는 인덱스에서 해당 크레이트 버전의 <code>yank</code> 필드를 <code>true</code> 로 설정합니다.</p>
<p>성공적인 응답은 다음과 같은 JSON 객체를 포함합니다.</p>
<pre><code class="language-javascript">{
    // 철회가 성공했음을 나타내며, 항상 true입니다.
    "ok": true,
}
</code></pre>
<h2 id="철회-취소unyank"><a class="header" href="#철회-취소unyank">철회 취소(Unyank)</a></h2>
<ul>
<li>엔드포인트: <code>/api/v1/crates/{crate_name}/{version}/unyank</code></li>
<li>메서드: PUT</li>
<li>인증(Authorization): 포함됨</li>
</ul>
<p>철회 취소 엔드포인트는 인덱스에서 해당 크레이트 버전의 <code>yank</code> 필드를 <code>false</code> 로 설정합니다.</p>
<p>성공적인 응답은 다음과 같은 JSON 객체를 포함합니다.</p>
<pre><code class="language-javascript">{
    // 철회 취소가 성공했음을 나타내며, 항상 true입니다.
    "ok": true,
}
</code></pre>
<h2 id="소유자owners"><a class="header" href="#소유자owners">소유자(Owners)</a></h2>
<p>Cargo 자체적으로 사용자나 소유자에 대한 개념을 가지고 있지는 않지만, 크레이트를 제어할 권한을 누가 가졌는지 관리하는 것을 돕기 위해 <code>owner</code> 명령어를 제공합니다. 사용자 및 소유자를 어떻게 처리할지는 전적으로 레지스트리에 달려 있습니다. <a href="https://crates.io/">crates.io</a> 가 GitHub 사용자 및 팀을 통해 소유자를 어떻게 처리하는지에 대한 설명은 <a href="reference/publishing.html#cargo-owner">배포 관련 문서</a> 를 참조하세요.</p>
<h3 id="소유자-목록"><a class="header" href="#소유자-목록">소유자: 목록</a></h3>
<ul>
<li>엔드포인트: <code>/api/v1/crates/{crate_name}/owners</code></li>
<li>메서드: GET</li>
<li>인증(Authorization): 포함됨</li>
</ul>
<p>소유자 엔드포인트는 해당 크레이트의 소유자 목록을 반환합니다.</p>
<p>성공적인 응답은 다음과 같은 JSON 객체를 포함합니다.</p>
<pre><code class="language-javascript">{
    // 크레이트 소유자들의 배열입니다.
    "users": [
        {
            // 소유자의 고유한 부호 없는 32비트 정수 ID입니다.
            "id": 70,
            // 소유자의 고유한 사용자 이름입니다.
            "login": "github:rust-lang:core",
            // 소유자의 이름입니다.
            // 이는 선택 사항이며 null일 수 있습니다.
            "name": "Core",
        }
    ]
}
</code></pre>
<h3 id="소유자-추가"><a class="header" href="#소유자-추가">소유자: 추가</a></h3>
<ul>
<li>엔드포인트: <code>/api/v1/crates/{crate_name}/owners</code></li>
<li>메서드: PUT</li>
<li>인증(Authorization): 포함됨</li>
</ul>
<p>PUT 요청은 크레이트에 새 소유자를 추가하기 위한 요청을 레지스트리에 보냅니다. 요청을 어떻게 처리할지는 레지스트리에 달려 있습니다. 예를 들어 <a href="https://crates.io/">crates.io</a> 는 사용자에게 초대장을 보내고, 사용자가 이를 수락해야 소유자로 추가됩니다.</p>
<p>요청은 다음과 같은 JSON 객체를 포함해야 합니다.</p>
<pre><code class="language-javascript">{
    // 추가할 소유자들의 `login` 문자열 배열입니다.
    "users": ["login_name"]
}
</code></pre>
<p>성공적인 응답은 다음과 같은 JSON 객체를 포함합니다.</p>
<pre><code class="language-javascript">{
    // 추가가 성공했음을 나타내며, 항상 true입니다.
    "ok": true,
    // 사용자에게 표시될 문자열입니다.
    "msg": "사용자 ehuss가 cargo 크레이트의 소유자로 초대되었습니다."
}
</code></pre>
<h3 id="소유자-삭제"><a class="header" href="#소유자-삭제">소유자: 삭제</a></h3>
<ul>
<li>엔드포인트: <code>/api/v1/crates/{crate_name}/owners</code></li>
<li>메서드: DELETE</li>
<li>인증(Authorization): 포함됨</li>
</ul>
<p>DELETE 요청은 크레이트에서 소유자를 삭제합니다. 요청은 다음과 같은 JSON 객체를 포함해야 합니다.</p>
<pre><code class="language-javascript">{
    // 삭제할 소유자들의 `login` 문자열 배열입니다.
    "users": ["login_name"]
}
</code></pre>
<p>성공적인 응답은 다음과 같은 JSON 객체를 포함합니다.</p>
<pre><code class="language-javascript">{
    // 삭제가 성공했음을 나타내며, 항상 true입니다.
    "ok": true
    // 사용자에게 표시될 문자열입니다. 현재 cargo에 의해 무시됩니다.
    "msg": "소유자가 성공적으로 삭제되었습니다.",
}
</code></pre>
<h2 id="검색search"><a class="header" href="#검색search">검색(Search)</a></h2>
<ul>
<li>엔드포인트: <code>/api/v1/crates</code></li>
<li>메서드: GET</li>
<li>쿼리 파라미터:
<ul>
<li><code>q</code>: 검색 쿼리 문자열입니다.</li>
<li><code>per_page</code>: 결과의 개수입니다. 기본값은 10, 최대값은 100입니다.</li>
</ul>
</li>
</ul>
<p>검색 요청은 서버에 정의된 기준을 사용하여 크레이트 검색을 수행합니다.</p>
<p>성공적인 응답은 다음과 같은 JSON 객체를 포함합니다.</p>
<pre><code class="language-javascript">{
    // 결과 배열.
    "crates": [
        {
            // 크레이트 이름.
            "name": "rand",
            // 사용 가능한 가장 높은 버전.
            "max_version": "0.6.1",
            // 크레이트에 대한 텍스트 설명.
            "description": "난수 생성기 및 기타 무작위 기능.\n",
        }
    ],
    "meta": {
        // 서버에서 사용 가능한 총 결과 수.
        "total": 119
    }
}
</code></pre>
<h2 id="로그인"><a class="header" href="#로그인">로그인</a></h2>
<ul>
<li>엔드포인트: <code>/me</code></li>
</ul>
<p>“login” 엔드포인트는 실제 API 요청이 아닙니다. <a href="reference/../commands/cargo-login.html"><code>cargo login</code></a> 명령어가 사용자에게 웹 브라우저에서 로그인하고 API 토큰을 검색하도록 지시하는 URL을 표시하기 위해 존재합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="semver-호환성-2"><a class="header" href="#semver-호환성-2">SemVer 호환성</a></h1>
<p>이 장에서는 패키지의 새 릴리스에 대해 관례적으로 호환 가능하거나 호환되지 않는 SemVer 변경으로 간주되는 사항에 대한 세부 정보를 제공합니다. SemVer가 무엇인지, Cargo가 라이브러리의 호환성을 보장하기 위해 이를 어떻게 사용하는지에 대한 자세한 내용은 <a href="reference/resolver.html#semver-compatibility">SemVer 호환성</a> 섹션을 참조하세요.</p>
<p>이것들은 <em>가이드라인</em> 일 뿐이며, 모든 프로젝트가 따라야 하는 엄격한 규칙은 아닙니다. <a href="reference/semver.html#change-categories">변경 카테고리</a> 섹션에서는 이 가이드가 변경의 수준과 심각성을 어떻게 분류하는지 설명합니다. 이 가이드의 대부분은 이전에 작동하던 것을 <code>cargo</code> 와 <code>rustc</code> 가 빌드하지 못하게 하는 변경 사항에 초점을 맞추고 있습니다. 거의 모든 변경 사항은 런타임 동작에 부정적인 영향을 미칠 수 있는 위험을 내포하고 있으며, 이러한 경우 일반적으로 프로젝트 유지 관리자가 SemVer 호환 가능 여부를 판단합니다.</p>
<h2 id="변경-카테고리"><a class="header" href="#변경-카테고리">변경 카테고리</a></h2>
<p>아래 나열된 모든 정책은 변경 수준에 따라 분류됩니다:</p>
<ul>
<li><strong>메이저 변경</strong>: 메이저 SemVer 범프가 필요한 변경입니다.</li>
<li><strong>마이너 변경</strong>: 마이너 SemVer 범프만 필요한 변경입니다.</li>
<li><strong>중단 가능성 있음(Possibly-breaking)</strong>: 일부 프로젝트에서는 메이저로 간주하고 다른 프로젝트에서는 마이너로 간주할 수 있는 변경입니다.</li>
</ul>
<p>“중단 가능성 있음(Possibly-breaking)” 카테고리는 업데이트 중에 중단될 <em>잠재력</em> 이 있지만 반드시 중단을 일으키지는 않는 변경 사항을 다룹니다. 이러한 변경 사항의 영향은 신중하게 고려되어야 합니다. 정확한 성격은 변경 사항과 프로젝트 유지 관리자의 원칙에 따라 달라집니다.</p>
<p>일부 프로젝트는 마이너 변경 시 패치 번호만 올리기로 선택할 수 있습니다. SemVer 명세를 따르고 패치 릴리스에는 버그 수정만 적용할 것을 권장합니다. 그러나 버그 수정을 위해 “마이너 변경“으로 표시된 API 변경이 필요할 수 있으며, 이는 호환성에 영향을 미치지 않아야 합니다. 이 가이드는 각 개별 “마이너 변경“이 어떻게 처리되어야 하는지에 대해 입장을 취하지 않습니다. 마이너 변경과 패치 변경의 차이는 변경의 성격에 따른 관례이기 때문입니다.</p>
<p>일부 변경 사항은 빌드를 중단시킬 잠재적 위험이 있음에도 불구하고 “마이너“로 표시됩니다. 이는 잠재적 위험이 매우 낮고, 중단을 일으킬 가능성이 있는 코드가 관용적인 Rust로 작성되었을 가능성이 낮거나 사용이 명확하게 권장되지 않는 상황을 위한 것입니다.</p>
<p>이 가이드에서 사용하는 “메이저” 및 “마이너“라는 용어는 “1.0.0” 이상의 릴리스와 관련이 있다고 가정합니다. “0.y.z“로 시작하는 초기 개발 릴리스는 “y“의 변경을 메이저 릴리스로, “z“의 변경을 마이너 릴리스로 취급할 수 있습니다. “0.0.z” 릴리스는 항상 메이저 변경입니다. 이는 Cargo가 가장 왼쪽의 0이 아닌 구성 요소의 변경만 비호환으로 간주하는 관례를 사용하기 때문입니다.</p>
<ul>
<li>API 호환성
<ul>
<li>아이템
<ul>
<li><a href="reference/semver.html#item-remove">메이저: 공개 아이템의 이름 변경/이동/제거</a></li>
<li><a href="reference/semver.html#item-new">마이너: 새로운 공개 아이템 추가</a></li>
</ul>
</li>
<li>타입
<ul>
<li><a href="reference/semver.html#type-layout">메이저: 잘 정의된 타입의 정렬, 레이아웃 또는 크기 변경</a></li>
</ul>
</li>
<li>구조체
<ul>
<li><a href="reference/semver.html#struct-add-private-field-when-public">메이저: 현재 모든 필드가 공개인 상태에서 비공개 구조체 필드 추가</a></li>
<li><a href="reference/semver.html#struct-add-public-field-when-no-private">메이저: 비공개 필드가 없을 때 공개 필드 추가</a></li>
<li><a href="reference/semver.html#struct-private-fields-with-private">마이너: 적어도 하나 이상의 비공개 필드가 존재할 때 비공개 필드 추가 또는 제거</a></li>
<li><a href="reference/semver.html#struct-tuple-normal-with-private">마이너: 모든 필드가 비공개인 튜플 구조체(적어도 하나의 필드 포함)에서 일반 구조체로의 전환, 또는 그 반대</a></li>
</ul>
</li>
<li>열거형
<ul>
<li><a href="reference/semver.html#enum-variant-new">메이저: 새로운 열거형 변형 추가(<code>non_exhaustive</code> 없음)</a></li>
<li><a href="reference/semver.html#enum-fields-new">메이저: 열거형 변형에 새 필드 추가</a></li>
</ul>
</li>
<li>트레이트
<ul>
<li><a href="reference/semver.html#trait-new-item-no-default">메이저: 기본값이 없는 트레이트 아이템 추가</a></li>
<li><a href="reference/semver.html#trait-item-signature">메이저: 트레이트 아이템 시그니처의 모든 변경</a></li>
<li><a href="reference/semver.html#trait-new-default-item">중단 가능성 있음: 기본값이 있는 트레이트 아이템 추가</a></li>
<li><a href="reference/semver.html#trait-object-safety">메이저: 트레이트를 객체 안전하지 않게 만드는 트레이트 아이템 추가</a></li>
<li><a href="reference/semver.html#trait-new-parameter-no-default">메이저: 기본값 없이 타입 매개변수 추가</a></li>
<li><a href="reference/semver.html#trait-new-parameter-default">마이너: 기본값이 있는 트레이트 타입 매개변수 추가</a></li>
</ul>
</li>
<li>구현(Implementations)
<ul>
<li><a href="reference/semver.html#impl-item-new">중단 가능성 있음: 고유 아이템(inherent items) 추가</a></li>
</ul>
</li>
<li>제네릭(Generics)
<ul>
<li><a href="reference/semver.html#generic-bounds-tighten">메이저: 제네릭 바운드 강화</a></li>
<li><a href="reference/semver.html#generic-bounds-loosen">마이너: 제네릭 바운드 완화</a></li>
<li><a href="reference/semver.html#generic-new-default">마이너: 기본값이 있는 타입 매개변수 추가</a></li>
<li><a href="reference/semver.html#generic-generalize-identical">마이너: 타입을 제네릭을 사용하도록 일반화 (동일한 타입 사용)</a></li>
<li><a href="reference/semver.html#generic-generalize-different">메이저: 타입을 제네릭을 사용하도록 일반화 (다른 타입이 될 수 있음)</a></li>
<li><a href="reference/semver.html#generic-more-generic">마이너: 제네릭 타입을 더 일반적인 타입으로 변경</a></li>
<li><a href="reference/semver.html#generic-rpit-capture">메이저: RPIT(Return Position Impl Trait)에서 더 많은 제네릭 매개변수 캡처</a></li>
</ul>
</li>
<li>함수
<ul>
<li><a href="reference/semver.html#fn-change-arity">메이저: 함수 매개변수 추가/제거</a></li>
<li><a href="reference/semver.html#fn-generic-new">중단 가능성 있음: 새로운 함수 타입 매개변수 도입</a></li>
<li><a href="reference/semver.html#fn-generalize-compatible">마이너: 함수를 제네릭을 사용하도록 일반화 (원래 타입 지원)</a></li>
<li><a href="reference/semver.html#fn-generalize-mismatch">메이저: 함수를 제네릭을 사용하도록 일반화할 때 타입 불일치 발생</a></li>
<li><a href="reference/semver.html#fn-unsafe-safe">마이너: <code>unsafe</code> 함수를 안전(safe)하게 만들기</a></li>
</ul>
</li>
<li>속성(Attributes)
<ul>
<li><a href="reference/semver.html#attr-no-std-to-std">메이저: <code>no_std</code> 지원에서 <code>std</code> 필수 요구로 전환</a></li>
<li><a href="reference/semver.html#attr-adding-non-exhaustive">메이저: 비공개 필드가 없는 기존 열거형, 변형(variant) 또는 구조체에 <code>non_exhaustive</code> 추가</a></li>
</ul>
</li>
</ul>
</li>
<li>도구 및 환경 호환성
<ul>
<li><a href="reference/semver.html#env-new-rust">중단 가능성 있음: 필요한 최소 Rust 버전 변경</a></li>
<li><a href="reference/semver.html#env-change-requirements">중단 가능성 있음: 플랫폼 및 환경 요구 사항 변경</a></li>
<li><a href="reference/semver.html#new-lints">마이너: 새로운 린트(lints) 도입</a></li>
<li>Cargo
<ul>
<li><a href="reference/semver.html#cargo-feature-add">마이너: 새로운 Cargo 기능 추가</a></li>
<li><a href="reference/semver.html#cargo-feature-remove">메이저: Cargo 기능 제거</a></li>
<li><a href="reference/semver.html#cargo-feature-remove-another">메이저: 기능 또는 공개 아이템을 변경하는 경우 기능 목록에서 기능 제거</a></li>
<li><a href="reference/semver.html#cargo-remove-opt-dep">중단 가능성 있음: 선택적 의존성 제거</a></li>
<li><a href="reference/semver.html#cargo-change-dep-feature">마이너: 의존성 기능 변경</a></li>
<li><a href="reference/semver.html#cargo-dep-add">마이너: 의존성 추가</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="reference/semver.html#application-compatibility">애플리케이션 호환성</a></li>
</ul>
<h2 id="api-호환성"><a class="header" href="#api-호환성">API 호환성</a></h2>
<p>아래의 모든 예제는 세 부분으로 구성됩니다: 원래 코드, 수정된 후의 코드, 그리고 다른 프로젝트에서 나타날 수 있는 코드 사용 예시입니다. 마이너 변경의 경우, 사용 예시는 수정 전과 후 버전 모두에서 성공적으로 빌드되어야 합니다.</p>
<h3 id="item-remove"><a class="header" href="#item-remove">메이저: 모든 공개 아이템의 이름 변경/이동/제거</a></h3>
<p>공개적으로 노출된 <a href="reference/../../reference/items.html">아이템</a> 이 없으면 해당 아이템을 사용하는 모든 코드가 컴파일에 실패합니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub fn foo() {}

///////////////////////////////////////////////////////////
// 변경 후
// ... 아이템이 제거됨

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
fn main() {
    updated_crate::foo(); // 에러: `foo` 함수를 찾을 수 없음
}</code></pre>
<p>여기에는 <a href="reference/../../reference/conditional-compilation.html">조건부 컴파일</a> 에 따라 어떤 아이템이나 동작을 사용할 수 있는지 변경할 수 있는 모든 종류의 <a href="reference/../../reference/conditional-compilation.html#the-cfg-attribute"><code>cfg</code> 속성</a> 을 추가하는 것이 포함됩니다.</p>
<p>완화 전략:</p>
<ul>
<li>제거할 아이템을 <a href="reference/../../reference/attributes/diagnostics.html#the-deprecated-attribute">권장되지 않음(deprecated)</a> 으로 표시한 후, 나중에 SemVer를 중단하는 릴리스에서 제거하세요.</li>
<li>이름이 변경된 아이템을 <a href="reference/../../reference/attributes/diagnostics.html#the-deprecated-attribute">권장되지 않음(deprecated)</a> 으로 표시하고, <a href="reference/../../reference/items/use-declarations.html"><code>pub use</code></a> 아이템을 사용하여 이전 이름으로 다시 내보내기(re-export)하세요.</li>
</ul>
<h3 id="item-new"><a class="header" href="#item-new">마이너: 새로운 공개 아이템 추가</a></h3>
<p>새로운 공개 <a href="reference/../../reference/items.html">아이템</a> 을 추가하는 것은 마이너 변경입니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
// ... 아이템 없음

///////////////////////////////////////////////////////////
// 변경 후
pub fn foo() {}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
// `foo` 는 이전에 존재하지 않았으므로 사용되지 않음.</code></pre>
<p>드문 경우지만 와일드카드(glob) 임포트로 인해 <strong>중단되는 변경 사항(breaking change)</strong> 이 될 수 있습니다. 예를 들어, 새로운 트레이트를 추가하고, 어떤 프로젝트에서 해당 트레이트를 스코프로 가져오는 와일드카드 임포트를 사용하고 있으며, 새로운 트레이트가 구현된 타입과 충돌하는 연관 아이템을 도입하는 경우 모호함으로 인해 컴파일 오류가 발생할 수 있습니다. 예시:</p>
<pre><code class="language-rust ignore">// 중단되는 변경 예시

///////////////////////////////////////////////////////////
// 변경 전
// ... 트레이트 없음

///////////////////////////////////////////////////////////
// 변경 후
pub trait NewTrait {
    fn foo(&amp;self) {}
}

impl NewTrait for i32 {}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::*;

pub trait LocalTrait {
    fn foo(&amp;self) {}
}

impl LocalTrait for i32 {}

fn main() {
    123i32.foo(); // 에러: 스코프 내에 적용 가능한 아이템이 여러 개 있음
}</code></pre>
<p>관례적으로 와일드카드(glob) 임포트는 미래 호환성을 해치는 위험 요소로 알려져 있기 때문에 이는 메이저 변경으로 간주되지 않습니다. 외부 크레이트 아이템의 와일드카드 임포트는 피해야 합니다.</p>
<h3 id="type-layout"><a class="header" href="#type-layout">메이저: 잘 정의된 타입의 정렬, 레이아웃 또는 크기 변경</a></h3>
<p>이전에 잘 정의되었던 타입의 정렬, 레이아웃 또는 크기를 변경하는 것은 중단되는 변경(breaking change)입니다.</p>
<p>일반적으로 <a href="reference/../../reference/type-layout.html#the-default-representation">기본 표현(the default representation)</a> 을 사용하는 타입은 잘 정의된 정렬, 레이아웃 또는 크기를 갖지 않습니다. 컴파일러는 정렬, 레이아웃 또는 크기를 자유롭게 변경할 수 있으므로, 코드는 이에 대해 어떤 가정도 해서는 안 됩니다.</p>
<blockquote>
<p><strong>참고</strong>: 외부 크레이트가 잘 정의되지 않은 타입의 정렬, 레이아웃 또는 크기에 대해 가정을 하는 경우 중단될 가능성이 있습니다. 하지만 그러한 가정을 해서는 안 되기 때문에 이는 SemVer 중단 변경으로 간주되지 않습니다.</p>
</blockquote>
<p>중단 변경이 아닌 변경 사항의 몇 가지 예는 다음과 같습니다(이 가이드의 다른 규칙을 위반하지 않는다고 가정함):</p>
<ul>
<li>이 가이드의 다른 규칙을 따르는 방식으로 기본 표현 구조체, 공용체(union) 또는 열거형의 필드를 추가, 제거, 재정렬 또는 변경하는 것 (예를 들어, <code>non_exhaustive</code> 를 사용하여 이러한 변경을 허용하거나 이미 비공개인 필드를 변경하는 경우). <a href="reference/semver.html#struct-add-private-field-when-public">struct-add-private-field-when-public</a>, <a href="reference/semver.html#struct-add-public-field-when-no-private">struct-add-public-field-when-no-private</a>, <a href="reference/semver.html#struct-private-fields-with-private">struct-private-fields-with-private</a>, <a href="reference/semver.html#enum-fields-new">enum-fields-new</a> 를 참조하세요.</li>
<li>열거형이 <code>non_exhaustive</code> 를 사용하는 경우 기본 표현 열거형에 변형(variant)을 추가하는 것. 이는 열거형의 정렬이나 크기를 변경할 수 있지만, 이들은 잘 정의되어 있지 않습니다. <a href="reference/semver.html#enum-variant-new">enum-variant-new</a> 를 참조하세요.</li>
<li>이 가이드의 다른 규칙을 따르며 <code>repr(C)</code> 구조체, 공용체 또는 열거형의 비공개 필드를 추가, 제거, 재정렬 또는 변경하는 것 (예를 들어, <code>non_exhaustive</code> 를 사용하거나 다른 비공개 필드가 이미 존재할 때 비공개 필드를 추가하는 경우). <a href="reference/semver.html#repr-c-private-change">repr-c-private-change</a> 를 참조하세요.</li>
<li>열거형이 <code>non_exhaustive</code> 를 사용하는 경우 <code>repr(C)</code> 열거형에 변형(variant)을 추가하는 것. <a href="reference/semver.html#repr-c-enum-variant-new">repr-c-enum-variant-new</a> 를 참조하세요.</li>
<li>기본 표현 구조체, 공용체 또는 열거형에 <code>repr(C)</code> 를 추가하는 것. <a href="reference/semver.html#repr-c-add">repr-c-add</a> 를 참조하세요.</li>
<li>열거형에 <code>repr(&lt;int&gt;)</code> <a href="reference/../../reference/type-layout.html#primitive-representations">원시 표현(primitive representation)</a> 을 추가하는 것. <a href="reference/semver.html#repr-int-enum-add">repr-int-enum-add</a> 를 참조하세요.</li>
<li>기본 표현 구조체 또는 열거형에 <code>repr(transparent)</code> 를 추가하는 것. <a href="reference/semver.html#repr-transparent-add">repr-transparent-add</a> 를 참조하세요.</li>
</ul>
<p><a href="reference/../../reference/type-layout.html#representations"><code>repr</code> 속성</a> 을 사용하는 타입은 어떤 방식으로든 정의된 정렬 및 레이아웃을 갖는다고 할 수 있으며, 코드가 이에 대해 가정을 할 수 있습니다. 해당 타입을 변경하면 이러한 가정이 깨질 수 있습니다.</p>
<p>어떤 경우에는 <code>repr</code> 속성이 있는 타입이라도 정렬, 레이아웃 또는 크기가 잘 정의되지 않을 수 있습니다. 이러한 경우 타입을 변경하는 것이 안전할 수 있지만 주의를 기울여야 합니다. 예를 들어, 공개 API가 타입의 정렬, 레이아웃 또는 크기를 완전히 정의하지 않는 경우, 정렬, 레이아웃 또는 크기 보장을 별도로 문서화하지 않은 비공개 필드가 있는 타입을 외부 크레이트가 신뢰해서는 안 됩니다.</p>
<p><em>비공개</em> 필드가 있는 타입이 잘 정의된 일반적인 예로는 <code>repr(transparent)</code> 를 사용하고 단일 비공개 제네릭 타입 필드를 가지며, 문서에서 해당 제네릭 타입에 대해 투명하다는 것을 설명하는 타입이 있습니다. 예를 들어 <a href="reference/../../std/cell/struct.UnsafeCell.html#memory-layout"><code>UnsafeCell</code></a> 을 참조하세요.</p>
<p>중단되는 변경의 몇 가지 예는 다음과 같습니다.</p>
<ul>
<li>구조체 또는 공용체에 <code>repr(packed)</code> 를 추가하는 것. <a href="reference/semver.html#repr-packed-add">repr-packed-add</a> 를 참조하세요.</li>
<li>구조체, 공용체 또는 열거형에 <code>repr(align)</code> 을 추가하는 것. <a href="reference/semver.html#repr-align-add">repr-align-add</a> 를 참조하세요.</li>
<li>구조체 또는 공용체에서 <code>repr(packed)</code> 를 제거하는 것. <a href="reference/semver.html#repr-packed-remove">repr-packed-remove</a> 를 참조하세요.</li>
<li>정렬이나 레이아웃이 변경되는 경우 <code>repr(packed(N))</code> 의 N 값을 변경하는 것. <a href="reference/semver.html#repr-packed-n-change">repr-packed-n-change</a> 를 참조하세요.</li>
<li>정렬이 변경되는 경우 <code>repr(align(N))</code> 의 N 값을 변경하는 것. <a href="reference/semver.html#repr-align-n-change">repr-align-n-change</a> 를 참조하세요.</li>
<li>구조체, 공용체 또는 열거형에서 <code>repr(align)</code> 을 제거하는 것. <a href="reference/semver.html#repr-align-remove">repr-align-remove</a> 를 참조하세요.</li>
<li><code>repr(C)</code> 타입의 공개 필드 순서를 변경하는 것. <a href="reference/semver.html#repr-c-shuffle">repr-c-shuffle</a> 를 참조하세요.</li>
<li>구조체, 공용체 또는 열거형에서 <code>repr(C)</code> 를 제거하는 것. <a href="reference/semver.html#repr-c-remove">repr-c-remove</a> 를 참조하세요.</li>
<li>열거형에서 <code>repr(&lt;int&gt;)</code> 를 제거하는 것. <a href="reference/semver.html#repr-int-enum-remove">repr-int-enum-remove</a> 를 참조하세요.</li>
<li><code>repr(&lt;int&gt;)</code> 열거형의 원시 표현을 변경하는 것. <a href="reference/semver.html#repr-int-enum-change">repr-int-enum-change</a> 를 참조하세요.</li>
<li>구조체 또는 열거형에서 <code>repr(transparent)</code> 를 제거하는 것. <a href="reference/semver.html#repr-transparent-remove">repr-transparent-remove</a> 를 참조하세요.</li>
</ul>
<h4 id="repr-c-private-change"><a class="header" href="#repr-c-private-change">마이너: <code>repr(C)</code> 비공개 필드 추가, 제거 또는 변경</a></h4>
<p>이 가이드의 다른 지침을 따르는 한, <code>repr(C)</code> 구조체, 공용체 또는 열거형의 비공개 필드를 추가, 제거 또는 변경하는 것은 일반적으로 안전합니다. (<a href="reference/semver.html#struct-add-private-field-when-public">struct-add-private-field-when-public</a>, <a href="reference/semver.html#struct-add-public-field-when-no-private">struct-add-public-field-when-no-private</a>, <a href="reference/semver.html#struct-private-fields-with-private">struct-private-fields-with-private</a>, <a href="reference/semver.html#enum-fields-new">enum-fields-new</a> 를 참조하세요.)</p>
<p>예를 들어, 비공개 필드 추가는 다른 비공개 필드가 이미 존재하거나 <code>non_exhaustive</code> 인 경우에만 가능합니다. 공개 필드는 비공개 필드가 있거나 <code>non_exhaustive</code> 이며, 추가로 인해 다른 필드의 레이아웃이 변경되지 않는 경우에 추가될 수 있습니다.</p>
<p>However, this may change the size and alignment of the type. Care should be taken if the size or alignment changes. Code should not make assumptions about the size or alignment of types with private fields or <code>non_exhaustive</code> unless it has a documented size or alignment.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
#[derive(Default)]
#[repr(C)]
pub struct Example {
    pub f1: i32,
    f2: i32, // 비공개 필드
}

///////////////////////////////////////////////////////////
// 변경 후
#[derive(Default)]
#[repr(C)]
pub struct Example {
    pub f1: i32,
    f2: i32,
    f3: i32, // 새로운 필드
}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
fn main() {
    // 참고: 크기나 정렬은 문서화되지 않았으므로 사용자는 이에 대해 가정해서는 안 됩니다.
    let f = updated_crate::Example::default();
}</code></pre>
<h4 id="repr-c-enum-variant-new"><a class="header" href="#repr-c-enum-variant-new">마이너: <code>repr(C)</code> 열거형 변형(variant) 추가</a></h4>
<p>열거형이 <code>non_exhaustive</code> 를 사용하는 경우, <code>repr(C)</code> 열거형에 변형(variant)을 추가하는 것은 일반적으로 안전합니다. 자세한 내용은 <a href="reference/semver.html#enum-variant-new">enum-variant-new</a> 를 참조하세요.</p>
<p>이는 타입의 크기와 정렬을 변경하기 때문에 중단되는 변경(breaking change)이 될 수 있습니다. 유사한 문제에 대해서는 <a href="reference/semver.html#repr-c-private-change">repr-c-private-change</a> 를 참조하세요.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(C)]
#[non_exhaustive]
pub enum Example {
    Variant1 { f1: i16 },
    Variant2 { f1: i32 },
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(C)]
#[non_exhaustive]
pub enum Example {
    Variant1 { f1: i16 },
    Variant2 { f1: i32 },
    Variant3 { f1: i64 }, // 추가됨
}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
fn main() {
    // 참고: 크기나 정렬은 명시되지 않았으므로 사용자는 이에 대해 가정해서는 안 됩니다. 예를 들어, 이로 인해 크기가 8바이트에서 16바이트로 늘어났습니다.
    let f = updated_crate::Example::Variant2 { f1: 123 };
}</code></pre>
<h4 id="repr-c-add"><a class="header" href="#repr-c-add">마이너: 기본 표현에 <code>repr(C)</code> 추가</a></h4>
<p><a href="reference/../../reference/type-layout.html#the-default-representation">기본 표현(the default representation)</a> 을 사용하는 구조체, 공용체 또는 열거형에 <code>repr(C)</code> 를 추가하는 것은 안전합니다. 기본 표현을 사용하는 타입의 정렬, 레이아웃 또는 크기에 대해 사용자가 어떤 가정도 해서는 안 되기 때문에 이는 안전합니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Example {
    pub f1: i32,
    pub f2: i16,
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(C)] // 추가됨
pub struct Example {
    pub f1: i32,
    pub f2: i16,
}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
fn main() {
    let f = updated_crate::Example { f1: 123, f2: 456 };
}</code></pre>
<h4 id="repr-int-enum-add"><a class="header" href="#repr-int-enum-add">마이너: 열거형에 <code>repr(&lt;int&gt;)</code> 추가</a></h4>
<p><a href="reference/../../reference/type-layout.html#the-default-representation">기본 표현(the default representation)</a> 을 사용하는 열거형에 <code>repr(&lt;int&gt;)</code> <a href="reference/../../reference/type-layout.html#primitive-representations">원시 표현(primitive representation)</a> 을 추가하는 것은 안전합니다. 기본 표현을 사용하는 열거형의 정렬, 레이아웃 또는 크기에 대해 사용자가 어떤 가정도 해서는 안 되기 때문에 이는 안전합니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
pub enum E {
    Variant1,
    Variant2(i32),
    Variant3 { f1: f64 },
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(i32)] // 추가됨
pub enum E {
    Variant1,
    Variant2(i32),
    Variant3 { f1: f64 },
}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
fn main() {
    let x = updated_crate::E::Variant3 { f1: 1.23 };
}</code></pre>
<h4 id="repr-transparent-add"><a class="header" href="#repr-transparent-add">마이너: 기본 표현 구조체 또는 열거형에 <code>repr(transparent)</code> 추가</a></h4>
<p><a href="reference/../../reference/type-layout.html#the-default-representation">기본 표현(the default representation)</a> 을 사용하는 구조체 또는 열거형에 <code>repr(transparent)</code> 를 추가하는 것은 안전합니다. 기본 표현을 사용하는 구조체 또는 열거형의 정렬, 레이아웃 또는 크기에 대해 사용자가 어떤 가정도 해서는 안 되기 때문에 이는 안전합니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
#[derive(Default)]
pub struct Example&lt;T&gt;(T);

///////////////////////////////////////////////////////////
// 변경 후
#[derive(Default)]
#[repr(transparent)] // 추가됨
pub struct Example&lt;T&gt;(T);

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
fn main() {
    let x = updated_crate::Example::&lt;i32&gt;::default();
}</code></pre>
<h4 id="repr-packed-add"><a class="header" href="#repr-packed-add">메이저: 구조체 또는 공용체에 <code>repr(packed)</code> 추가</a></h4>
<p>구조체 또는 공용체에 <code>repr(packed)</code> 를 추가하는 것은 중단되는 변경(breaking change)입니다. 타입을 <code>repr(packed)</code> 로 만들면 필드에 대한 참조를 가져오는 것이 무효화되거나, 불연속 클로저 캡처(disjoint closure captures)의 잘림(truncation)이 발생하는 등 코드를 중단시킬 수 있는 변경이 발생합니다.</p>
<!-- TODO: If all fields are private, should this be safe to do? -->
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Example {
    pub f1: u8,
    pub f2: u16,
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(packed)] // 추가됨
pub struct Example {
    pub f1: u8,
    pub f2: u16,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
fn main() {
    let f = updated_crate::Example { f1: 1, f2: 2 };
    let x = &amp;f.f2; // Error: error[E0793]: reference to field of packed struct is unaligned
}</code></pre>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Example(pub i32, pub i32);

///////////////////////////////////////////////////////////
// 변경 후
#[repr(packed)]
pub struct Example(pub i32, pub i32);

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
fn main() {
    let mut f = updated_crate::Example(123, 456);
    let c = || {
        // repr(packed)가 없으면 클로저는 정확히 `&amp;f.0` 을 캡처합니다.
        // repr(packed)가 있으면 클로저는 정의되지 않은 동작을 피하기 위해 `&amp;f` 를 캡처합니다.
        let a = f.0;
    };
    f.1 = 789; // 에러: `f.1` 이 대여 중이므로 값을 할당할 수 없음
    c();
}</code></pre>
<h4 id="repr-align-add"><a class="header" href="#repr-align-add">메이저: 구조체, 공용체 또는 열거형에 <code>repr(align)</code> 추가</a></h4>
<p>구조체, 공용체 또는 열거형에 <code>repr(align)</code> 을 추가하는 것은 중단되는 변경(breaking change)입니다. 타입을 <code>repr(align)</code> 으로 만들면 해당 타입을 <code>repr(packed)</code> 타입에서 사용하는 것이 중단됩니다. 이 두 조합은 허용되지 않기 때문입니다.</p>
<!-- TODO: This seems like it should be extraordinarily rare. Should there be any exceptions carved out for this? -->
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Aligned {
    pub a: i32,
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(align(8))] // 추가됨
pub struct Aligned {
    pub a: i32,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Aligned;

#[repr(packed)]
pub struct Packed { // 에러: packed 타입은 전이적으로 `#[repr(align)]` 타입을 포함할 수 없음
    f1: Aligned,
}

fn main() {
    let p = Packed {
        f1: Aligned { a: 123 },
    };
}</code></pre>
<h4 id="repr-packed-remove"><a class="header" href="#repr-packed-remove">메이저: 구조체 또는 공용체에서 <code>repr(packed)</code> 제거</a></h4>
<p>구조체 또는 공용체에서 <code>repr(packed)</code> 를 제거하는 것은 중단되는 변경(breaking change)입니다. 이는 외부 크레이트가 의존하고 있는 정렬이나 레이아웃을 변경할 수 있습니다.</p>
<p>공개 필드가 있는 경우, <code>repr(packed)</code> 를 제거하면 불연속 클로저 캡처(disjoint closure captures) 방식이 변경될 수 있습니다. 어떤 경우에는 <a href="reference/../../edition-guide/rust-2021/disjoint-capture-in-closures.html">에디션 가이드</a> 에 설명된 것과 유사하게 코드가 중단될 수 있습니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(C, packed)]
pub struct Packed {
    pub a: u8,
    pub b: u16,
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(C)] // packed 제거됨
pub struct Packed {
    pub a: u8,
    pub b: u16,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Packed;

fn main() {
    let p = Packed { a: 1, b: 2 };
    // 타입 크기에 대한 어떤 가정.
    // `packed` 가 없으면 크기가 4이므로 실패함.
    const _: () = assert!(std::mem::size_of::&lt;Packed&gt;() == 3); // Error: assertion failed
}</code></pre>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(C, packed)]
pub struct Packed {
    pub a: *mut i32,
    pub b: i32,
}
unsafe impl Send for Packed {}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(C)] // packed 제거됨
pub struct Packed {
    pub a: *mut i32,
    pub b: i32,
}
unsafe impl Send for Packed {}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Packed;

fn main() {
    let mut x = 123;

    let p = Packed {
        a: &amp;mut x as *mut i32,
        b: 456,
    };

    // 구조체가 packed였을 때, 클로저는 Send인 `p` 를 캡처합니다.
    // `packed` 가 제거되면 Send가 아닌 `p.a` 를 캡처하게 됩니다.
    std::thread::spawn(move || unsafe {
        *(p.a) += 1; // 에러: 스레드 간에 안전하게 보낼 수 없음
    });
}</code></pre>
<h4 id="repr-packed-n-change"><a class="header" href="#repr-packed-n-change">메이저: 정렬이나 레이아웃이 변경되는 경우 <code>repr(packed(N))</code> 의 N 값 변경</a></h4>
<p>정렬이나 레이아웃이 변경되는 경우 <code>repr(packed(N))</code> 의 N 값을 변경하는 것은 중단되는 변경(breaking change)입니다. 이는 외부 크레이트가 의존하고 있는 정렬이나 레이아웃을 변경할 수 있습니다.</p>
<p><code>N</code> 값이 공개 필드의 정렬보다 낮아지면, 해당 필드의 참조를 가져오려는 모든 코드가 중단됩니다.</p>
<p>현재 값이 이미 타입의 자연스러운 정렬(natural alignment)과 같은 상태에서 이를 높이는 경우와 같이, <code>N</code> 에 대한 일부 변경은 정렬이나 레이아웃을 변경하지 않을 수도 있습니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(packed(4))]
pub struct Packed {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(packed(2))] // 2로 변경됨
pub struct Packed {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Packed;

fn main() {
    let p = Packed { a: 1, b: 2 };
    let x = &amp;p.b; // Error: error[E0793]: reference to field of packed struct is unaligned
}</code></pre>
<h4 id="repr-align-n-change"><a class="header" href="#repr-align-n-change">메이저: 정렬이 변경되는 경우 <code>repr(align(N))</code> 의 N 값 변경</a></h4>
<p>정렬이 변경되는 경우 <code>repr(align(N))</code> 의 <code>N</code> 값을 변경하는 것은 중단되는 변경(breaking change)입니다. 이는 외부 크레이트가 의존하고 있는 정렬을 변경할 수 있습니다.</p>
<p><a href="reference/semver.html#type-layout">타입 레이아웃</a> 에서 논의된 바와 같이 타입이 잘 정의되지 않은 경우(예: 비공개 필드가 있고 정렬이나 레이아웃이 문서화되지 않은 경우), 이러한 변경은 안전할 것입니다.</p>
<p>현재 값이 이미 타입의 자연스러운 정렬보다 작거나 같은 상태에서 이를 줄이는 경우와 같이, <code>N</code> 에 대한 일부 변경은 정렬이나 레이아웃을 변경하지 않을 수도 있습니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(align(8))]
pub struct Packed {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(align(4))] // 4로 변경됨
pub struct Packed {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Packed;

fn main() {
    let p = Packed { a: 1, b: 2 };
    // 타입 크기에 대한 어떤 가정.
    // 정렬이 8에서 4로 변경됨.
    const _: () = assert!(std::mem::align_of::&lt;Packed&gt;() == 8); // Error: assertion failed
}</code></pre>
<h4 id="repr-align-remove"><a class="header" href="#repr-align-remove">메이저: 구조체, 공용체 또는 열거형에서 <code>repr(align)</code> 제거</a></h4>
<p>구조체, 공용체 또는 열거형의 레이아웃이 잘 정의되어 있는 경우, <code>repr(align)</code> 을 제거하는 것은 중단되는 변경(breaking change)입니다. 이는 외부 크레이트가 의존하고 있는 정렬이나 레이아웃을 변경할 수 있습니다.</p>
<p><a href="reference/semver.html#type-layout">타입 레이아웃</a> 에서 논의된 바와 같이 타입이 잘 정의되지 않은 경우(예: 비공개 필드가 있고 정렬이 문서화되지 않은 경우), 이러한 변경은 안전할 것입니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(C, align(8))]
pub struct Packed {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(C)] // align 제거됨
pub struct Packed {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Packed;

fn main() {
    let p = Packed { a: 1, b: 2 };
    // 타입 크기에 대한 어떤 가정.
    // 정렬이 8에서 4로 변경됨.
    const _: () = assert!(std::mem::align_of::&lt;Packed&gt;() == 8); // Error: assertion failed
}</code></pre>
<h4 id="repr-c-shuffle"><a class="header" href="#repr-c-shuffle">메이저: <code>repr(C)</code> 타입의 공개 필드 순서 변경</a></h4>
<p><code>repr(C)</code> 타입의 공개 필드 순서를 변경하는 것은 중단되는 변경(breaking change)입니다. 외부 크레이트가 필드의 특정 순서에 의존하고 있을 수 있습니다.</p>
<pre><code class="language-rust ignore run-fail">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(C)]
pub struct SpecificLayout {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(C)]
pub struct SpecificLayout {
    pub b: u32, // 순서 변경됨
    pub a: u8,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::SpecificLayout;

unsafe extern "C" {
    // 이 C 함수는 C 헤더에 정의된 특정 레이아웃을 가정하고 있습니다.
    fn c_fn_get_b(x: &amp;SpecificLayout) -&gt; u32;
}

fn main() {
    let p = SpecificLayout { a: 1, b: 2 };
    unsafe { assert_eq!(c_fn_get_b(&amp;p), 2) } // 에러: 값이 2와 같지 않음
}

<span class="boring">mod cdep {
</span><span class="boring">    // 이는 보통 빌드 스크립트에서 포함되는 내용을 시뮬레이션합니다.
</span><span class="boring">    // 이 정의는 C 헤더에 있을 것입니다.
</span><span class="boring">    #[repr(C)]
</span><span class="boring">    pub struct SpecificLayout {
</span><span class="boring">        pub a: u8,
</span><span class="boring">        pub b: u32,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[no_mangle]
</span><span class="boring">    pub fn c_fn_get_b(x: &amp;SpecificLayout) -&gt; u32 {
</span><span class="boring">        x.b
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h4 id="repr-c-remove"><a class="header" href="#repr-c-remove">메이저: 구조체, 공용체 또는 열거형에서 <code>repr(C)</code> 제거</a></h4>
<p>구조체, 공용체 또는 열거형에서 <code>repr(C)</code> 를 제거하는 것은 중단되는 변경(breaking change)입니다. 외부 크레이트가 해당 타입의 특정 레이아웃에 의존하고 있을 수 있습니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(C)]
pub struct SpecificLayout {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// 변경 후
// repr(C) 제거됨
pub struct SpecificLayout {
    pub a: u8,
    pub b: u32,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::SpecificLayout;

unsafe extern "C" {
    // 이 C 함수는 C 헤더에 정의된 특정 레이아웃을 가정하고 있습니다.
    fn c_fn_get_b(x: &amp;SpecificLayout) -&gt; u32; // 에러: FFI 안전하지 않음
}

fn main() {
    let p = SpecificLayout { a: 1, b: 2 };
    unsafe { assert_eq!(c_fn_get_b(&amp;p), 2) }
}

<span class="boring">mod cdep {
</span><span class="boring">    // 이는 보통 빌드 스크립트에서 포함되는 내용을 시뮬레이션합니다.
</span><span class="boring">    // 이 정의는 C 헤더에 있을 것입니다.
</span><span class="boring">    #[repr(C)]
</span><span class="boring">    pub struct SpecificLayout {
</span><span class="boring">        pub a: u8,
</span><span class="boring">        pub b: u32,
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[no_mangle]
</span><span class="boring">    pub fn c_fn_get_b(x: &amp;SpecificLayout) -&gt; u32 {
</span><span class="boring">        x.b
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<h4 id="repr-int-enum-remove"><a class="header" href="#repr-int-enum-remove">메이저: 열거형에서 <code>repr(&lt;int&gt;)</code> 제거</a></h4>
<p>열거형에서 <code>repr(&lt;int&gt;)</code> 를 제거하는 것은 중단되는 변경(breaking change)입니다. 외부 크레이트가 판별자(discriminant)가 특정 크기라고 가정하고 있을 수 있습니다. 예를 들어, 열거형의 <a href="reference/../../std/mem/fn.transmute.html"><code>std::mem::transmute</code></a> 이 실패할 수 있습니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(u16)]
pub enum Example {
    Variant1,
    Variant2,
    Variant3,
}

///////////////////////////////////////////////////////////
// 변경 후
// repr(u16) 제거됨
pub enum Example {
    Variant1,
    Variant2,
    Variant3,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시

fn main() {
    let e = updated_crate::Example::Variant2;
    let i: u16 = unsafe { std::mem::transmute(e) }; // 에러: 크기가 다른 타입 간에 transmute할 수 없음
}</code></pre>
<h4 id="repr-int-enum-change"><a class="header" href="#repr-int-enum-change">메이저: <code>repr(&lt;int&gt;)</code> 열거형의 원시 표현 변경</a></h4>
<p><code>repr(&lt;int&gt;)</code> 열거형의 원시 표현을 변경하는 것은 중단되는 변경(breaking change)입니다. 외부 크레이트가 판별자(discriminant)가 특정 크기라고 가정하고 있을 수 있습니다. 예를 들어, 열거형의 <a href="reference/../../std/mem/fn.transmute.html"><code>std::mem::transmute</code></a> 이 실패할 수 있습니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(u16)]
pub enum Example {
    Variant1,
    Variant2,
    Variant3,
}

///////////////////////////////////////////////////////////
// 변경 후
#[repr(u8)] // repr 크기가 변경됨
pub enum Example {
    Variant1,
    Variant2,
    Variant3,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시

fn main() {
    let e = updated_crate::Example::Variant2;
    let i: u16 = unsafe { std::mem::transmute(e) }; // 에러: 크기가 다른 타입 간에 transmute할 수 없음
}</code></pre>
<h4 id="repr-transparent-remove"><a class="header" href="#repr-transparent-remove">메이저: 구조체 또는 열거형에서 <code>repr(transparent)</code> 제거</a></h4>
<p>구조체 또는 열거형에서 <code>repr(transparent)</code> 를 제거하는 것은 중단되는 변경(breaking change)입니다. 외부 크레이트가 해당 타입이 투명 필드(transparent field)의 정렬, 레이아웃 또는 크기를 갖는 것에 의존하고 있을 수 있습니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[repr(transparent)]
pub struct Transparent&lt;T&gt;(T);

///////////////////////////////////////////////////////////
// 변경 후
// repr 제거됨
pub struct Transparent&lt;T&gt;(T);

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
#![deny(improper_ctypes)]
use updated_crate::Transparent;

unsafe extern "C" {
    fn c_fn() -&gt; Transparent&lt;f64&gt;; // 에러: FFI 안전하지 않음
}

fn main() {}</code></pre>
<h3 id="struct-add-private-field-when-public"><a class="header" href="#struct-add-private-field-when-public">메이저: 현재 모든 필드가 공개인 상태에서 비공개 구조체 필드 추가</a></h3>
<p>이전에 모든 필드가 공개였던 구조체에 비공개 필드가 추가되면, <a href="reference/../../reference/expressions/struct-expr.html">구조체 리터럴</a> 을 사용하여 해당 구조체를 생성하려는 모든 코드가 중단됩니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Foo {
    pub f1: i32,
}

///////////////////////////////////////////////////////////
// 변경 후
pub struct Foo {
    pub f1: i32,
    f2: i32,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
fn main() {
    let x = updated_crate::Foo { f1: 123 }; // 에러: `Foo` 를 생성할 수 없음
}</code></pre>
<p>완화 전략:</p>
<ul>
<li>모든 필드가 공개인 구조체에 새로운 필드를 추가하지 마세요.</li>
<li>구조체를 처음 도입할 때 사용자가 구조체 리터럴 구문을 사용하지 못하도록 <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>로 표시하고, 대신 생성자 메서드 및/또는 <a href="reference/../../std/default/trait.Default.html">Default</a> 구현을 제공하세요.</li>
</ul>
<h3 id="struct-add-public-field-when-no-private"><a class="header" href="#struct-add-public-field-when-no-private">메이저: 비공개 필드가 없는 상태에서 공개 필드 추가</a></h3>
<p>모든 필드가 공개인 구조체에 공개 필드가 추가되면, <a href="reference/../../reference/expressions/struct-expr.html">구조체 리터럴</a> 을 사용하여 해당 구조체를 생성하려는 모든 코드가 중단됩니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Foo {
    pub f1: i32,
}

///////////////////////////////////////////////////////////
// 변경 후
pub struct Foo {
    pub f1: i32,
    pub f2: i32,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
fn main() {
    let x = updated_crate::Foo { f1: 123 }; // 에러: `f2` 필드가 누락됨
}</code></pre>
<p>완화 전략:</p>
<ul>
<li>모든 필드가 공개인 구조체에 새로운 필드를 추가하지 마세요.</li>
<li>구조체를 처음 도입할 때 사용자가 구조체 리터럴 구문을 사용하지 못하도록 <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>로 표시하고, 대신 생성자 메서드 및/또는 <a href="reference/../../std/default/trait.Default.html">Default</a> 구현을 제공하세요.</li>
</ul>
<h3 id="struct-private-fields-with-private"><a class="header" href="#struct-private-fields-with-private">마이너: 적어도 하나의 비공개 필드가 이미 존재하는 상태에서 비공개 필드 추가 또는 제거</a></h3>
<p>구조체에 이미 적어도 하나의 비공개 필드가 있는 경우, 비공개 필드를 추가하거나 제거하는 것은 안전합니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
#[derive(Default)]
pub struct Foo {
    f1: i32,
}

///////////////////////////////////////////////////////////
// 변경 후
#[derive(Default)]
pub struct Foo {
    f2: f64,
}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
fn main() {
    // 비공개 필드에 접근할 수 없음.
    let x = updated_crate::Foo::default();
}</code></pre>
<p>기존 코드가 <a href="reference/../../reference/expressions/struct-expr.html">구조체 리터럴</a> 을 사용하여 이를 생성할 수 없고, 그 내용을 철저하게 매칭(exhaustive match)할 수도 없기 때문에 이는 안전합니다.</p>
<p>튜플 구조체의 경우, 튜플에 공개 필드가 포함되어 있고 비공개 필드의 추가 또는 제거가 공개 필드의 인덱스를 변경한다면 이는 <strong>메이저 변경</strong> 이라는 점에 유의하세요.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#[derive(Default)]
pub struct Foo(pub i32, i32);

///////////////////////////////////////////////////////////
// 변경 후
#[derive(Default)]
pub struct Foo(f64, pub i32, i32);

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
fn main() {
    let x = updated_crate::Foo::default();
    let y = x.0; // 에러: 비공개임
}</code></pre>
<h3 id="struct-tuple-normal-with-private"><a class="header" href="#struct-tuple-normal-with-private">마이너: (하나 이상의 필드가 있는) 모든 필드가 비공개인 튜플 구조체에서 일반 구조체로의 전환, 또는 그 반대</a></h3>
<p>모든 필드가 비공개인 경우 튜플 구조체를 일반 구조체로 변경하는 것(또는 그 반대)은 안전합니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
#[derive(Default)]
pub struct Foo(i32);

///////////////////////////////////////////////////////////
// 변경 후
#[derive(Default)]
pub struct Foo {
    f1: i32,
}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
fn main() {
    // 비공개 필드에 접근할 수 없음.
    let x = updated_crate::Foo::default();
}</code></pre>
<p>기존 코드가 <a href="reference/../../reference/expressions/struct-expr.html">구조체 리터럴</a> 을 사용하여 이를 생성할 수 없고, 그 내용을 매칭할 수도 없기 때문에 이는 안전합니다.</p>
<h3 id="enum-variant-new"><a class="header" href="#enum-variant-new">메이저: 새로운 열거형 변형(variant) 추가 (<code>non_exhaustive</code> 없이)</a></h3>
<p>열거형이 <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a> 속성을 사용하지 않는 경우 새로운 열거형 변형을 추가하는 것은 중단되는 변경(breaking change)입니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub enum E {
    Variant1,
}

///////////////////////////////////////////////////////////
// 변경 후
pub enum E {
    Variant1,
    Variant2,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
fn main() {
    use updated_crate::E;
    let x = E::Variant1;
    match x { // 에러: `E::Variant2` 가 처리되지 않음
        E::Variant1 =&gt; {}
    }
}</code></pre>
<p>완화 전략:</p>
<ul>
<li>열거형을 도입할 때 <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>로 표시하여 사용자가 새로운 변형을 처리하기 위해 <a href="reference/../../reference/patterns.html#wildcard-pattern">와일드카드 패턴</a> 을 사용하도록 강제하세요.</li>
</ul>
<h3 id="enum-fields-new"><a class="header" href="#enum-fields-new">메이저: 열거형 변형에 새로운 필드 추가</a></h3>
<p>열거형 변형의 모든 필드는 공개이므로 새로운 필드를 추가하면 생성자와 매칭의 컴파일이 실패하게 되어 중단되는 변경(breaking change)이 됩니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub enum E {
    Variant1 { f1: i32 },
}

///////////////////////////////////////////////////////////
// 변경 후
pub enum E {
    Variant1 { f1: i32, f2: i32 },
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
fn main() {
    use updated_crate::E;
    let x = E::Variant1 { f1: 1 }; // 에러: f2가 누락됨
    match x {
        E::Variant1 { f1 } =&gt; {} // 에러: f2가 누락됨
    }
}</code></pre>
<p>완화 전략:</p>
<ul>
<li>
<p>열거형을 도입할 때 변형을 <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>non_exhaustive</code></a> 로 표시하여 와일드카드 없이 생성하거나 매칭할 수 없도록 하세요.</p>
<pre><code class="language-rust ignore skip">pub enum E {
    #[non_exhaustive]
    Variant1{f1: i32}
}</code></pre>
</li>
<li>
<p>열거형을 도입할 때 필드 가시성을 제어할 수 있는 명시적인 구조체를 값으로 사용하세요.</p>
<pre><code class="language-rust ignore skip">pub struct Foo {
   f1: i32,
   f2: i32,
}
pub enum E {
    Variant1(Foo)
}</code></pre>
</li>
</ul>
<h3 id="trait-new-item-no-default"><a class="header" href="#trait-new-item-no-default">메이저: 기본값이 없는 트레이트 아이템 추가</a></h3>
<p>트레이트에 기본값이 없는 아이템을 추가하는 것은 중단되는 변경(breaking change)입니다. 이는 트레이트의 모든 구현체를 중단시킵니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub trait Trait {}

///////////////////////////////////////////////////////////
// 변경 후
pub trait Trait {
    fn foo(&amp;self);
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}  // 에러: 모든 트레이트 아이템이 구현되지 않음</code></pre>
<p>완화 전략:</p>
<ul>
<li>새로운 연관 트레이트 아이템에는 항상 기본 구현이나 값을 제공하세요.</li>
<li>트레이트를 도입할 때, 크레이트 외부의 사용자가 트레이트를 구현하지 못하도록 <a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed">봉인된 트레이트(sealed trait)</a> 기법을 사용하세요.</li>
</ul>
<h3 id="trait-item-signature"><a class="header" href="#trait-item-signature">메이저: 트레이트 아이템 시그니처의 모든 변경</a></h3>
<p>트레이트 아이템 시그니처를 변경하는 것은 중단되는 변경(breaking change)입니다. 이는 트레이트의 외부 구현체를 중단시킬 수 있습니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub trait Trait {
    fn f(&amp;self, x: i32) {}
}

///////////////////////////////////////////////////////////
// 변경 후
pub trait Trait {
    // 봉인된 트레이트나 일반 함수의 경우, 제네릭을 사용한 일반화가 가능한 용도를 엄격하게 확장하기 때문에 이는 마이너 변경일 것입니다.
    // 하지만 이 경우 트레이트 구현은 동일한 시그니처를 사용해야 합니다.
    fn f&lt;V&gt;(&amp;self, x: V) {}
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {
    fn f(&amp;self, x: i32) {}  // 에러: 트레이트 선언에 1개의 타입 매개변수가 있음
}</code></pre>
<p>완화 전략:</p>
<ul>
<li>기존 아이템을 수정하는 대신, 새로운 기능을 제공하기 위해 기본 구현이 포함된 새로운 아이템을 도입하세요.</li>
<li>트레이트를 도입할 때, 크레이트 외부의 사용자가 트레이트를 구현하지 못하도록 <a href="https://rust-lang.github.io/api-guidelines/future-proofing.html#sealed-traits-protect-against-downstream-implementations-c-sealed">봉인된 트레이트(sealed trait)</a> 기법을 사용하세요.</li>
</ul>
<h3 id="trait-new-default-item"><a class="header" href="#trait-new-default-item">중단 가능성 있음: 기본값이 있는 트레이트 아이템 추가</a></h3>
<p>기본값이 있는 트레이트 아이템을 추가하는 것은 일반적으로 안전합니다. 하지만 때때로 컴파일 오류를 일으킬 수 있습니다. 예를 들어, 다른 트레이트에 동일한 이름의 메서드가 존재하는 경우 모호함이 발생할 수 있습니다.</p>
<pre><code class="language-rust ignore">// 중단되는 변경 예시

///////////////////////////////////////////////////////////
// 변경 전
pub trait Trait {}

///////////////////////////////////////////////////////////
// 변경 후
pub trait Trait {
    fn foo(&amp;self) {}
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Trait;
struct Foo;

trait LocalTrait {
    fn foo(&amp;self) {}
}

impl Trait for Foo {}
impl LocalTrait for Foo {}

fn main() {
    let x = Foo;
    x.foo(); // 에러: 스코프 내에 적용 가능한 아이템이 여러 개 있음
}</code></pre>
<p><a href="reference/../../reference/items/implementations.html#inherent-implementations">고유 구현(inherent implementations)</a> 의 이름 충돌에 대해서는 이러한 모호함이 발생하지 않습니다. 고유 구현이 트레이트 아이템보다 우선순위를 갖기 때문입니다.</p>
<p>트레이트 아이템을 추가할 때 고려해야 할 특별한 경우에 대해서는 <a href="reference/semver.html#trait-object-safety">trait-object-safety</a> 를 참조하세요.</p>
<p>완화 전략:</p>
<ul>
<li>일부 프로젝트에서는 특히 새로운 아이템 이름이 기존 코드와 충돌할 가능성이 낮은 경우, 이를 허용 가능한 중단으로 간주할 수 있습니다. 이러한 충돌을 피하기 위해 이름을 신중하게 선택하세요. 또한, 의존성을 업데이트할 때 다운스트림 사용자가 올바른 함수를 선택하기 위해 <a href="reference/../../reference/expressions/call-expr.html#disambiguating-function-calls">모호성 해소 구문(disambiguation syntax)</a> 을 추가하도록 요구하는 것이 허용될 수 있습니다.</li>
</ul>
<h3 id="trait-object-safety"><a class="header" href="#trait-object-safety">메이저: 트레이트를 객체 안전하지 않게 만드는 트레이트 아이템 추가</a></h3>
<p>트레이트를 <a href="reference/../../reference/items/traits.html#object-safety">객체 안전(object safe)</a> 하지 않게 변경하는 트레이트 아이템을 추가하는 것은 중단되는 변경(breaking change)입니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub trait Trait {}

///////////////////////////////////////////////////////////
// 변경 후
pub trait Trait {
    // 연관 상수는 트레이트를 객체 안전하지 않게 만듭니다.
    const CONST: i32 = 123;
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}

fn main() {
    let obj: Box&lt;dyn Trait&gt; = Box::new(Foo); // Error: the trait `Trait` is not dyn compatible
}</code></pre>
<p>그 반대(객체 안전하지 않은 트레이트를 객체 안전하게 만드는 것)는 안전합니다.</p>
<h3 id="trait-new-parameter-no-default"><a class="header" href="#trait-new-parameter-no-default">메이저: 기본값 없이 타입 매개변수 추가</a></h3>
<p>트레이트에 기본값 없이 타입 매개변수를 추가하는 것은 중단되는 변경(breaking change)입니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub trait Trait {}

///////////////////////////////////////////////////////////
// 변경 후
pub trait Trait&lt;T&gt; {}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}  // 에러: 제네릭이 누락됨</code></pre>
<p>완화 전략:</p>
<ul>
<li><a href="reference/semver.html#trait-new-parameter-default">기본값이 있는 트레이트 타입 매개변수 추가</a> 를 참조하세요.</li>
</ul>
<h3 id="trait-new-parameter-default"><a class="header" href="#trait-new-parameter-default">마이너: 기본값이 있는 트레이트 타입 매개변수 추가</a></h3>
<p>기본값이 있는 한 트레이트에 타입 매개변수를 추가하는 것은 안전합니다. 외부 구현체는 매개변수를 지정할 필요 없이 기본값을 사용하게 됩니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
pub trait Trait {}

///////////////////////////////////////////////////////////
// 변경 후
pub trait Trait&lt;T = i32&gt; {}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
use updated_crate::Trait;
struct Foo;

impl Trait for Foo {}</code></pre>
<h3 id="impl-item-new"><a class="header" href="#impl-item-new">중단 가능성 있음: 고유 아이템(inherent items) 추가</a></h3>
<p>일반적으로 고유 아이템이 트레이트 아이템보다 우선순위를 갖기 때문에 구현에 고유 아이템을 추가하는 것은 안전할 것입니다. 그러나 이름이 구현된 트레이트 아이템과 같고 시그니처가 다른 경우 충돌이 발생하여 문제가 생길 수 있습니다.</p>
<pre><code class="language-rust ignore">// 중단되는 변경 예시

///////////////////////////////////////////////////////////
// 변경 전
pub struct Foo;

///////////////////////////////////////////////////////////
// 변경 후
pub struct Foo;

impl Foo {
    pub fn foo(&amp;self) {}
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Foo;

trait Trait {
    fn foo(&amp;self, x: i32) {}
}

impl Trait for Foo {}

fn main() {
    let x = Foo;
    x.foo(1); // 에러: 이 메서드는 0개의 인수를 받지만 1개의 인수가 제공됨
}</code></pre>
<p>시그니처가 일치하는 경우에는 컴파일 오류는 발생하지 않지만, 런타임 동작이 조용히 변경될 수 있습니다(이제 다른 함수를 실행하게 되기 때문입니다).</p>
<p>완화 전략:</p>
<ul>
<li>일부 프로젝트에서는 특히 새로운 아이템 이름이 기존 코드와 충돌할 가능성이 낮은 경우, 이를 허용 가능한 중단으로 간주할 수 있습니다. 이러한 충돌을 피하기 위해 이름을 신중하게 선택하세요. 또한, 의존성을 업데이트할 때 다운스트림 사용자가 올바른 함수를 선택하기 위해 <a href="reference/../../reference/expressions/call-expr.html#disambiguating-function-calls">모호성 해소 구문(disambiguation syntax)</a> 을 추가하도록 요구하는 것이 허용될 수 있습니다.</li>
</ul>
<h3 id="generic-bounds-tighten"><a class="header" href="#generic-bounds-tighten">메이저: 제네릭 바운드 강화</a></h3>
<p>타입의 제네릭 바운드를 강화하는 것은 더 느슨한 바운드를 예상하는 사용자들을 중단시킬 수 있으므로 중단되는 변경(breaking change)입니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Foo&lt;A&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// 변경 후
pub struct Foo&lt;A: Eq&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Foo;

fn main() {
    let s = Foo { f1: 1.23 }; // 에러: 트레이트 바운드 `{float}: Eq` 가 충족되지 않음
}</code></pre>
<h3 id="generic-bounds-loosen"><a class="header" href="#generic-bounds-loosen">마이너: 제네릭 바운드 완화</a></h3>
<p>타입의 제네릭 바운드를 완화하는 것은 허용되는 범위를 확장할 뿐이므로 안전합니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Foo&lt;A: Clone&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// 변경 후
pub struct Foo&lt;A&gt; {
    pub f1: A,
}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
use updated_crate::Foo;

fn main() {
    let s = Foo { f1: 123 };
}</code></pre>
<h3 id="generic-new-default"><a class="header" href="#generic-new-default">마이너: 기본값이 있는 타입 매개변수 추가</a></h3>
<p>기본값이 있는 한 타입에 타입 매개변수를 추가하는 것은 안전합니다. 모든 기존 참조는 매개변수를 지정할 필요 없이 기본값을 사용하게 됩니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
#[derive(Default)]
pub struct Foo {}

///////////////////////////////////////////////////////////
// 변경 후
#[derive(Default)]
pub struct Foo&lt;A = i32&gt; {
    f1: A,
}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
use updated_crate::Foo;

fn main() {
    let s: Foo = Default::default();
}</code></pre>
<h3 id="generic-generalize-identical"><a class="header" href="#generic-generalize-identical">마이너: 타입을 제네릭을 사용하도록 일반화 (동일한 타입 사용)</a></h3>
<p>구조체 또는 열거형 필드는 변경 결과가 모든 기존 사용 사례에 대해 동일한 타입이 되는 한, 구체적인 타입에서 제네릭 타입 매개변수로 변경할 수 있습니다. 예를 들어, 다음과 같은 변경은 허용됩니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Foo(pub u8);

///////////////////////////////////////////////////////////
// 변경 후
pub struct Foo&lt;T = u8&gt;(pub T);

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
use updated_crate::Foo;

fn main() {
    let s: Foo = Foo(123);
}</code></pre>
<p><code>Foo</code> 의 기존 용법은 동일한 필드 타입을 생성하는 <code>Foo&lt;u8&gt;</code> 의 약어이기 때문입니다.</p>
<h3 id="generic-generalize-different"><a class="header" href="#generic-generalize-different">메이저: 타입을 제네릭을 사용하도록 일반화 (다른 타입이 될 수 있음)</a></h3>
<p>구조체 또는 열거형 필드를 구체적인 타입에서 제네릭 타입 매개변수로 변경하면 타입이 바뀔 수 있는 경우 중단될 수 있습니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Foo&lt;T = u8&gt;(pub T, pub u8);

///////////////////////////////////////////////////////////
// 변경 후
pub struct Foo&lt;T = u8&gt;(pub T, pub T);

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::Foo;

fn main() {
    let s: Foo&lt;f32&gt; = Foo(3.14, 123); // 에러: 타입 불일치
}</code></pre>
<h3 id="generic-more-generic"><a class="header" href="#generic-more-generic">마이너: 제네릭 타입을 더 일반적인 타입으로 변경</a></h3>
<p>제네릭 타입을 더 일반적인 타입으로 변경하는 것은 안전합니다. 예를 들어, 다음은 원래 타입으로 기본 설정되는 제네릭 매개변수를 추가하는데, 모든 기존 사용자가 두 필드에 대해 동일한 타입을 사용하게 되며 기본 매개변수를 지정할 필요가 없기 때문에 안전합니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Foo&lt;T&gt;(pub T, pub T);

///////////////////////////////////////////////////////////
// 변경 후
pub struct Foo&lt;T, U = T&gt;(pub T, pub U);

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
use updated_crate::Foo;

fn main() {
    let s: Foo&lt;f32&gt; = Foo(1.0, 2.0);
}</code></pre>
<h3 id="generic-rpit-capture"><a class="header" href="#generic-rpit-capture">메이저: RPIT(Return Position Impl Trait)에서 더 많은 제네릭 매개변수 캡처</a></h3>
<p><a href="reference/../../reference/types/impl-trait.html#abstract-return-types">RPIT(return-position impl trait)</a> 에서 추가적인 제네릭 매개변수를 캡처하는 것은 중단되는 변경(breaking change)입니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub fn f&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; impl Iterator&lt;Item = char&gt; + use&lt;'a&gt; {
    x.chars()
}

///////////////////////////////////////////////////////////
// 변경 후
pub fn f&lt;'a, 'b&gt;(x: &amp;'a str, y: &amp;'b str) -&gt; impl Iterator&lt;Item = char&gt; + use&lt;'a, 'b&gt; {
    x.chars().chain(y.chars())
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
fn main() {
    let a = String::new();
    let b = String::new();
    let iter = updated_crate::f(&amp;a, &amp;b);
    drop(b); // 에러: `b` 가 대여 중이므로 이동할 수 없음
}</code></pre>
<p>RPIT에 제네릭 매개변수를 추가하면 결과 타입이 사용되는 방식에 추가적인 제약 조건이 생깁니다.</p>
<p><code>use&lt;&gt;</code> 구문을 지정하지 않았을 때 암시적 캡처가 발생한다는 점에 유의하세요. Rust 2021 및 이전 에디션에서 수명(lifetime) 매개변수는 RPIT 타입 시그니처의 바운드 내에 구문적으로 나타나는 경우에만 캡처됩니다. Rust 2024부터는 모든 수명 매개변수가 무조건 캡처됩니다. 이는 Rust 2024부터 기본값이 최대 호환성을 갖도록 설정되었음을 의미하며, 더 적게 캡처하고 싶을 때는 이를 명시해야 함을 뜻합니다. 이는 SemVer 약속의 일부입니다.</p>
<p>RPIT 캡처에 대한 자세한 내용은 <a href="reference/../../edition-guide/rust-2024/rpit-lifetime-capture.html">에디션 가이드</a> 및 <a href="reference/../../reference/types/impl-trait.html#capturing">레퍼런스</a> 를 참조하세요.</p>
<p>RPIT에서 더 적은 수의 제네릭 매개변수를 캡처하는 것은 마이너 변경입니다.</p>
<blockquote>
<p>참고: 스코프 내의 모든 타입 및 상수 제네릭 매개변수는 암시적으로 캡처되거나(<code>+ use&lt;…&gt;</code> 가 지정되지 않은 경우) 명시적으로 캡처되어야(<code>+ use&lt;…&gt;</code> 에 나열되어야 함) 합니다. 따라서 현재는 이러한 종류의 제네릭에서 무엇이 캡처되는지 변경하는 것이 허용되지 않습니다.</p>
</blockquote>
<h3 id="fn-change-arity"><a class="header" href="#fn-change-arity">메이저: 함수 매개변수 추가/제거</a></h3>
<p>함수의 매개변수 개수(arity)를 변경하는 것은 중단되는 변경(breaking change)입니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub fn foo() {}

///////////////////////////////////////////////////////////
// 변경 후
pub fn foo(x: i32) {}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
fn main() {
    updated_crate::foo(); // 에러: 이 함수는 1개의 인수를 받음
}</code></pre>
<p>완화 전략:</p>
<ul>
<li>새로운 시그니처를 가진 새로운 함수를 도입하고, 가능하면 기존 함수를 <a href="reference/../../reference/attributes/diagnostics.html#the-deprecated-attribute">권장되지 않음(deprecate)</a>으로 표시하세요.</li>
<li>구조체 인수를 받는 함수를 도입하고, 해당 구조체는 빌더 패턴으로 생성되도록 하세요. 이렇게 하면 나중에 구조체에 새로운 필드를 추가할 수 있습니다.</li>
</ul>
<h3 id="fn-generic-new"><a class="header" href="#fn-generic-new">중단 가능성 있음: 새로운 함수 타입 매개변수 도입</a></h3>
<p>일반적으로 기본값이 없는 타입 매개변수를 추가하는 것은 안전하지만, 경우에 따라 중단 변경이 될 수 있습니다:</p>
<pre><code class="language-rust ignore">// 중단되는 변경 예시

///////////////////////////////////////////////////////////
// 변경 전
pub fn foo&lt;T&gt;() {}

///////////////////////////////////////////////////////////
// 변경 후
pub fn foo&lt;T, U&gt;() {}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::foo;

fn main() {
    foo::&lt;u8&gt;(); // 에러: 함수는 2개의 제네릭 인수를 받지만 1개의 제네릭 인수가 제공됨
}</code></pre>
<p>그러나 이러한 명시적 호출은 충분히 드물며(대개 다른 방식으로 작성할 수 있음), 이러한 중단은 보통 허용됩니다. 해당 함수가 명시적 타입 인수와 함께 호출될 가능성이 얼마나 되는지 고려해야 합니다.</p>
<h3 id="fn-generalize-compatible"><a class="header" href="#fn-generalize-compatible">마이너: 함수를 제네릭을 사용하도록 일반화 (원래 타입 지원)</a></h3>
<p>함수의 매개변수 타입 또는 반환 값은 원래 타입으로 인스턴스화될 수 있는 한, 새로운 타입 매개변수 도입을 포함하여 제네릭을 사용하도록 <em>일반화</em> 될 수 있습니다. 예를 들어, 다음 변경은 허용됩니다:</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
pub fn foo(x: u8) -&gt; u8 {
    x
}
pub fn bar&lt;T: Iterator&lt;Item = u8&gt;&gt;(t: T) {}

///////////////////////////////////////////////////////////
// 변경 후
use std::ops::Add;
pub fn foo&lt;T: Add&gt;(x: T) -&gt; T {
    x
}
pub fn bar&lt;T: IntoIterator&lt;Item = u8&gt;&gt;(t: T) {}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
use updated_crate::{bar, foo};

fn main() {
    foo(1);
    bar(vec![1, 2, 3].into_iter());
}</code></pre>
<p>모든 기존 사용은 새 시그니처의 인스턴스화이기 때문입니다.</p>
<p>다소 놀랍게도, 모든 트레이트가 자기 자신을 구현한다는 점을 고려하면 일반화는 트레이트 객체에도 적용됩니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
pub trait Trait {}
pub fn foo(t: &amp;dyn Trait) {}

///////////////////////////////////////////////////////////
// 변경 후
pub trait Trait {}
pub fn foo&lt;T: Trait + ?Sized&gt;(t: &amp;T) {}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.
use updated_crate::{foo, Trait};

struct Foo;
impl Trait for Foo {}

fn main() {
    let obj = Foo;
    foo(&amp;obj);
}</code></pre>
<p>(<code>?Sized</code> 를 사용하는 것은 필수적입니다. 그렇지 않으면 원래의 시그니처를 복구할 수 없습니다.)</p>
<p>이런 방식으로 제네릭을 도입하면 잠재적으로 타입 추론 실패가 발생할 수 있습니다. 이는 보통 드문 경우이며, 추가적인 타입 어노테이션으로 해결할 수 있으므로 일부 프로젝트에서는 허용 가능한 중단일 수 있습니다.</p>
<pre><code class="language-rust ignore">// 중단되는 변경 예시

///////////////////////////////////////////////////////////
// 변경 전
pub fn foo() -&gt; i32 {
    0
}

///////////////////////////////////////////////////////////
// 변경 후
pub fn foo&lt;T: Default&gt;() -&gt; T {
    Default::default()
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::foo;

fn main() {
    let x = foo(); // 에러: 타입 어노테이션이 필요함
}</code></pre>
<h3 id="fn-generalize-mismatch"><a class="header" href="#fn-generalize-mismatch">메이저: 타입 불일치가 발생하는 제네릭을 사용하도록 함수 일반화</a></h3>
<p>제네릭 타입이 이전에 허용되었던 타입을 제한하거나 변경하는 경우 함수 매개변수나 반환 타입을 변경하는 것은 중단되는 변경(breaking change)입니다. 예를 들어, 다음은 기존 코드에서 충족되지 않을 수 있는 제네릭 제약 조건을 추가합니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub fn foo(x: Vec&lt;u8&gt;) {}

///////////////////////////////////////////////////////////
// 변경 후
pub fn foo&lt;T: Copy + IntoIterator&lt;Item = u8&gt;&gt;(x: T) {}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::foo;

fn main() {
    foo(vec![1, 2, 3]); // 에러: `Vec&lt;u8&gt;` 에 `Copy` 가 구현되지 않음
}</code></pre>
<h3 id="fn-unsafe-safe"><a class="header" href="#fn-unsafe-safe">마이너: <code>unsafe</code> 함수를 안전하게 만들기</a></h3>
<p>이전에 <code>unsafe</code> 였던 함수는 코드를 중단시키지 않고 안전하게 만들 수 있습니다.</p>
<p>하지만 아래 예시와 같이 <a href="reference/../../rustc/lints/listing/warn-by-default.html#unused-unsafe"><code>unused_unsafe</code></a> 린트가 트리거될 수 있으며, 이로 인해 <code>#![deny(warnings)]</code> 를 지정한 로컬 크레이트의 컴파일이 중단될 수 있습니다. <a href="reference/semver.html#new-lints">새로운 린트 도입</a> 에 따라 업데이트 시 새로운 경고가 도입되는 것은 허용됩니다.</p>
<p>반대 방향(안전한 함수를 <code>unsafe</code> 로 만들기)은 중단되는 변경입니다.</p>
<pre><code class="language-rust ignore">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
pub unsafe fn foo() {}

///////////////////////////////////////////////////////////
// 변경 후
pub fn foo() {}

///////////////////////////////////////////////////////////
// 린트를 트리거하는 라이브러리 사용 예시
use updated_crate::foo;

unsafe fn bar(f: unsafe fn()) {
    f()
}

fn main() {
    unsafe { foo() }; // 여기서 `unused_unsafe` 린트가 트리거됩니다.
    unsafe { bar(foo) };
}</code></pre>
<p>구조체나 열거형의 이전에 <code>unsafe</code> 였던 연관 함수나 메서드를 안전하게 만드는 것도 마이너 변경이지만, 트레이트의 연관 함수의 경우에는 해당되지 않습니다 (<a href="reference/semver.html#trait-item-signature">트레이트 아이템 시그니처의 모든 변경</a> 참조).</p>
<h3 id="attr-no-std-to-std"><a class="header" href="#attr-no-std-to-std">메이저: <code>no_std</code> 지원에서 <code>std</code> 필요로 전환</a></h3>
<p>라이브러리가 특별히 <a href="reference/../../reference/names/preludes.html#the-no_std-attribute"><code>no_std</code></a> 환경을 지원하는 경우, <code>std</code> 를 필요로 하는 새 릴리스를 만드는 것은 중단되는 변경입니다.</p>
<pre><code class="language-rust ignore skip">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
#![no_std]
pub fn foo() {}

///////////////////////////////////////////////////////////
// 변경 후
pub fn foo() {
    std::time::SystemTime::now();
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
// no_std 타겟에는 `std` 크레이트가 없기 때문에 링크에 실패합니다.
#![no_std]
use updated_crate::foo;

fn example() {
    foo();
}</code></pre>
<p>완화 전략:</p>
<ul>
<li>이를 피하기 위한 일반적인 관용구는 <code>std</code> 지원을 선택적으로 활성화하는 <code>std</code> <a href="reference/features.html">Cargo 기능</a>을 포함하고, 해당 기능이 꺼져 있을 때 라이브러리를 <code>no_std</code> 환경에서 사용할 수 있도록 하는 것입니다.</li>
</ul>
<h3 id="attr-adding-non-exhaustive"><a class="header" href="#attr-adding-non-exhaustive">메이저: 비공개 필드가 없는 기존 열거형, 변형(variant) 또는 구조체에 <code>non_exhaustive</code> 추가</a></h3>
<p>아이템을 <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>로 만들면 해당 아이템이 정의된 크레이트 외부에서 사용되는 방식이 변경됩니다.</p>
<ul>
<li>Non-exhaustive 구조체 및 열거형 변형은 <a href="reference/../../reference/expressions/struct-expr.html">구조체 리터럴</a> 구문( <a href="reference/../../reference/expressions/struct-expr.html#functional-update-syntax">함수형 업데이트 구문</a> 포함)을 사용하여 생성할 수 없습니다.</li>
<li>Non-exhaustive 구조체에 대한 패턴 매칭에는 <code>..</code> 이 필요하며, 열거형에 대한 매칭은 철저함(exhaustiveness)에 포함되지 않습니다.</li>
<li><code>as</code> 를 사용하여 열거형 변형을 해당 판별자(discriminant)로 캐스팅하는 것은 허용되지 않습니다.</li>
</ul>
<p>비공개 필드가 있는 구조체는 <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a> 사용 여부와 관계없이 <a href="reference/../../reference/expressions/struct-expr.html">구조체 리터럴</a> 구문을 사용하여 생성할 수 없습니다. 그러한 구조체에 <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>를 추가하는 것은 중단되는 변경이 아닙니다.</p>
<pre><code class="language-rust ignore">// 메이저 변경

///////////////////////////////////////////////////////////
// 변경 전
pub struct Foo {
    pub bar: usize,
}

pub enum Bar {
    X,
    Y(usize),
    Z { a: usize },
}

pub enum Quux {
    Var,
}

///////////////////////////////////////////////////////////
// 변경 후
#[non_exhaustive]
pub struct Foo {
    pub bar: usize,
}

pub enum Bar {
    #[non_exhaustive]
    X,

    #[non_exhaustive]
    Y(usize),

    #[non_exhaustive]
    Z { a: usize },
}

#[non_exhaustive]
pub enum Quux {
    Var,
}

///////////////////////////////////////////////////////////
// 중단될 수 있는 사용 예시
use updated_crate::{Bar, Foo, Quux};

fn main() {
    let foo = Foo { bar: 0 }; // 에러: 구조체 식을 사용하여 non-exhaustive 구조체를 생성할 수 없음

    let bar_x = Bar::X; // 에러: 유닛 변형 `X` 는 비공개임
    let bar_y = Bar::Y(0); // 에러: 튜플 변형 `Y` 는 비공개임
    let bar_z = Bar::Z { a: 0 }; // 에러: 구조체 식을 사용하여 non-exhaustive 변형을 생성할 수 없음

    let q = Quux::Var;
    match q {
        Quux::Var =&gt; 0,
        // 에러: non-exhaustive 패턴: `_` 가 포함되지 않음
    };
}</code></pre>
<p>완화 전략:</p>
<ul>
<li>구조체, 열거형 및 열거형 변형을 나중에 추가하기보다는 처음 도입할 때 <a href="reference/../../reference/attributes/type_system.html#the-non_exhaustive-attribute"><code>#[non_exhaustive]</code></a>로 표시하세요.</li>
</ul>
<h2 id="도구-및-환경-호환성"><a class="header" href="#도구-및-환경-호환성">도구 및 환경 호환성</a></h2>
<h3 id="env-new-rust"><a class="header" href="#env-new-rust">중단 가능성 있음: 필요한 최소 Rust 버전 변경</a></h3>
<p>새로운 Rust 릴리스에서 새로운 기능을 사용하도록 도입하면 이전 버전의 Rust를 사용하는 프로젝트가 중단될 수 있습니다. 여기에는 새로운 Cargo 릴리스의 새로운 기능을 사용하는 것과, 이전에는 stable에서 작동하던 크레이트에서 nightly 전용 기능을 사용하도록 요구하는 것이 포함됩니다.</p>
<p><a href="https://github.com/rust-lang/api-guidelines/discussions/231">다양한 이유</a> 로 인해 이를 메이저 변경보다는 마이너 변경으로 취급하는 것이 일반적으로 권장됩니다. 새로운 버전의 Rust로 업데이트하는 것은 보통 상대적으로 쉽습니다. Rust는 6주의 빠른 릴리스 주기를 가지고 있으며, 일부 프로젝트는 일정 범위 내의 릴리스(예: 현재 stable 릴리스 + 이전 N개의 릴리스) 내에서 호환성을 제공합니다. 다만 일부 대규모 프로젝트는 Rust 툴체인을 빠르게 업데이트하지 못할 수도 있다는 점을 유의하세요.</p>
<p>완화 전략:</p>
<ul>
<li>Document your package’s minimum-supported Rust version by setting <a href="reference/rust-version.html"><code>package.rust-version</code></a>, allowing Cargo’s dependency resolution to attempt to <a href="reference/resolver.html#rust-version">select older versions of your package</a> when needed. Be sure to consider the <a href="reference/rust-version.html#support-expectations">support expectations</a> when doing so.</li>
<li><a href="reference/features.html">Cargo 기능</a> 을 사용하여 새로운 기능을 선택 사항(opt-in)으로 만드세요.</li>
<li>이전 릴리스에 대해 충분한 지원 범위를 제공하세요.</li>
<li>가능하다면 새로운 표준 라이브러리 아이템의 소스를 복사하여, 이전 버전을 계속 사용하면서도 새로운 기능을 활용할 수 있도록 하세요.</li>
<li>중요한 버그 수정을 백포트(backport)받을 수 있는 이전 마이너 릴리스를 위한 별도의 브랜치를 제공하세요.</li>
<li>새로운 기능에 대한 선택 메커니즘을 제공하는 <a href="https://github.com/rust-lang/rust/issues/64796"><code>[cfg(version(..))]</code></a> 및 <a href="https://github.com/rust-lang/rust/issues/64797"><code>#[cfg(accessible(..))]</code></a> 기능을 주시하세요. 이 기능들은 현재 불안정하며 nightly 채널에서만 사용할 수 있습니다.</li>
</ul>
<h3 id="env-change-requirements"><a class="header" href="#env-change-requirements">중단 가능성 있음: 플랫폼 및 환경 요구 사항 변경</a></h3>
<p>라이브러리는 호스트 플랫폼, 운영 체제 버전, 사용 가능한 서비스, 파일 시스템 지원 등 라이브러리가 실행되는 환경에 대해 매우 광범위한 가정을 합니다. 예를 들어 더 최신 버전의 운영 체제를 요구하는 등 이전에 지원되었던 것을 제한하는 새 릴리스를 만드는 것은 중단되는 변경이 될 수 있습니다. 이러한 변경 사항은 자동으로 테스트되지 않는 환경에서 변경이 중단되는지 여부를 항상 알 수 없기 때문에 추적하기 어려울 수 있습니다.</p>
<p>일부 프로젝트에서는 특히 대부분의 사용자에게 중단이 발생할 가능성이 낮거나 프로젝트에 모든 환경을 지원할 리소스가 없는 경우 이를 허용 가능한 중단으로 간주할 수 있습니다. 또 다른 주목할 만한 상황은 벤더가 특정 하드웨어나 OS에 대한 지원을 중단할 때, 프로젝트에서도 지원을 중단하는 것이 합리적이라고 판단할 수 있는 경우입니다.</p>
<p>완화 전략:</p>
<ul>
<li>특별히 지원하는 플랫폼과 환경을 문서화하세요.</li>
<li>CI에서 광범위한 환경에 대해 코드를 테스트하세요.</li>
</ul>
<h3 id="new-lints"><a class="header" href="#new-lints">마이너: 새로운 린트 도입</a></h3>
<p>라이브러리의 일부 변경으로 인해 해당 라이브러리 사용자에게 새로운 린트가 트리거될 수 있습니다. 이는 일반적으로 호환되는 변경으로 간주되어야 합니다.</p>
<pre><code class="language-rust ignore dont-deny">// 마이너 변경

///////////////////////////////////////////////////////////
// 변경 전
pub fn foo() {}

///////////////////////////////////////////////////////////
// 변경 후
#[deprecated]
pub fn foo() {}

///////////////////////////////////////////////////////////
// 안전하게 작동할 라이브러리 사용 예시.

fn main() {
    updated_crate::foo(); // 경고: 권장되지 않는(deprecated) 함수 사용
}</code></pre>
<p>사용자가 경고를 명시적으로 거부(deny)했고 업데이트된 크레이트가 직접적인 의존성인 경우, 이로 인해 기술적으로 프로젝트가 실패할 수 있음에 유의하세요. 경고를 거부하는 것은 시간이 지남에 따라 새로운 린트가 도입될 수 있음을 이해하고 주의 깊게 수행해야 합니다. 하지만 라이브러리 작성자 또한 새로운 경고를 도입하는 데 신중해야 하며 사용자에게 미칠 잠재적 영향을 고려해야 합니다.</p>
<p>다음 린트들은 의존성을 업데이트할 때 도입될 수 있는 예시들입니다.</p>
<ul>
<li><a href="reference/../../rustc/lints/listing/warn-by-default.html#deprecated"><code>deprecated</code></a> — 사용 중인 아이템에 의존성이 <a href="reference/../../reference/attributes/diagnostics.html#the-deprecated-attribute"><code>#[deprecated]</code> 속성</a>을 추가할 때 도입됩니다.</li>
<li><a href="reference/../../rustc/lints/listing/warn-by-default.html#unused-must-use"><code>unused_must_use</code></a> — 결과를 사용하지 않는 아이템에 의존성이 <a href="reference/../../reference/attributes/diagnostics.html#the-must_use-attribute"><code>#[must_use]</code> 속성</a>을 추가할 때 도입됩니다.</li>
<li><a href="reference/../../rustc/lints/listing/warn-by-default.html#unused-unsafe"><code>unused_unsafe</code></a> — 의존성이 함수에서 <code>unsafe</code> 한정자를 <em>제거</em> 하고, 그 함수가 unsafe 블록에서 호출되는 유일한 unsafe 함수일 때 도입됩니다.</li>
</ul>
<p>또한, <code>rustc</code> 를 새 버전으로 업데이트하면 새로운 린트가 도입될 수 있습니다.</p>
<p>새로운 린트를 도입하는 전이적(transitive) 의존성은 보통 실패를 일으키지 않는데, 이는 Cargo가 <a href="reference/../../rustc/lints/levels.html#capping-lints"><code>--cap-lints</code></a> 를 사용하여 의존성의 모든 린트를 억제하기 때문입니다.</p>
<p>완화 전략:</p>
<ul>
<li>경고를 거부(deny)하도록 빌드하는 경우, 의존성을 업데이트할 때마다 새로운 경고를 해결해야 할 수도 있음을 이해해야 합니다. RUSTFLAGS를 사용하여 <code>-Dwarnings</code> 를 전달하는 경우, <code>-Adeprecated</code> 와 같이 문제를 일으킬 가능성이 높은 린트를 허용하기 위해 <code>-A</code> 플래그도 함께 추가하세요.</li>
<li>권장되지 않는(deprecation) 사항을 <a href="reference/features.html">기능(feature)</a> 뒤에 도입하세요. 예를 들어 <code>#[cfg_attr(feature = "deprecated", deprecated="use bar instead")]</code> 와 같이 작성합니다. 그런 다음 향후 SemVer 중단 변경 시 아이템을 제거할 계획이 있을 때, 사용자에게 권장되지 않는 아이템의 사용을 제거하기 위해 업데이트하기 <em>전에</em> <code>deprecated</code> 기능을 활성화해야 한다고 알릴 수 있습니다. 이를 통해 사용자는 즉시 대응할 필요 없이 언제 대응할지 선택할 수 있습니다. 단점은 메이저 업데이트를 준비하기 위해 이러한 수동 단계를 거쳐야 한다는 점을 사용자에게 전달하기 어려울 수 있다는 것입니다.</li>
</ul>
<h3 id="cargo"><a class="header" href="#cargo">Cargo</a></h3>
<h4 id="cargo-feature-add"><a class="header" href="#cargo-feature-add">마이너: 새로운 Cargo 기능 추가</a></h4>
<p>새로운 <a href="reference/features.html">Cargo 기능</a> 을 추가하는 것은 보통 안전합니다. 기능이 중단되는 변경을 일으키는 새로운 변화를 도입하는 경우, 엄격한 하위 호환성 요구 사항이 있는 프로젝트에 어려움을 줄 수 있습니다. 그런 시나리오에서는 해당 기능을 “default” 목록에 추가하는 것을 피하고, 기능을 활성화할 때의 결과를 문서화하는 것이 좋습니다.</p>
<pre><code class="language-toml"># MINOR CHANGE

###########################################################
# Before
[features]
# ..empty

###########################################################
# After
[features]
std = []
</code></pre>
<h4 id="cargo-feature-remove"><a class="header" href="#cargo-feature-remove">메이저: Cargo 기능 제거</a></h4>
<p><a href="reference/features.html">Cargo 기능</a> 을 제거하는 것은 보통 중단되는 변경입니다. 이는 해당 기능을 활성화한 모든 프로젝트에서 오류를 일으킵니다.</p>
<pre><code class="language-toml"># MAJOR CHANGE

###########################################################
# Before
[features]
logging = []

###########################################################
# After
[dependencies]
# ..logging removed
</code></pre>
<p>완화 전략:</p>
<ul>
<li>기능을 명확하게 문서화하세요. 내부용이거나 실험적인 기능이 있다면 그렇게 표시하여 사용자가 해당 기능의 상태를 알 수 있도록 하세요.</li>
<li><code>Cargo.toml</code> 에 기존 기능을 남겨두되, 기능 자체는 제거하세요. 해당 기능이 권장되지 않음(deprecated)을 문서화하고, 향후 메이저 SemVer 릴리스에서 제거하세요.</li>
</ul>
<h4 id="cargo-feature-remove-another"><a class="header" href="#cargo-feature-remove-another">메이저: 기능이나 공개 아이템을 변경하는 경우 기능 목록에서 기능 제거</a></h4>
<p>다른 기능에서 특정 기능을 제거하는 경우, 해당 기능을 통해 그 기능이 제공될 것으로 기대하는 기존 사용자들에게는 중단될 수 있습니다.</p>
<pre><code class="language-toml"># 중단되는 변경 예시

###########################################################
# 변경 전
[features]
default = ["std"]
std = []

###########################################################
# 변경 후
[features]
default = []  # std가 활성화될 것으로 기대하는 패키지에서 실패가 발생할 수 있습니다.
std = []
</code></pre>
<h4 id="cargo-remove-opt-dep"><a class="header" href="#cargo-remove-opt-dep">중단 가능성 있음: 선택적 의존성 제거</a></h4>
<p><a href="reference/features.html#optional-dependencies">선택적 의존성(optional dependency)</a> 을 제거하는 것은 귀하의 라이브러리를 사용하는 프로젝트를 중단시킬 수 있습니다. 다른 프로젝트에서 <a href="reference/features.html">Cargo 기능</a> 을 통해 해당 의존성을 활성화하고 있을 수 있기 때문입니다.</p>
<p>선택적 의존성이 있을 때, Cargo는 의존성을 활성화하고 활성화 여부를 확인하는 메커니즘을 제공하기 위해 동일한 이름의 기능을 암시적으로 정의합니다. 이 문제는 <code>[features]</code> 표에서 <code>dep:</code> 구문을 사용하여 해당 암시적 기능을 비활성화함으로써 피할 수 있습니다. <code>dep:</code> 를 사용하면 선택적 의존성의 존재를 보다 의미 있는 이름 아래에 숨길 수 있으며, 이를 통해 보다 안전하게 수정할 수 있습니다.</p>
<pre><code class="language-toml"># 중단되는 변경 예시

###########################################################
# 변경 전
[dependencies]
curl = { version = "0.4.31", optional = true }

###########################################################
# 변경 후
[dependencies]
# ..curl 제거됨
</code></pre>
<pre><code class="language-toml"># 마이너 변경
#
# 이 예제는 선택적 의존성을 사용하여 중단되는 변경을 피하는 방법을 보여줍니다.

###########################################################
# 변경 전
[dependencies]
curl = { version = "0.4.31", optional = true }

[features]
networking = ["dep:curl"]

###########################################################
# 변경 후
[dependencies]
# 여기서 하나의 선택적 의존성이 다른 것으로 교체되었습니다.
hyper = { version = "0.14.27", optional = true }

[features]
networking = ["dep:hyper"]
</code></pre>
<p>완화 전략:</p>
<ul>
<li>애초에 선택적 의존성이 노출되지 않도록 <code>[features]</code> 표에서 <code>dep:</code> 구문을 사용하세요. 자세한 내용은 <a href="reference/features.html#optional-dependencies">선택적 의존성</a> 을 참조하세요.</li>
<li>기능을 명확하게 문서화하세요. 선택적 의존성이 문서화된 기능 목록에 포함되어 있지 않다면, 문서화되지 않은 항목을 변경하는 것은 안전하다고 판단할 수 있습니다.</li>
<li>선택적 의존성을 그대로 두고, 라이브러리 내에서 사용하지 마세요.</li>
<li>선택적 의존성을 아무 작업도 하지 않는 <a href="reference/features.html">Cargo 기능</a> 으로 교체하고, 해당 기능이 권장되지 않음(deprecated)을 문서화하세요.</li>
<li>선택적 의존성을 활성화하는 고수준 기능을 사용하고, 이를 확장 기능을 활성화하는 권장되는 방법으로 문서화하세요. 예를 들어, 귀하의 라이브러리에 “네트워킹“과 같은 것에 대한 선택적 지원이 있는 경우, “네트워킹” 구현에 필요한 선택적 의존성을 활성화하는 일반적인 기능 이름인 “networking“을 만드세요. 그런 다음 “networking” 기능을 문서화합니다.</li>
</ul>
<h4 id="cargo-change-dep-feature"><a class="header" href="#cargo-change-dep-feature">마이너: 의존성 기능 변경</a></h4>
<p>기능이 중단되는 변경을 도입하지 않는 한, 의존성의 기능을 변경하는 것은 보통 안전합니다.</p>
<pre><code class="language-toml"># 마이너 변경

###########################################################
# 변경 전
[dependencies]
rand = { version = "0.7.3", features = ["small_rng"] }


###########################################################
# 변경 후
[dependencies]
rand = "0.7.3"
</code></pre>
<h4 id="cargo-dep-add"><a class="header" href="#cargo-dep-add">마이너: 의존성 추가</a></h4>
<p>새로운 의존성이 중단되는 변경을 초래하는 새로운 요구 사항을 도입하지 않는 한, 새로운 의존성을 추가하는 것은 보통 안전합니다. 예를 들어, 이전에 stable에서 작동하던 프로젝트에 nightly를 요구하는 새로운 의존성을 추가하는 것은 메이저 변경입니다.</p>
<pre><code class="language-toml"># 마이너 변경

###########################################################
# 변경 전
[dependencies]
# ..비어 있음

###########################################################
# 변경 후
[dependencies]
log = "0.4.11"
</code></pre>
<h2 id="애플리케이션-호환성"><a class="header" href="#애플리케이션-호환성">애플리케이션 호환성</a></h2>
<p>Cargo 프로젝트에는 고유한 인터페이스(예: CLI 인터페이스, OS 수준 상호작용 등)를 가진 실행 파일 바이너리도 포함될 수 있습니다. 이러한 바이너리는 Cargo 패키지의 일부이므로 패키지와 동일한 버전을 사용하고 공유하는 경우가 많습니다. 귀하의 애플리케이션을 변경할 때 사용자에게 SemVer 계약을 어떻게 적용할지 결정해야 합니다. 애플리케이션에서 발생할 수 있는 중단 및 호환 변경 사항은 너무 많아서 일일이 열거할 수 없으므로, <a href="https://semver.org/">SemVer</a> 명세의 정신을 활용하여 애플리케이션에 버전을 적용하는 방법을 결정하거나, 최소한 귀하의 약속이 무엇인지 문서화하는 것이 좋습니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="미래-비호환성-보고서"><a class="header" href="#미래-비호환성-보고서">미래 비호환성 보고서</a></h1>
<p>Cargo는 모든 의존성에서 미래 비호환(future-incompatible) 경고를 확인합니다. 이러한 경고는 나중에 하드 에러(hard error)가 되어 미래 버전의 rustc에서 의존성 빌드가 중단될 수 있는 변경 사항에 대한 것입니다. 경고가 발견되면 경고가 발견되었음을 알리는 작은 알림이 표시되고 전체 보고서를 표시하는 방법이 안내됩니다.</p>
<p>예를 들어, 빌드 끝에 다음과 같은 내용이 표시될 수 있습니다.</p>
<pre><code class="language-text">warning: the following packages contain code that will be rejected by a future
         version of Rust: rental v0.5.5
note: to see what the problems were, use the option `--future-incompat-report`,
      or run `cargo report future-incompatibilities --id 1`
</code></pre>
<p>전체 보고서는 <code>cargo report future-incompatibilities --id ID</code> 명령어를 사용하거나, <code>--future-incompat-report</code> 플래그를 사용하여 빌드를 다시 실행함으로써 표시할 수 있습니다. 개발자는 문제가 수정된 버전으로 의존성을 업데이트하거나, 의존성 개발자와 협력하여 문제를 해결해야 합니다.</p>
<h2 id="설정-2"><a class="header" href="#설정-2">설정</a></h2>
<p>이 기능은 <code>.cargo/config.toml</code> 의 <a href="reference/config.html#future-incompat-report"><code>[future-incompat-report]</code></a> 섹션을 통해 설정할 수 있습니다. 현재 지원되는 옵션은 다음과 같습니다.</p>
<pre><code class="language-toml">[future-incompat-report]
frequency = "always"
</code></pre>
<p>빈도(frequency)에 대해 지원되는 값은 <code>"always"</code> 와 <code>"never"</code> 이며, 이는 <code>cargo build</code> / <code>cargo check</code> 끝에 메시지가 출력될지 여부를 제어합니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="빌드-시간-보고"><a class="header" href="#빌드-시간-보고">빌드 시간 보고</a></h1>
<p><code>--timings</code> 옵션은 각 컴파일이 소요되는 시간에 대한 정보를 제공하고, 시간 경과에 따른 동시성 정보를 추적합니다.</p>
<pre><code class="language-sh">cargo build --timings
</code></pre>
<p>이것은 <code>target/cargo-timings/cargo-timing.html</code> 에 HTML 보고서를 작성합니다. 또한 이전 실행 기록을 보고 싶은 경우를 위해, 파일 이름에 타임스탬프가 포함된 보고서 사본을 동일한 디렉터리에 작성합니다.</p>
<h2 id="그래프-읽기"><a class="header" href="#그래프-읽기">그래프 읽기</a></h2>
<p>출력에는 두 개의 표와 두 개의 그래프가 있습니다.</p>
<p>첫 번째 표는 프로젝트의 빌드 정보를 표시합니다. 여기에는 빌드된 유닛 수, 최대 동시성 수, 빌드 시간, 현재 사용 중인 컴파일러의 버전 정보가 포함됩니다.</p>
<p><img src="reference/../images/build-info.png" alt="빌드 정보" /></p>
<p>The “unit” graph shows the duration of each unit over time. A “unit” is a single compiler invocation. There are lines that show which additional units are “unblocked” when a unit finishes. That is, it shows the new units that are now allowed to run because their dependencies are all finished. Hover the mouse over a unit to highlight the lines. This can help visualize the critical path of dependencies. This may change between runs because the units may finish in different orders.</p>
<p>“코드 생성(codegen)” 시간은 연보라색으로 강조 표시됩니다. 어떤 경우에는 빌드 파이프라이닝을 통해 의존성이 코드 생성을 수행 중일 때 유닛이 시작될 수 있습니다. 이 정보가 항상 표시되는 것은 아닙니다 (예를 들어, 바이너리 유닛은 코드 생성이 시작되는 시점을 표시하지 않습니다).</p>
<p>“커스텀 빌드” 유닛은 <code>build.rs</code> 스크립트이며, 실행 시 주황색으로 강조 표시됩니다.</p>
<p><img src="reference/../images/build-unit-time.png" alt="빌드 유닛 시간" /></p>
<p>두 번째 그래프는 시간에 따른 Cargo의 병렬성(concurrency)을 보여줍니다. 배경은 CPU 사용량을 나타냅니다. 세 개의 선은 다음과 같습니다.</p>
<ul>
<li>“대기 중(Waiting)” (빨간색) — CPU 슬롯이 비기를 기다리는 유닛의 수입니다.</li>
<li>“비활성(Inactive)” (파란색) — 의존성이 완료되기를 기다리는 유닛의 수입니다.</li>
<li>“활성(Active)” (초록색) — 현재 실행 중인 유닛의 수입니다.</li>
</ul>
<p><img src="reference/../images/cargo-concurrency-over-time.png" alt="시간에 따른 Cargo 병렬성" /></p>
<p>참고: 이는 컴파일러 자체의 병렬성을 보여주는 것은 아닙니다. <code>rustc</code> 는 병렬성 제한 내에서 유지하기 위해 “작업 서버(job server)“를 통해 Cargo와 조율합니다. 현재 이는 주로 코드 생성 단계에 적용됩니다.</p>
<p>컴파일 시간을 해결하기 위한 팁:</p>
<ul>
<li>속도가 느린 의존성을 찾으세요.
<ul>
<li>비활성화를 고려해볼 만한 기능(feature)이 있는지 확인하세요.</li>
<li>의존성을 완전히 제거하는 것을 고려해보세요.</li>
</ul>
</li>
<li>서로 다른 버전으로 여러 번 빌드되는 크레이트가 있는지 확인하세요. 의존성 그래프에서 이전 버전을 제거해 보세요.</li>
<li>큰 크레이트를 작은 조각으로 나누세요.</li>
<li>단일 크레이트에서 병목 현상이 발생하는 크레이트가 많은 경우, 병렬성을 개선하기 위해 해당 크레이트를 개선하는 데 집중하세요.</li>
</ul>
<p>마지막 표에는 각 유닛에 소요된 총 시간과 “코드 생성” 시간, 그리고 각 유닛 컴파일 중에 활성화된 기능들이 나열됩니다.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="린트"><a class="header" href="#린트">린트</a></h1>
<p>참고: <a href="reference/unstable.html#lintscargo">Cargo의 린트 시스템은 불안정</a> 하며 나이틀리 툴체인에서만 사용할 수 있습니다</p>
<div class="table-wrapper"><table><thead><tr><th>Group</th><th>설명</th><th>Default level</th></tr></thead><tbody>
<tr><td><code>cargo::complexity</code></td><td>code that does something simple but in a complex way</td><td>warn</td></tr>
<tr><td><code>cargo::correctness</code></td><td>code that is outright wrong or useless</td><td>deny</td></tr>
<tr><td><code>cargo::nursery</code></td><td>new lints that are still under development</td><td>allow</td></tr>
<tr><td><code>cargo::pedantic</code></td><td>lints which are rather strict or have occasional false positives</td><td>allow</td></tr>
<tr><td><code>cargo::perf</code></td><td>code that can be written to run faster</td><td>warn</td></tr>
<tr><td><code>cargo::restriction</code></td><td>lints which prevent the use of Cargo features</td><td>allow</td></tr>
<tr><td><code>cargo::style</code></td><td>code that should be written in a more idiomatic way</td><td>warn</td></tr>
<tr><td><code>cargo::suspicious</code></td><td>code that is most likely wrong or useless</td><td>warn</td></tr>
</tbody></table>
</div>
<h2 id="allowed-by-default"><a class="header" href="#allowed-by-default">Allowed-by-default</a></h2>
<p>These lints are all set to the ‘allow’ level by default.</p>
<ul>
<li><a href="reference/lints.html#implicit_minimum_version_req"><code>implicit_minimum_version_req</code></a></li>
<li><a href="reference/lints.html#non_kebab_case_features"><code>non_kebab_case_features</code></a></li>
<li><a href="reference/lints.html#non_kebab_case_packages"><code>non_kebab_case_packages</code></a></li>
<li><a href="reference/lints.html#non_snake_case_features"><code>non_snake_case_features</code></a></li>
<li><a href="reference/lints.html#non_snake_case_packages"><code>non_snake_case_packages</code></a></li>
</ul>
<h2 id="기본-경고warn-by-default"><a class="header" href="#기본-경고warn-by-default">기본 경고(Warn-by-default)</a></h2>
<p>이 린트들은 기본적으로 모두 ‘warn’(경고) 수준으로 설정되어 있습니다.</p>
<ul>
<li><a href="reference/lints.html#blanket_hint_mostly_unused"><code>blanket_hint_mostly_unused</code></a></li>
<li><a href="reference/lints.html#missing_lints_inheritance"><code>missing_lints_inheritance</code></a></li>
<li><a href="reference/lints.html#non_kebab_case_bins"><code>non_kebab_case_bins</code></a></li>
<li><a href="reference/lints.html#redundant_homepage"><code>redundant_homepage</code></a></li>
<li><a href="reference/lints.html#redundant_readme"><code>redundant_readme</code></a></li>
<li><a href="reference/lints.html#unknown_lints"><code>unknown_lints</code></a></li>
<li><a href="reference/lints.html#unused_workspace_dependencies"><code>unused_workspace_dependencies</code></a></li>
<li><a href="reference/lints.html#unused_workspace_package_fields"><code>unused_workspace_package_fields</code></a></li>
</ul>
<h2 id="blanket_hint_mostly_unused"><a class="header" href="#blanket_hint_mostly_unused"><code>blanket_hint_mostly_unused</code></a></h2>
<p>Group: <code>suspicious</code></p>
<p>Level: <code>warn</code></p>
<p>MSRV: <code>1.79.0</code></p>
<h3 id="동작-방식"><a class="header" href="#동작-방식">동작 방식</a></h3>
<p>Checks if <code>hint-mostly-unused</code> being applied to all dependencies.</p>
<h3 id="나쁜-이유"><a class="header" href="#나쁜-이유">나쁜 이유</a></h3>
<p><code>hint-mostly-unused</code> indicates that most of a crate’s API surface will go unused by anything depending on it; this hint can speed up the build by attempting to minimize compilation time for items that aren’t used at all. Misapplication to crates that don’t fit that criteria will slow down the build rather than speeding it up. It should be selectively applied to dependencies that meet these criteria. Applying it globally is always a misapplication and will likely slow down the build.</p>
<h3 id="예제-1"><a class="header" href="#예제-1">예제</a></h3>
<pre><code class="language-toml">[profile.dev.package."*"]
hint-mostly-unused = true
</code></pre>
<p>Should instead be:</p>
<pre><code class="language-toml">[profile.dev.package.huge-mostly-unused-dependency]
hint-mostly-unused = true
</code></pre>
<h2 id="implicit_minimum_version_req"><a class="header" href="#implicit_minimum_version_req"><code>implicit_minimum_version_req</code></a></h2>
<p>Group: <code>pedantic</code></p>
<p>Level: <code>allow</code></p>
<h3 id="동작-방식-1"><a class="header" href="#동작-방식-1">동작 방식</a></h3>
<p>Checks for dependency version requirements that do not explicitly specify a full <code>major.minor.patch</code> version requirement, such as <code>serde = "1"</code> or <code>serde = "1.0"</code>.</p>
<p>This lint currently only applies to caret requirements (the <a href="reference/specifying-dependencies.html#default-requirements">default requirements</a>).</p>
<h3 id="나쁜-이유-1"><a class="header" href="#나쁜-이유-1">나쁜 이유</a></h3>
<p>Version requirements without an explicit full version can be misleading about the actual minimum supported version. For example, <code>serde = "1"</code> has an implicit minimum bound of <code>1.0.0</code>. If your code actually requires features from <code>1.0.219</code>, the implicit minimum bound of <code>1.0.0</code> gives a false impression about compatibility.</p>
<p>Specifying the full version helps with:</p>
<ul>
<li>Accurate minimum version documentation</li>
<li>Better compatibility with <code>-Z minimal-versions</code></li>
<li>Clearer dependency constraints for consumers</li>
</ul>
<h3 id="drawbacks"><a class="header" href="#drawbacks">Drawbacks</a></h3>
<p>Even with a fully specified version, the minimum bound might still be incorrect if untested. This lint helps make the minimum version requirement explicit but doesn’t guarantee correctness.</p>
<h3 id="예제-2"><a class="header" href="#예제-2">예제</a></h3>
<pre><code class="language-toml">[dependencies]
serde = "1"
</code></pre>
<p>Should be written as a full specific version:</p>
<pre><code class="language-toml">[dependencies]
serde = "1.0.219"
</code></pre>
<h2 id="missing_lints_inheritance"><a class="header" href="#missing_lints_inheritance"><code>missing_lints_inheritance</code></a></h2>
<p>Group: <code>suspicious</code></p>
<p>Level: <code>warn</code></p>
<p>MSRV: <code>1.79.0</code></p>
<h3 id="동작-방식-2"><a class="header" href="#동작-방식-2">동작 방식</a></h3>
<p>Checks for packages without a <code>lints</code> table while <code>workspace.lints</code> is present.</p>
<h3 id="나쁜-이유-2"><a class="header" href="#나쁜-이유-2">나쁜 이유</a></h3>
<p>Many people mistakenly think that <code>workspace.lints</code> is implicitly inherited when it is not.</p>
<h3 id="drawbacks-1"><a class="header" href="#drawbacks-1">Drawbacks</a></h3>
<h3 id="예제-3"><a class="header" href="#예제-3">예제</a></h3>
<pre><code class="language-toml">[workspace.lints.cargo]
</code></pre>
<p>Should be written as:</p>
<pre><code class="language-toml">[workspace.lints.cargo]

[lints]
workspace = true
</code></pre>
<h2 id="non_kebab_case_bins"><a class="header" href="#non_kebab_case_bins"><code>non_kebab_case_bins</code></a></h2>
<p>Group: <code>style</code></p>
<p>Level: <code>warn</code></p>
<p>MSRV: <code>1.79.0</code></p>
<h3 id="동작-방식-3"><a class="header" href="#동작-방식-3">동작 방식</a></h3>
<p>Detect binary names, explicit and implicit, that are not kebab-case</p>
<h3 id="나쁜-이유-3"><a class="header" href="#나쁜-이유-3">나쁜 이유</a></h3>
<p>Kebab-case binary names is a common convention among command line tools.</p>
<h3 id="drawbacks-2"><a class="header" href="#drawbacks-2">Drawbacks</a></h3>
<p>It would be disruptive to existing users to change the binary name.</p>
<p>A binary may need to conform to externally controlled conventions which can include a different naming convention.</p>
<p>GUI applications may wish to choose a more user focused naming convention, like “Title Case” or “Sentence case”.</p>
<h3 id="예제-4"><a class="header" href="#예제-4">예제</a></h3>
<pre><code class="language-toml">[[bin]]
name = "foo_bar"
</code></pre>
<p>Should be written as:</p>
<pre><code class="language-toml">[[bin]]
name = "foo-bar"
</code></pre>
<h2 id="non_kebab_case_features"><a class="header" href="#non_kebab_case_features"><code>non_kebab_case_features</code></a></h2>
<p>Group: <code>restriction</code></p>
<p>Level: <code>allow</code></p>
<h3 id="동작-방식-4"><a class="header" href="#동작-방식-4">동작 방식</a></h3>
<p>Detect feature names that are not kebab-case.</p>
<h3 id="나쁜-이유-4"><a class="header" href="#나쁜-이유-4">나쁜 이유</a></h3>
<p>Having multiple naming styles within a workspace can be confusing.</p>
<h3 id="drawbacks-3"><a class="header" href="#drawbacks-3">Drawbacks</a></h3>
<p>Users would expect that a feature tightly coupled to a dependency would match the dependency’s name.</p>
<h3 id="예제-5"><a class="header" href="#예제-5">예제</a></h3>
<pre><code class="language-toml">[features]
foo_bar = []
</code></pre>
<p>Should be written as:</p>
<pre><code class="language-toml">[features]
foo-bar = []
</code></pre>
<h2 id="non_kebab_case_packages"><a class="header" href="#non_kebab_case_packages"><code>non_kebab_case_packages</code></a></h2>
<p>Group: <code>restriction</code></p>
<p>Level: <code>allow</code></p>
<h3 id="동작-방식-5"><a class="header" href="#동작-방식-5">동작 방식</a></h3>
<p>Detect package names that are not kebab-case.</p>
<h3 id="나쁜-이유-5"><a class="header" href="#나쁜-이유-5">나쁜 이유</a></h3>
<p>Having multiple naming styles within a workspace can be confusing.</p>
<h3 id="drawbacks-4"><a class="header" href="#drawbacks-4">Drawbacks</a></h3>
<p>Users have to mentally translate package names to namespaces in Rust.</p>
<h3 id="예제-6"><a class="header" href="#예제-6">예제</a></h3>
<pre><code class="language-toml">[package]
name = "foo_bar"
</code></pre>
<p>Should be written as:</p>
<pre><code class="language-toml">[package]
name = "foo-bar"
</code></pre>
<h2 id="non_snake_case_features"><a class="header" href="#non_snake_case_features"><code>non_snake_case_features</code></a></h2>
<p>Group: <code>restriction</code></p>
<p>Level: <code>allow</code></p>
<h3 id="동작-방식-6"><a class="header" href="#동작-방식-6">동작 방식</a></h3>
<p>Detect feature names that are not snake-case.</p>
<h3 id="나쁜-이유-6"><a class="header" href="#나쁜-이유-6">나쁜 이유</a></h3>
<p>Having multiple naming styles within a workspace can be confusing.</p>
<h3 id="drawbacks-5"><a class="header" href="#drawbacks-5">Drawbacks</a></h3>
<p>Users would expect that a feature tightly coupled to a dependency would match the dependency’s name.</p>
<h3 id="예제-7"><a class="header" href="#예제-7">예제</a></h3>
<pre><code class="language-toml">[features]
foo-bar = []
</code></pre>
<p>Should be written as:</p>
<pre><code class="language-toml">[features]
foo_bar = []
</code></pre>
<h2 id="non_snake_case_packages"><a class="header" href="#non_snake_case_packages"><code>non_snake_case_packages</code></a></h2>
<p>Group: <code>restriction</code></p>
<p>Level: <code>allow</code></p>
<h3 id="동작-방식-7"><a class="header" href="#동작-방식-7">동작 방식</a></h3>
<p>Detect package names that are not snake-case.</p>
<h3 id="나쁜-이유-7"><a class="header" href="#나쁜-이유-7">나쁜 이유</a></h3>
<p>Having multiple naming styles within a workspace can be confusing.</p>
<h3 id="drawbacks-6"><a class="header" href="#drawbacks-6">Drawbacks</a></h3>
<p>Users have to mentally translate package names to namespaces in Rust.</p>
<h3 id="예제-8"><a class="header" href="#예제-8">예제</a></h3>
<pre><code class="language-toml">[package]
name = "foo_bar"
</code></pre>
<p>Should be written as:</p>
<pre><code class="language-toml">[package]
name = "foo-bar"
</code></pre>
<h2 id="redundant_homepage"><a class="header" href="#redundant_homepage"><code>redundant_homepage</code></a></h2>
<p>Group: <code>style</code></p>
<p>Level: <code>warn</code></p>
<p>MSRV: <code>1.79.0</code></p>
<h3 id="동작-방식-8"><a class="header" href="#동작-방식-8">동작 방식</a></h3>
<p>Checks if the value of <code>package.homepage</code> is already covered by another field.</p>
<p>See also <a href="reference/manifest.html#the-homepage-field"><code>package.homepage</code> reference documentation</a>.</p>
<h3 id="나쁜-이유-8"><a class="header" href="#나쁜-이유-8">나쁜 이유</a></h3>
<p>When package browsers render each link, a redundant link adds visual noise.</p>
<h3 id="drawbacks-7"><a class="header" href="#drawbacks-7">Drawbacks</a></h3>
<h3 id="예제-9"><a class="header" href="#예제-9">예제</a></h3>
<pre><code class="language-toml">[package]
name = "foo"
homepage = "https://github.com/rust-lang/cargo/"
repository = "https://github.com/rust-lang/cargo/"
</code></pre>
<p>Should be written as:</p>
<pre><code class="language-toml">[package]
name = "foo"
repository = "https://github.com/rust-lang/cargo/"
</code></pre>
<h2 id="redundant_readme"><a class="header" href="#redundant_readme"><code>redundant_readme</code></a></h2>
<p>Group: <code>style</code></p>
<p>Level: <code>warn</code></p>
<p>MSRV: <code>1.79.0</code></p>
<h3 id="동작-방식-9"><a class="header" href="#동작-방식-9">동작 방식</a></h3>
<p>Checks for <code>package.readme</code> fields that can be inferred.</p>
<p>See also <a href="reference/manifest.html#the-readme-field"><code>package.readme</code> reference documentation</a>.</p>
<h3 id="나쁜-이유-9"><a class="header" href="#나쁜-이유-9">나쁜 이유</a></h3>
<p>Adds boilerplate.</p>
<h3 id="drawbacks-8"><a class="header" href="#drawbacks-8">Drawbacks</a></h3>
<p>It might not be obvious if they named their file correctly.</p>
<h3 id="예제-10"><a class="header" href="#예제-10">예제</a></h3>
<pre><code class="language-toml">[package]
name = "foo"
readme = "README.md"
</code></pre>
<p>Should be written as:</p>
<pre><code class="language-toml">[package]
name = "foo"
</code></pre>
<h2 id="unknown_lints"><a class="header" href="#unknown_lints"><code>unknown_lints</code></a></h2>
<p>Group: <code>suspicious</code></p>
<p>Level: <code>warn</code></p>
<p>MSRV: <code>1.79.0</code></p>
<h3 id="동작-방식-10"><a class="header" href="#동작-방식-10">동작 방식</a></h3>
<p><code>[lints.cargo]</code> 테이블에서 알 수 없는 린트를 확인합니다</p>
<h3 id="나쁜-이유-10"><a class="header" href="#나쁜-이유-10">나쁜 이유</a></h3>
<ul>
<li>린트 이름의 철자가 틀려서 예상대로 작동하지 않는 이유에 대한 혼란을 초래할 수 있습니다</li>
<li><code>cargo</code> 가 나중에 같은 이름의 린트를 만들기로 결정하면 알 수 없는 린트가 오류를 일으킬 수 있습니다</li>
</ul>
<h3 id="예제-11"><a class="header" href="#예제-11">예제</a></h3>
<pre><code class="language-toml">[lints.cargo]
this-lint-does-not-exist = "warn"
</code></pre>
<h2 id="unused_workspace_dependencies"><a class="header" href="#unused_workspace_dependencies"><code>unused_workspace_dependencies</code></a></h2>
<p>Group: <code>suspicious</code></p>
<p>Level: <code>warn</code></p>
<p>MSRV: <code>1.79.0</code></p>
<h3 id="동작-방식-11"><a class="header" href="#동작-방식-11">동작 방식</a></h3>
<p>Checks for any entry in <code>[workspace.dependencies]</code> that has not been inherited</p>
<h3 id="나쁜-이유-11"><a class="header" href="#나쁜-이유-11">나쁜 이유</a></h3>
<p>They can give the false impression that these dependencies are used</p>
<h3 id="예제-12"><a class="header" href="#예제-12">예제</a></h3>
<pre><code class="language-toml">[workspace.dependencies]
regex = "1"

[dependencies]
</code></pre>
<h2 id="unused_workspace_package_fields"><a class="header" href="#unused_workspace_package_fields"><code>unused_workspace_package_fields</code></a></h2>
<p>Group: <code>suspicious</code></p>
<p>Level: <code>warn</code></p>
<p>MSRV: <code>1.79.0</code></p>
<h3 id="동작-방식-12"><a class="header" href="#동작-방식-12">동작 방식</a></h3>
<p>Checks for any fields in <code>[workspace.package]</code> that has not been inherited</p>
<h3 id="나쁜-이유-12"><a class="header" href="#나쁜-이유-12">나쁜 이유</a></h3>
<p>They can give the false impression that these fields are used</p>
<h3 id="예제-13"><a class="header" href="#예제-13">예제</a></h3>
<pre><code class="language-toml">[workspace.package]
edition = "2024"

[package]
name = "foo"
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="불안정한-기능"><a class="header" href="#불안정한-기능">불안정한 기능</a></h1>
<p>실험적인 Cargo 기능은 <a href="reference/../../book/appendix-07-nightly-rust.html">나이틀리 채널</a> 에서만 사용할 수 있습니다. 이러한 기능이 요구 사항을 충족하는지, 문제나 이슈가 있는지 확인하기 위해 실험해 보는 것을 권장합니다. 기능에 대한 자세한 정보는 아래 링크된 추적 이슈(tracking issues)를 확인하고, 향후 업데이트를 받고 싶다면 GitHub 구독 버튼을 클릭하세요.</p>
<p>일정 기간이 지난 후 주요 우려 사항이 없다면 해당 기능은 <a href="https://doc.crates.io/contrib/process/unstable.html#stabilization">안정화</a>될 수 있으며, 현재 나이틀리 릴리스가 안정 채널에 도달하면(6주에서 12주 소요) 안정 버전에서 사용할 수 있게 됩니다.</p>
<p>기능이 작동하는 방식에 따라 불안정한 기능을 활성화하는 세 가지 방법이 있습니다:</p>
<ul>
<li>
<p><code>Cargo.toml</code> 의 새로운 문법은 <code>Cargo.toml</code> 상단, 모든 테이블 앞에 <code>cargo-features</code> 키가 필요합니다. 예를 들어:</p>
<pre><code class="language-toml"># 활성화할 새로운 Cargo.toml 기능을 지정합니다.
cargo-features = ["test-dummy-unstable"]

[package]
name = "my-package"
version = "0.1.0"
im-a-teapot = true  # 이것은 test-dummy-unstable에 의해 활성화된 새로운 옵션입니다.
</code></pre>
</li>
<li>
<p>새로운 명령줄 플래그, 옵션 및 하위 명령어를 사용하려면 <code>-Z unstable-options</code> CLI 옵션도 함께 포함해야 합니다. 예를 들어, 새로운 <code>--artifact-dir</code> 옵션은 나이틀리에서만 사용할 수 있습니다:</p>
<p><code>cargo +nightly build --artifact-dir=out -Z unstable-options</code></p>
</li>
<li>
<p><code>-Z</code> 명령줄 플래그는 인터페이스가 없거나 아직 설계되지 않은 새로운 기능, 또는 Cargo의 여러 부분에 영향을 미치는 더 복잡한 기능을 활성화하는 데 사용됩니다. 예를 들어, <a href="reference/unstable.html#mtime-on-use">mtime-on-use</a> 기능은 다음을 통해 활성화할 수 있습니다:</p>
<p><code>cargo +nightly build -Z mtime-on-use</code></p>
<p>사용 가능한 플래그 목록을 보려면 <code>cargo -Z help</code> 를 실행하세요.</p>
<p><code>-Z</code> 플래그로 구성할 수 있는 모든 것은 cargo <a href="reference/config.html">설정 파일</a> (<code>.cargo/config.toml</code>)의 <code>unstable</code> 테이블에서도 설정할 수 있습니다. 예를 들어:</p>
<pre><code class="language-toml">[unstable]
mtime-on-use = true
build-std = ["core", "alloc"]
</code></pre>
</li>
</ul>
<p>아래 설명된 각 새로운 기능은 사용 방법을 설명해야 합니다.</p>
<p><em>최신 나이틀리에 대해서는 이 페이지의 <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html">나이틀리 버전</a>을 참조하세요.</em></p>
<h2 id="불안정한-기능-목록"><a class="header" href="#불안정한-기능-목록">불안정한 기능 목록</a></h2>
<ul>
<li>불안정 기능 전용 기능
<ul>
<li><a href="reference/unstable.html#allow-features">-Z allow-features</a> — 사용되는 불안정한 기능을 제한하는 방법을 제공합니다.</li>
</ul>
</li>
<li>빌드 스크립트 및 링킹
<ul>
<li><a href="reference/unstable.html#metabuild">Metabuild</a> — 선언적 빌드 스크립트를 제공합니다.</li>
<li><a href="reference/unstable.html#multiple-build-scripts">Multiple Build Scripts</a> — Allows use of multiple build scripts.</li>
<li><a href="reference/unstable.html#any-build-script-metadata">Any Build Script Metadata</a> — Allow any build script to specify env vars via <code>cargo::metadata=key=value</code></li>
</ul>
</li>
<li>리졸버 및 기능
<ul>
<li><a href="reference/unstable.html#no-index-update">no-index-update</a> — Cargo가 인덱스 캐시를 업데이트하지 않도록 합니다.</li>
<li><a href="reference/unstable.html#avoid-dev-deps">avoid-dev-deps</a> — 의존성 해결 중에 리졸버가 개발 의존성(dev-dependencies)을 포함하지 않도록 합니다.</li>
<li><a href="reference/unstable.html#minimal-versions">minimal-versions</a> — 리졸버가 가장 높은 버전 대신 호환되는 가장 낮은 버전을 사용하도록 강제합니다.</li>
<li><a href="reference/unstable.html#direct-minimal-versions">direct-minimal-versions</a> — 리졸버가 가장 높은 버전 대신 호환되는 가장 낮은 버전을 사용하도록 강제합니다.</li>
<li><a href="reference/unstable.html#public-dependency">public-dependency</a> — 의존성을 공개 또는 비공개로 분류할 수 있게 합니다.</li>
<li><a href="reference/unstable.html#msrv-policy">msrv-policy</a> — MSRV를 인식하는 리졸버 및 버전 선택</li>
<li><a href="reference/unstable.html#precise-pre-release">precise-pre-release</a> — <code>update --precise</code> 로 프리릴리스 버전을 선택할 수 있게 합니다.</li>
<li><a href="reference/unstable.html#sbom">sbom</a> — 컴파일된 결과물에 대한 SBOM 전구체 파일을 생성합니다.</li>
<li><a href="reference/unstable.html#update-breaking">update-breaking</a> — <code>update --breaking</code> 으로 중단되는 변경이 포함된 버전으로 업그레이드할 수 있게 합니다.</li>
<li><a href="reference/unstable.html#feature-unification">feature-unification</a> — 워크스페이스에서 새로운 기능 통합 모드를 활성화합니다.</li>
<li><a href="reference/unstable.html#lockfile-publish-time">lockfile-publish-time</a> — Limit resolver to packages older than the specified time</li>
</ul>
</li>
<li>출력 동작
<ul>
<li><a href="reference/unstable.html#artifact-dir">artifact-dir</a> — 결과물이 복사될 디렉토리를 추가합니다.</li>
<li><a href="reference/unstable.html#build-dir-new-layout">build-dir-new-layout</a> — Enables the new build-dir filesystem layout</li>
<li><a href="reference/unstable.html#different-binary-name">Different binary name</a> — 빌드된 바이너리에 크레이트 이름과 별개의 이름을 할당합니다.</li>
<li><a href="reference/unstable.html#root-dir">root-dir</a> — 경로가 출력될 기준이 되는 루트 디렉토리를 제어합니다.</li>
</ul>
</li>
<li>컴파일 동작
<ul>
<li><a href="reference/unstable.html#mtime-on-use">mtime-on-use</a> — 의존성이 사용될 때마다 최종 수정 시간을 업데이트하여, 사용되지 않는 결과물을 삭제하는 메커니즘을 제공합니다.</li>
<li><a href="reference/unstable.html#build-std">build-std</a> — 사전 빌드된 바이너리를 사용하는 대신 표준 라이브러리를 빌드합니다.</li>
<li><a href="reference/unstable.html#build-std-features">build-std-features</a> — 표준 라이브러리와 함께 사용할 기능을 설정합니다.</li>
<li><a href="reference/unstable.html#binary-dep-depinfo">binary-dep-depinfo</a> — dep-info 파일이 바이너리 의존성을 추적하게 합니다.</li>
<li><a href="reference/unstable.html#checksum-freshness">checksum-freshness</a> — 이 옵션이 전달되면, 크레이트 재빌드 여부를 결정할 때 파일의 mtime 대신 파일 체크섬을 사용합니다.</li>
<li><a href="reference/unstable.html#panic-abort-tests">panic-abort-tests</a> — “abort” 패닉 전략으로 테스트를 실행할 수 있게 합니다.</li>
<li><a href="reference/unstable.html#host-config">host-config</a> — 호스트 빌드 타겟에 대해 <code>[target]</code> 과 유사한 설정 구성을 허용합니다.</li>
<li><a href="reference/unstable.html#no-embed-metadata">no-embed-metadata</a> — Passes <code>-Zembed-metadata=no</code> to the compiler, which avoid embedding metadata into rlib and dylib artifacts, to save disk space.</li>
<li><a href="reference/unstable.html#target-applies-to-host">target-applies-to-host</a> — 특정 플래그가 호스트 빌드 타겟에 전달될지 여부를 변경합니다.</li>
<li><a href="reference/unstable.html#gc">gc</a> — 전역 캐시 가비지 컬렉션.</li>
<li><a href="reference/unstable.html#open-namespaces">open-namespaces</a> — 여러 패키지가 동일한 API 네임스페이스에 참여할 수 있게 합니다.</li>
<li><a href="reference/unstable.html#panic-immediate-abort">panic-immediate-abort</a> — Passes <code>-Cpanic=immediate-abort</code> to the compiler.</li>
<li><a href="reference/unstable.html#compile-time-deps">compile-time-deps</a> — Perma-unstable feature for rust-analyzer</li>
<li><a href="reference/unstable.html#fine-grain-locking">fine-grain-locking</a> — Use fine grain locking instead of locking the entire build cache</li>
<li><a href="reference/unstable.html#target-spec-json">target-spec-json</a> — Allows the use of <code>.json</code> custom target specs.</li>
</ul>
</li>
<li>rustdoc
<ul>
<li><a href="reference/unstable.html#rustdoc-map">rustdoc-map</a> — 문서가 <a href="https://docs.rs/">docs.rs</a> 와 같은 외부 사이트로 링크될 수 있도록 매핑을 제공합니다.</li>
<li><a href="reference/unstable.html#scrape-examples">scrape-examples</a> — 문서 내에 예제를 보여줍니다.</li>
<li><a href="reference/unstable.html#output-format-for-rustdoc">output-format</a> — 문서를 실험적인 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustdoc_json_types/">JSON 형식</a> 으로도 출력할 수 있게 합니다.</li>
<li><a href="reference/unstable.html#rustdoc-depinfo">rustdoc-depinfo</a> — Use dep-info files in rustdoc rebuild detection.</li>
<li><a href="reference/unstable.html#rustdoc-mergeable-info">rustdoc-mergeable-info</a> — Use rustdoc mergeable cross-crate-info files.</li>
</ul>
</li>
<li><code>Cargo.toml</code> 확장
<ul>
<li><a href="reference/unstable.html#profile-rustflags-option">Profile <code>rustflags</code> 옵션</a> — rustc에 직접 전달됩니다.</li>
<li><a href="reference/unstable.html#profile-hint-mostly-unused-option">Profile <code>hint-mostly-unused</code> option</a> — Hint that a dependency is mostly unused, to optimize compilation time.</li>
<li><a href="reference/unstable.html#codegen-backend">codegen-backend</a> — rustc에서 사용할 코드 생성 백엔드를 선택합니다.</li>
<li><a href="reference/unstable.html#per-package-target">per-package-target</a> — 각 개별 패키지에 사용할 <code>--target</code> 을 설정합니다.</li>
<li><a href="reference/unstable.html#artifact-dependencies">결과물 의존성(artifact dependencies)</a> — 빌드 결과물을 다른 빌드 결과물에 포함할 수 있게 하고, 다른 타겟에 대해 빌드할 수 있게 합니다.</li>
<li><a href="reference/unstable.html#profile-trim-paths-option">Profile <code>trim-paths</code> 옵션</a> — 빌드 출력에서 파일 경로의 정리(sanitization)를 제어합니다.</li>
<li><a href="reference/unstable.html#lintscargo"><code>[lints.cargo]</code></a> — Cargo에 대한 린트를 설정할 수 있게 합니다.</li>
<li><a href="reference/unstable.html#path-bases">path bases</a> — 경로 의존성을 위한 이름이 지정된 기본 디렉토리입니다.</li>
<li><a href="reference/unstable.html#unstable-editions"><code>unstable-editions</code></a> — Allows use of editions that are not yet stable.</li>
</ul>
</li>
<li>정보 및 메타데이터
<ul>
<li><a href="reference/unstable.html#unit-graph">unit-graph</a> — Cargo의 내부 그래프 구조에 대한 JSON을 출력합니다.</li>
<li><a href="reference/unstable.html#rustc---print"><code>cargo rustc --print</code></a> — <code>--print</code> 와 함께 rustc를 호출하여 rustc의 정보를 표시합니다.</li>
<li><a href="reference/unstable.html#build-analysis">Build analysis</a> — Record and persist detailed build metrics across runs, with new commands to query past builds.</li>
<li><a href="reference/unstable.html#rustc-unicode"><code>rustc-unicode</code></a> — Enables <code>rustc</code>’s unicode error format in Cargo’s error messages</li>
</ul>
</li>
<li>설정
<ul>
<li><a href="reference/unstable.html#cargo-config"><code>cargo config</code></a> — 설정 파일을 확인하기 위한 새로운 하위 명령어를 추가합니다.</li>
</ul>
</li>
<li>레지스트리
<ul>
<li><a href="reference/unstable.html#publish-timeout">publish-timeout</a> — 크레이트 업로드와 인덱스에서 사용 가능해지는 사이의 타임아웃을 제어합니다.</li>
<li><a href="reference/unstable.html#asymmetric-token">asymmetric-token</a> — 비대칭 암호화(<code>cargo:paseto</code> 제공자)를 사용한 인증 토큰 지원을 추가합니다.</li>
</ul>
</li>
<li>기타
<ul>
<li><a href="reference/unstable.html#gitoxide">gitoxide</a> — 일련의 작업에 대해 <code>git2</code> 대신 <code>gitoxide</code> 를 사용합니다.</li>
<li><a href="reference/unstable.html#script">script</a> — 단일 파일 <code>.rs</code> 패키지에 대한 지원을 활성화합니다.</li>
<li><a href="reference/unstable.html#lockfile-path">lockfile-path</a> — 기본 경로인 <code>&lt;workspace_root&gt;/Cargo.lock</code> 이외의 잠금 파일 경로를 지정할 수 있게 합니다.</li>
<li><a href="reference/unstable.html#native-completions">native-completions</a> — Cargo 셸 완성을 네이티브 완성으로 이동합니다.</li>
<li><a href="reference/unstable.html#warnings">warnings</a> — 경고 동작을 제어합니다. 경고를 허용하거나 거부하는 옵션이 있습니다.</li>
<li><a href="reference/unstable.html#package-message-format">Package message format</a> — Message format for <code>cargo package</code>.</li>
<li><a href="reference/unstable.html#fix-edition"><code>fix-edition</code></a> — A permanently unstable edition migration helper.</li>
<li><a href="https://github.com/crate-ci/cargo-plumbing">Plumbing subcommands</a> — Low, level commands that act as APIs for Cargo, like <code>cargo metadata</code></li>
</ul>
</li>
</ul>
<h2 id="allow-features"><a class="header" href="#allow-features">allow-features</a></h2>
<p>이 영구적으로 불안정한(permanently-unstable) 플래그는 나열된 일련의 불안정한 기능들만 사용할 수 있게 합니다. 구체적으로, <code>-Zallow-features=foo,bar</code> 를 전달하면 <code>cargo</code> 에 <code>-Zfoo</code> 와 <code>-Zbar</code> 는 계속 전달할 수 있지만, <code>-Zbaz</code> 는 전달할 수 없게 됩니다. 빈 문자열(<code>-Zallow-features=</code>)을 전달하여 모든 불안정한 기능을 허용하지 않을 수도 있습니다.</p>
<p><code>-Zallow-features</code> 는 또한 <code>Cargo.toml</code> 의 <code>cargo-features</code> 항목에 전달될 수 있는 불안정한 기능을 제한합니다. 예를 들어, 다음을 허용하고 싶다면</p>
<pre><code class="language-toml">cargo-features = ["test-dummy-unstable"]
</code></pre>
<p>여기서 <code>test-dummy-unstable</code> 이 불안정한 기능인 경우, 해당 기능은 <code>-Zallow-features=</code> 에 의해 허용되지 않으며, <code>-Zallow-features=test-dummy-unstable</code> 을 사용해야 허용됩니다.</p>
<p>Cargo의 <code>-Zallow-features</code> 에 전달된 기능 목록은 Cargo가 호출하는 모든 Rust 도구(<code>rustc</code> 나 <code>rustdoc</code> 등)에도 전달됩니다. 따라서 <code>cargo -Zallow-features=</code> 를 실행하면 불안정한 Cargo 기능이나 Rust 기능을 모두 사용할 수 없습니다.</p>
<h2 id="no-index-update"><a class="header" href="#no-index-update">no-index-update</a></h2>
<ul>
<li>원본 이슈: <a href="https://github.com/rust-lang/cargo/issues/3479">#3479</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/7404">#7404</a></li>
</ul>
<p><code>-Z no-index-update</code> 플래그는 Cargo가 레지스트리 인덱스 업데이트를 시도하지 않도록 합니다. 이것은 Crater와 같이 많은 Cargo 명령을 내리는 도구를 위한 것이며, 매번 인덱스를 업데이트하는 네트워크 지연 시간을 피하고 싶을 때 사용합니다.</p>
<h2 id="mtime-on-use"><a class="header" href="#mtime-on-use">mtime-on-use</a></h2>
<ul>
<li>원본 이슈: <a href="https://github.com/rust-lang/cargo/pull/6477">#6477</a></li>
<li>캐시 사용 메타 추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/7150">#7150</a></li>
</ul>
<p><code>-Z mtime-on-use</code> 플래그는 사용된 파일의 mtime을 Cargo가 업데이트하도록 하여 cargo-sweep와 같은 도구가 어떤 파일이 오래되었는지 더 쉽게 감지할 수 있도록 하는 실험입니다. 많은 워크플로에서 이 설정은 Cargo의 <em>모든</em> 호출에 적용되어야 합니다. 이를 보다 실용적으로 만들기 위해 <code>.cargo/config.toml</code> 에서 <code>unstable.mtime_on_use</code> 플래그를 설정하거나 해당 환경 변수를 설정하면 nightly Cargo의 모든 호출에 <code>-Z mtime-on-use</code> 가 적용됩니다. (이 설정 플래그는 stable에서는 무시됩니다.)</p>
<h2 id="avoid-dev-deps"><a class="header" href="#avoid-dev-deps">avoid-dev-deps</a></h2>
<ul>
<li>원본 이슈: <a href="https://github.com/rust-lang/cargo/issues/4988">#4988</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/5133">#5133</a></li>
</ul>
<p><code>cargo install</code> 이나 <code>cargo build</code> 와 같은 명령을 실행할 때, 현재 Cargo는 사용되지 않더라도 개발 의존성(dev-dependencies)을 다운로드해야 합니다. <code>-Z avoid-dev-deps</code> 플래그를 사용하면 필요하지 않은 경우 개발 의존성 다운로드를 피할 수 있습니다. 개발 의존성을 건너뛰면 <code>Cargo.lock</code> 파일이 생성되지 않습니다.</p>
<h2 id="minimal-versions"><a class="header" href="#minimal-versions">minimal-versions</a></h2>
<ul>
<li>원본 이슈: <a href="https://github.com/rust-lang/cargo/issues/4100">#4100</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/5657">#5657</a></li>
</ul>
<blockquote>
<p>참고: 이 기능을 사용하는 것은 권장되지 않습니다. 모든 전이적(transitive) 의존성에 대해 최소 버전을 강제하기 때문에, 모든 외부 의존성이 적절한 하위 버전 범위를 선언하지는 않으므로 유용성이 제한적입니다. 향후 직접적인 의존성에 대해서만 최소 버전을 강제하도록 변경될 예정입니다.</p>
</blockquote>
<p><code>Cargo.lock</code> 파일이 생성될 때, <code>-Z minimal-versions</code> 플래그는 요구 사항을 충족하는 가장 높은 버전 대신 가장 낮은 SemVer 버전으로 의존성을 해결합니다.</p>
<p>이 플래그의 의도된 사용 사례는 지속적 통합(CI) 중에 Cargo.toml에 지정된 버전이 실제로 사용 중인 최소 버전을 올바르게 반영하고 있는지 확인하는 것입니다. 즉, Cargo.toml에 <code>foo = "1.0.0"</code> 이라고 되어 있을 때 실수로 <code>foo 1.5.0</code> 에서만 추가된 기능에 의존하고 있지는 않은지 확인하는 것입니다.</p>
<h2 id="direct-minimal-versions"><a class="header" href="#direct-minimal-versions">direct-minimal-versions</a></h2>
<ul>
<li>원본 이슈: <a href="https://github.com/rust-lang/cargo/issues/4100">#4100</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/5657">#5657</a></li>
</ul>
<p><code>Cargo.lock</code> 파일이 생성될 때, <code>-Z direct-minimal-versions</code> 플래그는 직접적인 의존성에 대해서만 요구 사항을 충족하는 가장 높은 버전 대신 가장 낮은 SemVer 버전으로 의존성을 해결합니다.</p>
<p>이 플래그의 의도된 사용 사례는 지속적 통합(CI) 중에 Cargo.toml에 지정된 버전이 실제로 사용 중인 최소 버전을 올바르게 반영하고 있는지 확인하는 것입니다. 즉, Cargo.toml에 <code>foo = "1.0.0"</code> 이라고 되어 있을 때 실수로 <code>foo 1.5.0</code> 에서만 추가된 기능에 의존하고 있지는 않은지 확인하는 것입니다.</p>
<p>간접적인 의존성은 최소 버전 검증에 의해 차단되지 않도록 정상적으로 해결됩니다.</p>
<h2 id="artifact-dir"><a class="header" href="#artifact-dir">artifact-dir</a></h2>
<ul>
<li>원본 이슈: <a href="https://github.com/rust-lang/cargo/issues/4875">#4875</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/6790">#6790</a></li>
</ul>
<p>이 기능을 사용하면 결과물이 빌드된 후 복사될 디렉토리를 지정할 수 있습니다. 일반적으로 결과물은 <code>target/release</code> 나 <code>target/debug</code> 디렉토리에만 기록됩니다. 그러나 JSON 출력을 파싱해야 하므로 정확한 파일 이름을 결정하는 것이 까다로울 수 있습니다. <code>--artifact-dir</code> 플래그를 사용하면 예측 가능한 방식으로 결과물에 접근하기가 더 쉬워집니다. 결과물은 복사되는 것이므로 원본은 여전히 <code>target</code> 디렉토리에 남아 있음에 유의하세요. 예시:</p>
<pre><code class="language-sh">cargo +nightly build --artifact-dir=out -Z unstable-options
</code></pre>
<p>이는 <code>.cargo/config.toml</code> 파일에서도 지정할 수 있습니다.</p>
<pre><code class="language-toml">[build]
artifact-dir = "out"
</code></pre>
<h2 id="root-dir"><a class="header" href="#root-dir">root-dir</a></h2>
<ul>
<li>원본 이슈: <a href="https://github.com/rust-lang/cargo/issues/9887">#9887</a></li>
<li>추적 이슈: 없음 (현재 안정화 계획 없음)</li>
</ul>
<p><code>-Zroot-dir</code> 플래그는 경로가 출력되는 기준이 되는 루트 디렉토리를 설정합니다. 이는 진단 정보와 <code>file!()</code> 매크로에 의해 출력되는 경로 모두에 영향을 미칩니다.</p>
<h2 id="metabuild"><a class="header" href="#metabuild">Metabuild</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/rust/issues/49803">rust-lang/rust#49803</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/blob/master/text/2196-metabuild.md">#2196</a></li>
</ul>
<p>Metabuild는 선언적 빌드 스크립트를 가질 수 있는 기능입니다. <code>build.rs</code> 스크립트를 작성하는 대신, <code>Cargo.toml</code> 의 <code>metabuild</code> 키에 빌드 의존성 목록을 지정합니다. 각 빌드 의존성을 순서대로 실행하는 빌드 스크립트가 자동으로 생성됩니다. Metabuild 패키지는 <code>Cargo.toml</code> 에서 메타데이터를 읽어 동작을 지정할 수 있습니다.</p>
<p><code>Cargo.toml</code> 상단에 <code>cargo-features</code> 를 포함하고, <code>package</code> 에 <code>metabuild</code> 키를 추가하며, <code>build-dependencies</code> 에 의존성을 나열하고, metabuild 패키지가 요구하는 메타데이터를 <code>package.metadata</code> 아래에 추가하세요. 예시:</p>
<pre><code class="language-toml">[package]
name = "my-package"
version = "0.1.0"
metabuild = ["foo", "bar"]

[build-dependencies]
foo = "1.0"
bar = "1.0"

[package.metadata.foo]
extra-info = "qwerty"
</code></pre>
<p>Metabuild 패키지는 일반적인 <code>build.rs</code> 스크립트가 수행하는 것과 동일한 작업을 수행하는 <code>metabuild</code> 라는 이름의 공개 함수를 가지고 있어야 합니다.</p>
<h2 id="multiple-build-scripts"><a class="header" href="#multiple-build-scripts">Multiple Build Scripts</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/14903">#14903</a></li>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/15630">#15630</a></li>
</ul>
<p>Multiple Build Scripts feature allows you to have multiple build scripts in your package.</p>
<p>Include <code>cargo-features</code> at the top of <code>Cargo.toml</code> and add <code>multiple-build-scripts</code> to enable feature. Add the paths of the build scripts as an array in <code>package.build</code>. For example:</p>
<pre><code class="language-toml">cargo-features = ["multiple-build-scripts"]

[package]
name = "mypackage"
version = "0.0.1"
build = ["foo.rs", "bar.rs"]
</code></pre>
<p><strong>Accessing Output Directories</strong>:  Output directory of each build script can be accessed by using <code>&lt;script-name&gt;_OUT_DIR</code> where the <code>&lt;script-name&gt;</code> is the file-stem of the build script, exactly as-is. For example, <code>bar_OUT_DIR</code> for script at <code>foo/bar.rs</code>. (Only set during compilation, can be accessed via <code>env!</code> macro)</p>
<h2 id="any-build-script-metadata"><a class="header" href="#any-build-script-metadata">Any Build Script Metadata</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/3544">#14903</a></li>
</ul>
<p>Allow any build script to specify env vars via <code>cargo::metadata=key=value</code></p>
<p>Depedant build scripts can access these key/value pair by reading the <code>CARGO_DEP_&lt;dep&gt;_&lt;key&gt;</code> env variable at runtime. For build scripts of crates with a <code>links</code>, both <code>DEP_&lt;links&gt;_&lt;key&gt;</code> and <code>CARGO_DEP_&lt;dep&gt;_&lt;key&gt;</code> will be set.</p>
<p>Note that <code>dep</code> and <code>key</code> in <code>CARGO_DEP_&lt;dep&gt;_&lt;key&gt;</code> are uppercased and hyphens (<code>-</code>) replaced with underscores (<code>_</code>).</p>
<h2 id="public-dependency"><a class="header" href="#public-dependency">public-dependency</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/rust/issues/44663">#44663</a></li>
</ul>
<p>‘public-dependency’ 기능을 사용하면 의존성을 ‘공개(public)’ 또는 ’비공개(private)’로 표시할 수 있습니다. 이 기능이 활성화되면, <a href="reference/../../rustc/lints/listing/warn-by-default.html#exported-private-dependencies">exported_private_dependencies</a> 린트가 제대로 작동할 수 있도록 rustc에 추가 정보가 전달됩니다.</p>
<p>이 기능을 활성화하려면, <code>-Zpublic-dependency</code> 를 사용하거나</p>
<pre><code class="language-sh">cargo +nightly run -Zpublic-dependency
</code></pre>
<p>또는 예를 들어 <code>[unstable]</code> 표를 사용할 수 있습니다.</p>
<pre><code class="language-toml"># .cargo/config.toml
[unstable]
public-dependency = true
</code></pre>
<p><code>public-dependency</code> 는 <code>cargo-features</code> 에서도 활성화할 수 있었으나, <strong>현재는 권장되지 않으며(deprecated) 곧 제거될 예정</strong> 입니다.</p>
<pre><code class="language-toml">cargo-features = ["public-dependency"]

[dependencies]
my_dep = { version = "1.2.3", public = true }
private_dep = "2.0.0" # 기본적으로 '비공개(private)'가 됩니다
</code></pre>
<p>문서 업데이트:</p>
<ul>
<li>워크스페이스의 “The <code>dependencies</code> table” 섹션에 대해, <code>workspace.dependencies</code> 에서 지원되지 않는 필드로 <code>public</code> 을 포함하세요.</li>
</ul>
<h2 id="msrv-policy"><a class="header" href="#msrv-policy">msrv-policy</a></h2>
<ul>
<li><a href="https://rust-lang.github.io/rfcs/3537-msrv-resolver.html">RFC: MSRV-aware Resolver</a></li>
<li><a href="https://github.com/rust-lang/cargo/issues/9930">#9930</a> (MSRV 인식 리졸버)</li>
</ul>
<p><a href="https://github.com/rust-lang/rfcs/pull/2495">RFC 2495</a> 에 따른 MSRV 인식 Cargo 기능을 위한 포괄적 불안정 기능입니다.</p>
<h3 id="msrv-인식-cargo-add"><a class="header" href="#msrv-인식-cargo-add">MSRV 인식 cargo add</a></h3>
<p>이는 1.79 버전에서 <a href="https://github.com/rust-lang/cargo/pull/13608">#13608</a> 을 통해 안정화되었습니다.</p>
<h3 id="msrv-인식-리졸버"><a class="header" href="#msrv-인식-리졸버">MSRV 인식 리졸버</a></h3>
<p>이는 1.84 버전에서 <a href="https://github.com/rust-lang/cargo/pull/14639">#14639</a> 을 통해 안정화되었습니다.</p>
<h3 id="incompatible_toolchain-오류를-린트로-변환"><a class="header" href="#incompatible_toolchain-오류를-린트로-변환"><code>incompatible_toolchain</code> 오류를 린트로 변환</a></h3>
<p>미구현</p>
<h3 id="cargo-add-cargo-update-를-위한---update-rust-version-플래그"><a class="header" href="#cargo-add-cargo-update-를-위한---update-rust-version-플래그"><code>cargo add</code>, <code>cargo update</code> 를 위한 <code>--update-rust-version</code> 플래그</a></h3>
<p>미구현</p>
<h3 id="packagerust-version--toolchain"><a class="header" href="#packagerust-version--toolchain"><code>package.rust-version = "toolchain"</code></a></h3>
<p>미구현</p>
<h3 id="packagerust-version--toolchain-을-설정하도록-cargo-new-템플릿을-업데이트합니다"><a class="header" href="#packagerust-version--toolchain-을-설정하도록-cargo-new-템플릿을-업데이트합니다"><code>package.rust-version = "toolchain"</code> 을 설정하도록 <code>cargo new</code> 템플릿을 업데이트합니다.</a></h3>
<p>미구현</p>
<h2 id="precise-pre-release"><a class="header" href="#precise-pre-release">precise-pre-release</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/13290">#13290</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/3493">#3493</a></li>
</ul>
<p><code>precise-pre-release</code> 기능을 사용하면 프로젝트의 <code>Cargo.toml</code> 에 프리릴리스가 지정되어 있지 않더라도 <code>update --precise</code> 를 통해 프리릴리스 버전을 선택할 수 있습니다.</p>
<p>예를 들어 다음과 같은 <code>Cargo.toml</code> 이 있다고 가정해 봅시다.</p>
<pre><code class="language-toml">[dependencies]
my-dependency = "0.1.1"
</code></pre>
<p><code>update -Zunstable-options my-dependency --precise 0.1.2-pre.0</code> 를 사용하여 <code>my-dependency</code> 를 프리릴리스 버전으로 업데이트할 수 있습니다. 이는 <code>0.1.2-pre.0</code> 이 <code>0.1.1</code> 과 호환되는 것으로 간주되기 때문입니다. 같은 방식으로 <code>0.1.1</code> 에서 <code>0.2.0-pre.0</code> 으로 업그레이드하는 것은 불가능합니다.</p>
<h2 id="sbom"><a class="header" href="#sbom">sbom</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/pull/13709">#13709</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/3553">#3553</a></li>
</ul>
<p><code>sbom</code> 빌드 설정을 사용하면 각 컴파일된 결과물과 함께 이른바 SBOM 전구체(pre-cursor) 파일을 생성할 수 있습니다. 소프트웨어 자재 명세서(SBOM) 도구는 이러한 생성된 파일을 통합하여, 다른 방식으로는 얻기 어렵거나 불가능한 Cargo 빌드 과정의 중요한 정보를 수집할 수 있습니다.</p>
<p>이 기능을 활성화하려면 <code>.cargo/config.toml</code> 에서 <code>sbom</code> 필드를 설정하거나</p>
<pre><code class="language-toml">[unstable]
sbom = true

[build]
sbom = true
</code></pre>
<p>또는 <code>CARGO_BUILD_SBOM</code> 환경 변수를 <code>true</code> 로 설정하세요. 이 기능은 <code>-Z sbom</code> 플래그를 통해 사용할 수 있습니다.</p>
<p>생성된 출력 파일은 JSON 형식이며 <code>&lt;artifact&gt;.cargo-sbom.json</code> 명명 규칙을 따릅니다. JSON 파일에는 의존성, 타겟, 기능 및 사용된 <code>rustc</code> 컴파일러에 대한 정보가 포함되어 있습니다.</p>
<p>SBOM 전구체 파일은 타겟 또는 결과물 디렉토리로 상향(uplifted)되는 모든 실행 가능 및 링크 가능 출력물에 대해 생성됩니다.</p>
<h3 id="cargo가-크레이트를-위해-설정하는-환경-변수-1"><a class="header" href="#cargo가-크레이트를-위해-설정하는-환경-변수-1">Cargo가 크레이트를 위해 설정하는 환경 변수</a></h3>
<ul>
<li><code>CARGO_SBOM_PATH</code> – 플랫폼 PATH 구분자로 구분된 생성된 SBOM 전구체 파일 목록입니다. 이 목록은 <code>std::env::split_paths</code> 로 분리할 수 있습니다.</li>
</ul>
<h3 id="sbom-전구체-스키마"><a class="header" href="#sbom-전구체-스키마">SBOM 전구체 스키마</a></h3>
<pre><code class="language-json5">{
  // Schema version.
  "version": 1,
  // Index into the crates array for the root crate.
  "root": 0,
  // Array of all crates. There may be duplicates of the same crate if that
  // crate is compiled differently (different opt-level, features, etc).
  "crates": [
    {
      // Fully qualified package ID specification
      "id": "path+file:///sample-package#0.1.0",
      // List of target kinds: bin, lib, rlib, dylib, cdylib, staticlib, proc-macro, example, test, bench, custom-build
      "kind": ["bin"],
      // Enabled feature flags.
      "features": [],
      // Dependencies for this crate.
      "dependencies": [
        {
          // Index in to the crates array.
          "index": 1,
          // Dependency kind: 
          // Normal: A dependency linked to the artifact produced by this crate.
          // Build: A compile-time dependency used to build this crate (build-script or proc-macro).
          "kind": "normal"
        },
        {
          // A crate can depend on another crate with both normal and build edges.
          "index": 1,
          "kind": "build"
        }
      ]
    },
    {
      "id": "registry+https://github.com/rust-lang/crates.io-index#zerocopy@0.8.16",
      "kind": ["bin"],
      "features": [],
      "dependencies": []
    }
  ],
  // Information about rustc used to perform the compilation.
  "rustc": {
    // Compiler version
    "version": "1.86.0-nightly",
    // Compiler wrapper
    "wrapper": null,
    // Compiler workspace wrapper
    "workspace_wrapper": null,
    // Commit hash for rustc
    "commit_hash": "bef3c3b01f690de16738b1c9f36470fbfc6ac623",
    // Host target triple
    "host": "x86_64-pc-windows-msvc",
    // Verbose version string: `rustc -vV`
    "verbose_version": "rustc 1.86.0-nightly (bef3c3b01 2025-02-04)\nbinary: rustc\ncommit-hash: bef3c3b01f690de16738b1c9f36470fbfc6ac623\ncommit-date: 2025-02-04\nhost: x86_64-pc-windows-msvc\nrelease: 1.86.0-nightly\nLLVM version: 19.1.7\n"
  }
}
</code></pre>
<h2 id="update-breaking"><a class="header" href="#update-breaking">update-breaking</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/12425">#12425</a></li>
</ul>
<p><code>--breaking</code> 플래그를 사용하여 <code>Cargo.toml</code> 의 의존성 버전 요구 사항을 SemVer와 호환되지 않는 버전으로 업그레이드할 수 있게 합니다.</p>
<p>이는 다음과 같은 경우의 의존성에만 적용됩니다</p>
<ul>
<li>패키지가 워크스페이스 멤버의 의존성인 경우</li>
<li>의존성 이름이 변경되지 않은 경우</li>
<li>SemVer와 호환되지 않는 버전을 사용할 수 있는 경우</li>
<li>“SemVer 연산자“가 사용된 경우 (기본값인 <code>^</code>)</li>
</ul>
<p>사용자는 명령줄에 패키지를 지정하여 업그레이드할 패키지를 더 제한할 수 있습니다.</p>
<p>예시:</p>
<pre><code class="language-console">$ cargo +nightly -Zunstable-options update --breaking
$ cargo +nightly -Zunstable-options update --breaking clap
</code></pre>
<p><em>이는 <a href="https://github.com/killercup/cargo-edit/">cargo-upgrade</a> 와 유사한 역할을 하기 위한 것입니다.</em></p>
<h2 id="build-std"><a class="header" href="#build-std">build-std</a></h2>
<ul>
<li>추적 저장소: <a href="https://github.com/rust-lang/wg-cargo-std-aware">https://github.com/rust-lang/wg-cargo-std-aware</a></li>
</ul>
<p><code>build-std</code> 기능을 사용하면 Cargo가 크레이트 그래프 컴파일의 일부로 표준 라이브러리 자체를 컴파일할 수 있습니다. 이 기능은 역사적으로 “std-aware Cargo“라고도 알려져 왔습니다. 이 기능은 아직 개발 초기 단계에 있으며, Cargo에 추가될 수 있는 거대한 기능이기도 합니다. 오늘날 존재하는 최소한의 형태조차도 문서화하기에는 매우 방대한 기능이므로, 최신 상태를 유지하고 싶다면 <a href="https://github.com/rust-lang/wg-cargo-std-aware">추적 저장소</a> 와 관련 이슈들을 팔로우하는 것이 좋습니다.</p>
<p>오늘날 구현된 기능은 <code>-Z build-std</code> 라는 플래그 뒤에 있습니다. 이 플래그는 메인 빌드 자체와 동일한 프로파일을 사용하여 소스 코드로부터 표준 라이브러리를 컴파일하도록 Cargo에 지시합니다. 이 기능이 작동하려면 표준 라이브러리의 소스 코드가 있어야 하며, 현재로서는 <code>rust-src</code> rustup 컴포넌트를 추가하는 것이 유일하게 지원되는 방법입니다.</p>
<pre><code class="language-console">$ rustup component add rust-src --toolchain nightly
</code></pre>
<p>사용법은 다음과 같습니다.</p>
<pre><code class="language-console">$ cargo new foo
$ cd foo
$ cargo +nightly run -Z build-std --target x86_64-unknown-linux-gnu
   Compiling core v0.0.0 (...)
   ...
   Compiling foo v0.1.0 (...)
    Finished dev [unoptimized + debuginfo] target(s) in 21.00s
     Running `target/x86_64-unknown-linux-gnu/debug/foo`
Hello, world!
</code></pre>
<p>여기서는 디버그 어설션이 포함된 디버그 모드로 표준 라이브러리를 재컴파일했으며(<code>src/main.rs</code> 가 컴파일되는 방식과 동일), 마지막에 모든 것이 함께 링크되었습니다.</p>
<p><code>-Z build-std</code> 를 사용하면 안정적인 크레이트인 <code>core</code>, <code>std</code>, <code>alloc</code>, <code>proc_macro</code> 가 암시적으로 컴파일됩니다. <code>cargo test</code> 를 사용하는 경우 <code>test</code> 크레이트도 컴파일됩니다. 이러한 크레이트 중 일부를 지원하지 않는 환경에서 작업하는 경우 <code>-Zbuild-std</code> 에 인수를 전달할 수도 있습니다.</p>
<pre><code class="language-console">$ cargo +nightly build -Z build-std=core,alloc
</code></pre>
<p>여기에 입력할 값은 빌드할 표준 라이브러리 크레이트의 쉼표로 구분된 목록입니다.</p>
<h3 id="요구-사항"><a class="header" href="#요구-사항">요구 사항</a></h3>
<p>요약하자면, 현재 <code>-Z build-std</code> 를 사용하기 위한 요구 사항은 다음과 같습니다.</p>
<ul>
<li><code>rustup component add rust-src</code> 를 통해 libstd의 소스 코드를 설치해야 합니다.</li>
<li>nightly Cargo와 nightly rustc를 모두 사용해야 합니다.</li>
<li>모든 <code>cargo</code> 호출 시 <code>-Z build-std</code> 플래그를 전달해야 합니다.</li>
</ul>
<h3 id="버그-보고-및-지원"><a class="header" href="#버그-보고-및-지원">버그 보고 및 지원</a></h3>
<p><code>-Z build-std</code> 기능은 아직 개발 초기 단계에 있습니다! 이 기능은 Cargo에서 매우 긴 역사를 가지고 있으며 범위도 매우 넓지만, 이제 막 시작된 단계입니다. 버그를 보고하고 싶으시다면 다음 중 한 곳에 보고해 주세요.</p>
<ul>
<li>Cargo — <a href="https://github.com/rust-lang/cargo/issues/new">https://github.com/rust-lang/cargo/issues/new</a> — 구현 버그용</li>
<li>추적 저장소 — <a href="https://github.com/rust-lang/wg-cargo-std-aware/issues/new">https://github.com/rust-lang/wg-cargo-std-aware/issues/new</a> — 큰 규모의 설계 관련 질문용</li>
</ul>
<p>또한 아직 구현되지 않은 기능을 보고 싶거나 무언가 원하는 대로 작동하지 않는 경우, 추적 저장소의 <a href="https://github.com/rust-lang/wg-cargo-std-aware/issues">이슈 트래커</a> 를 자유롭게 확인해 보세요. 거기에 없다면 새 이슈를 등록해 주세요!</p>
<h2 id="build-std-features"><a class="header" href="#build-std-features">build-std-features</a></h2>
<ul>
<li>추적 저장소: <a href="https://github.com/rust-lang/wg-cargo-std-aware">https://github.com/rust-lang/wg-cargo-std-aware</a></li>
</ul>
<p>이 플래그는 <code>-Zbuild-std</code> 기능 플래그의 자매격입니다. 표준 라이브러리를 빌드할 때 표준 라이브러리 자체에 활성화할 기능을 설정합니다. 현재 기본적으로 활성화되는 기능은 <code>backtrace</code> 와 <code>panic-unwind</code> 입니다. 이 플래그는 쉼표로 구분된 목록을 받으며, 제공될 경우 기본 활성화 기능 목록을 덮어씁니다.</p>
<h2 id="binary-dep-depinfo"><a class="header" href="#binary-dep-depinfo">binary-dep-depinfo</a></h2>
<ul>
<li>rustc 추적 이슈: <a href="https://github.com/rust-lang/rust/issues/63012">#63012</a></li>
</ul>
<p><code>-Z binary-dep-depinfo</code> 플래그는 Cargo가 동일한 플래그를 <code>rustc</code> 에 전달하도록 하여, <code>rustc</code> 가 “.d” 확장자를 가진 “dep info” 파일에 모든 바이너리 의존성의 경로를 포함하게 합니다. 그 후 Cargo는 이 정보를 사용하여 변경 사항을 감지합니다(바이너리 의존성이 변경되면 크레이트가 다시 빌드됩니다). 주요 사용 사례는 컴파일러 자체를 빌드할 때로, 표준 라이브러리에 대한 암시적인 의존성이 있어 그렇지 않으면 변경 감지가 되지 않는 경우를 대비한 것입니다.</p>
<h2 id="checksum-freshness"><a class="header" href="#checksum-freshness">checksum-freshness</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/14136">#14136</a></li>
</ul>
<p><code>-Z checksum-freshness</code> 플래그는 Cargo의 핑거프린트(fingerprint)에서 파일 mtime 대신 파일 체크섬 값을 사용하도록 대체합니다. 이는 mtime 구현이 부실한 시스템이나 CI/CD 환경에서 유용합니다. 체크섬 알고리즘은 Cargo 버전에 따라 예고 없이 변경될 수 있습니다. 핑거프린트는 Cargo가 크레이트 재빌드 필요 여부를 결정하는 데 사용됩니다.</p>
<p>당분간은 <code>checksum-freshness</code> 가 활성화되어 있더라도 빌드 스크립트에서 사용되는 파일들은 계속해서 mtime을 사용합니다. 이는 장기적인 해결책으로 의도된 것은 아닙니다.</p>
<h2 id="panic-abort-tests"><a class="header" href="#panic-abort-tests">panic-abort-tests</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/rust/issues/67650">#67650</a></li>
<li>원본 풀 리퀘스트: <a href="https://github.com/rust-lang/cargo/pull/7460">#7460</a></li>
</ul>
<p><code>-Z panic-abort-tests</code> 플래그는 테스트 하네스(test harness) 크레이트를 <code>-Cpanic=abort</code> 로 컴파일하는 nightly 지원을 활성화합니다. 이 플래그가 없으면 Cargo는 테스트와 그 모든 의존성을 <code>-Cpanic=unwind</code> 로 컴파일하는데, 이는 <code>test</code> 크레이트가 작동하는 유일한 방법이기 때문입니다. 하지만 <a href="https://github.com/rust-lang/rust/pull/64158">rust-lang/rust#64158</a>부터 <code>test</code> 크레이트는 프로세스당 하나의 테스트(test-per-process) 방식으로 <code>-C panic=abort</code> 를 지원하며, 이는 크레이트 그래프를 여러 번 컴파일하는 것을 피하는 데 도움이 될 수 있습니다.</p>
<p>현재 이 기능이 Cargo에서 어떻게 안정화될지는 불분명하지만, 어떤 방식으로든 안정화되기를 원합니다!</p>
<h2 id="target-applies-to-host"><a class="header" href="#target-applies-to-host">target-applies-to-host</a></h2>
<ul>
<li>원본 풀 리퀘스트: <a href="https://github.com/rust-lang/cargo/pull/9322">#9322</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/9453">#9453</a></li>
</ul>
<p>역사적으로, 환경 변수 및 <a href="reference/config.html#target"><code>[target]</code></a>의 <code>linker</code> 및 <code>rustflags</code> 설정 옵션이 빌드 스크립트, 플러그인 및 항상 호스트 플랫폼용으로 빌드되는 기타 결과물에 대해 적용되는지 여부에 관한 Cargo의 동작은 다소 일관되지 않았습니다. <code>--target</code> 이 전달되지 <em>않으면</em>, Cargo는 다른 모든 컴파일 결과물과 동일한 <code>linker</code> 및 <code>rustflags</code> 를 빌드 스크립트에 적용합니다. 그러나 <code>--target</code> 이 전달 <em>되면</em>, Cargo는 <a href="reference/config.html#targettriplelinker"><code>[target.&lt;host triple&gt;]</code></a>의 <code>linker</code> 는 적용하지만, 어떤 <code>rustflags</code> 설정도 가져오지 않습니다. 이러한 이중적인 동작은 혼란스러울 뿐만 아니라, 호스트 트리플과 <a href="reference/../appendix/glossary.html#target" title="&quot;target&quot; (용어집)">타겟 트리플</a>이 우연히 같더라도 빌드 호스트에서 실행될 결과물을 다르게 설정해야 하는 빌드를 올바르게 구성하는 것을 어렵게 만듭니다.</p>
<p><code>-Ztarget-applies-to-host</code> 는 Cargo 설정 파일에서 최상위 <code>target-applies-to-host</code> 설정을 활성화하여 사용자가 이러한 속성들에 대해 다르고 (더 일관된) 동작을 선택할 수 있게 합니다. 설정 파일에서 <code>target-applies-to-host</code> 가 설정되지 않았거나 <code>true</code> 로 설정된 경우 기존 Cargo 동작이 유지됩니다 (단, 해당 기본값을 변경하는 <code>-Zhost-config</code> 를 참고하세요). <code>false</code> 로 설정되면, Cargo에 <code>--target</code> 전달 여부와 관계없이 호스트 결과물에 대해 <code>[target.&lt;host triple&gt;]</code>, <code>RUSTFLAGS</code> 또는 <code>[build]</code> 의 어떤 옵션도 적용되지 않습니다. 호스트에서 실행될 결과물을 사용자 정의하려면 <code>[host]</code> (<a href="reference/unstable.html#host-config"><code>host-config</code></a>)를 사용하세요.</p>
<p>향후에는 더 합리적이고 일관된 기본 동작을 제공하기 위해 <code>target-applies-to-host</code> 의 기본값이 <code>false</code> 가 될 수 있습니다.</p>
<pre><code class="language-toml"># config.toml
target-applies-to-host = false
</code></pre>
<pre><code class="language-console">cargo +nightly -Ztarget-applies-to-host build --target x86_64-unknown-linux-gnu
</code></pre>
<h2 id="host-config"><a class="header" href="#host-config">host-config</a></h2>
<ul>
<li>원본 풀 리퀘스트: <a href="https://github.com/rust-lang/cargo/pull/9322">#9322</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/9452">#9452</a></li>
</ul>
<p>설정 파일의 <code>host</code> 키는 교차 컴파일 시 타겟 시스템 대신 호스트 시스템에서 실행되어야 하는 빌드 스크립트와 같은 호스트 빌드 타겟에 플래그를 전달하는 데 사용할 수 있습니다. 일반적인 테이블과 호스트 아키텍처별 테이블을 모두 지원합니다. 일치하는 호스트 아키텍처 테이블은 일반 호스트 테이블보다 우선순위를 가집니다.</p>
<p>이 기능은 <code>-Zhost-config</code> 및 <code>-Ztarget-applies-to-host</code> 명령줄 옵션이 설정되어 있어야 하며, Cargo 설정 파일에 <code>target-applies-to-host = false</code> 가 설정되어 있어야 합니다.</p>
<pre><code class="language-toml"># config.toml
[host]
linker = "/path/to/host/linker"
runner = "host-runner"
[host.x86_64-unknown-linux-gnu]
linker = "/path/to/host/arch/linker"
runner = "host-arch-runner"
rustflags = ["-Clink-arg=--verbose"]
[target.x86_64-unknown-linux-gnu]
linker = "/path/to/target/linker"
</code></pre>
<p>The <code>host.runner</code> setting wraps execution of host build targets such as build scripts, similar to how <code>target.&lt;triple&gt;.runner</code> wraps <code>cargo run</code>/<code>test</code>/<code>bench</code>.</p>
<p>위의 일반 <code>host</code> 테이블은 <code>x86_64-unknown-linux-gnu</code> 호스트에서 빌드할 때 <code>host.x86_64-unknown-linux-gnu</code> 테이블이 우선하므로 완전히 무시됩니다.</p>
<p><code>-Zhost-config</code> 를 설정하면 <code>target-applies-to-host</code> 의 기본값이 <code>true</code> 에서 <code>false</code> 로 변경됩니다.</p>
<pre><code class="language-console">cargo +nightly -Ztarget-applies-to-host -Zhost-config build --target x86_64-unknown-linux-gnu
</code></pre>
<h2 id="unit-graph"><a class="header" href="#unit-graph">unit-graph</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/8002">#8002</a></li>
</ul>
<p><code>--unit-graph</code> 플래그는 Cargo의 내부 유닛 그래프를 나타내는 JSON 객체를 표준 출력으로 내보내기 위해 모든 빌드 명령 (<code>build</code>, <code>check</code>, <code>run</code>, <code>test</code>, <code>bench</code>, <code>doc</code> 등)에 전달될 수 있습니다. 실제로 빌드되는 것은 없으며, 명령은 출력 후 즉시 반환됩니다. 각 “유닛“은 컴파일러의 한 번의 실행에 해당합니다. 이러한 객체에는 각 유닛이 의존하는 유닛 정보도 포함됩니다.</p>
<pre><code>cargo +nightly build --unit-graph -Z unstable-options
</code></pre>
<p>이 구조는 Cargo가 바라보는 의존성 관계에 대한 더 완전한 뷰를 제공합니다. 특히 “features” 필드는 의존성이 서로 다른 기능으로 여러 번 빌드될 수 있는 새로운 기능 리졸버를 지원합니다. <code>cargo metadata</code> 는 기본적으로 서로 다른 의존성 종류 간의 기능 관계를 나타낼 수 없으며, 이제 기능은 어떤 명령이 실행되고 어떤 패키지와 타겟이 선택되었는지에 따라 달라집니다. 또한 빌드 스크립트나 테스트와 같은 패키지 내부 의존성에 대한 세부 정보도 제공할 수 있습니다.</p>
<p>다음은 JSON 구조에 대한 설명입니다.</p>
<pre><code class="language-javascript">{
  /* JSON 출력 구조의 버전입니다. 하위 호환되지 않는 변경이 이루어지면,
     이 값이 증가합니다.
  */
  "version": 1,
  /* 모든 빌드 유닛의 배열. */
  "units": [
    {
      /* 패키지를 나타내는 불투명 문자열.
         패키지에 대한 정보는 `cargo metadata` 에서 얻을 수 있습니다.
      */
      "pkg_id": "my-package 0.1.0 (path+file:///path/to/my-package)",
      /* Cargo 타겟. 이 필드에 대한 자세한 정보는 `cargo metadata` 문서를
         참조하세요.
         https://doc.rust-lang.org/cargo/commands/cargo-metadata.html
      */
      "target": {
        "kind": ["lib"],
        "crate_types": ["lib"],
        "name": "my_package",
        "src_path": "/path/to/my-package/src/lib.rs",
        "edition": "2018",
        "test": true,
        "doctest": true
      },
      /* 이 유닛에 대한 프로파일 설정입니다.
         이 값들은 매니페스트에 정의된 프로파일과 일치하지 않을 수 있습니다.
         유닛은 수정된 프로파일 설정을 사용할 수 있습니다. 예를 들어, 테스트를 위해
         "panic" 설정을 강제로 "unwind"로 재정의할 수 있습니다.
      */
      "profile": {
        /* 이 설정들이 파생된 프로파일 이름입니다. */
        "name": "dev",
        /* 문자열 형태의 최적화 수준. */
        "opt_level": "0",
        /* 문자열 형태의 LTO 설정. */
        "lto": "false",
        /* 정수 형태의 코드 생성 유닛 수.
           컴파일러 기본값을 사용해야 하는 경우 `null` 입니다.
        */
        "codegen_units": null,
        /* 정수 형태의 디버그 정보 레벨.
           컴파일러 기본값(0)을 사용해야 하는 경우 `null` 입니다.
        */
        "debuginfo": 2,
        /* 디버그 어설션 활성화 여부. */
        "debug_assertions": true,
        /* 오버플로 체크 활성화 여부. */
        "overflow_checks": true,
        /* rpath 활성화 여부. */
        "rpath": false,
        /* 증분(incremental) 컴파일 활성화 여부. */
        "incremental": true,
        /* 패닉 전략, "unwind" 또는 "abort". */
        "panic": "unwind"
      },
      /* 이 타겟이 어떤 플랫폼을 위해 빌드되는지 나타냅니다.
         `null` 값은 호스트를 위한 것임을 나타냅니다.
         그렇지 않으면 타겟 트리플 문자열(예: "x86_64-unknown-linux-gnu")입니다.
      */
      "platform": null,
      /* 이 유닛의 "모드(mode)"입니다. 유효한 값:

         * "test" --- 테스트용으로 `rustc` 를 사용하여 빌드합니다.
         * "build" --- `rustc` 를 사용하여 빌드합니다.
         * "check" --- "check" 모드에서 `rustc` 를 사용하여 빌드합니다.
         * "doc" --- `rustdoc` 을 사용하여 빌드합니다.
         * "doctest" --- `rustdoc` 을 사용하여 테스트합니다.
         * "run-custom-build" --- 빌드 스크립트의 실행을 나타냅니다.
      */
      "mode": "build",
      /* 이 유닛에서 활성화된 기능의 문자열 배열입니다. */
      "features": ["somefeat"],
      /* 이것이 표준 라이브러리 유닛인지 여부이며,
         불안정한 build-std 기능의 일부입니다.
         설정되지 않은 경우 `false` 로 처리합니다.
      */
      "is_std": false,
      /* 이 유닛의 의존성 배열입니다. */
      "dependencies": [
        {
          /* 의존성에 대한 "units" 배열에서의 인덱스입니다. */
          "index": 1,
          /* 이 의존성이 참조될 이름입니다. */
          "extern_crate_name": "unicode_xid",
          /* 이 의존성이 "공개(public)"인지 여부이며,
             불안정한 public-dependency 기능의 일부입니다.
             설정되지 않은 경우, public-dependency 기능이 활성화되지 않습니다.
          */
          "public": false,
          /* 이 의존성이 프렐류드(prelude)에 주입되는지 여부이며,
             현재 build-std 기능에서 사용됩니다.
             설정되지 않은 경우 `false` 로 처리합니다.
          */
          "noprelude": false
        }
      ]
    },
    // ...
  ],
  /* 의존성 그래프의 "루트(roots)"인 "units" 배열 인덱스의 배열입니다.
  */
  "roots": [0],
}
</code></pre>
<h2 id="프로파일-rustflags-옵션"><a class="header" href="#프로파일-rustflags-옵션">프로파일 <code>rustflags</code> 옵션</a></h2>
<ul>
<li>원본 이슈: <a href="https://github.com/rust-lang/cargo/issues/7878">rust-lang/cargo#7878</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/10271">rust-lang/cargo#10271</a></li>
</ul>
<p>이 기능은 <code>[profile]</code> 섹션에서 rustc에 직접 전달할 플래그를 지정할 수 있는 새로운 옵션을 제공합니다. 다음과 같이 활성화할 수 있습니다:</p>
<pre><code class="language-toml">cargo-features = ["profile-rustflags"]

[package]
# ...

[profile.release]
rustflags = [ "-C", "..." ]
</code></pre>
<p>Cargo 설정의 프로파일에서 이를 설정하려면, <code>-Z profile-rustflags</code> 또는 <code>[unstable]</code> 테이블을 사용하여 활성화해야 합니다. 예를 들어,</p>
<pre><code class="language-toml"># .cargo/config.toml
[unstable]
profile-rustflags = true

[profile.release]
rustflags = [ "-C", "..." ]
</code></pre>
<h2 id="profile-hint-mostly-unused-option"><a class="header" href="#profile-hint-mostly-unused-option">Profile <code>hint-mostly-unused</code> option</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15644">#15644</a></li>
</ul>
<p>This feature provides a new option in the <code>[profile]</code> section to enable the rustc <code>hint-mostly-unused</code> option. This is primarily useful to enable for specific dependencies:</p>
<pre><code class="language-toml">[profile.dev.package.huge-mostly-unused-dependency]
hint-mostly-unused = true
</code></pre>
<p>To enable this feature, pass <code>-Zprofile-hint-mostly-unused</code>. However, since this option is a hint, using it without passing <code>-Zprofile-hint-mostly-unused</code> will only warn and ignore the profile option. Versions of Cargo prior to the introduction of this feature will give an “unused manifest key” warning, but will otherwise function without erroring. This allows using the hint in a crate’s <code>Cargo.toml</code> without mandating the use of a newer Cargo to build it.</p>
<p>A crate can also provide this hint automatically for crates that depend on it, using the <code>[hints]</code> table (which will likewise be ignored by older Cargo):</p>
<pre><code class="language-toml">[hints]
mostly-unused = true
</code></pre>
<p>This will cause the crate to default to hint-mostly-unused, unless overridden via <code>profile</code>, which takes precedence, and which can only be specified in the top-level crate being built.</p>
<h2 id="rustdoc-map"><a class="header" href="#rustdoc-map">rustdoc-map</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/8296">#8296</a></li>
</ul>
<p>이 기능은 <code>rustdoc</code> 에 전달되는 설정값을 추가하여, 의존성의 문서가 로컬에 생성되지 않았을 때 다른 곳에서 호스팅되는 의존성 문서로 링크를 생성할 수 있게 합니다. 먼저, <code>.cargo/config</code> 에 다음을 추가하세요:</p>
<pre><code class="language-toml">[doc.extern-map.registries]
crates-io = "https://docs.rs/"
</code></pre>
<p>그 다음, 문서를 빌드할 때 다음 플래그를 사용하여 의존성 링크가 <a href="https://docs.rs/">docs.rs</a> 로 연결되도록 하세요:</p>
<pre><code>cargo +nightly doc --no-deps -Zrustdoc-map
</code></pre>
<p><code>registries</code> 테이블은 레지스트리 이름과 링크할 URL의 매핑을 포함합니다. URL에는 <code>{pkg_name}</code> 과 <code>{version}</code> 마커를 사용할 수 있으며, 이는 해당 값으로 대체됩니다. 둘 다 지정되지 않은 경우, Cargo는 기본적으로 URL 끝에 <code>{pkg_name}/{version}/</code> 을 추가합니다.</p>
<p>표준 라이브러리 링크를 리다이렉션하는 또 다른 설정이 있습니다. 기본적으로 rustdoc은 <a href="https://doc.rust-lang.org/nightly/">https://doc.rust-lang.org/nightly/</a>로 링크를 생성합니다. 이 동작을 변경하려면 <code>doc.extern-map.std</code> 설정을 사용하세요:</p>
<pre><code class="language-toml">[doc.extern-map]
std = "local"
</code></pre>
<p><code>"local"</code> 값은 <code>rustc</code> sysroot에 있는 문서를 링크한다는 뜻입니다. rustup을 사용하고 있다면 <code>rustup component add rust-docs</code> 로 이 문서를 설치할 수 있습니다.</p>
<p>기본값은 <code>"remote"</code> 입니다.</p>
<p>이 값은 또한 사용자 정의 위치를 위한 URL을 가질 수도 있습니다.</p>
<h2 id="per-package-target"><a class="header" href="#per-package-target">per-package-target</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/pull/9406">#9406</a></li>
<li>원본 풀 리퀘스트: <a href="https://github.com/rust-lang/cargo/pull/9030">#9030</a></li>
<li>원본 이슈: <a href="https://github.com/rust-lang/cargo/pull/7004">#7004</a></li>
</ul>
<p><code>per-package-target</code> 기능은 매니페스트에 <code>package.default-target</code> 과 <code>package.forced-target</code> 두 개의 키를 추가합니다. 첫 번째는 패키지가 기본적으로 (즉, <code>--target</code> 인수가 전달되지 않았을 때) 특정 타겟을 위해 컴파일되게 합니다. 두 번째는 패키지가 항상 해당 타겟을 위해 컴파일되게 합니다.</p>
<p>예시:</p>
<pre><code class="language-toml">[package]
forced-target = "wasm32-unknown-unknown"
</code></pre>
<p>이 예시에서 크레이트는 항상 <code>wasm32-unknown-unknown</code> 을 위해 빌드됩니다. 예를 들어, 호스트(또는 명령줄에서 제공된) 타겟에서 실행되는 메인 프로그램의 플러그인으로 사용될 것이기 때문입니다.</p>
<h2 id="artifact-dependencies"><a class="header" href="#artifact-dependencies">artifact-dependencies</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/pull/9096">#9096</a></li>
<li>원본 풀 리퀘스트: <a href="https://github.com/rust-lang/cargo/pull/9992">#9992</a></li>
</ul>
<p>아티팩트(Artifact) 의존성은 Cargo 패키지가 <code>bin</code>, <code>cdylib</code>, <code>staticlib</code> 크레이트에 의존하고, 해당 크레이트에 의해 빌드된 결과물을 컴파일 타임에 사용할 수 있게 합니다.</p>
<p>이 기능을 활성화하려면 <code>-Z bindeps</code> 와 함께 <code>cargo</code> 를 실행하세요.</p>
<h3 id="artifact-dependencies-의존성-선언"><a class="header" href="#artifact-dependencies-의존성-선언">artifact-dependencies: 의존성 선언</a></h3>
<p>아티팩트 의존성은 <code>Cargo.toml</code> 의 의존성 선언에 다음 키들을 추가합니다:</p>
<ul>
<li>
<p><code>artifact</code> — 빌드할 <a href="reference/cargo-targets.html">Cargo 타겟</a> 을 지정합니다. 보통 이 필드가 없으면 Cargo는 의존성에서 <code>[lib]</code> 타겟만 빌드합니다. 이 필드를 사용하면 어떤 타겟을 빌드할지 지정할 수 있으며, 빌드 시점에 바이너리로 사용할 수 있게 됩니다.</p>
<ul>
<li><code>"bin"</code> — 컴파일된 실행 바이너리들로, 의존성 매니페스트의 모든 <code>[[bin]]</code> 섹션에 해당합니다.</li>
<li><code>"bin:&lt;bin-name&gt;"</code> — 컴파일된 실행 바이너리로, 주어진 <code>&lt;bin-name&gt;</code> 으로 지정된 특정 바이너리 타겟에 해당합니다.</li>
<li><code>"cdylib"</code> — C 호환 동적 라이브러리로, 의존성 매니페스트에서 <code>crate-type = ["cdylib"]</code> 인 <code>[lib]</code> 섹션에 해당합니다.</li>
<li><code>"staticlib"</code> — C 호환 정적 라이브러리로, 의존성 매니페스트에서 <code>crate-type = ["staticlib"]</code> 인 <code>[lib]</code> 섹션에 해당합니다.
<code>artifact</code> 값은 문자열일 수 있으며, 여러 타겟을 지정하기 위해 문자열 배열일 수도 있습니다.</li>
</ul>
<p>예시:</p>
<pre><code class="language-toml">[dependencies]
bar = { version = "1.0", artifact = "staticlib" }
zoo = { version = "1.0", artifact = ["bin:cat", "bin:dog"]}
</code></pre>
</li>
<li>
<p><code>lib</code> — 의존성의 라이브러리를 일반적인 Rust <code>lib</code> 의존성으로도 빌드할지 여부를 나타내는 불리언(Boolean) 값입니다. 이 필드는 <code>artifact</code> 가 지정된 경우에만 지정할 수 있습니다.</p>
<p><code>artifact</code> 가 지정된 경우 이 필드의 기본값은 <code>false</code> 입니다. 이 값을 <code>true</code> 로 설정하면, 의존성을 선언한 패키지가 빌드되는 플랫폼 타겟에 대해 의존성의 <code>[lib]</code> 타겟도 함께 빌드됩니다. 이를 통해 패키지는 아티팩트 의존성뿐만 아니라 일반 의존성처럼 Rust 코드에서 해당 의존성을 사용할 수 있게 됩니다.</p>
<p>예시:</p>
<pre><code class="language-toml">[dependencies]
bar = { version = "1.0", artifact = "bin", lib = true }
</code></pre>
</li>
<li>
<p><code>target</code> — 의존성을 빌드할 플랫폼 타겟입니다. 이 필드는 <code>artifact</code> 가 지정된 경우에만 지정할 수 있습니다.</p>
<p>이 필드를 지정하지 않았을 때의 기본값은 의존성 종류에 따라 다릅니다. 빌드 의존성(build dependencies)의 경우, 호스트 타겟을 위해 빌드됩니다. 그 외 모든 의존성의 경우, 의존성을 선언한 패키지가 빌드되는 타겟과 동일한 타겟을 위해 빌드됩니다.</p>
<p>빌드 의존성의 경우, <code>"target"</code> 이라는 특별한 값을 가질 수도 있는데, 이는 패키지가 빌드되는 것과 동일한 타겟으로 의존성을 빌드하라는 의미입니다.</p>
<pre><code class="language-toml">[build-dependencies]
bar = { version = "1.0", artifact = "cdylib", target = "wasm32-unknown-unknown"}
same-target = { version = "1.0", artifact = "bin", target = "target" }
</code></pre>
</li>
</ul>
<h3 id="artifact-dependencies-환경-변수"><a class="header" href="#artifact-dependencies-환경-변수">artifact-dependencies: 환경 변수</a></h3>
<p>아티팩트 의존성을 빌드한 후, Cargo는 해당 아티팩트에 접근하는 데 사용할 수 있는 다음과 같은 환경 변수를 제공합니다:</p>
<ul>
<li>
<p><code>CARGO_&lt;ARTIFACT-TYPE&gt;_DIR_&lt;DEP&gt;</code> — 의존성에서 생성된 모든 아티팩트를 포함하는 디렉토리입니다.</p>
<p><code>&lt;ARTIFACT-TYPE&gt;</code> 은 의존성에 지정된 <code>artifact</code>(<code>CDYLIB</code>, <code>STATICLIB</code>, <code>BIN</code> 과 같이 대문자화됨)이며, <code>&lt;DEP&gt;</code> 은 의존성의 이름입니다. 다른 Cargo 환경 변수와 마찬가지로, 의존성 이름은 대문자로 변환되고 대시는 밑줄로 대체됩니다.</p>
<p>매니페스트에서 의존성 이름을 변경한 경우, <code>&lt;DEP&gt;</code> 는 원래 패키지 이름이 아니라 사용자가 지정한 이름에 해당합니다.</p>
</li>
<li>
<p><code>CARGO_&lt;ARTIFACT-TYPE&gt;_FILE_&lt;DEP&gt;_&lt;NAME&gt;</code> — 아티팩트의 전체 경로입니다.</p>
<p><code>&lt;ARTIFACT-TYPE&gt;</code> 은 위와 같이 대문자로 변환된 의존성의 <code>artifact</code> 이며, <code>&lt;DEP&gt;</code> 는 위와 같이 변환된 의존성 이름, 그리고 <code>&lt;NAME&gt;</code> 은 의존성에서 제공하는 아티팩트의 이름입니다.</p>
<p><code>&lt;NAME&gt;</code> 은 아티팩트를 제공하는 크레이트에 지정된 <code>name</code>(지정되지 않은 경우 크레이트 이름)에서 어떠한 방식으로도 변경되지 않는다는 점에 유의하세요. 예를 들어, 소문자이거나 대시를 포함할 수 있습니다.</p>
<p>편의를 위해, 아티팩트 이름이 원래 패키지 이름과 일치하는 경우 Cargo는 <code>_&lt;NAME&gt;</code> 접미사가 생략된 변수의 복사본을 추가로 제공합니다. 예를 들어, <code>cmake</code> 크레이트가 <code>cmake</code> 라는 이름의 바이너리를 제공하면 Cargo는 <code>CARGO_BIN_FILE_CMAKE</code> 와 <code>CARGO_BIN_FILE_CMAKE_cmake</code> 를 모두 제공합니다.</p>
</li>
</ul>
<p>각 의존성 종류별로, 이러한 변수들은 해당 의존성에 접근할 수 있는 빌드 프로세스의 동일한 부분에 제공됩니다:</p>
<ul>
<li>빌드 의존성(build-dependencies)의 경우, 이러한 변수들은 <code>build.rs</code> 스크립트에 제공되며, <a href="https://doc.rust-lang.org/std/env/fn.var_os.html"><code>std::env::var_os</code></a> 를 사용하여 접근할 수 있습니다. (모든 OS 파일 경로와 마찬가지로, 이들은 유효한 UTF-8일 수도 있고 아닐 수도 있습니다.)</li>
<li>일반 의존성(normal dependencies)의 경우, 이러한 변수들은 크레이트 컴파일 중에 제공되며, <a href="https://doc.rust-lang.org/std/macro.env.html"><code>env!</code></a> 매크로를 사용하여 접근할 수 있습니다.</li>
<li>개발 의존성(dev-dependencies)의 경우, 이러한 변수들은 예제, 테스트, 벤치마크 컴파일 중에 제공되며, <a href="https://doc.rust-lang.org/std/macro.env.html"><code>env!</code></a> 매크로를 사용하여 접근할 수 있습니다.</li>
</ul>
<h3 id="artifact-dependencies-예제"><a class="header" href="#artifact-dependencies-예제">artifact-dependencies: 예제</a></h3>
<h4 id="예제-빌드-스크립트에서-바이너리-실행-파일-사용"><a class="header" href="#예제-빌드-스크립트에서-바이너리-실행-파일-사용">예제: 빌드 스크립트에서 바이너리 실행 파일 사용</a></h4>
<p><code>Cargo.toml</code> 파일에서 빌드 스크립트가 사용할 수 있도록 바이너리 의존성을 지정할 수 있습니다:</p>
<pre><code class="language-toml">[build-dependencies]
some-build-tool = { version = "1.0", artifact = "bin" }
</code></pre>
<p>그 다음 빌드 스크립트 내부에서, 해당 바이너리를 빌드 시점에 실행할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let build_tool = std::env::var_os("CARGO_BIN_FILE_SOME_BUILD_TOOL").unwrap();
    let status = std::process::Command::new(build_tool)
        .arg("do-stuff")
        .status()
        .unwrap();
    if !status.success() {
        eprintln!("failed!");
        std::process::exit(1);
    }
}</code></pre></pre>
<h4 id="예제-빌드-스크립트에서-cdylib-아티팩트-사용"><a class="header" href="#예제-빌드-스크립트에서-cdylib-아티팩트-사용">예제: 빌드 스크립트에서 <em>cdylib</em> 아티팩트 사용</a></h4>
<p>아티팩트를 사용하는 패키지의 <code>Cargo.toml</code> 에서, 특정 빌드 타겟을 위해 <code>bar</code> 라이브러리를 <code>cdylib</code> 로 빌드합니다…</p>
<pre><code class="language-toml">[build-dependencies]
bar = { artifact = "cdylib", version = "1.0", target = "wasm32-unknown-unknown" }
</code></pre>
<p>…그리고 <code>build.rs</code> 에 있는 빌드 스크립트입니다.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    wasm::run_file(std::env::var("CARGO_CDYLIB_FILE_BAR").unwrap());
}</code></pre></pre>
<h4 id="예제-바이너리에서-바이너리-아티팩트-및-해당-라이브러리-사용"><a class="header" href="#예제-바이너리에서-바이너리-아티팩트-및-해당-라이브러리-사용">예제: 바이너리에서 <em>바이너리</em> 아티팩트 및 해당 라이브러리 사용</a></h4>
<p>아티팩트를 사용하는 패키지의 <code>Cargo.toml</code> 에서, <code>bar</code> 바이너리를 아티팩트로 포함하기 위해 빌드하면서 라이브러리로도 사용할 수 있게 합니다…</p>
<pre><code class="language-toml">[dependencies]
bar = { artifact = "bin", version = "1.0", lib = true }
</code></pre>
<p>…그리고 <code>main.rs</code> 를 사용하는 실행 파일입니다.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    bar::init();
    command::run(env!("CARGO_BIN_FILE_BAR"));
}</code></pre></pre>
<h2 id="publish-timeout"><a class="header" href="#publish-timeout">publish-timeout</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/11222">11222</a></li>
</ul>
<p>설정 파일의 <code>publish.timeout</code> 키는 <code>cargo publish</code> 가 패키지를 레지스트리에 게시한 후 로컬 인덱스에서 사용 가능해질 때까지 대기하는 시간을 제어하는 데 사용할 수 있습니다.</p>
<p><code>0</code> 의 타임아웃은 어떠한 검사도 발생하지 않도록 합니다. 현재 기본값은 <code>60</code> 초입니다.</p>
<p>이 기능은 <code>-Zpublish-timeout</code> 명령줄 옵션이 설정되어 있어야 합니다.</p>
<pre><code class="language-toml"># config.toml
[publish]
timeout = 300  # in seconds
</code></pre>
<h2 id="asymmetric-token"><a class="header" href="#asymmetric-token">asymmetric-token</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/10519">10519</a></li>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/3231">#3231</a></li>
</ul>
<p>The <code>-Z asymmetric-token</code> flag enables the <code>cargo:paseto</code> credential provider which allows Cargo to authenticate to registries without sending secrets over the network.</p>
<p><a href="reference/config.html"><code>config.toml</code></a> 및 <code>credentials.toml</code> 파일에는 <code>private-key</code> 라는 필드가 있으며, 이는 <a href="https://github.com/paseto-standard/paserk/blob/master/types/secret.md"><code>PASERK</code> 의 비밀 하위 집합</a> 형식의 비공개 키로, 비대칭 토큰에 서명하는 데 사용됩니다.</p>
<p>키 쌍은 <code>cargo login --generate-keypair</code> 를 사용하여 생성할 수 있으며, 이는 다음 작업을 수행합니다:</p>
<ul>
<li>현재 권장되는 방식으로 공개/비공개 키 쌍을 생성합니다.</li>
<li>비공개 키를 <code>credentials.toml</code> 에 저장합니다.</li>
<li>공개 키를 <a href="https://github.com/paseto-standard/paserk/blob/master/types/public.md">PASERK public</a> 형식으로 출력합니다.</li>
</ul>
<p><code>private-key</code> 는 <code>credentials.toml</code> 에 저장하는 것을 권장합니다. <code>config.toml</code> 에서도 지원되는데, 이는 주로 관련 환경 변수를 사용하여 설정할 수 있도록 하기 위함이며, 이는 CI 환경에서 키를 제공하는 권장되는 방식입니다. 이 설정 방식은 비밀 토큰을 설정하기 위한 <code>token</code> 필드에 적용되는 방식과 동일합니다.</p>
<p><code>private-key-subject</code> 라는 선택적 필드도 있으며, 이는 레지스트리가 선택하는 문자열입니다. 이 문자열은 비대칭 토큰의 일부로 포함되며 비밀이 아니어야 합니다. 이는 “중앙 CA 서버가 이 작업을 승인했다는 암호화 증명“과 같은 드문 사용 사례를 위한 것입니다. Cargo는 이를 공백이 없는 인쇄 가능한 ASCII로 요구합니다. 비 ASCII 데이터가 필요한 레지스트리는 base64 인코딩을 해야 합니다.</p>
<p>두 필드 모두 <code>cargo login --registry=name --private-key --private-key-subject="subject"</code> 를 사용하여 설정할 수 있으며, 이 경우 키 값을 입력하라는 메시지가 표시됩니다.</p>
<p>레지스트리에는 <code>private-key</code> 또는 <code>token</code> 중 하나만 설정할 수 있습니다.</p>
<p>모든 PASETO에는 ISO 8601 형식의 현재 시간인 <code>iat</code> 가 포함됩니다. Cargo는 적절한 경우 다음을 포함합니다:</p>
<ul>
<li><code>sub</code> 레지스트리가 선택하는 선택적인 비밀이 아닌 문자열로, 모든 요청에서 클레임으로 포함될 것으로 예상됩니다. 이 값은 <code>config.toml</code> 파일의 <code>private-key-subject</code> 가 됩니다.</li>
<li><code>mutation</code> 이 있는 경우, 이 요청이 변경 작업임을 나타내며(없으면 읽기 전용 작업), <code>publish</code>, <code>yank</code>, <code>unyank</code> 중 하나의 문자열이어야 합니다.
<ul>
<li><code>name</code> 이 요청과 관련된 크레이트의 이름입니다.</li>
<li><code>vers</code> 이 요청과 관련된 크레이트의 버전 문자열입니다.</li>
<li><code>cksum</code> 64자리의 소문자 16진수 문자열로 표현된 크레이트 내용의 SHA256 해시입니다. <code>mutation</code> 이 <code>publish</code> 인 경우에만 존재해야 합니다.</li>
</ul>
</li>
<li><code>challenge</code> 이번 세션에서 이 서버의 401/403 응답으로부터 받은 챌린지 문자열입니다. 챌린지를 발행하는 레지스트리는 어떤 챌린지가 발행/사용되었는지 추적해야 하며, 동일한 유효 기간 내에 주어진 챌린지를 두 번 이상 수락해서는 안 됩니다(지금껏 발행된 모든 챌린지를 추적할 필요는 없습니다).</li>
</ul>
<p>“푸터(footer)”(서명의 일부임)는 UTF-8 형식의 JSON 문자열이며 다음을 포함합니다:</p>
<ul>
<li><code>url</code> Cargo가 config.json 파일을 가져온 RFC 3986 준수 URL입니다.
<ul>
<li>HTTP 인덱스를 사용하는 레지스트리인 경우, 이는 모든 인덱스 쿼리의 기준이 되는 베이스 URL입니다.</li>
<li>GIT 인덱스를 사용하는 레지스트리인 경우, Cargo가 인덱스를 클론하는 데 사용한 URL입니다.</li>
</ul>
</li>
<li><code>kid</code> <a href="https://github.com/paseto-standard/paserk/blob/master/operations/ID.md">PASERK IDs</a> 표준을 사용하여 요청 서명에 사용된 비공개 키의 식별자입니다.</li>
</ul>
<p>PASETO에는 서명된 메시지가 포함되어 있으므로 서버는 서명을 확인하기 위해 요청에서 정확한 문자열을 재구성할 필요가 없습니다. 서버는 PASETO의 문자열에 대해 서명이 유효한지, 그리고 그 문자열의 내용이 요청과 일치하는지 확인해야 합니다. 요청에 대해 클레임이 예상되지만 PASETO에 누락된 경우 해당 요청은 거부되어야 합니다.</p>
<h2 id="cargo-config"><a class="header" href="#cargo-config"><code>cargo config</code></a></h2>
<ul>
<li>원본 이슈: <a href="https://github.com/rust-lang/cargo/issues/2362">#2362</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/9301">#9301</a></li>
</ul>
<p><code>cargo config</code> 하위 명령어는 Cargo가 로드하는 설정 파일들을 표시하는 방법을 제공합니다. 현재는 표시할 선택적 설정값을 인수로 받을 수 있는 <code>get</code> 하위 명령어를 포함하고 있습니다.</p>
<pre><code class="language-console">cargo +nightly -Zunstable-options config get build.rustflags
</code></pre>
<p>설정값이 포함되지 않으면 모든 설정값을 표시합니다. 사용 가능한 더 많은 옵션은 <code>--help</code> 출력을 참조하세요.</p>
<h2 id="rustc---print"><a class="header" href="#rustc---print">rustc <code>--print</code></a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/9357">#9357</a></li>
</ul>
<p><code>cargo rustc --print=VAL</code> 은 <code>rustc</code> 로부터 정보를 추출하기 위해 <code>--print</code> 플래그를 <code>rustc</code> 에 전달합니다. 이는 해당 <a href="https://doc.rust-lang.org/rustc/command-line-arguments.html#--print-print-compiler-information"><code>--print</code></a> 플래그와 함께 <code>rustc</code> 를 실행한 후 컴파일 없이 즉시 종료됩니다. 이를 Cargo 플래그로 노출함으로써 Cargo가 현재 설정을 기반으로 올바른 타겟과 RUSTFLAGS를 주입할 수 있게 합니다.</p>
<p>주요 사용 사례는 <code>cargo rustc --print=cfg</code> 를 실행하여 적절한 타겟에 대한 설정값을 얻고, 다른 RUSTFLAGS의 영향을 받는 정보를 확인하는 것입니다.</p>
<h2 id="다른-바이너리-이름"><a class="header" href="#다른-바이너리-이름">다른 바이너리 이름</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/9778">#9778</a></li>
<li>PR: <a href="https://github.com/rust-lang/cargo/pull/9627">#9627</a></li>
</ul>
<p><code>different-binary-name</code> 기능은 크레이트 이름에 적용되는 제한을 따르지 않고 바이너리의 파일 이름을 설정할 수 있게 해줍니다. 예를 들어, 크레이트 이름은 <code>영숫자 </code> 문자나 <code>-</code> 또는 <code>_</code> 만 사용해야 하며 비어 있을 수 없습니다.</p>
<p><code>filename</code> 매개변수는 바이너리 확장자를 포함해서는 <strong>안 됩니다</strong>. <code>cargo</code> 가 적절한 확장자를 파악하여 바이너리에 직접 사용합니다.</p>
<p><code>filename</code> 매개변수는 매니페스트의 <code>[[bin]]</code> 섹션에서만 사용할 수 있습니다.</p>
<pre><code class="language-toml">cargo-features = ["different-binary-name"]

[package]
name =  "foo"
version = "0.0.1"

[[bin]]
name = "foo"
filename = "007bar"
path = "src/main.rs"
</code></pre>
<h2 id="scrape-examples"><a class="header" href="#scrape-examples">scrape-examples</a></h2>
<ul>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/pull/3123">#3123</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/9910">#9910</a></li>
</ul>
<p><code>-Z rustdoc-scrape-examples</code> 플래그는 Rustdoc에게 현재 워크스페이스의 크레이트에서 함수 호출을 검색하도록 지시합니다. 이러한 호출 위치(call-sites)는 문서에 포함됩니다. 다음과 같이 플래그를 사용할 수 있습니다:</p>
<pre><code>cargo doc -Z unstable-options -Z rustdoc-scrape-examples
</code></pre>
<p>기본적으로 Cargo는 문서화되는 패키지의 예제 타겟에서 예제를 수집합니다. 다음과 같이 <code>doc-scrape-examples</code> 플래그를 사용하여 개별 타겟의 수집 여부를 활성화하거나 비활성화할 수 있습니다:</p>
<pre><code class="language-toml"># 라이브러리에서 예제 수집 활성화
[lib]
doc-scrape-examples = true

# 예제 타겟에서 예제 수집 비활성화
[[example]]
name = "my-example"
doc-scrape-examples = false
</code></pre>
<p><strong>테스트 관련 참고:</strong> 테스트 타겟에서 <code>doc-scrape-examples</code> 를 활성화하는 것은 현재 아무런 효과가 없습니다. 테스트에서 예제를 수집하는 기능은 현재 개발 중입니다.</p>
<p><strong>개발 의존성 관련 참고:</strong> 라이브러리를 문서화할 때는 일반적으로 크레이트의 개발 의존성이 필요하지 않습니다. 그러나 예제 타겟은 개발 의존성을 필요로 합니다. 하위 호환성을 위해 <code>-Z rustdoc-scrape-examples</code> 는 <code>cargo doc</code> 에 개발 의존성 요구 사항을 도입하지 <em>않습니다</em>. 따라서 다음 조건에서는 예제 타겟에서 예제가 수집되지 <em>않습니다</em>:</p>
<ol>
<li>문서화 중인 타겟 중 어느 것도 개발 의존성을 필요로 하지 않으며, 그리고</li>
<li>문서화 중인 타겟을 가진 크레이트 중 적어도 하나가 개발 의존성을 가지고 있으며, 그리고</li>
<li>모든 <code>[[example]]</code> 타겟에 대해 <code>doc-scrape-examples</code> 매개변수가 설정되지 않았거나 false인 경우.</li>
</ol>
<p>예제 타겟에서 예제가 수집되기를 원한다면, 위 조건 중 하나를 충족하지 않아야 합니다. 예를 들어, 하나의 예제 타겟에 대해 <code>doc-scrape-examples</code> 를 true로 설정할 수 있으며, 이는 <code>cargo doc</code> 을 위해 개발 의존성이 빌드되는 것을 허용한다는 신호를 Cargo에 보냅니다.</p>
<h2 id="rustdoc용-출력-형식output-format"><a class="header" href="#rustdoc용-출력-형식output-format">rustdoc용 출력 형식(output-format)</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/13283">#13283</a></li>
</ul>
<p>이 플래그는 <code>cargo rustdoc</code> 의 출력 형식을 결정합니다. <code>html</code> 또는 <code>json</code> 을 허용하며, 도구들이 <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustdoc_json_types/">rustdoc의 실험적인 JSON 형식</a> 을 활용할 수 있는 방법을 제공합니다.</p>
<p>다음과 같이 플래그를 사용할 수 있습니다:</p>
<pre><code>cargo rustdoc -Z unstable-options --output-format json
</code></pre>
<h2 id="코드-생성-백엔드codegen-backend"><a class="header" href="#코드-생성-백엔드codegen-backend">코드 생성 백엔드(codegen-backend)</a></h2>
<p><code>codegen-backend</code> 기능을 사용하면 프로파일을 통해 rustc에서 사용하는 코드 생성 백엔드를 선택할 수 있습니다.</p>
<p>예시:</p>
<pre><code class="language-toml">[package]
name = "foo"

[dependencies]
serde = "1.0.117"

[profile.dev.package.foo]
codegen-backend = "cranelift"
</code></pre>
<p>Cargo 설정의 프로파일에서 이를 설정하려면, <code>-Z codegen-backend</code> 또는 <code>[unstable]</code> 테이블을 사용하여 활성화해야 합니다. 예를 들어,</p>
<pre><code class="language-toml"># .cargo/config.toml
[unstable]
codegen-backend = true

[profile.dev.package.foo]
codegen-backend = "cranelift"
</code></pre>
<h2 id="gitoxide"><a class="header" href="#gitoxide">gitoxide</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/11813">#11813</a></li>
</ul>
<p>‘gitoxide’ 불안정 기능을 사용하면, 모든 또는 지정된 Git 작업이 <code>git2</code> 대신 <code>gitoxide</code> 크레이트에 의해 수행됩니다.</p>
<p><code>-Zgitoxide</code> 는 현재 구현된 모든 기능을 활성화하지만, <code>-Zgitoxide=operation[,operationN]</code> 구문을 사용하여 <code>gitoxide</code> 로 실행할 개별 Git 작업을 선택할 수 있습니다.</p>
<p>유효한 작업은 다음과 같습니다:</p>
<ul>
<li><code>fetch</code> - 모든 페치(fetch) 작업이 <code>gitoxide</code> 로 수행되며, 여기에는 git 의존성뿐만 아니라 크레이트 인덱스도 포함됩니다.</li>
<li><code>checkout</code> <em>(계획됨)</em> - 필터 및 서브모듈 지원을 포함하여 작업 트리를 체크아웃합니다.</li>
</ul>
<h2 id="git"><a class="header" href="#git">git</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/13285">#13285</a></li>
</ul>
<p>‘git’ 불안정 기능을 사용하면, <code>gitoxide</code> 와 <code>git2</code> 모두 크레이트 인덱스와 git 의존성의 얕은 페치(shallow fetch)를 수행합니다.</p>
<p><code>-Zgit</code> 이 현재 구현된 모든 기능을 활성화하는 반면, <code>-Zgit=operation[,operationN]</code> 문법을 사용하여 언제 얕은 페치(shallow fetch)를 수행할지 개별적으로 선택할 수 있습니다.</p>
<p>유효한 작업은 다음과 같습니다:</p>
<ul>
<li><code>shallow-index</code> - 인덱스의 얕은 클론(shallow clone)을 수행합니다.</li>
<li><code>shallow-deps</code> - git 의존성의 얕은 클론(shallow clone)을 수행합니다.</li>
</ul>
<p><strong>얕은 클론(shallow clones)에 대한 세부 사항</strong></p>
<ul>
<li>얕은 클론을 활성화하려면, git 의존성을 가져오는 경우 <code>-Zgit=shallow-deps</code> 를 추가하고 레지스트리 인덱스를 가져오는 경우 <code>-Zgit=shallow-index</code> 를 추가하세요.</li>
<li>얕은 클론(shallow-cloned) 및 얕은 체크아웃(shallow-checked-out)된 git 저장소는 <code>-shallow</code> 접미사가 붙은 자체 디렉토리에 위치합니다. 즉,
<ul>
<li><code>~/.cargo/registry/index/*-shallow</code></li>
<li><code>~/.cargo/git/db/*-shallow</code></li>
<li><code>~/.cargo/git/checkouts/*-shallow</code></li>
</ul>
</li>
<li>불안정한 기능이 켜져 있으면 git 저장소를 가져오거나 클론할 때 항상 얕은 페치(shallow fetch)를 수행합니다. 이는 모든 곳에서 <code>git fetch --depth 1</code> 을 수행하는 것과 거의 같습니다.</li>
<li><code>Cargo.lock</code> 이 있거나 <code>{ rev = "…" }</code> 로 커밋을 지정하더라도, gitoxide와 libgit2는 기존 저장소의 얕은 페치 상태를 해제(unshallowing)하지 않고 얕은 페치를 수행할 만큼 똑똑합니다.</li>
</ul>
<h2 id="script"><a class="header" href="#script">script</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/12207">#12207</a></li>
</ul>
<p>Cargo는 다음과 같이 <code>.rs</code> 파일을 직접 실행할 수 있습니다:</p>
<pre><code class="language-console">$ cargo +nightly -Zscript file.rs
</code></pre>
<p>여기서 <code>file.rs</code> 는 다음과 같이 간단할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {}</code></pre></pre>
<p>사용자는 선택적으로 다음과 같이 모듈 레벨 주석의 <code>cargo</code> 코드 펜스 안에 매니페스트를 지정할 수 있습니다:</p>
<pre><pre class="playground"><code class="language-rust">#!/usr/bin/env -S cargo +nightly -Zscript
---cargo
[dependencies]
clap = { version = "4.2", features = ["derive"] }
---

use clap::Parser;

#[derive(Parser, Debug)]
#[clap(version)]
struct Args {
    #[clap(short, long, help = "Path to config")]
    config: Option&lt;std::path::PathBuf&gt;,
}

fn main() {
    let args = Args::parse();
    println!("{:?}", args);
}</code></pre></pre>
<h3 id="단일-파일-패키지"><a class="header" href="#단일-파일-패키지">단일 파일 패키지</a></h3>
<p>기존의 다중 파일 패키지(다른 <code>.rs</code> 파일들과 함께 있는 <code>Cargo.toml</code> 파일) 외에, 임베디드 매니페스트를 포함할 수 있는 단일 파일 패키지 개념을 추가합니다. 단일 파일 <code>.rs</code> 패키지를 다른 <code>.rs</code> 파일과 구별하기 위한 필수적인 표시법은 없습니다.</p>
<p>단일 파일 패키지는 <code>cargo test --manifest-path foo.rs</code> 와 같이 <code>--manifest-path</code> 를 통해 선택할 수 있습니다. <code>Cargo.toml</code> 과 달리, 이러한 파일은 자동으로 감지되지 않습니다.</p>
<p>단일 파일 패키지는 임베디드 매니페스트를 포함할 수 있습니다. 임베디드 매니페스트는 파일 상단의 정보 문자열(infostring) 시작 부분에 <code>cargo</code> 가 있는 마크다운 코드 펜스인 Rust “프론트매터(frontmatter)” 내에 <code>TOML</code> 을 사용하여 저장됩니다.</p>
<p>추론 / 기본값으로 설정된 매니페스트 필드:</p>
<ul>
<li><code>package.name = &lt;슬러그화된 파일 이름 줄기&gt;</code></li>
<li>Rust 업그레이드 시 스크립트가 중단될 수 있는 위험을 감수하고, 항상 임베디드 매니페스트를 추가해야 하는 번거로움을 피하기 위해 <code>package.edition = &lt;현재 버전&gt;</code> 을 사용합니다.
<ul>
<li>이 사항을 알리기 위해 <code>edition</code> 이 지정되지 않은 경우 경고를 표시합니다.</li>
</ul>
</li>
</ul>
<p>허용되지 않는 매니페스트 필드:</p>
<ul>
<li><code>[workspace]</code>, <code>[lib]</code>, <code>[[bin]]</code>, <code>[[example]]</code>, <code>[[test]]</code>, <code>[[bench]]</code></li>
<li><code>package.workspace</code>, <code>package.build</code>, <code>package.links</code>, <code>package.autolib</code>, <code>package.autobins</code>, <code>package.autoexamples</code>, <code>package.autotests</code>, <code>package.autobenches</code></li>
</ul>
<p>단일 파일 패키지의 기본 <code>CARGO_TARGET_DIR</code> 은 <code>$CARGO_HOME/target/&lt;hash&gt;</code> 에 위치합니다:</p>
<ul>
<li>동일한 디렉토리에 여러 단일 파일 패키지가 있을 때 발생하는 충돌 방지</li>
<li>단일 파일 패키지의 상위 디렉토리가 읽기 전용일 때 발생하는 문제 방지</li>
<li>사용자 디렉토리가 복잡해지는 것 방지</li>
</ul>
<p>단일 파일 패키지의 잠금 파일(lockfile)은 <code>CARGO_TARGET_DIR</code> 에 위치하게 됩니다. 향후 워크스페이스가 지원되면 사용자가 영구적인 잠금 파일을 가질 수 있게 될 것입니다.</p>
<h3 id="매니페스트-명령어manifest-commands"><a class="header" href="#매니페스트-명령어manifest-commands">매니페스트 명령어(Manifest-commands)</a></h3>
<p>하위 명령어 없이 <code>foo/Cargo.toml</code> 이나 <code>foo.rs</code> 와 같은 단일 파일 패키지처럼 매니페스트를 <code>cargo</code> 명령에 직접 전달할 수 있습니다. 이는 주로 <code>#!</code> 라인에 넣기 위한 용도입니다.</p>
<p><code>cargo &lt;subcommand&gt;</code> 를 해석하는 우선순위는 다음과 같습니다:</p>
<ol>
<li>내장(Built-in) XOR 단일 파일 패키지</li>
<li>별칭(Aliases)</li>
<li>외부 하위 명령어</li>
</ol>
<p>매개변수가 다음 중 하나를 포함하면 매니페스트 명령어로 식별됩니다:</p>
<ul>
<li>경로 구분자</li>
<li><code>.rs</code> 확장자</li>
<li>파일 이름이 <code>Cargo.toml</code> 인 경우</li>
</ul>
<p><code>cargo run --manifest-path &lt;path&gt;</code> 와 <code>cargo &lt;path&gt;</code> 의 차이점</p>
<ul>
<li><code>cargo &lt;path&gt;</code> 는 현재 디렉토리가 아닌 <code>&lt;path&gt;</code> 에 대한 설정으로 실행됩니다. <code>cargo install --path &lt;path&gt;</code> 와 더 비슷합니다.</li>
<li><code>cargo &lt;path&gt;</code> 는 일반적인 기본값보다 낮은 상세 수준으로 실행됩니다. 정상적인 출력을 얻으려면 <code>-v</code> 를 전달하세요.</li>
</ul>
<p>When running a package with an embedded manifest, <a href="https://doc.rust-lang.org/std/os/unix/process/trait.CommandExt.html#tymethod.arg0"><code>arg0</code></a> will be the scripts path. To get the executable’s path, see <a href="https://doc.rust-lang.org/std/env/fn.current_exe.html"><code>current_exe</code></a>.</p>
<h3 id="문서-업데이트"><a class="header" href="#문서-업데이트">문서 업데이트</a></h3>
<h2 id="프로파일-trim-paths-옵션"><a class="header" href="#프로파일-trim-paths-옵션">프로파일 <code>trim-paths</code> 옵션</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/12137">rust-lang/cargo#12137</a></li>
<li>rustc 추적 이슈: <a href="https://github.com/rust-lang/rust/issues/111540">rust-lang/rust#111540</a></li>
</ul>
<p>이는 생성된 바이너리에서 경로가 정제(sanitize)되는 방식을 제어하는 새로운 프로파일 설정을 추가합니다. 다음과 같이 활성화할 수 있습니다:</p>
<pre><code class="language-toml">cargo-features = ["trim-paths"]

[package]
# ...

[profile.release]
trim-paths = ["diagnostics", "object"]
</code></pre>
<p>Cargo 설정의 프로파일에서 이를 설정하려면, <code>-Z trim-paths</code> 또는 <code>[unstable]</code> 테이블을 사용하여 활성화해야 합니다. 예를 들어,</p>
<pre><code class="language-toml"># .cargo/config.toml
[unstable]
trim-paths = true

[profile.release]
trim-paths = ["diagnostics", "object"]
</code></pre>
<h3 id="문서-업데이트-1"><a class="header" href="#문서-업데이트-1">문서 업데이트</a></h3>
<h4 id="trim-paths"><a class="header" href="#trim-paths">trim-paths</a></h4>
<p><em>새로운 <a href="reference/./profiles.html#profile-settings">“프로파일 설정” 항목</a> 으로</em></p>
<p><code>trim-paths</code> 는 빌드 출력에서 파일 경로의 정제(sanitization)를 활성화하고 제어하는 프로파일 설정입니다. 다음과 같은 값들을 가질 수 있습니다:</p>
<ul>
<li><code>"none"</code> 및 <code>false</code> — 경로 정제를 비활성화합니다.</li>
<li><code>"macro"</code> — <code>std::file!()</code> 매크로 확장 시 경로를 정제합니다. 이곳이 임베디드 패닉 메시지의 경로가 나오는 곳입니다.</li>
<li><code>"diagnostics"</code> — 출력된 컴파일러 진단 정보의 경로를 정제합니다.</li>
<li><code>"object"</code> — 컴파일된 실행 파일 또는 라이브러리의 경로를 정제합니다.</li>
<li><code>"all"</code> 및 <code>true</code> — 가능한 모든 위치의 경로를 정제합니다.</li>
</ul>
<p><code>"macro"</code>, <code>"diagnostics"</code>, <code>"object"</code> 의 조합으로 이루어진 배열을 받을 수도 있습니다.</p>
<p><code>dev</code> 프로파일의 경우 기본값은 <code>none</code> 이며, <code>release</code> 프로파일의 경우 <code>object</code> 입니다. <code>Cargo.toml</code> 에 이 옵션을 지정하여 수동으로 재정의할 수 있습니다:</p>
<pre><code class="language-toml">[profile.dev]
trim-paths = "all"

[profile.release]
trim-paths = ["object", "diagnostics"]
</code></pre>
<p>기본 <code>release</code> 프로파일 설정(<code>object</code>)은 생성된 실행 파일이나 라이브러리 파일의 경로만 정제합니다. 패닉 메시지와 같은 매크로의 경로에는 항상 영향을 미치며, 디버그 정보의 경우 바이너리에 함께 임베드되는 경우(Linux 및 windows-gnu와 같은 ELF 바이너리가 있는 플랫폼의 기본값)에만 영향을 미치고 별도의 파일에 있는 경우(Windows MSVC 및 macOS의 기본값)에는 건드리지 않습니다. 그러나 이러한 별도 파일의 경로는 정제됩니다.</p>
<p><code>trim-paths</code> 가 <code>none</code> 또는 <code>false</code> 가 아니면, 선택된 범위에 나타나는 다음 경로들이 정제됩니다:</p>
<ol>
<li>표준 및 코어 라이브러리(sysroot)의 소스 파일 경로는 <code>/rustc/[rustc commit hash]</code> 로 시작하게 됩니다. 예: <code>/home/username/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs</code> -&gt; <code>/rustc/fe72845f7bb6a77b9e671e6a4f32fe714962cec4/library/core/src/result.rs</code></li>
<li>현재 패키지의 경로는 현재 워크스페이스 루트를 기준으로 제거됩니다. 예: <code>/home/username/crate/src/lib.rs</code> -&gt; <code>src/lib.rs</code>.</li>
<li>의존성 패키지의 경로는 <code>[패키지 이름]-[버전]</code> 으로 대체됩니다. 예: <code>/home/username/deps/foo/src/lib.rs</code> -&gt; <code>foo-0.1.0/src/lib.rs</code></li>
</ol>
<p>표준 및 코어 라이브러리 소스 파일의 경로가 정제 범위에 포함되지 않은 경우, 출력되는 경로는 <code>rust-src</code> 컴포넌트의 존재 여부에 따라 달라집니다. 컴포넌트가 있으면 일부 경로는 파일 시스템의 소스 파일 복사본을 가리키고, 없으면 (정제 대상으로 선택되었을 때와 마찬가지로) <code>/rustc/[rustc commit hash]/library/...</code>로 표시됩니다. 다른 모든 소스 파일의 경로는 영향을 받지 않습니다.</p>
<p>이는 문자열과 같이 소스 코드에 하드코딩된 경로에는 영향을 주지 않습니다.</p>
<h4 id="환경-변수-2"><a class="header" href="#환경-변수-2">환경 변수</a></h4>
<p><em><a href="reference/./environment-variables.html#environment-variables-cargo-sets-for-crates">“Cargo가 빌드 스크립트를 위해 설정하는 환경 변수”</a> 의 새 항목으로</em></p>
<ul>
<li><code>CARGO_TRIM_PATHS</code> — <code>trim-paths</code> 프로파일 옵션의 값입니다. <code>false</code>, <code>"none"</code>, 빈 배열은 <code>none</code> 으로 변환됩니다. <code>true</code> 와 <code>"all"</code> 은 <code>all</code> 이 됩니다. 비어 있지 않은 배열의 값들은 쉼표로 구분된 목록으로 결합됩니다. 빌드 스크립트가 (컴파일러 호출 등을 통해) 빌드 결과물에 절대 경로를 도입하는 경우, 사용자는 다양한 유형의 결과물에서 이를 정제하도록 요청할 수 있습니다. 정제가 필요한 일반적인 경로로는 <code>OUT_DIR</code>, <code>CARGO_MANIFEST_DIR</code>, <code>CARGO_MANIFEST_PATH</code> 등이 있으며, 헤더 디렉토리와 같이 빌드 스크립트에 의해 도입된 다른 경로들도 포함됩니다.</li>
</ul>
<h2 id="gc"><a class="header" href="#gc">gc</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/12633">#12633</a></li>
</ul>
<p>The <code>-Zgc</code> flag is used to enable certain features related to garbage-collection of cargo’s global cache within the cargo home directory.</p>
<h4 id="자동-gc-설정"><a class="header" href="#자동-gc-설정">자동 GC 설정</a></h4>
<p>The <code>-Zgc</code> flag will enable Cargo to read extra configuration options related to garbage collection. The settings available are:</p>
<pre><code class="language-toml"># Example config.toml file.

# Sub-table for defining specific settings for cleaning the global cache.
[cache.global-clean]
# Anything older than this duration will be deleted in the source cache.
max-src-age = "1 month"
# Anything older than this duration will be deleted in the compressed crate cache.
max-crate-age = "3 months"
# Any index older than this duration will be deleted from the index cache.
max-index-age = "3 months"
# Any git checkout older than this duration will be deleted from the checkout cache.
max-git-co-age = "1 month"
# Any git clone older than this duration will be deleted from the git cache.
max-git-db-age = "3 months"
</code></pre>
<p>Note that the <a href="reference/config.html#cacheauto-clean-frequency"><code>cache.auto-clean-frequency</code></a> option was stabilized in Rust 1.88.</p>
<h3 id="cargo-clean-을-사용한-수동-가비지-컬렉션"><a class="header" href="#cargo-clean-을-사용한-수동-가비지-컬렉션"><code>cargo clean</code> 을 사용한 수동 가비지 컬렉션</a></h3>
<p>Manual deletion can be done with the <code>cargo clean gc -Zgc</code> command. Deletion of cache contents can be performed by passing one of the cache options:</p>
<ul>
<li><code>--max-src-age=DURATION</code> — 지정된 기간 동안 사용되지 않은 소스 캐시 파일을 삭제합니다.</li>
<li><code>--max-crate-age=DURATION</code> — 지정된 기간 동안 사용되지 않은 크레이트 캐시 파일을 삭제합니다.</li>
<li><code>--max-index-age=DURATION</code> — 지정된 기간 동안 사용되지 않은 레지스트리 인덱스(해당 <code>.crate</code> 및 <code>src</code> 파일 포함)를 삭제합니다.</li>
<li><code>--max-git-co-age=DURATION</code> — 지정된 기간 동안 사용되지 않은 Git 의존성 체크아웃을 삭제합니다.</li>
<li><code>--max-git-db-age=DURATION</code> — 지정된 기간 동안 사용되지 않은 Git 의존성 복제본을 삭제합니다.</li>
<li><code>--max-download-age=DURATION</code> — 지정된 기간 동안 사용되지 않은 모든 다운로드 캐시 데이터를 삭제합니다.</li>
<li><code>--max-src-size=SIZE</code> — 캐시가 지정된 크기 이하가 될 때까지 가장 오래된 소스 캐시 파일을 삭제합니다.</li>
<li><code>--max-crate-size=SIZE</code> — 캐시가 지정된 크기 이하가 될 때까지 가장 오래된 크레이트 캐시 파일을 삭제합니다.</li>
<li><code>--max-git-size=SIZE</code> — 캐시가 지정된 크기 이하가 될 때까지 가장 오래된 Git 의존성 캐시를 삭제합니다.</li>
<li><code>--max-download-size=SIZE</code> — 캐시가 지정된 크기 이하가 될 때까지 가장 오래된 다운로드 캐시 데이터를 삭제합니다.</li>
</ul>
<p>DURATION은 “N seconds/minutes/days/weeks/months” 형식으로 지정하며, N은 정수입니다.</p>
<p>SIZE는 “N <em>suffix</em>” 형식으로 지정하며, <em>suffix</em> 는 B, kB, MB, GB, kiB, MiB, GiB 중 하나이고 N은 정수 또는 부동 소수점 숫자입니다. 접미사가 지정되지 않으면 바이트 단위 숫자로 간주됩니다.</p>
<pre><code class="language-sh">cargo clean gc -Zgc
cargo clean gc -Zgc --max-download-age=1week
cargo clean gc -Zgc --max-git-size=0 --max-download-size=100MB
</code></pre>
<h2 id="open-namespaces"><a class="header" href="#open-namespaces">open-namespaces</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/13576">#13576</a></li>
</ul>
<p>여러 패키지가 동일한 API 네임스페이스에 참여할 수 있게 합니다.</p>
<p>다음과 같이 활성화할 수 있습니다:</p>
<pre><code class="language-toml">cargo-features = ["open-namespaces"]

[package]
# ...
</code></pre>
<h2 id="panic-immediate-abort"><a class="header" href="#panic-immediate-abort">panic-immediate-abort</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/16042">#16042</a></li>
<li>Upstream Tracking Issue: <a href="https://github.com/rust-lang/rust/issues/147286">rust-lang/rust#147286</a></li>
</ul>
<p>Extends the <code>panic</code> profile setting to support the <a href="reference/../../rustc/codegen-options/index.html#panic"><code>immediate-abort</code></a> panic strategy. This can be enabled like so:</p>
<pre><code class="language-toml"># Cargo.toml
cargo-features = ["panic-immediate-abort"]

[package]
# ...

[profile.release]
panic = "immediate-abort"
</code></pre>
<p>To set this in a profile in Cargo configuration, you need to use either <code>-Z panic-immediate-abort</code> CLI flag or the <code>[unstable]</code> table to enable it. For example,</p>
<pre><code class="language-toml"># .cargo/config.toml
[unstable]
panic-immediate-abort = true

[profile.release]
panic = "immediate-abort"
</code></pre>
<h2 id="fine-grain-locking"><a class="header" href="#fine-grain-locking">fine-grain-locking</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/4282">#4282</a></li>
</ul>
<p>Use fine grain locking instead of locking the entire build cache.</p>
<p>Note: Fine grain locking implicitly enables <a href="reference/unstable.html#build-dir-new-layout">build-dir-new-layout</a> as fine grain locking builds on that directory reoganization.</p>
<h2 id="lintscargo"><a class="header" href="#lintscargo"><code>[lints.cargo]</code></a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/12235">#12235</a></li>
</ul>
<p><code>-Zcargo-lints</code> 가 사용될 때 Cargo 자체에서 내보내는 린트를 설정하는 데 사용할 수 있는 Cargo용 새로운 <code>lints</code> 도구 테이블입니다.</p>
<pre><code class="language-toml">[lints.cargo]
implicit-features = "warn"
</code></pre>
<p>이는 <a href="https://rust-lang.github.io/rfcs/2906-cargo-workspace-deduplicate.html">RFC 2906 <code>workspace-deduplicate</code></a>와 함께 작동합니다:</p>
<pre><code class="language-toml">[workspace.lints.cargo]
implicit-features = "warn"

[lints]
workspace = true
</code></pre>
<h2 id="경로-베이스-path-bases"><a class="header" href="#경로-베이스-path-bases">경로 베이스 (Path Bases)</a></h2>
<ul>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/14355">#14355</a></li>
</ul>
<p><code>path</code> 의존성은 <a href="reference/config.html">설정</a> 이나 <a href="reference/unstable.html#built-in-path-bases">내장 경로 베이스</a> 중 하나에 있는 <code>[path-bases]</code> 테이블의 경로 베이스 이름을 <code>base</code> 키로 설정하여 베이스를 지정할 수 있습니다. 해당 경로 베이스의 값은 <code>path</code> 값 앞에 추가되어(필요한 경우 경로 구분자와 함께), Cargo가 의존성을 찾을 실제 위치를 생성합니다.</p>
<p>예를 들어, <code>Cargo.toml</code> 에 다음이 포함되어 있다면:</p>
<pre><code class="language-toml">cargo-features = ["path-bases"]

[dependencies]
foo = { base = "dev", path = "foo" }
</code></pre>
<p>설정에 다음과 같은 <code>[path-bases]</code> 테이블이 있다고 가정해 봅시다:</p>
<pre><code class="language-toml">[path-bases]
dev = "/home/user/dev/rust/libraries/"
</code></pre>
<p>이것은 <code>/home/user/dev/rust/libraries/foo</code> 에 위치한 <code>path</code> 의존성 <code>foo</code> 를 생성합니다.</p>
<p>경로 베이스는 절대 경로이거나 상대 경로일 수 있습니다. 상대 경로 베이스는 해당 경로 베이스를 선언한 설정 파일의 부모 디렉토리를 기준으로 합니다.</p>
<p>경로 베이스의 이름은 <a href="https://doc.rust-lang.org/std/primitive.char.html#method.is_alphanumeric">영문자 및 숫자</a> 또는 <code>-</code>, <code>_</code> 만 사용해야 하며, <a href="https://doc.rust-lang.org/std/primitive.char.html#method.is_alphabetic">영문자</a> 로 시작해야 하고 비어 있어서는 안 됩니다.</p>
<p>의존성에서 사용된 경로 베이스의 이름이 설정에도 없고 내장 경로 베이스 중 하나도 아닌 경우, Cargo는 오류를 발생시킵니다.</p>
<h4 id="내장-경로-베이스"><a class="header" href="#내장-경로-베이스">내장 경로 베이스</a></h4>
<p>Cargo는 <code>[path-bases]</code> 테이블에 지정할 필요 없이 사용할 수 있는 암시적 경로 베이스를 제공합니다.</p>
<ul>
<li><code>workspace</code> - 프로젝트가 <a href="reference/workspaces.html">워크스페이스 또는 워크스페이스 구성원</a> 인 경우, 이 경로 베이스는 워크스페이스의 루트 <code>Cargo.toml</code> 이 있는 부모 디렉토리로 정의됩니다.</li>
</ul>
<p>내장 경로 베이스 이름이 설정에서도 선언된 경우, Cargo는 설정에 있는 값을 우선적으로 사용합니다. 이를 통해 Cargo는 기존 사용이 내장 이름을 가릴 수 있으므로 호환성 문제 없이 새로운 내장 경로 베이스를 추가할 수 있습니다.</p>
<h2 id="lockfile-path"><a class="header" href="#lockfile-path">lockfile-path</a></h2>
<ul>
<li>원래 이슈: <a href="https://github.com/rust-lang/cargo/issues/5707">#5707</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/14421">#14421</a></li>
</ul>
<p>The <code>-Zlockfile-path</code> flag enables the <code>resolver.lockfile-path</code> configuration option, which allows you to specify the path of the lockfile <code>Cargo.lock</code>.</p>
<p>By default, lockfile is written into <code>&lt;workspace_root&gt;/Cargo.lock</code>. However, when sources are stored in read-only directory, most of the cargo commands would fail when trying to write a lockfile. This configuration makes it easier to work with readonly sources.</p>
<p>Note, that currently path must end with <code>Cargo.lock</code>. If you want to use this feature in multiple projects, lockfiles should be stored in different directories.</p>
<h3 id="문서-업데이트-2"><a class="header" href="#문서-업데이트-2">문서 업데이트</a></h3>
<p><em>as a new <code>resolver.lockfile-path</code> entry in config.md</em></p>
<h4 id="resolverlockfile-path"><a class="header" href="#resolverlockfile-path"><code>resolver.lockfile-path</code></a></h4>
<ul>
<li>타입: 문자열 (경로)</li>
<li>Default: <code>&lt;workspace_root&gt;/Cargo.lock</code></li>
<li>Environment: <code>CARGO_RESOLVER_LOCKFILE_PATH</code></li>
</ul>
<p>Specifies the path to the lockfile. By default, the lockfile is written to <code>&lt;workspace_root&gt;/Cargo.lock</code>. This option is useful when working with read-only source directories.</p>
<p>The path must end with <code>Cargo.lock</code>.</p>
<h2 id="native-completions"><a class="header" href="#native-completions">native-completions</a></h2>
<ul>
<li>원래 이슈: <a href="https://github.com/rust-lang/cargo/issues/6645">#6645</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/14520">#14520</a></li>
</ul>
<p>이 기능은 수동으로 작성된 자동 완성 스크립트를 Rust 네이티브로 옮겨, 새로운 자동 완성을 추가, 확장 및 테스트하기 쉽게 만듭니다. 이 기능은 나이틀리 채널에서 추가적인 <code>-Z</code> 옵션 없이 활성화됩니다.</p>
<p>피드백을 기다리는 주요 영역</p>
<ul>
<li>탈출 문자(escaping)나 따옴표 처리가 올바르지 않은 인수들</li>
<li>정보의 부정확성</li>
<li>명령줄 파싱 버그</li>
<li>자동 완성이 제안되지 않는 인수들</li>
<li>알려진 이슈로 인해 문제가 발생하는 경우</li>
</ul>
<p>피드백은 다음과 같이 분류될 수 있습니다:</p>
<ul>
<li>보고되는 자동 완성 후보들
<ul>
<li>알려진 이슈: <a href="https://github.com/rust-lang/cargo/issues/14520">#14520</a>, <a href="https://github.com/rust-lang/cargo/labels/A-completions"><code>A-completions</code></a></li>
<li><a href="https://github.com/rust-lang/cargo/issues/new">이슈 보고</a> 또는 <a href="https://github.com/rust-lang/cargo/issues/14520">동작 논의</a></li>
</ul>
</li>
<li>셸 통합, 명령줄 파싱, 자동 완성 필터링
<ul>
<li>알려진 이슈: <a href="https://github.com/clap-rs/clap/issues/3166">clap#3166</a>, <a href="https://github.com/clap-rs/clap/labels/A-completion">clap’s <code>A-completions</code></a></li>
<li><a href="https://github.com/clap-rs/clap/issues/new/choose">이슈 보고</a> 또는 <a href="https://github.com/clap-rs/clap/discussions/new/choose">동작 논의</a></li>
</ul>
</li>
</ul>
<p>확실하지 않은 경우 <a href="https://github.com/rust-lang/cargo/issues/14520">#14520</a> 이나 <a href="https://rust-lang.zulipchat.com/#narrow/stream/246057-t-cargo">zulip</a> 에서 논의할 수 있습니다.</p>
<h3 id="native-completions-기능-사용-방법"><a class="header" href="#native-completions-기능-사용-방법">native-completions 기능 사용 방법:</a></h3>
<ul>
<li>
<p>bash: Add <code>source &lt;(CARGO_COMPLETE=bash cargo +nightly)</code> to <code>~/.local/share/bash-completion/completions/cargo</code>.</p>
</li>
<li>
<p>zsh: Add <code>source &lt;(CARGO_COMPLETE=zsh cargo +nightly)</code> to your <code>.zshrc</code>.</p>
</li>
<li>
<p>fish: <code>$XDG_CONFIG_HOME/fish/completions/cargo.fish</code> 에 <code>source (CARGO_COMPLETE=fish cargo +nightly | psub)</code>를 추가하세요.</p>
</li>
<li>
<p>elvish: <code>$XDG_CONFIG_HOME/elvish/rc.elv</code> 에 <code>eval (E:CARGO_COMPLETE=elvish cargo +nightly | slurp)</code>를 추가하세요.</p>
</li>
<li>
<p>powershell: <code>$PROFILE</code> 에 <code>CARGO_COMPLETE=powershell cargo +nightly | Invoke-Expression</code>을 추가하세요.</p>
</li>
</ul>
<h2 id="warnings"><a class="header" href="#warnings">warnings</a></h2>
<ul>
<li>원래 이슈: <a href="https://github.com/rust-lang/cargo/issues/8424">#8424</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/14802">#14802</a></li>
</ul>
<p><code>-Z warnings</code> 기능은 Cargo가 경고를 처리하는 방식을 제어하는 <code>build.warnings</code> 설정 옵션을 활성화합니다. <code>-Z warnings</code> 불안정 플래그가 활성화되지 않으면 <code>build.warnings</code> 설정은 무시됩니다.</p>
<p>이 설정은 현재 rustc 경고에만 적용됩니다. 향후 추가적인 경고(Cargo 린트나 Cargo 경고 등)에 대해서도 적용될 수 있습니다.</p>
<h3 id="buildwarnings"><a class="header" href="#buildwarnings"><code>build.warnings</code></a></h3>
<ul>
<li>타입: 문자열</li>
<li>기본값: <code>warn</code></li>
<li>환경 변수: <code>CARGO_BUILD_WARNINGS</code></li>
</ul>
<p>Cargo가 경고를 처리하는 방식을 제어합니다. 허용되는 값은 다음과 같습니다:</p>
<ul>
<li><code>warn</code>: 경고가 경고로 출력됩니다 (기본값).</li>
<li><code>allow</code>: 경고가 숨겨집니다.</li>
<li><code>deny</code>: 경고가 발생하면 작업이 끝날 때 오류가 발생하며 프로세스가 실패 종료 코드로 종료됩니다.</li>
</ul>
<h2 id="기능-통합-feature-unification"><a class="header" href="#기능-통합-feature-unification">기능 통합 (feature unification)</a></h2>
<ul>
<li>RFC: <a href="https://github.com/rust-lang/rfcs/blob/master/text/3692-feature-unification.md">#3692</a></li>
<li>추적 이슈: <a href="https://github.com/rust-lang/cargo/issues/14774">#14774</a></li>
</ul>
<p><code>-Z feature-unification</code> 은 워크스페이스 전반에서 기능이 통합되는 방식을 제어하는 <code>resolver.feature-unification</code> 설정 옵션을 활성화합니다. <code>-Z feature-unification</code> 불안정 플래그가 활성화되지 않으면 <code>resolver.feature-unification</code> 설정은 무시됩니다.</p>
<h3 id="resolverfeature-unification"><a class="header" href="#resolverfeature-unification"><code>resolver.feature-unification</code></a></h3>
<ul>
<li>타입: 문자열</li>
<li>기본값: <code>"selected"</code></li>
<li>환경 변수: <code>CARGO_RESOLVER_FEATURE_UNIFICATION</code></li>
</ul>
<p>어떤 패키지가 <a href="reference/../reference/features.html#feature-unification">기능 통합</a> 에 참여할지 지정합니다.</p>
<ul>
<li><code>selected</code>: 현재 빌드를 위해 지정된 모든 패키지의 의존성 기능을 병합합니다.</li>
<li><code>workspace</code>: 현재 빌드를 위해 지정된 패키지에 관계없이, 모든 워크스페이스 구성원의 의존성 기능을 병합합니다.</li>
<li><code>package</code>: Dependency features are considered on a package-by-package basis, preferring duplicate builds of dependencies when different sets of features are activated by the packages.</li>
</ul>
<h2 id="lockfile-publish-time"><a class="header" href="#lockfile-publish-time">lockfile-publish-time</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/5221">#5221</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/16271">#16271</a></li>
</ul>
<p>With <code>cargo generate-lockfile -Zunstable-options --publish-time &lt;time&gt;</code>, package resolution will not consider any package newer than the specified time.</p>
<h2 id="package-message-format"><a class="header" href="#package-message-format">Package message format</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/11666">#11666</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15353">#15353</a></li>
</ul>
<p>The <code>--message-format</code> flag in <code>cargo package</code> controls the output message format. Currently, it only works with the <code>--list</code> flag and affects the file listing format, Requires <code>-Zunstable-options</code>. See <a href="reference/../commands/cargo-package.html#option-cargo-package---message-format"><code>cargo package --message-format</code></a> for more information.</p>
<h2 id="rustdoc-depinfo"><a class="header" href="#rustdoc-depinfo">rustdoc depinfo</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/cargo/issues/12266">#12266</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15370">#15370</a></li>
</ul>
<p>The <code>-Z rustdoc-depinfo</code> flag leverages rustdoc’s dep-info files to determine whether documentations are required to re-generate. This can be combined with <code>-Z checksum-freshness</code> to detect checksum changes rather than file mtime.</p>
<h2 id="no-embed-metadata"><a class="header" href="#no-embed-metadata">no-embed-metadata</a></h2>
<ul>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/15378">#15378</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15495">#15495</a></li>
</ul>
<p>The default behavior of Rust is to embed crate metadata into <code>rlib</code> and <code>dylib</code> artifacts. Since Cargo also passes <code>--emit=metadata</code> to these intermediate artifacts to enable pipelined compilation, this means that a lot of metadata ends up being duplicated on disk, which wastes disk space in the target directory.</p>
<p>This feature tells Cargo to pass the <code>-Zembed-metadata=no</code> flag to the compiler, which instructs it not to embed metadata within rlib and dylib artifacts. In this case, the metadata will only be stored in <code>.rmeta</code> files.</p>
<pre><code class="language-console">cargo +nightly -Zno-embed-metadata build
</code></pre>
<h2 id="unstable-editions"><a class="header" href="#unstable-editions"><code>unstable-editions</code></a></h2>
<p>The <code>unstable-editions</code> value in the <code>cargo-features</code> list allows a <code>Cargo.toml</code> manifest to specify an edition that is not yet stable.</p>
<pre><code class="language-toml">cargo-features = ["unstable-editions"]

[package]
name = "my-package"
edition = "future"
</code></pre>
<p>When new editions are introduced, the <code>unstable-editions</code> feature is required until the edition is stabilized.</p>
<p>The special “future” edition is a home for new features that are under development, and is permanently unstable. The “future” edition also has no new behavior by itself. Each change in the future edition requires an opt-in such as a <code>#![feature(...)]</code> attribute.</p>
<h2 id="fix-edition"><a class="header" href="#fix-edition"><code>fix-edition</code></a></h2>
<p><code>-Zfix-edition</code> is a permanently unstable flag to assist with testing edition migrations, particularly with the use of crater. It only works with the <code>cargo fix</code> subcommand. It takes two different forms:</p>
<ul>
<li><code>-Zfix-edition=start=$INITIAL</code> — This form checks if the current edition is equal to the given number. If not, it exits with success (because we want to ignore older editions). If it is, then it runs the equivalent of <code>cargo check</code>. This is intended to be used with crater’s “start” toolchain to set a baseline for the “before” toolchain.</li>
<li><code>-Zfix-edition=end=$INITIAL,$NEXT</code> — This form checks if the current edition is equal to the given <code>$INITIAL</code> value. If not, it exits with success. If it is, then it performs an edition migration to the edition specified in <code>$NEXT</code>. Afterwards, it will modify <code>Cargo.toml</code> to add the appropriate <code>cargo-features = ["unstable-edition"]</code>, update the <code>edition</code> field, and run the equivalent of <code>cargo check</code> to verify that the migration works on the new edition.</li>
</ul>
<p>예를 들어 다음과 같습니다.</p>
<pre><code class="language-console">cargo +nightly fix -Zfix-edition=end=2024,future
</code></pre>
<h2 id="section-timings"><a class="header" href="#section-timings">section-timings</a></h2>
<ul>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/15780">#15780</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15817">#15817</a></li>
</ul>
<p>This feature can be used to extend the output of <code>cargo build --timings</code>. It will tell rustc to produce timings of individual compilation sections, which will be then displayed in the timings HTML/JSON output.</p>
<pre><code class="language-console">cargo +nightly -Zsection-timings build --timings
</code></pre>
<h2 id="build-analysis"><a class="header" href="#build-analysis">Build analysis</a></h2>
<ul>
<li>Original Issue: <a href="https://github.com/rust-lang/rust-project-goals/pull/332">rust-lang/rust-project-goals#332</a></li>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15844">#15844</a></li>
</ul>
<p>The <code>-Zbuild-analysis</code> feature records and persists detailed build metrics on disk, with new commands to query past builds.</p>
<p>When enabled, Cargo writes build logs in JSONL format to the <code>$CARGO_HOME/log/</code> directory Each cargo invocation produces a log file named with a unique session ID. These logs contain timing information, rebuild reasons, and other build metadata that can be analyzed with the <code>cargo report</code> subcommands.</p>
<p>To enable build analysis, add the following <a href="reference/config.html">Cargo configuration</a>:</p>
<pre><code class="language-toml"># Example config.toml file.

[unstable]
build-analysis = true

# Enable the build metric collection
[build.analysis]
enabled = true
</code></pre>
<p>Setting it on a stable toolchain only emits an unknown config warning, so it’s safe to keep enabled in your Cargo configuration.</p>
<h3 id="cargo-report-commands"><a class="header" href="#cargo-report-commands"><code>cargo report</code> commands</a></h3>
<p>The following commands are available under <code>-Zbuild-analysis</code>:</p>
<ul>
<li><code>cargo report sessions</code> — Lists previous build sessions. Use this to find session IDs for other report commands.</li>
<li><code>cargo report timings</code> — Generates an HTML timing report from a previous session, similar to <code>cargo build --timings</code> but without rebuilding.</li>
<li><code>cargo report rebuilds</code> — Reports why crates were rebuilt, helping diagnose unexpected recompilations.</li>
</ul>
<h2 id="build-dir-new-layout"><a class="header" href="#build-dir-new-layout">build-dir-new-layout</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/cargo/issues/15010">#15010</a></li>
</ul>
<p>Enables the new build-dir filesystem layout. This layout change unblocks work towards caching and locking improvements.</p>
<h2 id="compile-time-deps"><a class="header" href="#compile-time-deps">compile-time-deps</a></h2>
<p>This permanently-unstable flag to only build proc-macros and build scripts (and their required dependencies), as well as run the build scripts.</p>
<p>It is intended for use by tools like rust-analyzer and will never be stabilized.</p>
<p>예시:</p>
<pre><code class="language-console">cargo +nightly build --compile-time-deps -Z unstable-options
cargo +nightly check --compile-time-deps --all-targets -Z unstable-options
</code></pre>
<h2 id="rustc-unicode"><a class="header" href="#rustc-unicode"><code>rustc-unicode</code></a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/rust/issues/148607">rust#148607</a></li>
</ul>
<p>Enable <code>rustc</code>’s unicode error format in Cargo’s error messages</p>
<h2 id="rustdoc-mergeable-info"><a class="header" href="#rustdoc-mergeable-info">rustdoc mergeable info</a></h2>
<ul>
<li>Original Pull Request: <a href="https://github.com/rust-lang/cargo/pull/16309">#16309</a></li>
<li>Tracking issue: <a href="https://github.com/rust-lang/cargo/issues/16306">#16306</a></li>
<li>Tracking rustc issue: <a href="https://github.com/rust-lang/rust/issues/130676">rust-lang/rust#130676</a></li>
</ul>
<p>The <code>-Z rustdoc-mergeable-info</code> leverage rustdoc’s mergeable crate info, so that <code>cargo doc</code> can merge cross-crate information (like the search index, source files index, etc.) from separate output directories, and run <code>rustdoc</code> in parallel.</p>
<h2 id="target-spec-json"><a class="header" href="#target-spec-json">target-spec-json</a></h2>
<ul>
<li>Tracking Issue: <a href="https://github.com/rust-lang/rust/issues/151528">rust-lang/rust#151528</a></li>
</ul>
<p>The <code>-Z target-spec-json</code> CLI flag enables the ability to use <a href="https://doc.rust-lang.org/nightly/rustc/targets/custom.html">custom target spec JSON files</a> as a target.</p>
<pre><code class="language-console">cargo +nightly build --target my-target.json -Z target-spec-json
</code></pre>
<p>This usually must be combined with <a href="reference/unstable.html#build-std">build-std</a>.</p>
<h1 id="안정화-및-제거된-기능"><a class="header" href="#안정화-및-제거된-기능">안정화 및 제거된 기능</a></h1>
<h2 id="컴파일-진행-상황"><a class="header" href="#컴파일-진행-상황">컴파일 진행 상황</a></h2>
<p>compile-progress 기능은 1.30 릴리스에서 안정화되었습니다. 이제 진행률 표시줄(Progress bars)이 기본적으로 활성화됩니다. 이 기능을 제어하는 방법에 대한 자세한 내용은 <a href="reference/config.html#termprogresswhen"><code>term.progress</code></a> 를 참조하세요.</p>
<h2 id="에디션-edition"><a class="header" href="#에디션-edition">에디션 (Edition)</a></h2>
<p><code>Cargo.toml</code> 에서 <code>edition</code> 을 지정하는 기능은 1.31 릴리스에서 안정화되었습니다. 이 필드를 지정하는 방법에 대한 자세한 내용은 <a href="reference/manifest.html#the-edition-field">edition 필드</a>를 참조하세요.</p>
<h2 id="rename-dependency"><a class="header" href="#rename-dependency">rename-dependency</a></h2>
<p><code>Cargo.toml</code> 에서 이름을 바꾼 의존성을 지정하는 기능은 1.31 릴리스에서 안정화되었습니다. 의존성 이름 변경에 대한 자세한 내용은 <a href="reference/specifying-dependencies.html#renaming-dependencies-in-cargotoml">의존성 이름 바꾸기</a>를 참조하세요.</p>
<h2 id="대체-레지스트리"><a class="header" href="#대체-레지스트리">대체 레지스트리</a></h2>
<p>대체 레지스트리에 대한 지원은 1.34 릴리스에서 안정화되었습니다. 대체 레지스트리에 대한 자세한 내용은 <a href="reference/registries.html">레지스트리 장</a> 을 참조하세요.</p>
<h2 id="오프라인-모드"><a class="header" href="#오프라인-모드">오프라인 모드</a></h2>
<p>offline 기능은 1.36 릴리스에서 안정화되었습니다. 오프라인 모드 사용에 대한 자세한 내용은 <a href="reference/../commands/cargo.html#option-cargo---offline"><code>--offline</code> 플래그</a> 를 참조하세요.</p>
<h2 id="publish-lockfile"><a class="header" href="#publish-lockfile">publish-lockfile</a></h2>
<p><code>publish-lockfile</code> 기능은 1.37 릴리스에서 제거되었습니다. 패키지에 바이너리 타겟이 포함된 경우 패키지를 게시할 때 <code>Cargo.lock</code> 파일이 항상 포함됩니다. <code>cargo install</code> 에서 <code>Cargo.lock</code> 파일을 사용하려면 <code>--locked</code> 플래그가 필요합니다. 자세한 내용은 <a href="reference/../commands/cargo-package.html"><code>cargo package</code></a> 와 <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> 을 참조하세요.</p>
<h2 id="default-run"><a class="header" href="#default-run">default-run</a></h2>
<p><code>default-run</code> 기능은 1.37 릴리스에서 안정화되었습니다. 실행할 기본 타겟을 지정하는 방법에 대한 자세한 내용은 <a href="reference/manifest.html#the-default-run-field"><code>default-run</code> 필드</a>를 참조하세요.</p>
<h2 id="cache-messages"><a class="header" href="#cache-messages">cache-messages</a></h2>
<p>컴파일러 메시지 캐싱은 1.40 릴리스에서 안정화되었습니다. 컴파일러 경고는 이제 기본적으로 캐시되며, Cargo를 다시 실행할 때 자동으로 다시 표시됩니다.</p>
<h2 id="install-upgrade"><a class="header" href="#install-upgrade">install-upgrade</a></h2>
<p><code>install-upgrade</code> 기능은 1.41 릴리스에서 안정화되었습니다. 이제 <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a>은 패키지가 오래된 것으로 보이면 자동으로 업그레이드합니다. 자세한 내용은 <a href="reference/../commands/cargo-install.html"><code>cargo install</code></a> 문서를 참조하세요.</p>
<h2 id="프로파일-재정의-profile-overrides"><a class="header" href="#프로파일-재정의-profile-overrides">프로파일 재정의 (Profile Overrides)</a></h2>
<p>프로파일 재정의 기능은 1.41 릴리스에서 안정화되었습니다. 재정의 사용에 대한 자세한 내용은 <a href="reference/profiles.html#overrides">프로파일 재정의</a> 를 참조하세요.</p>
<h2 id="설정-프로파일-config-profiles"><a class="header" href="#설정-프로파일-config-profiles">설정 프로파일 (Config Profiles)</a></h2>
<p>Cargo 설정 파일 및 환경 변수에서 프로파일을 지정하는 기능은 1.43 릴리스에서 안정화되었습니다. 설정 파일에서 <a href="reference/profiles.html">프로파일</a> 을 지정하는 방법에 대한 자세한 내용은 <a href="reference/config.html#profile">설정 <code>[profile]</code> 테이블</a>을 참조하세요.</p>
<h2 id="crate-versions"><a class="header" href="#crate-versions">crate-versions</a></h2>
<p><code>-Z crate-versions</code> 플래그는 1.47 릴리스에서 안정화되었습니다. 이제 크레이트 버전이 <a href="reference/../commands/cargo-doc.html"><code>cargo doc</code></a> 문서 사이드바에 자동으로 포함됩니다.</p>
<h2 id="기능-2"><a class="header" href="#기능-2">기능</a></h2>
<p><code>-Z features</code> 플래그는 1.51 릴리스에서 안정화되었습니다. 새로운 기능 리졸버 사용에 대한 자세한 내용은 <a href="reference/features.html#feature-resolver-version-2">기능 리졸버 버전 2</a>를 참조하세요.</p>
<h2 id="package-features"><a class="header" href="#package-features">package-features</a></h2>
<p><code>-Z package-features</code> 플래그는 1.51 릴리스에서 안정화되었습니다. 기능 CLI 옵션 사용에 대한 자세한 내용은 <a href="reference/features.html#resolver-version-2-command-line-flags">리졸버 버전 2 명령줄 플래그</a>를 참조하세요.</p>
<h2 id="리졸버-resolver"><a class="header" href="#리졸버-resolver">리졸버 (Resolver)</a></h2>
<p><code>Cargo.toml</code> 의 <code>resolver</code> 기능은 1.51 릴리스에서 안정화되었습니다. 리졸버 지정에 대한 자세한 내용은 <a href="reference/resolver.html#resolver-versions">리졸버 버전</a> 을 참조하세요.</p>
<h2 id="extra-link-arg"><a class="header" href="#extra-link-arg">extra-link-arg</a></h2>
<p>빌드 스크립트에서 추가 링커 인수를 지정하는 <code>extra-link-arg</code> 기능은 1.56 릴리스에서 안정화되었습니다. 추가 링커 인수를 지정하는 방법에 대한 자세한 내용은 <a href="reference/build-scripts.html#outputs-of-the-build-script">빌드 스크립트 문서</a> 를 참조하세요.</p>
<h2 id="configurable-env"><a class="header" href="#configurable-env">configurable-env</a></h2>
<p>Cargo 설정에서 환경 변수를 지정하는 <code>configurable-env</code> 기능은 1.56 릴리스에서 안정화되었습니다. 환경 변수 설정에 대한 자세한 내용은 <a href="reference/config.html#env">설정 문서</a>를 참조하세요.</p>
<h2 id="rust-version"><a class="header" href="#rust-version">rust-version</a></h2>
<p><code>Cargo.toml</code> 의 <code>rust-version</code> 필드는 1.56 릴리스에서 안정화되었습니다. <code>rust-version</code> 필드 사용 및 <code>--ignore-rust-version</code> 옵션에 대한 자세한 내용은 <a href="reference/manifest.html#the-rust-version-field">rust-version 필드</a> 를 참조하세요.</p>
<h2 id="patch-in-config"><a class="header" href="#patch-in-config">patch-in-config</a></h2>
<p><code>-Z patch-in-config</code> 플래그와 그에 대응하는 Cargo 설정 파일의 <code>[patch]</code> 섹션 지원은 1.56 릴리스에서 안정화되었습니다. 자세한 내용은 <a href="reference/config.html#patch">patch 필드</a>를 참조하세요.</p>
<h2 id="2021-에디션"><a class="header" href="#2021-에디션">2021 에디션</a></h2>
<p>2021 에디션은 1.56 릴리스에서 안정화되었습니다. 에디션 설정에 대한 자세한 내용은 <a href="reference/manifest.html#the-edition-field"><code>edition</code> 필드</a> 를 참조하세요. 기존 프로젝트를 마이그레이션하는 방법에 대한 자세한 내용은 <a href="reference/../commands/cargo-fix.html"><code>cargo fix --edition</code></a> 및 <a href="reference/../../edition-guide/index.html">에디션 가이드</a> 를 참조하세요.</p>
<h2 id="사용자-정의-이름-프로파일"><a class="header" href="#사용자-정의-이름-프로파일">사용자 정의 이름 프로파일</a></h2>
<p>사용자 정의 이름 프로파일은 1.57 릴리스에서 안정화되었습니다. 자세한 내용은 <a href="reference/profiles.html#custom-profiles">프로파일 장</a> 을 참조하세요.</p>
<h2 id="프로파일-strip-옵션"><a class="header" href="#프로파일-strip-옵션">프로파일 strip 옵션</a></h2>
<p>프로파일 <code>strip</code> 옵션은 1.59 릴리스에서 안정화되었습니다. 자세한 내용은 <a href="reference/profiles.html#strip">프로파일 장</a> 을 참조하세요.</p>
<h2 id="미래-비호환성-보고서-1"><a class="header" href="#미래-비호환성-보고서-1">미래 비호환성 보고서</a></h2>
<p>미래 비호환성 보고서(future-incompat report) 생성 지원은 1.59 릴리스에서 안정화되었습니다. 자세한 내용은 <a href="reference/future-incompat-report.html">미래 비호환성 보고서 장</a>을 참조하세요.</p>
<h2 id="네임스페이스가-지정된-기능-namespaced-features"><a class="header" href="#네임스페이스가-지정된-기능-namespaced-features">네임스페이스가 지정된 기능 (Namespaced features)</a></h2>
<p>네임스페이스가 지정된 기능은 1.60 릴리스에서 안정화되었습니다. 자세한 내용은 <a href="reference/features.html#optional-dependencies">기능 장</a> 을 참조하세요.</p>
<h2 id="약한-의존성-기능-weak-dependency-features"><a class="header" href="#약한-의존성-기능-weak-dependency-features">약한 의존성 기능 (Weak dependency features)</a></h2>
<p>약한 의존성 기능은 1.60 릴리스에서 안정화되었습니다. 자세한 내용은 <a href="reference/features.html#dependency-features">기능 장</a> 을 참조하세요.</p>
<h2 id="timings"><a class="header" href="#timings">timings</a></h2>
<p>The <code>-Ztimings</code> option has been stabilized as <code>--timings</code> in the 1.60 release. The timings output format option (e.g., the <code>--timings=html</code> and the machine-readable <code>--timings=json</code> output) has been removed in 1.94.0-nightly.</p>
<h2 id="config-cli"><a class="header" href="#config-cli">config-cli</a></h2>
<p><code>--config</code> CLI 옵션은 1.63 릴리스에서 안정화되었습니다. 자세한 내용은 <a href="reference/config.html#command-line-overrides">설정 문서</a>를 참조하세요.</p>
<h2 id="multitarget"><a class="header" href="#multitarget">multitarget</a></h2>
<p><code>-Z multitarget</code> 옵션은 1.64 릴리스에서 안정화되었습니다. 기본 [타겟 플랫폼 트리플](../appendix/glossary.md#target “타겟” (용어집)) 설정에 대한 자세한 내용은 <a href="reference/config.html#buildtarget"><code>build.target</code></a> 을 참조하세요.</p>
<h2 id="crate-type"><a class="header" href="#crate-type">crate-type</a></h2>
<p><code>cargo rustc</code> 를 위한 <code>--crate-type</code> 플래그는 1.64 릴리스에서 안정화되었습니다. 자세한 내용은 <a href="reference/../commands/cargo-rustc.html"><code>cargo rustc</code> 문서</a> 를 참조하세요.</p>
<h2 id="워크스페이스-상속-workspace-inheritance"><a class="header" href="#워크스페이스-상속-workspace-inheritance">워크스페이스 상속 (Workspace Inheritance)</a></h2>
<p>워크스페이스 상속 기능은 1.64 릴리스에서 안정화되었습니다. 자세한 내용은 <a href="reference/workspaces.html#the-package-table">workspace.package</a>, <a href="reference/workspaces.html#the-dependencies-table">workspace.dependencies</a>, 그리고 <a href="reference/specifying-dependencies.html#inheriting-a-dependency-from-a-workspace">워크스페이스로부터 의존성 상속하기</a>를 참조하세요.</p>
<h2 id="terminal-width"><a class="header" href="#terminal-width">terminal-width</a></h2>
<p><code>-Z terminal-width</code> 옵션은 1.68 릴리스에서 안정화되었습니다. Cargo가 너비를 자동으로 감지할 수 있는 터미널에서 실행할 때 터미널 너비가 항상 컴파일러에 전달됩니다.</p>
<h2 id="sparse-registry"><a class="header" href="#sparse-registry">sparse-registry</a></h2>
<p>희소 레지스트리(Sparse registry) 지원은 1.68 릴리스에서 안정화되었습니다. 자세한 내용은 <a href="reference/registries.html#registry-protocols">레지스트리 프로토콜</a> 을 참조하세요.</p>
<h3 id="cargo-logout"><a class="header" href="#cargo-logout"><code>cargo logout</code></a></h3>
<p><a href="reference/../commands/cargo-logout.html"><code>cargo logout</code></a> 명령어는 1.70 릴리스에서 안정화되었습니다.</p>
<h2 id="doctest-in-workspace"><a class="header" href="#doctest-in-workspace"><code>doctest-in-workspace</code></a></h2>
<p><code>cargo test</code> 를 위한 <code>-Z doctest-in-workspace</code> 옵션은 1.72 릴리스에서 안정화되었으며 기본적으로 활성화되었습니다. 테스트 컴파일 및 실행을 위한 작업 디렉토리에 대한 자세한 내용은 <a href="reference/../commands/cargo-test.html#working-directory-of-tests"><code>cargo test</code> 문서</a>를 참조하세요.</p>
<h2 id="keep-going"><a class="header" href="#keep-going">keep-going</a></h2>
<p><code>--keep-going</code> 옵션은 1.74 릴리스에서 안정화되었습니다. 자세한 내용은 <code>cargo build</code>의 <a href="reference/../commands/cargo-build.html#option-cargo-build---keep-going"><code>--keep-going</code> 플래그</a>를 예시로 참조하세요.</p>
<h2 id="lints"><a class="header" href="#lints"><code>[lints]</code></a></h2>
<p><a href="reference/manifest.html#the-lints-section"><code>[lints]</code></a> (<code>-Zlints</code> 를 통해 활성화됨) 기능은 1.74 릴리스에서 안정화되었습니다.</p>
<h2 id="credential-process"><a class="header" href="#credential-process">credential-process</a></h2>
<p><code>-Z credential-process</code> 기능은 1.74 릴리스에서 안정화되었습니다.</p>
<p>자세한 내용은 <a href="reference/registry-authentication.html">레지스트리 인증</a> 문서를 참조하세요.</p>
<h2 id="registry-auth"><a class="header" href="#registry-auth">registry-auth</a></h2>
<p><code>-Z registry-auth</code> 기능은 1.74 릴리스에서 안정화되었으며, <code>credential-provider</code>가 설정되어 있어야 한다는 추가 요구 사항이 있습니다.</p>
<p>자세한 내용은 <a href="reference/registry-authentication.html">레지스트리 인증</a> 문서를 참조하세요.</p>
<h2 id="check-cfg"><a class="header" href="#check-cfg">check-cfg</a></h2>
<p><code>-Z check-cfg</code> 기능은 1.80 릴리스에서 기본 동작으로 설정됨에 따라 안정화되었습니다.</p>
<p>사용자 정의 cfg를 지정하는 방법에 대한 자세한 내용은 <a href="reference/build-scripts.html#rustc-check-cfg">빌드 스크립트 문서</a>를 참조하세요.</p>
<h2 id="2024-에디션"><a class="header" href="#2024-에디션">2024 에디션</a></h2>
<p>2024 에디션은 1.85 릴리스에서 안정화되었습니다. 에디션 설정에 대한 자세한 내용은 <a href="reference/manifest.html#the-edition-field"><code>edition</code> 필드</a> 를 참조하세요. 기존 프로젝트를 마이그레이션하는 방법에 대한 자세한 내용은 <a href="reference/../commands/cargo-fix.html"><code>cargo fix --edition</code></a> 및 <a href="reference/../../edition-guide/index.html">에디션 가이드</a> 를 참조하세요.</p>
<h2 id="자동-가비지-컬렉션"><a class="header" href="#자동-가비지-컬렉션">자동 가비지 컬렉션</a></h2>
<p>Support for automatically deleting old files was stabilized in Rust 1.88. More information can be found in the <a href="reference/config.html#cache">config chapter</a>.</p>
<h2 id="doctest-xcompile"><a class="header" href="#doctest-xcompile">doctest-xcompile</a></h2>
<p>Doctest cross-compiling is now unconditionally enabled starting in Rust 1.89. Running doctests with <code>cargo test</code> will now honor the <code>--target</code> flag.</p>
<h2 id="package-workspace"><a class="header" href="#package-workspace">package-workspace</a></h2>
<p>Multi-package publishing has been stabilized in Rust 1.90.0.</p>
<h2 id="build-dir"><a class="header" href="#build-dir">build-dir</a></h2>
<p>Support for <code>build.build-dir</code> was stabilized in the 1.91 release. See the <a href="reference/config.html#buildbuild-dir">config documentation</a> for information about changing the build-dir</p>
<h2 id="build-plan"><a class="header" href="#build-plan">Build-plan</a></h2>
<p>The <code>--build-plan</code> argument for the <code>build</code> command has been removed in 1.93.0-nightly. See <a href="https://github.com/rust-lang/cargo/issues/7614">https://github.com/rust-lang/cargo/issues/7614</a> for the reason for its removal.</p>
<h2 id="config-include"><a class="header" href="#config-include">config-include</a></h2>
<p>Support for including extra configuration files via the <code>include</code> config key has been stabilized in 1.93.0. See the <a href="reference/config.html#include"><code>include</code> config documentation</a> for more.</p>
<h2 id="pubtime"><a class="header" href="#pubtime">pubtime</a></h2>
<p>The <code>pubtime</code> index field  has been stabilized in Rust 1.94.0.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-명령어"><a class="header" href="#cargo-명령어">Cargo 명령어</a></h1>
<ul>
<li><a href="commands/general-commands.html">일반 명령어</a></li>
<li><a href="commands/build-commands.html">빌드 명령어</a></li>
<li><a href="commands/manifest-commands.html">매니페스트 명령어</a></li>
<li><a href="commands/package-commands.html">패키지 명령어</a></li>
<li><a href="commands/publishing-commands.html">게시 명령어</a></li>
<li><a href="commands/report-commands.html">Report Commands</a></li>
<li><a href="commands/deprecated-and-removed.html">사용 중단 및 제거됨</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="일반-명령어"><a class="header" href="#일반-명령어">일반 명령어</a></h1>
<ul>
<li><a href="commands/cargo.html">cargo</a></li>
<li><a href="commands/cargo-help.html">cargo help</a></li>
<li><a href="commands/cargo-version.html">cargo version</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo1"><a class="header" href="#cargo1">cargo(1)</a></h1>
<h2 id="이름"><a class="header" href="#이름">이름</a></h2>
<p>cargo — 러스트 패키지 관리자</p>
<h2 id="사용법"><a class="header" href="#사용법">사용법</a></h2>
<p><code>cargo</code> [<em>options</em>] <em>command</em> [<em>args</em>]<br />
<code>cargo</code> [<em>options</em>] <code>--version</code><br />
<code>cargo</code> [<em>options</em>] <code>--list</code><br />
<code>cargo</code> [<em>options</em>] <code>--help</code><br />
<code>cargo</code> [<em>options</em>] <code>--explain</code> <em>code</em></p>
<h2 id="설명"><a class="header" href="#설명">설명</a></h2>
<p>이 프로그램은 러스트 언어를 위한 패키지 관리자 및 빌드 도구이며, <a href="https://rust-lang.org">https://rust-lang.org</a>에서 사용할 수 있습니다.</p>
<p><em>command</em> may be one of:</p>
<ul>
<li>built-in commands, see below</li>
<li><a href="commands/../reference/config.html#alias">aliases</a></li>
<li><a href="commands/../reference/external-tools.html#custom-subcommands">external tools</a></li>
</ul>
<h2 id="명령어"><a class="header" href="#명령어">명령어</a></h2>
<h3 id="빌드-명령어"><a class="header" href="#빌드-명령어">빌드 명령어</a></h3>
<p><a href="commands/cargo-bench.html">cargo-bench(1)</a><br />
    패키지의 벤치마크를 실행합니다.</p>
<p><a href="commands/cargo-build.html">cargo-build(1)</a><br />
    패키지를 컴파일합니다.</p>
<p><a href="commands/cargo-check.html">cargo-check(1)</a><br />
    로컬 패키지와 모든 의존성의 오류를 확인합니다.</p>
<p><a href="commands/cargo-clean.html">cargo-clean(1)</a><br />
    Cargo가 이전에 생성한 결과물들을 제거합니다.</p>
<p><a href="commands/cargo-doc.html">cargo-doc(1)</a><br />
    패키지 문서를 빌드합니다.</p>
<p><a href="commands/cargo-fetch.html">cargo-fetch(1)</a><br />
    네트워크에서 패키지 의존성을 가져옵니다.</p>
<p><a href="commands/cargo-fix.html">cargo-fix(1)</a><br />
    rustc가 보고한 린트 경고를 자동으로 수정합니다.</p>
<p><a href="commands/cargo-run.html">cargo-run(1)</a><br />
    로컬 패키지의 바이너리나 예제를 실행합니다.</p>
<p><a href="commands/cargo-rustc.html">cargo-rustc(1)</a><br />
    패키지를 컴파일하고 컴파일러에 추가 옵션을 전달합니다.</p>
<p><a href="commands/cargo-rustdoc.html">cargo-rustdoc(1)</a><br />
    지정된 사용자 정의 플래그를 사용하여 패키지 문서를 빌드합니다.</p>
<p><a href="commands/cargo-test.html">cargo-test(1)</a><br />
    패키지의 단위 및 통합 테스트를 실행합니다.</p>
<h3 id="매니페스트-명령어"><a class="header" href="#매니페스트-명령어">매니페스트 명령어</a></h3>
<p><a href="commands/cargo-add.html">cargo-add(1)</a><br />
    <code>Cargo.toml</code> 매니페스트 파일에 의존성을 추가합니다.</p>
<p><a href="commands/cargo-generate-lockfile.html">cargo-generate-lockfile(1)</a><br />
    프로젝트를 위한 <code>Cargo.lock</code> 을 생성합니다.</p>
<p><a href="commands/cargo-info.html">cargo-info(1)</a><br />
    레지스트리에 있는 패키지 정보를 표시합니다. 기본 레지스트리는 crates.io입니다.</p>
<p><a href="commands/cargo-locate-project.html">cargo-locate-project(1)</a><br />
    <code>Cargo.toml</code> 파일 위치의 JSON 표현을 출력합니다.</p>
<p><a href="commands/cargo-metadata.html">cargo-metadata(1)</a><br />
    패키지의 해결된 의존성을 기계 판독 가능한 형식으로 출력합니다.</p>
<p><a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a><br />
    정규화된 패키지 명세를 출력합니다.</p>
<p><a href="commands/cargo-remove.html">cargo-remove(1)</a><br />
    <code>Cargo.toml</code> 매니페스트 파일에서 의존성을 제거합니다.</p>
<p><a href="commands/cargo-tree.html">cargo-tree(1)</a><br />
    의존성 그래프를 트리 시각화로 표시합니다.</p>
<p><a href="commands/cargo-update.html">cargo-update(1)</a><br />
    로컬 잠금 파일에 기록된 대로 의존성을 업데이트합니다.</p>
<p><a href="commands/cargo-vendor.html">cargo-vendor(1)</a><br />
    모든 의존성을 로컬로 벤더링합니다.</p>
<h3 id="패키지-명령어"><a class="header" href="#패키지-명령어">패키지 명령어</a></h3>
<p><a href="commands/cargo-init.html">cargo-init(1)</a><br />
    기존 디렉토리에 새로운 Cargo 패키지를 생성합니다.</p>
<p><a href="commands/cargo-install.html">cargo-install(1)</a><br />
    러스트 바이너리를 빌드하고 설치합니다.</p>
<p><a href="commands/cargo-new.html">cargo-new(1)</a><br />
    새로운 Cargo 패키지를 생성합니다.</p>
<p><a href="commands/cargo-search.html">cargo-search(1)</a><br />
    crates.io에서 패키지를 검색합니다.</p>
<p><a href="commands/cargo-uninstall.html">cargo-uninstall(1)</a><br />
    러스트 바이너리를 제거합니다.</p>
<h3 id="게시-명령어"><a class="header" href="#게시-명령어">게시 명령어</a></h3>
<p><a href="commands/cargo-login.html">cargo-login(1)</a><br />
    레지스트리의 API 토큰을 로컬에 저장합니다.</p>
<p><a href="commands/cargo-logout.html">cargo-logout(1)</a><br />
    레지스트리의 API 토큰을 로컬에서 제거합니다.</p>
<p><a href="commands/cargo-owner.html">cargo-owner(1)</a><br />
    레지스트리 상의 크레이트 소유자를 관리합니다.</p>
<p><a href="commands/cargo-package.html">cargo-package(1)</a><br />
    로컬 패키지를 배포 가능한 tarball로 조립합니다.</p>
<p><a href="commands/cargo-publish.html">cargo-publish(1)</a><br />
    패키지를 레지스트리에 업로드합니다.</p>
<p><a href="commands/cargo-yank.html">cargo-yank(1)</a><br />
    인덱스에서 푸시된 크레이트를 제거(yank)합니다.</p>
<h3 id="report-commands"><a class="header" href="#report-commands">Report Commands</a></h3>
<p><a href="commands/cargo-report.html">cargo-report(1)</a><br />
    Generate and display various kinds of reports.</p>
<p><a href="commands/cargo-report-future-incompatibilities.html">cargo-report-future-incompatibilities(1)</a><br />
    Reports any crates which will eventually stop compiling.</p>
<h3 id="일반-명령어-1"><a class="header" href="#일반-명령어-1">일반 명령어</a></h3>
<p><a href="commands/cargo-help.html">cargo-help(1)</a><br />
    Cargo에 대한 도움말 정보를 표시합니다.</p>
<p><a href="commands/cargo-version.html">cargo-version(1)</a><br />
    버전 정보를 보여줍니다.</p>
<h2 id="옵션"><a class="header" href="#옵션">옵션</a></h2>
<h3 id="특별-옵션"><a class="header" href="#특별-옵션">특별 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo--V"><a class="option-anchor" href="commands/cargo.html#option-cargo--V"><code>-V</code></a></dt>
<dt class="option-term" id="option-cargo---version"><a class="option-anchor" href="commands/cargo.html#option-cargo---version"><code>--version</code></a></dt>
<dd class="option-desc"><p>Print version info and exit. If used with <code>--verbose</code>, prints extra
information.</p>
</dd>
<dt class="option-term" id="option-cargo---list"><a class="option-anchor" href="commands/cargo.html#option-cargo---list"><code>--list</code></a></dt>
<dd class="option-desc"><p>List all installed Cargo subcommands. If used with <code>--verbose</code>, prints extra
information.</p>
</dd>
<dt class="option-term" id="option-cargo---explain"><a class="option-anchor" href="commands/cargo.html#option-cargo---explain"><code>--explain</code> <em>code</em></a></dt>
<dd class="option-desc"><p>Run <code>rustc --explain CODE</code> which will print out a detailed explanation of an
error message (for example, <code>E0004</code>).</p>
</dd>
</dl>
<h3 id="표시-옵션"><a class="header" href="#표시-옵션">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo--v"><a class="option-anchor" href="commands/cargo.html#option-cargo--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo---verbose"><a class="option-anchor" href="commands/cargo.html#option-cargo---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo--q"><a class="option-anchor" href="commands/cargo.html#option-cargo--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo---quiet"><a class="option-anchor" href="commands/cargo.html#option-cargo---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo---color"><a class="option-anchor" href="commands/cargo.html#option-cargo---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="매니페스트-옵션"><a class="header" href="#매니페스트-옵션">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo---locked"><a class="option-anchor" href="commands/cargo.html#option-cargo---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo---offline"><a class="option-anchor" href="commands/cargo.html#option-cargo---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo---frozen"><a class="option-anchor" href="commands/cargo.html#option-cargo---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션"><a class="header" href="#공통-옵션">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-+toolchain"><a class="option-anchor" href="commands/cargo.html#option-cargo-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo---config"><a class="option-anchor" href="commands/cargo.html#option-cargo---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo--C"><a class="option-anchor" href="commands/cargo.html#option-cargo--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo--h"><a class="option-anchor" href="commands/cargo.html#option-cargo--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo---help"><a class="option-anchor" href="commands/cargo.html#option-cargo---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo--Z"><a class="option-anchor" href="commands/cargo.html#option-cargo--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-3"><a class="header" href="#환경-변수-3">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태"><a class="header" href="#종료-상태">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="파일-1"><a class="header" href="#파일-1">파일</a></h2>
<p><code>~/.cargo/</code><br />
    다양한 파일을 저장하는 Cargo “홈” 디렉토리의 기본 위치입니다. 이 위치는 <code>CARGO_HOME</code> 환경 변수로 변경할 수 있습니다.</p>
<p><code>$CARGO_HOME/bin/</code><br />
    <a href="commands/cargo-install.html">cargo-install(1)</a> 로 설치된 바이너리들이 이곳에 위치합니다. <a href="https://rust-lang.github.io/rustup/">rustup</a> 을 사용하는 경우, Rust와 함께 배포된 실행 파일들도 이곳에 위치합니다.</p>
<p><code>$CARGO_HOME/config.toml</code><br />
    전역 설정 파일입니다. 설정 파일에 대한 자세한 내용은 <a href="commands/../reference/config.html">레퍼런스</a>를 참조하세요.</p>
<p><code>.cargo/config.toml</code><br />
    Cargo는 현재 디렉토리와 모든 상위 디렉토리에서 <code>.cargo/config.toml</code> 이라는 파일을 자동으로 찾습니다. 이 설정 파일들은 전역 설정 파일과 병합됩니다.</p>
<p><code>$CARGO_HOME/credentials.toml</code><br />
    레지스트리 로그인을 위한 개인 인증 정보입니다.</p>
<p><code>$CARGO_HOME/registry/</code><br />
    이 디렉토리에는 레지스트리 인덱스의 캐시된 다운로드와 다운로드된 의존성들이 포함됩니다.</p>
<p><code>$CARGO_HOME/git/</code><br />
    이 디렉토리에는 Git 의존성의 캐시된 다운로드들이 포함됩니다.</p>
<p><code>$CARGO_HOME</code> 디렉토리의 내부 구조는 아직 안정적이지 않으며 변경될 수 있음에 유의하십시오.</p>
<h2 id="예제-14"><a class="header" href="#예제-14">예제</a></h2>
<ol>
<li>
<p>로컬 패키지와 그 모든 의존성을 빌드합니다:</p>
<pre><code>cargo build
</code></pre>
</li>
<li>
<p>최적화를 적용하여 패키지를 빌드합니다:</p>
<pre><code>cargo build --release
</code></pre>
</li>
<li>
<p>교차 컴파일된 타겟에 대해 테스트를 실행합니다:</p>
<pre><code>cargo test --target i686-unknown-linux-gnu
</code></pre>
</li>
<li>
<p>실행 파일을 빌드하는 새 패키지를 생성합니다:</p>
<pre><code>cargo new foobar
</code></pre>
</li>
<li>
<p>현재 디렉토리에 패키지를 생성합니다:</p>
<pre><code>mkdir foo &amp;&amp; cd foo
cargo init .
</code></pre>
</li>
<li>
<p>명령어의 옵션과 사용법에 대해 알아봅니다:</p>
<pre><code>cargo help clean
</code></pre>
</li>
</ol>
<h2 id="버그"><a class="header" href="#버그">버그</a></h2>
<p>이슈 사항은 <a href="https://github.com/rust-lang/cargo/issues">https://github.com/rust-lang/cargo/issues</a>를 참조하세요.</p>
<h2 id="참고-항목"><a class="header" href="#참고-항목">참고 항목</a></h2>
<p><a href="https://doc.rust-lang.org/rustc/index.html">rustc(1)</a>, <a href="https://doc.rust-lang.org/rustdoc/index.html">rustdoc(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-help1"><a class="header" href="#cargo-help1">cargo-help(1)</a></h1>
<h2 id="이름-1"><a class="header" href="#이름-1">이름</a></h2>
<p>cargo-help — Cargo 명령어에 대한 도움말을 가져옵니다</p>
<h2 id="사용법-1"><a class="header" href="#사용법-1">사용법</a></h2>
<p><code>cargo help</code> [<em>subcommand</em>]</p>
<h2 id="설명-1"><a class="header" href="#설명-1">설명</a></h2>
<p>지정된 명령어에 대한 도움말 메시지를 출력합니다.</p>
<h2 id="옵션-1"><a class="header" href="#옵션-1">옵션</a></h2>
<h3 id="표시-옵션-1"><a class="header" href="#표시-옵션-1">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-help--v"><a class="option-anchor" href="commands/cargo-help.html#option-cargo-help--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-help---verbose"><a class="option-anchor" href="commands/cargo-help.html#option-cargo-help---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-help--q"><a class="option-anchor" href="commands/cargo-help.html#option-cargo-help--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-help---quiet"><a class="option-anchor" href="commands/cargo-help.html#option-cargo-help---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-help---color"><a class="option-anchor" href="commands/cargo-help.html#option-cargo-help---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="매니페스트-옵션-1"><a class="header" href="#매니페스트-옵션-1">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-help---locked"><a class="option-anchor" href="commands/cargo-help.html#option-cargo-help---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-help---offline"><a class="option-anchor" href="commands/cargo-help.html#option-cargo-help---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-help---frozen"><a class="option-anchor" href="commands/cargo-help.html#option-cargo-help---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션-1"><a class="header" href="#공통-옵션-1">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-help-+toolchain"><a class="option-anchor" href="commands/cargo-help.html#option-cargo-help-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-help---config"><a class="option-anchor" href="commands/cargo-help.html#option-cargo-help---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-help--C"><a class="option-anchor" href="commands/cargo-help.html#option-cargo-help--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-help--h"><a class="option-anchor" href="commands/cargo-help.html#option-cargo-help--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-help---help"><a class="option-anchor" href="commands/cargo-help.html#option-cargo-help---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-help--Z"><a class="option-anchor" href="commands/cargo-help.html#option-cargo-help--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-4"><a class="header" href="#환경-변수-4">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-1"><a class="header" href="#종료-상태-1">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-15"><a class="header" href="#예제-15">예제</a></h2>
<ol>
<li>
<p>명령어에 대한 도움말 가져오기:</p>
<pre><code>cargo help build
</code></pre>
</li>
<li>
<p>도움말은 <code>--help</code> 플래그로도 확인할 수 있습니다:</p>
<pre><code>cargo build --help
</code></pre>
</li>
</ol>
<h2 id="참고-항목-1"><a class="header" href="#참고-항목-1">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-version1"><a class="header" href="#cargo-version1">cargo-version(1)</a></h1>
<h2 id="이름-2"><a class="header" href="#이름-2">이름</a></h2>
<p>cargo-version — 버전 정보를 보여줍니다</p>
<h2 id="사용법-2"><a class="header" href="#사용법-2">사용법</a></h2>
<p><code>cargo version</code> [<em>options</em>]</p>
<h2 id="설명-2"><a class="header" href="#설명-2">설명</a></h2>
<p>Cargo의 버전을 표시합니다.</p>
<h2 id="옵션-2"><a class="header" href="#옵션-2">옵션</a></h2>
<dl>
<dt class="option-term" id="option-cargo-version--v"><a class="option-anchor" href="commands/cargo-version.html#option-cargo-version--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-version---verbose"><a class="option-anchor" href="commands/cargo-version.html#option-cargo-version---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Display additional version information.</p>
</dd>
</dl>
<h2 id="예제-16"><a class="header" href="#예제-16">예제</a></h2>
<ol>
<li>
<p>버전 표시:</p>
<pre><code>cargo version
</code></pre>
</li>
<li>
<p>버전 정보는 플래그를 통해서도 확인할 수 있습니다:</p>
<pre><code>cargo --version
cargo -V
</code></pre>
</li>
<li>
<p>추가적인 버전 정보 표시:</p>
<pre><code>cargo -Vv
</code></pre>
</li>
</ol>
<h2 id="참고-항목-2"><a class="header" href="#참고-항목-2">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="빌드-명령어-1"><a class="header" href="#빌드-명령어-1">빌드 명령어</a></h1>
<ul>
<li><a href="commands/cargo-bench.html">cargo bench</a></li>
<li><a href="commands/cargo-build.html">cargo build</a></li>
<li><a href="commands/cargo-check.html">cargo check</a></li>
<li><a href="commands/cargo-clean.html">cargo clean</a></li>
<li><a href="commands/cargo-clippy.html">cargo clippy</a></li>
<li><a href="commands/cargo-doc.html">cargo doc</a></li>
<li><a href="commands/cargo-fetch.html">cargo fetch</a></li>
<li><a href="commands/cargo-fix.html">cargo fix</a></li>
<li><a href="commands/cargo-fmt.html">cargo fmt</a></li>
<li><a href="commands/cargo-miri.html">cargo miri</a></li>
<li><a href="commands/cargo-run.html">cargo run</a></li>
<li><a href="commands/cargo-rustc.html">cargo rustc</a></li>
<li><a href="commands/cargo-rustdoc.html">cargo rustdoc</a></li>
<li><a href="commands/cargo-test.html">cargo test</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-bench1"><a class="header" href="#cargo-bench1">cargo-bench(1)</a></h1>
<h2 id="이름-3"><a class="header" href="#이름-3">이름</a></h2>
<p>cargo-bench — 패키지의 벤치마크를 실행합니다</p>
<h2 id="사용법-3"><a class="header" href="#사용법-3">사용법</a></h2>
<p><code>cargo bench</code> [<em>options</em>] [<em>benchname</em>] [<code>--</code> <em>bench-options</em>]</p>
<h2 id="설명-3"><a class="header" href="#설명-3">설명</a></h2>
<p>벤치마크를 컴파일하고 실행합니다.</p>
<p>벤치마크 필터링 인수인 <em>benchname</em> 과 두 개의 대시(<code>--</code>) 뒤에 오는 모든 인수는 벤치마크 바이너리에 전달되어 <em>libtest</em>(rustc에 내장된 단위 테스트 및 마이크로 벤치마킹 프레임워크)로 전달됩니다. Cargo와 바이너리 모두에 인수를 전달하는 경우, <code>--</code> 뒤의 인수는 바이너리로 전달되고 그 앞의 인수는 Cargo로 전달됩니다. libtest 인수에 대한 자세한 내용은 <code>cargo bench -- --help</code>의 출력을 확인하고, <a href="https://doc.rust-lang.org/rustc/tests/index.html">https://doc.rust-lang.org/rustc/tests/index.html</a>에서 테스트 작동 방식에 관한 rustc 북의 장을 참조하십시오.</p>
<p>예를 들어, 다음은 이름이 <code>foo</code> 인 벤치마크만 실행합니다 (<code>foobar</code> 와 같이 비슷하게 명명된 다른 벤치마크는 건너뜁니다):</p>
<pre><code>cargo bench -- foo --exact
</code></pre>
<p>벤치마크는 <code>rustc</code> 에 <code>--test</code> 옵션을 주어 빌드되며, 이는 코드를 libtest와 연결하여 특수한 실행 파일을 생성합니다. 이 실행 파일은 <code>#[bench]</code> 속성이 지정된 모든 함수를 자동으로 실행합니다. Cargo는 테스트 하네스에 <code>--bench</code> 플래그를 전달하여, 하네스가 libtest인지 사용자 정의 하네스인지에 관계없이 벤치마크만 실행하도록 지시합니다.</p>
<p>타겟 매니페스트 설정에서 <code>harness = false</code> 로 설정하여 libtest 하네스를 비활성화할 수 있습니다. 이 경우 코드는 벤치마크 실행을 처리하기 위해 자체 <code>main</code> 함수를 제공해야 합니다.</p>
<blockquote>
<p><strong>Note</strong>: The <a href="https://doc.rust-lang.org/nightly/unstable-book/library-features/test.html"><code>#[bench]</code> attribute</a> is currently unstable and only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly channel</a>. There are some packages available on <a href="https://crates.io/keywords/benchmark">crates.io</a> that may help with running benchmarks on the stable channel, such as <a href="https://crates.io/crates/criterion">Criterion</a>.</p>
</blockquote>
<p>기본적으로 <code>cargo bench</code> 는 최적화를 활성화하고 디버깅 정보를 비활성화하는 <a href="commands/../reference/profiles.html#bench"><code>bench</code> 프로파일</a> 을 사용합니다. 벤치마크를 디버깅해야 하는 경우, <code>--profile=dev</code> 명령줄 옵션을 사용하여 <code>dev</code> 프로파일로 전환할 수 있습니다. 그런 다음 디버거 내에서 디버깅이 활성화된 벤치마크를 실행할 수 있습니다.</p>
<h3 id="벤치마크의-작업-디렉토리"><a class="header" href="#벤치마크의-작업-디렉토리">벤치마크의 작업 디렉토리</a></h3>
<p>모든 벤치마크의 작업 디렉토리는 해당 벤치마크가 속한 패키지의 루트 디렉토리로 설정됩니다. 벤치마크의 작업 디렉토리를 패키지의 루트 디렉토리로 설정하면, <code>cargo bench</code> 가 어디에서 실행되었는지에 관계없이 벤치마크가 상대 경로를 사용하여 패키지의 파일에 안정적으로 접근할 수 있습니다.</p>
<h2 id="옵션-3"><a class="header" href="#옵션-3">옵션</a></h2>
<h3 id="벤치마크-옵션"><a class="header" href="#벤치마크-옵션">벤치마크 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-bench---no-run"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---no-run"><code>--no-run</code></a></dt>
<dd class="option-desc"><p>Compile, but don’t run benchmarks.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---no-fail-fast"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---no-fail-fast"><code>--no-fail-fast</code></a></dt>
<dd class="option-desc"><p>Run all benchmarks regardless of failure. Without this flag, Cargo will exit
after the first executable fails. The Rust test harness will run all benchmarks
within the executable to completion, this flag only applies to the executable
as a whole.</p>
</dd>
</dl>
<h3 id="패키지-선택-1"><a class="header" href="#패키지-선택-1">패키지 선택</a></h3>
<p>기본적으로 패키지 선택 옵션이 주어지지 않으면, 선택된 패키지는 선택된 매니페스트 파일에 따라 달라집니다 (<code>--manifest-path</code> 가 주어지지 않은 경우 현재 작업 디렉토리를 기준으로 함). 매니페스트가 워크스페이스의 루트인 경우 워크스페이스의 기본 구성원들이 선택되고, 그렇지 않으면 매니페스트에 정의된 패키지만 선택됩니다.</p>
<p>워크스페이스의 기본 구성원은 루트 매니페스트의 <code>workspace.default-members</code> 키로 명시적으로 설정할 수 있습니다. 이 값이 설정되지 않은 경우, 가상 워크스페이스(virtual workspace)는 모든 워크스페이스 구성원을 포함하며(<code>--workspace</code>를 전달하는 것과 동일), 가상이 아닌 워크스페이스는 루트 크레이트 자체만 포함합니다.</p>
<dl>
<dt class="option-term" id="option-cargo-bench--p"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--p"><code>-p</code> <em>spec</em>…</a></dt>
<dt class="option-term" id="option-cargo-bench---package"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---package"><code>--package</code> <em>spec</em>…</a></dt>
<dd class="option-desc"><p>Benchmark only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---workspace"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---workspace"><code>--workspace</code></a></dt>
<dd class="option-desc"><p>Benchmark all members in the workspace.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---all"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---all"><code>--all</code></a></dt>
<dd class="option-desc"><p>Deprecated alias for <code>--workspace</code>.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---exclude"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---exclude"><code>--exclude</code> <em>SPEC</em>…</a></dt>
<dd class="option-desc"><p>Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</p>
</dd>
</dl>
<h3 id="타겟-선택"><a class="header" href="#타겟-선택">타겟 선택</a></h3>
<p>타겟 선택 옵션이 주어지지 않으면, <code>cargo bench</code> 는 선택된 패키지의 다음 타겟들을 빌드합니다:</p>
<ul>
<li>lib — 바이너리 및 벤치마크와 연결하는 데 사용됩니다.</li>
<li>bins (벤치마크 타겟이 빌드되고 필요한 기능이 사용 가능한 경우에만)</li>
<li>벤치마크로서의 lib</li>
<li>벤치마크로서의 bins</li>
<li>벤치마크 타겟</li>
</ul>
<p>기본 동작은 매니페스트 설정에서 타겟의 <code>bench</code> 플래그를 설정하여 변경할 수 있습니다. 예제를 <code>bench = true</code> 로 설정하면 예제를 벤치마크로 빌드하고 실행하며, 예제의 <code>main</code> 함수를 libtest 하네스로 대체합니다.</p>
<p>타겟을 <code>bench = false</code> 로 설정하면 기본적으로 벤치마크 대상에서 제외됩니다. 이름을 통해 타겟을 선택하는 옵션(예: <code>--example foo</code>)은 <code>bench</code> 플래그를 무시하고 항상 해당 타겟을 벤치마크합니다.</p>
<p>타겟별 설정에 대한 자세한 내용은 <a href="commands/../reference/cargo-targets.html#configuring-a-target">타겟 구성하기</a>를 참조하세요.</p>
<p>Binary targets are automatically built if there is an integration test or benchmark being selected to benchmark. This allows an integration test to execute the binary to exercise and test its behavior. The <code>CARGO_BIN_EXE_&lt;name&gt;</code> <a href="commands/../reference/environment-variables.html#environment-variables-cargo-sets-for-crates">environment variable</a> is set when the integration test is built and run so that it can use the <a href="https://doc.rust-lang.org/std/macro.env.html"><code>env</code> macro</a> or the <a href="https://doc.rust-lang.org/std/env/fn.var.html"><code>var</code> function</a> to locate the executable.</p>
<p>타겟 선택 플래그를 전달하면 지정된 타겟만 벤치마크합니다.</p>
<p><code>--bin</code>, <code>--example</code>, <code>--test</code>, <code>--bench</code> 플래그는 <code>*</code>, <code>?</code>, <code>[]</code> 와 같은 일반적인 유닉스 글로브 패턴도 지원합니다. 하지만 Cargo가 처리하기 전에 셸이 실수로 글로브 패턴을 확장하는 것을 방지하기 위해, 각 글로브 패턴을 작은따옴표나 큰따옴표로 감싸야 합니다.</p>
<dl>
<dt class="option-term" id="option-cargo-bench---lib"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---lib"><code>--lib</code></a></dt>
<dd class="option-desc"><p>Benchmark the package’s library.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---bin"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---bin"><code>--bin</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Benchmark the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---bins"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---bins"><code>--bins</code></a></dt>
<dd class="option-desc"><p>Benchmark all binary targets.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---example"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---example"><code>--example</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Benchmark the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---examples"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---examples"><code>--examples</code></a></dt>
<dd class="option-desc"><p>Benchmark all example targets.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---test"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---test"><code>--test</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Benchmark the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---tests"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---tests"><code>--tests</code></a></dt>
<dd class="option-desc"><p>Benchmark all targets that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---bench"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---bench"><code>--bench</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Benchmark the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---benches"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---benches"><code>--benches</code></a></dt>
<dd class="option-desc"><p>Benchmark all targets that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---all-targets"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---all-targets"><code>--all-targets</code></a></dt>
<dd class="option-desc"><p>Benchmark all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</p>
</dd>
</dl>
<h3 id="기능-선택"><a class="header" href="#기능-선택">기능 선택</a></h3>
<p>기능 플래그를 통해 어떤 기능을 활성화할지 제어할 수 있습니다. 기능 옵션이 주어지지 않으면, 선택된 모든 패키지에 대해 <code>default</code> 기능이 활성화됩니다.</p>
<p>자세한 내용은 <a href="commands/../reference/features.html#command-line-feature-options">기능 문서</a>를 참조하세요.</p>
<dl>
<dt class="option-term" id="option-cargo-bench--F"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--F"><code>-F</code> <em>features</em></a></dt>
<dt class="option-term" id="option-cargo-bench---features"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---features"><code>--features</code> <em>features</em></a></dt>
<dd class="option-desc"><p>Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---all-features"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---all-features"><code>--all-features</code></a></dt>
<dd class="option-desc"><p>Activate all available features of all selected packages.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---no-default-features"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---no-default-features"><code>--no-default-features</code></a></dt>
<dd class="option-desc"><p>Do not activate the <code>default</code> feature of the selected packages.</p>
</dd>
</dl>
<h3 id="컴파일-옵션"><a class="header" href="#컴파일-옵션">컴파일 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-bench---target"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---target"><code>--target</code> <em>triple</em></a></dt>
<dd class="option-desc"><p>Benchmark for the specified target architecture. Flag may be specified multiple times. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>.</p>
<p>Possible values:</p>
<ul>
<li>Any supported target in <code>rustc --print target-list</code>.</li>
<li><code>"host-tuple"</code>, which will internally be substituted by the host’s target. This can be particularly useful if you’re cross-compiling some crates, and don’t want to specify your host’s machine as a target (for instance, an <code>xtask</code> in a shared project that may be worked on by many hosts).</li>
<li>A path to a custom target specification. See <a href="commands/../../rustc/targets/custom.html#custom-target-lookup-path">Custom Target Lookup Path</a> for more information.</li>
</ul>
<p>This may also be specified with the <code>build.target</code> <a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../reference/build-cache.html">build cache</a> documentation for more details.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---profile"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---profile"><code>--profile</code> <em>name</em></a></dt>
<dd class="option-desc"><p>Benchmark with the given profile.
See <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---timings"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---timings"><code>--timings</code></a></dt>
<dd class="option-desc"><p>Output information how long each compilation takes, and track concurrency
information over time.</p>
<p>A file <code>cargo-timing.html</code> will be written to the <code>target/cargo-timings</code>
directory at the end of the build. An additional report with a timestamp
in its filename is also written if you want to look at a previous run.
These reports are suitable for human consumption only, and do not provide
machine-readable timing data.</p>
</dd>
</dl>
<h3 id="출력-옵션"><a class="header" href="#출력-옵션">출력 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-bench---target-dir"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---target-dir"><code>--target-dir</code> <em>directory</em></a></dt>
<dd class="option-desc"><p>Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</p>
</dd>
</dl>
<h3 id="표시-옵션-2"><a class="header" href="#표시-옵션-2">표시 옵션</a></h3>
<p>By default the Rust test harness hides output from benchmark execution to keep results readable. Benchmark output can be recovered (e.g., for debugging) by passing <code>--no-capture</code> to the benchmark binaries:</p>
<pre><code>cargo bench -- --no-capture
</code></pre>
<dl>
<dt class="option-term" id="option-cargo-bench--v"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-bench---verbose"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-bench--q"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-bench---quiet"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---color"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---message-format"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---message-format"><code>--message-format</code> <em>fmt</em></a></dt>
<dd class="option-desc"><p>The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the “short” rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc’s default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo’s own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul>
</dd>
</dl>
<h3 id="매니페스트-옵션-2"><a class="header" href="#매니페스트-옵션-2">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-bench---manifest-path"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---ignore-rust-version"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---ignore-rust-version"><code>--ignore-rust-version</code></a></dt>
<dd class="option-desc"><p>Ignore <code>rust-version</code> specification in packages.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---locked"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---offline"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---frozen"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션-2"><a class="header" href="#공통-옵션-2">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-bench-+toolchain"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-bench---config"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-bench--C"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-bench--h"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-bench---help"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-bench--Z"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h3 id="기타-옵션"><a class="header" href="#기타-옵션">기타 옵션</a></h3>
<p><code>--jobs</code> 인수는 벤치마크 실행 파일의 빌드에는 영향을 미치지만, 벤치마크 실행 시 사용되는 스레드 수에는 영향을 미치지 않습니다. 러스트 테스트 하네스는 단일 스레드에서 벤치마크를 순차적으로 실행합니다.</p>
<dl>
<dt class="option-term" id="option-cargo-bench--j"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench--j"><code>-j</code> <em>N</em></a></dt>
<dt class="option-term" id="option-cargo-bench---jobs"><a class="option-anchor" href="commands/cargo-bench.html#option-cargo-bench---jobs"><code>--jobs</code> <em>N</em></a></dt>
<dd class="option-desc"><p>Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value. If
a string <code>default</code> is provided, it sets the value back to defaults.
Should not be 0.</p>
</dd>
</dl>
<p><code>cargo bench</code> 는 컴파일 과정을 포함하지만, <code>--keep-going</code> 플래그를 제공하지는 않습니다. 첫 번째 실패에서 멈추지 않고 가능한 많은 벤치마크를 실행하려면 <code>--no-fail-fast</code>를 사용하세요. 가능한 많은 벤치마크를 “컴파일“하려면 <code>--benches</code>를 사용하여 벤치마크 바이너리를 별도로 빌드하세요. 예:</p>
<pre><code>cargo build --benches --release --keep-going
cargo bench --no-fail-fast
</code></pre>
<h2 id="환경-변수-5"><a class="header" href="#환경-변수-5">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-2"><a class="header" href="#종료-상태-2">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-17"><a class="header" href="#예제-17">예제</a></h2>
<ol>
<li>
<p>현재 패키지의 모든 벤치마크를 빌드하고 실행합니다:</p>
<pre><code>cargo bench
</code></pre>
</li>
<li>
<p>특정 벤치마크 타겟 내의 특정 벤치마크만 실행합니다:</p>
<pre><code>cargo bench --bench bench_name -- modname::some_benchmark
</code></pre>
</li>
</ol>
<h2 id="참고-항목-3"><a class="header" href="#참고-항목-3">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-test.html">cargo-test(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-build1"><a class="header" href="#cargo-build1">cargo-build(1)</a></h1>
<h2 id="이름-4"><a class="header" href="#이름-4">이름</a></h2>
<p>cargo-build — 현재 패키지를 컴파일합니다</p>
<h2 id="사용법-4"><a class="header" href="#사용법-4">사용법</a></h2>
<p><code>cargo build</code> [<em>options</em>]</p>
<h2 id="설명-4"><a class="header" href="#설명-4">설명</a></h2>
<p>로컬 패키지와 모든 의존성을 컴파일합니다.</p>
<h2 id="옵션-4"><a class="header" href="#옵션-4">옵션</a></h2>
<h3 id="패키지-선택-2"><a class="header" href="#패키지-선택-2">패키지 선택</a></h3>
<p>기본적으로 패키지 선택 옵션이 주어지지 않으면, 선택된 패키지는 선택된 매니페스트 파일에 따라 달라집니다 (<code>--manifest-path</code> 가 주어지지 않은 경우 현재 작업 디렉토리를 기준으로 함). 매니페스트가 워크스페이스의 루트인 경우 워크스페이스의 기본 구성원들이 선택되고, 그렇지 않으면 매니페스트에 정의된 패키지만 선택됩니다.</p>
<p>워크스페이스의 기본 구성원은 루트 매니페스트의 <code>workspace.default-members</code> 키로 명시적으로 설정할 수 있습니다. 이 값이 설정되지 않은 경우, 가상 워크스페이스(virtual workspace)는 모든 워크스페이스 구성원을 포함하며(<code>--workspace</code>를 전달하는 것과 동일), 가상이 아닌 워크스페이스는 루트 크레이트 자체만 포함합니다.</p>
<dl>
<dt class="option-term" id="option-cargo-build--p"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--p"><code>-p</code> <em>spec</em>…</a></dt>
<dt class="option-term" id="option-cargo-build---package"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---package"><code>--package</code> <em>spec</em>…</a></dt>
<dd class="option-desc"><p>Build only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</p>
</dd>
<dt class="option-term" id="option-cargo-build---workspace"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---workspace"><code>--workspace</code></a></dt>
<dd class="option-desc"><p>Build all members in the workspace.</p>
</dd>
<dt class="option-term" id="option-cargo-build---all"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---all"><code>--all</code></a></dt>
<dd class="option-desc"><p>Deprecated alias for <code>--workspace</code>.</p>
</dd>
<dt class="option-term" id="option-cargo-build---exclude"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---exclude"><code>--exclude</code> <em>SPEC</em>…</a></dt>
<dd class="option-desc"><p>Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</p>
</dd>
</dl>
<h3 id="타겟-선택-1"><a class="header" href="#타겟-선택-1">타겟 선택</a></h3>
<p>타겟 선택 옵션이 주어지지 않으면, <code>cargo build</code> 는 선택된 패키지의 모든 바이너리 및 라이브러리 타겟을 빌드합니다. 필요한 기능(required-features)이 누락된 바이너리는 건너뜁니다.</p>
<p>Binary targets are automatically built if there is an integration test or benchmark being selected to build. This allows an integration test to execute the binary to exercise and test its behavior. The <code>CARGO_BIN_EXE_&lt;name&gt;</code> <a href="commands/../reference/environment-variables.html#environment-variables-cargo-sets-for-crates">environment variable</a> is set when the integration test is built and run so that it can use the <a href="https://doc.rust-lang.org/std/macro.env.html"><code>env</code> macro</a> or the <a href="https://doc.rust-lang.org/std/env/fn.var.html"><code>var</code> function</a> to locate the executable.</p>
<p>타겟 선택 플래그를 전달하면 지정된 타겟만 빌드합니다.</p>
<p><code>--bin</code>, <code>--example</code>, <code>--test</code>, <code>--bench</code> 플래그는 <code>*</code>, <code>?</code>, <code>[]</code> 와 같은 일반적인 유닉스 글로브 패턴도 지원합니다. 하지만 Cargo가 처리하기 전에 셸이 실수로 글로브 패턴을 확장하는 것을 방지하기 위해, 각 글로브 패턴을 작은따옴표나 큰따옴표로 감싸야 합니다.</p>
<dl>
<dt class="option-term" id="option-cargo-build---lib"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---lib"><code>--lib</code></a></dt>
<dd class="option-desc"><p>Build the package’s library.</p>
</dd>
<dt class="option-term" id="option-cargo-build---bin"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---bin"><code>--bin</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Build the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-build---bins"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---bins"><code>--bins</code></a></dt>
<dd class="option-desc"><p>Build all binary targets.</p>
</dd>
<dt class="option-term" id="option-cargo-build---example"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---example"><code>--example</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Build the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-build---examples"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---examples"><code>--examples</code></a></dt>
<dd class="option-desc"><p>Build all example targets.</p>
</dd>
<dt class="option-term" id="option-cargo-build---test"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---test"><code>--test</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Build the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-build---tests"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---tests"><code>--tests</code></a></dt>
<dd class="option-desc"><p>Build all targets that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</p>
</dd>
<dt class="option-term" id="option-cargo-build---bench"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---bench"><code>--bench</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Build the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-build---benches"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---benches"><code>--benches</code></a></dt>
<dd class="option-desc"><p>Build all targets that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</p>
</dd>
<dt class="option-term" id="option-cargo-build---all-targets"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---all-targets"><code>--all-targets</code></a></dt>
<dd class="option-desc"><p>Build all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</p>
</dd>
</dl>
<h3 id="기능-선택-1"><a class="header" href="#기능-선택-1">기능 선택</a></h3>
<p>기능 플래그를 통해 어떤 기능을 활성화할지 제어할 수 있습니다. 기능 옵션이 주어지지 않으면, 선택된 모든 패키지에 대해 <code>default</code> 기능이 활성화됩니다.</p>
<p>자세한 내용은 <a href="commands/../reference/features.html#command-line-feature-options">기능 문서</a>를 참조하세요.</p>
<dl>
<dt class="option-term" id="option-cargo-build--F"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--F"><code>-F</code> <em>features</em></a></dt>
<dt class="option-term" id="option-cargo-build---features"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---features"><code>--features</code> <em>features</em></a></dt>
<dd class="option-desc"><p>Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</p>
</dd>
<dt class="option-term" id="option-cargo-build---all-features"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---all-features"><code>--all-features</code></a></dt>
<dd class="option-desc"><p>Activate all available features of all selected packages.</p>
</dd>
<dt class="option-term" id="option-cargo-build---no-default-features"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---no-default-features"><code>--no-default-features</code></a></dt>
<dd class="option-desc"><p>Do not activate the <code>default</code> feature of the selected packages.</p>
</dd>
</dl>
<h3 id="컴파일-옵션-1"><a class="header" href="#컴파일-옵션-1">컴파일 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build---target"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---target"><code>--target</code> <em>triple</em></a></dt>
<dd class="option-desc"><p>Build for the specified target architecture. Flag may be specified multiple times. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>.</p>
<p>Possible values:</p>
<ul>
<li>Any supported target in <code>rustc --print target-list</code>.</li>
<li><code>"host-tuple"</code>, which will internally be substituted by the host’s target. This can be particularly useful if you’re cross-compiling some crates, and don’t want to specify your host’s machine as a target (for instance, an <code>xtask</code> in a shared project that may be worked on by many hosts).</li>
<li>A path to a custom target specification. See <a href="commands/../../rustc/targets/custom.html#custom-target-lookup-path">Custom Target Lookup Path</a> for more information.</li>
</ul>
<p>This may also be specified with the <code>build.target</code> <a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../reference/build-cache.html">build cache</a> documentation for more details.</p>
</dd>
<dt class="option-term" id="option-cargo-build--r"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--r"><code>-r</code></a></dt>
<dt class="option-term" id="option-cargo-build---release"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---release"><code>--release</code></a></dt>
<dd class="option-desc"><p>Build optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</p>
</dd>
<dt class="option-term" id="option-cargo-build---profile"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---profile"><code>--profile</code> <em>name</em></a></dt>
<dd class="option-desc"><p>Build with the given profile.
See <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</p>
</dd>
<dt class="option-term" id="option-cargo-build---timings"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---timings"><code>--timings</code></a></dt>
<dd class="option-desc"><p>Output information how long each compilation takes, and track concurrency
information over time.</p>
<p>A file <code>cargo-timing.html</code> will be written to the <code>target/cargo-timings</code>
directory at the end of the build. An additional report with a timestamp
in its filename is also written if you want to look at a previous run.
These reports are suitable for human consumption only, and do not provide
machine-readable timing data.</p>
</dd>
</dl>
<h3 id="출력-옵션-1"><a class="header" href="#출력-옵션-1">출력 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build---target-dir"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---target-dir"><code>--target-dir</code> <em>directory</em></a></dt>
<dd class="option-desc"><p>Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</p>
</dd>
<dt class="option-term" id="option-cargo-build---artifact-dir"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---artifact-dir"><code>--artifact-dir</code> <em>directory</em></a></dt>
<dd class="option-desc"><p>Copy final artifacts to this directory.</p>
<p>This option is unstable and available only on the
<a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly channel</a>
and requires the <code>-Z unstable-options</code> flag to enable.
See <a href="https://github.com/rust-lang/cargo/issues/6790">https://github.com/rust-lang/cargo/issues/6790</a> for more information.</p>
</dd>
</dl>
<h3 id="표시-옵션-3"><a class="header" href="#표시-옵션-3">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build--v"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-build---verbose"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-build--q"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-build---quiet"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-build---color"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-build---message-format"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---message-format"><code>--message-format</code> <em>fmt</em></a></dt>
<dd class="option-desc"><p>The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the “short” rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc’s default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo’s own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul>
</dd>
</dl>
<h3 id="매니페스트-옵션-3"><a class="header" href="#매니페스트-옵션-3">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build---manifest-path"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-build---ignore-rust-version"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---ignore-rust-version"><code>--ignore-rust-version</code></a></dt>
<dd class="option-desc"><p>Ignore <code>rust-version</code> specification in packages.</p>
</dd>
<dt class="option-term" id="option-cargo-build---locked"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-build---offline"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-build---frozen"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션-3"><a class="header" href="#공통-옵션-3">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build-+toolchain"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-build---config"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-build--C"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-build--h"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-build---help"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-build--Z"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h3 id="기타-옵션-1"><a class="header" href="#기타-옵션-1">기타 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-build--j"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build--j"><code>-j</code> <em>N</em></a></dt>
<dt class="option-term" id="option-cargo-build---jobs"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---jobs"><code>--jobs</code> <em>N</em></a></dt>
<dd class="option-desc"><p>Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value. If
a string <code>default</code> is provided, it sets the value back to defaults.
Should not be 0.</p>
</dd>
<dt class="option-term" id="option-cargo-build---keep-going"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---keep-going"><code>--keep-going</code></a></dt>
<dd class="option-desc"><p>Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build.</p>
<p>For example if the current package depends on dependencies <code>fails</code> and <code>works</code>,
one of which fails to build, <code>cargo build -j1</code> may or may not build the
one that succeeds (depending on which one of the two builds Cargo picked to run
first), whereas <code>cargo build -j1 --keep-going</code> would definitely run both
builds, even if the one run first fails.</p>
</dd>
<dt class="option-term" id="option-cargo-build---future-incompat-report"><a class="option-anchor" href="commands/cargo-build.html#option-cargo-build---future-incompat-report"><code>--future-incompat-report</code></a></dt>
<dd class="option-desc"><p>Displays a future-incompat report for any future-incompatible warnings
produced during execution of this command</p>
<p>See <a href="commands/cargo-report.html">cargo-report(1)</a></p>
</dd>
</dl>
<h2 id="환경-변수-6"><a class="header" href="#환경-변수-6">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-3"><a class="header" href="#종료-상태-3">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-18"><a class="header" href="#예제-18">예제</a></h2>
<ol>
<li>
<p>로컬 패키지와 그 모든 의존성을 빌드합니다:</p>
<pre><code>cargo build
</code></pre>
</li>
<li>
<p>최적화를 적용하여 빌드합니다:</p>
<pre><code>cargo build --release
</code></pre>
</li>
</ol>
<h2 id="참고-항목-4"><a class="header" href="#참고-항목-4">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-rustc.html">cargo-rustc(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-check1"><a class="header" href="#cargo-check1">cargo-check(1)</a></h1>
<h2 id="이름-5"><a class="header" href="#이름-5">이름</a></h2>
<p>cargo-check — 현재 패키지를 검사합니다</p>
<h2 id="사용법-5"><a class="header" href="#사용법-5">사용법</a></h2>
<p><code>cargo check</code> [<em>options</em>]</p>
<h2 id="설명-5"><a class="header" href="#설명-5">설명</a></h2>
<p>로컬 패키지와 모든 의존성의 오류를 검사합니다. 이는 본질적으로 코드 생성의 마지막 단계를 수행하지 않고 패키지를 컴파일하는 것으로, <code>cargo build</code> 를 실행하는 것보다 빠릅니다. 컴파일러는 메타데이터 파일을 디스크에 저장하여, 소스가 수정되지 않은 경우 향후 실행 시 이를 재사용합니다. 일부 진단 메시지와 오류는 코드 생성 중에만 발생하므로, <code>cargo check</code> 로는 보고되지 않을 수 있습니다.</p>
<h2 id="옵션-5"><a class="header" href="#옵션-5">옵션</a></h2>
<h3 id="패키지-선택-3"><a class="header" href="#패키지-선택-3">패키지 선택</a></h3>
<p>기본적으로 패키지 선택 옵션이 주어지지 않으면, 선택된 패키지는 선택된 매니페스트 파일에 따라 달라집니다 (<code>--manifest-path</code> 가 주어지지 않은 경우 현재 작업 디렉토리를 기준으로 함). 매니페스트가 워크스페이스의 루트인 경우 워크스페이스의 기본 구성원들이 선택되고, 그렇지 않으면 매니페스트에 정의된 패키지만 선택됩니다.</p>
<p>워크스페이스의 기본 구성원은 루트 매니페스트의 <code>workspace.default-members</code> 키로 명시적으로 설정할 수 있습니다. 이 값이 설정되지 않은 경우, 가상 워크스페이스(virtual workspace)는 모든 워크스페이스 구성원을 포함하며(<code>--workspace</code>를 전달하는 것과 동일), 가상이 아닌 워크스페이스는 루트 크레이트 자체만 포함합니다.</p>
<dl>
<dt class="option-term" id="option-cargo-check--p"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--p"><code>-p</code> <em>spec</em>…</a></dt>
<dt class="option-term" id="option-cargo-check---package"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---package"><code>--package</code> <em>spec</em>…</a></dt>
<dd class="option-desc"><p>Check only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</p>
</dd>
<dt class="option-term" id="option-cargo-check---workspace"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---workspace"><code>--workspace</code></a></dt>
<dd class="option-desc"><p>Check all members in the workspace.</p>
</dd>
<dt class="option-term" id="option-cargo-check---all"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---all"><code>--all</code></a></dt>
<dd class="option-desc"><p>Deprecated alias for <code>--workspace</code>.</p>
</dd>
<dt class="option-term" id="option-cargo-check---exclude"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---exclude"><code>--exclude</code> <em>SPEC</em>…</a></dt>
<dd class="option-desc"><p>Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</p>
</dd>
</dl>
<h3 id="타겟-선택-2"><a class="header" href="#타겟-선택-2">타겟 선택</a></h3>
<p>타겟 선택 옵션이 주어지지 않으면, <code>cargo check</code> 는 선택된 패키지의 모든 바이너리 및 라이브러리 타겟을 검사합니다. 필요한 기능(required-features)이 누락된 바이너리는 건너뜁니다.</p>
<p>타겟 선택 플래그를 전달하면 지정된 타겟만 검사합니다.</p>
<p><code>--bin</code>, <code>--example</code>, <code>--test</code>, <code>--bench</code> 플래그는 <code>*</code>, <code>?</code>, <code>[]</code> 와 같은 일반적인 유닉스 글로브 패턴도 지원합니다. 하지만 Cargo가 처리하기 전에 셸이 실수로 글로브 패턴을 확장하는 것을 방지하기 위해, 각 글로브 패턴을 작은따옴표나 큰따옴표로 감싸야 합니다.</p>
<dl>
<dt class="option-term" id="option-cargo-check---lib"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---lib"><code>--lib</code></a></dt>
<dd class="option-desc"><p>Check the package’s library.</p>
</dd>
<dt class="option-term" id="option-cargo-check---bin"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---bin"><code>--bin</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Check the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-check---bins"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---bins"><code>--bins</code></a></dt>
<dd class="option-desc"><p>Check all binary targets.</p>
</dd>
<dt class="option-term" id="option-cargo-check---example"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---example"><code>--example</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Check the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-check---examples"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---examples"><code>--examples</code></a></dt>
<dd class="option-desc"><p>Check all example targets.</p>
</dd>
<dt class="option-term" id="option-cargo-check---test"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---test"><code>--test</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Check the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-check---tests"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---tests"><code>--tests</code></a></dt>
<dd class="option-desc"><p>Check all targets that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</p>
</dd>
<dt class="option-term" id="option-cargo-check---bench"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---bench"><code>--bench</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Check the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-check---benches"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---benches"><code>--benches</code></a></dt>
<dd class="option-desc"><p>Check all targets that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</p>
</dd>
<dt class="option-term" id="option-cargo-check---all-targets"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---all-targets"><code>--all-targets</code></a></dt>
<dd class="option-desc"><p>Check all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</p>
</dd>
</dl>
<h3 id="기능-선택-2"><a class="header" href="#기능-선택-2">기능 선택</a></h3>
<p>기능 플래그를 통해 어떤 기능을 활성화할지 제어할 수 있습니다. 기능 옵션이 주어지지 않으면, 선택된 모든 패키지에 대해 <code>default</code> 기능이 활성화됩니다.</p>
<p>자세한 내용은 <a href="commands/../reference/features.html#command-line-feature-options">기능 문서</a>를 참조하세요.</p>
<dl>
<dt class="option-term" id="option-cargo-check--F"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--F"><code>-F</code> <em>features</em></a></dt>
<dt class="option-term" id="option-cargo-check---features"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---features"><code>--features</code> <em>features</em></a></dt>
<dd class="option-desc"><p>Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</p>
</dd>
<dt class="option-term" id="option-cargo-check---all-features"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---all-features"><code>--all-features</code></a></dt>
<dd class="option-desc"><p>Activate all available features of all selected packages.</p>
</dd>
<dt class="option-term" id="option-cargo-check---no-default-features"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---no-default-features"><code>--no-default-features</code></a></dt>
<dd class="option-desc"><p>Do not activate the <code>default</code> feature of the selected packages.</p>
</dd>
</dl>
<h3 id="컴파일-옵션-2"><a class="header" href="#컴파일-옵션-2">컴파일 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check---target"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---target"><code>--target</code> <em>triple</em></a></dt>
<dd class="option-desc"><p>Check for the specified target architecture. Flag may be specified multiple times. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>.</p>
<p>Possible values:</p>
<ul>
<li>Any supported target in <code>rustc --print target-list</code>.</li>
<li><code>"host-tuple"</code>, which will internally be substituted by the host’s target. This can be particularly useful if you’re cross-compiling some crates, and don’t want to specify your host’s machine as a target (for instance, an <code>xtask</code> in a shared project that may be worked on by many hosts).</li>
<li>A path to a custom target specification. See <a href="commands/../../rustc/targets/custom.html#custom-target-lookup-path">Custom Target Lookup Path</a> for more information.</li>
</ul>
<p>This may also be specified with the <code>build.target</code> <a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../reference/build-cache.html">build cache</a> documentation for more details.</p>
</dd>
<dt class="option-term" id="option-cargo-check--r"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--r"><code>-r</code></a></dt>
<dt class="option-term" id="option-cargo-check---release"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---release"><code>--release</code></a></dt>
<dd class="option-desc"><p>Check optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</p>
</dd>
<dt class="option-term" id="option-cargo-check---profile"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---profile"><code>--profile</code> <em>name</em></a></dt>
<dd class="option-desc"><p>Check with the given profile.</p>
<p>As a special case, specifying the <code>test</code> profile will also enable checking in
test mode which will enable checking tests and enable the <code>test</code> cfg option.
See <a href="https://doc.rust-lang.org/rustc/tests/index.html">rustc tests</a> for more
detail.</p>
<p>See <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</p>
</dd>
<dt class="option-term" id="option-cargo-check---timings"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---timings"><code>--timings</code></a></dt>
<dd class="option-desc"><p>Output information how long each compilation takes, and track concurrency
information over time.</p>
<p>A file <code>cargo-timing.html</code> will be written to the <code>target/cargo-timings</code>
directory at the end of the build. An additional report with a timestamp
in its filename is also written if you want to look at a previous run.
These reports are suitable for human consumption only, and do not provide
machine-readable timing data.</p>
</dd>
</dl>
<h3 id="출력-옵션-2"><a class="header" href="#출력-옵션-2">출력 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check---target-dir"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---target-dir"><code>--target-dir</code> <em>directory</em></a></dt>
<dd class="option-desc"><p>Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</p>
</dd>
</dl>
<h3 id="표시-옵션-4"><a class="header" href="#표시-옵션-4">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check--v"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-check---verbose"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-check--q"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-check---quiet"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-check---color"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-check---message-format"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---message-format"><code>--message-format</code> <em>fmt</em></a></dt>
<dd class="option-desc"><p>The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the “short” rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc’s default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo’s own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul>
</dd>
</dl>
<h3 id="매니페스트-옵션-4"><a class="header" href="#매니페스트-옵션-4">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check---manifest-path"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-check---ignore-rust-version"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---ignore-rust-version"><code>--ignore-rust-version</code></a></dt>
<dd class="option-desc"><p>Ignore <code>rust-version</code> specification in packages.</p>
</dd>
<dt class="option-term" id="option-cargo-check---locked"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-check---offline"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-check---frozen"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션-4"><a class="header" href="#공통-옵션-4">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check-+toolchain"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-check---config"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-check--C"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-check--h"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-check---help"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-check--Z"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h3 id="기타-옵션-2"><a class="header" href="#기타-옵션-2">기타 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-check--j"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check--j"><code>-j</code> <em>N</em></a></dt>
<dt class="option-term" id="option-cargo-check---jobs"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---jobs"><code>--jobs</code> <em>N</em></a></dt>
<dd class="option-desc"><p>Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value. If
a string <code>default</code> is provided, it sets the value back to defaults.
Should not be 0.</p>
</dd>
<dt class="option-term" id="option-cargo-check---keep-going"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---keep-going"><code>--keep-going</code></a></dt>
<dd class="option-desc"><p>Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build.</p>
<p>For example if the current package depends on dependencies <code>fails</code> and <code>works</code>,
one of which fails to build, <code>cargo check -j1</code> may or may not build the
one that succeeds (depending on which one of the two builds Cargo picked to run
first), whereas <code>cargo check -j1 --keep-going</code> would definitely run both
builds, even if the one run first fails.</p>
</dd>
<dt class="option-term" id="option-cargo-check---future-incompat-report"><a class="option-anchor" href="commands/cargo-check.html#option-cargo-check---future-incompat-report"><code>--future-incompat-report</code></a></dt>
<dd class="option-desc"><p>Displays a future-incompat report for any future-incompatible warnings
produced during execution of this command</p>
<p>See <a href="commands/cargo-report.html">cargo-report(1)</a></p>
</dd>
</dl>
<h2 id="환경-변수-7"><a class="header" href="#환경-변수-7">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-4"><a class="header" href="#종료-상태-4">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-19"><a class="header" href="#예제-19">예제</a></h2>
<ol>
<li>
<p>로컬 패키지의 오류를 검사합니다:</p>
<pre><code>cargo check
</code></pre>
</li>
<li>
<p>단위 테스트를 포함한 모든 타겟을 검사합니다:</p>
<pre><code>cargo check --all-targets --profile=test
</code></pre>
</li>
</ol>
<h2 id="참고-항목-5"><a class="header" href="#참고-항목-5">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-build.html">cargo-build(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-clean1"><a class="header" href="#cargo-clean1">cargo-clean(1)</a></h1>
<h2 id="이름-6"><a class="header" href="#이름-6">이름</a></h2>
<p>cargo-clean — 생성된 결과물들을 제거합니다</p>
<h2 id="사용법-6"><a class="header" href="#사용법-6">사용법</a></h2>
<p><code>cargo clean</code> [<em>options</em>]</p>
<h2 id="설명-6"><a class="header" href="#설명-6">설명</a></h2>
<p>Cargo가 이전에 생성한 타겟 디렉토리의 결과물들을 제거합니다.</p>
<p>옵션이 없으면 <code>cargo clean</code> 은 전체 타겟 디렉토리를 삭제합니다.</p>
<h2 id="옵션-6"><a class="header" href="#옵션-6">옵션</a></h2>
<h3 id="패키지-선택-4"><a class="header" href="#패키지-선택-4">패키지 선택</a></h3>
<p>패키지가 선택되지 않으면 워크스페이스의 모든 패키지와 의존성이 정리됩니다.</p>
<dl>
<dt class="option-term" id="option-cargo-clean--p"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean--p"><code>-p</code> <em>spec</em>…</a></dt>
<dt class="option-term" id="option-cargo-clean---package"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---package"><code>--package</code> <em>spec</em>…</a></dt>
<dd class="option-desc"><p>Clean only the specified packages. This flag may be specified
multiple times. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC format.</p>
</dd>
<dt class="option-term" id="option-cargo-clean---workspace"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---workspace"><code>--workspace</code></a></dt>
<dd class="option-desc"><p>Clean artifacts of the workspace members.</p>
</dd>
</dl>
<h3 id="정리-옵션"><a class="header" href="#정리-옵션">정리 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-clean---dry-run"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---dry-run"><code>--dry-run</code></a></dt>
<dd class="option-desc"><p>Displays a summary of what would be deleted without deleting anything.
Use with <code>--verbose</code> to display the actual files that would be deleted.</p>
</dd>
<dt class="option-term" id="option-cargo-clean---doc"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---doc"><code>--doc</code></a></dt>
<dd class="option-desc"><p>This option will cause <code>cargo clean</code> to remove only the <code>doc</code> directory in
the target directory.</p>
</dd>
<dt class="option-term" id="option-cargo-clean---release"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---release"><code>--release</code></a></dt>
<dd class="option-desc"><p>Remove all artifacts in the <code>release</code> directory.</p>
</dd>
<dt class="option-term" id="option-cargo-clean---profile"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---profile"><code>--profile</code> <em>name</em></a></dt>
<dd class="option-desc"><p>Remove all artifacts in the directory with the given profile name.</p>
</dd>
<dt class="option-term" id="option-cargo-clean---target-dir"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---target-dir"><code>--target-dir</code> <em>directory</em></a></dt>
<dd class="option-desc"><p>Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</p>
</dd>
<dt class="option-term" id="option-cargo-clean---target"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---target"><code>--target</code> <em>triple</em></a></dt>
<dd class="option-desc"><p>Clean for the specified target architecture. Flag may be specified multiple times. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>.</p>
<p>Possible values:</p>
<ul>
<li>Any supported target in <code>rustc --print target-list</code>.</li>
<li><code>"host-tuple"</code>, which will internally be substituted by the host’s target. This can be particularly useful if you’re cross-compiling some crates, and don’t want to specify your host’s machine as a target (for instance, an <code>xtask</code> in a shared project that may be worked on by many hosts).</li>
<li>A path to a custom target specification. See <a href="commands/../../rustc/targets/custom.html#custom-target-lookup-path">Custom Target Lookup Path</a> for more information.</li>
</ul>
<p>This may also be specified with the <code>build.target</code> <a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../reference/build-cache.html">build cache</a> documentation for more details.</p>
</dd>
</dl>
<h3 id="표시-옵션-5"><a class="header" href="#표시-옵션-5">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-clean--v"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-clean---verbose"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-clean--q"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-clean---quiet"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-clean---color"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="매니페스트-옵션-5"><a class="header" href="#매니페스트-옵션-5">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-clean---manifest-path"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-clean---locked"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-clean---offline"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-clean---frozen"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션-5"><a class="header" href="#공통-옵션-5">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-clean-+toolchain"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-clean---config"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-clean--C"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-clean--h"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-clean---help"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-clean--Z"><a class="option-anchor" href="commands/cargo-clean.html#option-cargo-clean--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-8"><a class="header" href="#환경-변수-8">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-5"><a class="header" href="#종료-상태-5">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-20"><a class="header" href="#예제-20">예제</a></h2>
<ol>
<li>
<p>전체 타겟 디렉토리 제거:</p>
<pre><code>cargo clean
</code></pre>
</li>
<li>
<p>릴리스 아티팩트만 제거:</p>
<pre><code>cargo clean --release
</code></pre>
</li>
</ol>
<h2 id="참고-항목-6"><a class="header" href="#참고-항목-6">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-build.html">cargo-build(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-clippy1"><a class="header" href="#cargo-clippy1">cargo-clippy(1)</a></h1>
<h2 id="이름-7"><a class="header" href="#이름-7">이름</a></h2>
<p>cargo-clippy — 패키지를 검사하여 흔한 실수를 찾아내고 Rust 코드를 개선합니다</p>
<h2 id="설명-7"><a class="header" href="#설명-7">설명</a></h2>
<p>이것은 Rust 툴체인과 함께 배포되는 외부 명령어로, 선택적 구성 요소입니다. Cargo에 내장되어 있지 않으며 추가 설치가 필요할 수 있습니다.</p>
<p>사용법 및 설치에 대한 정보는 <a href="commands/../../clippy/index.html">Clippy 문서</a> 를 참조하세요.</p>
<h2 id="참고-항목-7"><a class="header" href="#참고-항목-7">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-fix.html">cargo-fix(1)</a>, <a href="commands/cargo-fmt.html">cargo-fmt(1)</a>, <a href="commands/../reference/external-tools.html#custom-subcommands">사용자 지정 하위 명령어</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-doc1"><a class="header" href="#cargo-doc1">cargo-doc(1)</a></h1>
<h2 id="이름-8"><a class="header" href="#이름-8">이름</a></h2>
<p>cargo-doc — 패키지의 문서 빌드</p>
<h2 id="사용법-7"><a class="header" href="#사용법-7">사용법</a></h2>
<p><code>cargo doc</code> [<em>옵션</em>]</p>
<h2 id="설명-8"><a class="header" href="#설명-8">설명</a></h2>
<p>로컬 패키지 및 모든 의존성에 대한 문서를 빌드합니다. 출력물은 rustdoc의 일반적인 형식으로 <code>target/doc</code> 에 위치합니다.</p>
<p><strong>Note:</strong> Documentation generation is cumulative: existing doc files in the target directory are preserved across different <code>cargo doc</code> invocations. To remove existing generated docs, pass <code>--doc</code> to <a href="commands/cargo-clean.html">cargo-clean(1)</a>.</p>
<h2 id="옵션-7"><a class="header" href="#옵션-7">옵션</a></h2>
<h3 id="문서-옵션"><a class="header" href="#문서-옵션">문서 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc---open"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---open"><code>--open</code></a></dt>
<dd class="option-desc"><p>Open the docs in a browser after building them. This will use your default
browser unless you define another one in the <code>BROWSER</code> environment variable
or use the <a href="commands/../reference/config.html#docbrowser"><code>doc.browser</code></a> configuration
option.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---no-deps"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---no-deps"><code>--no-deps</code></a></dt>
<dd class="option-desc"><p>Do not build documentation for dependencies.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---document-private-items"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---document-private-items"><code>--document-private-items</code></a></dt>
<dd class="option-desc"><p>Include non-public items in the documentation. This will be enabled by default if documenting a binary target.</p>
</dd>
</dl>
<h3 id="패키지-선택-5"><a class="header" href="#패키지-선택-5">패키지 선택</a></h3>
<p>기본적으로 패키지 선택 옵션이 주어지지 않으면, 선택된 패키지는 선택된 매니페스트 파일에 따라 달라집니다 (<code>--manifest-path</code> 가 주어지지 않은 경우 현재 작업 디렉토리를 기준으로 함). 매니페스트가 워크스페이스의 루트인 경우 워크스페이스의 기본 구성원들이 선택되고, 그렇지 않으면 매니페스트에 정의된 패키지만 선택됩니다.</p>
<p>워크스페이스의 기본 구성원은 루트 매니페스트의 <code>workspace.default-members</code> 키로 명시적으로 설정할 수 있습니다. 이 값이 설정되지 않은 경우, 가상 워크스페이스(virtual workspace)는 모든 워크스페이스 구성원을 포함하며(<code>--workspace</code>를 전달하는 것과 동일), 가상이 아닌 워크스페이스는 루트 크레이트 자체만 포함합니다.</p>
<dl>
<dt class="option-term" id="option-cargo-doc--p"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--p"><code>-p</code> <em>spec</em>…</a></dt>
<dt class="option-term" id="option-cargo-doc---package"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---package"><code>--package</code> <em>spec</em>…</a></dt>
<dd class="option-desc"><p>Document only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---workspace"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---workspace"><code>--workspace</code></a></dt>
<dd class="option-desc"><p>Document all members in the workspace.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---all"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---all"><code>--all</code></a></dt>
<dd class="option-desc"><p>Deprecated alias for <code>--workspace</code>.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---exclude"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---exclude"><code>--exclude</code> <em>SPEC</em>…</a></dt>
<dd class="option-desc"><p>Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</p>
</dd>
</dl>
<h3 id="타겟-선택-3"><a class="header" href="#타겟-선택-3">타겟 선택</a></h3>
<p>타겟 선택 옵션이 주어지지 않으면 <code>cargo doc</code> 은 선택된 패키지의 모든 바이너리 및 라이브러리 타겟을 문서화합니다. 바이너리의 이름이 라이브러리 타겟과 같으면 바이너리는 건너뜁니다. <code>required-features</code> 가 누락된 경우 바이너리는 건너뜁니다.</p>
<p>기본 동작은 매니페스트 설정에서 타겟에 대해 <code>doc = false</code> 를 설정하여 변경할 수 있습니다. 타겟 선택 옵션을 사용하면 <code>doc</code> 플래그를 무시하고 항상 주어진 타겟을 문서화합니다.</p>
<dl>
<dt class="option-term" id="option-cargo-doc---lib"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---lib"><code>--lib</code></a></dt>
<dd class="option-desc"><p>Document the package’s library.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---bin"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---bin"><code>--bin</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Document the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---bins"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---bins"><code>--bins</code></a></dt>
<dd class="option-desc"><p>Document all binary targets.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---example"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---example"><code>--example</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Document the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---examples"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---examples"><code>--examples</code></a></dt>
<dd class="option-desc"><p>Document all example targets.</p>
</dd>
</dl>
<h3 id="기능-선택-3"><a class="header" href="#기능-선택-3">기능 선택</a></h3>
<p>기능 플래그를 통해 어떤 기능을 활성화할지 제어할 수 있습니다. 기능 옵션이 주어지지 않으면, 선택된 모든 패키지에 대해 <code>default</code> 기능이 활성화됩니다.</p>
<p>자세한 내용은 <a href="commands/../reference/features.html#command-line-feature-options">기능 문서</a>를 참조하세요.</p>
<dl>
<dt class="option-term" id="option-cargo-doc--F"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--F"><code>-F</code> <em>features</em></a></dt>
<dt class="option-term" id="option-cargo-doc---features"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---features"><code>--features</code> <em>features</em></a></dt>
<dd class="option-desc"><p>Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---all-features"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---all-features"><code>--all-features</code></a></dt>
<dd class="option-desc"><p>Activate all available features of all selected packages.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---no-default-features"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---no-default-features"><code>--no-default-features</code></a></dt>
<dd class="option-desc"><p>Do not activate the <code>default</code> feature of the selected packages.</p>
</dd>
</dl>
<h3 id="컴파일-옵션-3"><a class="header" href="#컴파일-옵션-3">컴파일 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc---target"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---target"><code>--target</code> <em>triple</em></a></dt>
<dd class="option-desc"><p>Document for the specified target architecture. Flag may be specified multiple times. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>.</p>
<p>Possible values:</p>
<ul>
<li>Any supported target in <code>rustc --print target-list</code>.</li>
<li><code>"host-tuple"</code>, which will internally be substituted by the host’s target. This can be particularly useful if you’re cross-compiling some crates, and don’t want to specify your host’s machine as a target (for instance, an <code>xtask</code> in a shared project that may be worked on by many hosts).</li>
<li>A path to a custom target specification. See <a href="commands/../../rustc/targets/custom.html#custom-target-lookup-path">Custom Target Lookup Path</a> for more information.</li>
</ul>
<p>This may also be specified with the <code>build.target</code> <a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../reference/build-cache.html">build cache</a> documentation for more details.</p>
</dd>
<dt class="option-term" id="option-cargo-doc--r"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--r"><code>-r</code></a></dt>
<dt class="option-term" id="option-cargo-doc---release"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---release"><code>--release</code></a></dt>
<dd class="option-desc"><p>Document optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---profile"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---profile"><code>--profile</code> <em>name</em></a></dt>
<dd class="option-desc"><p>Document with the given profile.
See <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---timings"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---timings"><code>--timings</code></a></dt>
<dd class="option-desc"><p>Output information how long each compilation takes, and track concurrency
information over time.</p>
<p>A file <code>cargo-timing.html</code> will be written to the <code>target/cargo-timings</code>
directory at the end of the build. An additional report with a timestamp
in its filename is also written if you want to look at a previous run.
These reports are suitable for human consumption only, and do not provide
machine-readable timing data.</p>
</dd>
</dl>
<h3 id="출력-옵션-3"><a class="header" href="#출력-옵션-3">출력 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc---target-dir"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---target-dir"><code>--target-dir</code> <em>directory</em></a></dt>
<dd class="option-desc"><p>Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</p>
</dd>
</dl>
<h3 id="표시-옵션-6"><a class="header" href="#표시-옵션-6">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc--v"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-doc---verbose"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-doc--q"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-doc---quiet"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---color"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---message-format"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---message-format"><code>--message-format</code> <em>fmt</em></a></dt>
<dd class="option-desc"><p>The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the “short” rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc’s default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo’s own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul>
</dd>
</dl>
<h3 id="매니페스트-옵션-6"><a class="header" href="#매니페스트-옵션-6">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc---manifest-path"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---ignore-rust-version"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---ignore-rust-version"><code>--ignore-rust-version</code></a></dt>
<dd class="option-desc"><p>Ignore <code>rust-version</code> specification in packages.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---locked"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---offline"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---frozen"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션-6"><a class="header" href="#공통-옵션-6">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc-+toolchain"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---config"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-doc--C"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-doc--h"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-doc---help"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-doc--Z"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h3 id="기타-옵션-3"><a class="header" href="#기타-옵션-3">기타 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-doc--j"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc--j"><code>-j</code> <em>N</em></a></dt>
<dt class="option-term" id="option-cargo-doc---jobs"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---jobs"><code>--jobs</code> <em>N</em></a></dt>
<dd class="option-desc"><p>Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value. If
a string <code>default</code> is provided, it sets the value back to defaults.
Should not be 0.</p>
</dd>
<dt class="option-term" id="option-cargo-doc---keep-going"><a class="option-anchor" href="commands/cargo-doc.html#option-cargo-doc---keep-going"><code>--keep-going</code></a></dt>
<dd class="option-desc"><p>Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build.</p>
<p>For example if the current package depends on dependencies <code>fails</code> and <code>works</code>,
one of which fails to build, <code>cargo doc -j1</code> may or may not build the
one that succeeds (depending on which one of the two builds Cargo picked to run
first), whereas <code>cargo doc -j1 --keep-going</code> would definitely run both
builds, even if the one run first fails.</p>
</dd>
</dl>
<h2 id="환경-변수-9"><a class="header" href="#환경-변수-9">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-6"><a class="header" href="#종료-상태-6">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-21"><a class="header" href="#예제-21">예제</a></h2>
<ol>
<li>
<p>로컬 패키지 문서 및 그 의존성을 빌드하고 <code>target/doc</code> 에 출력합니다.</p>
<pre><code>cargo doc
</code></pre>
</li>
</ol>
<h2 id="참고-항목-8"><a class="header" href="#참고-항목-8">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-rustdoc.html">cargo-rustdoc(1)</a>, <a href="https://doc.rust-lang.org/rustdoc/index.html">rustdoc(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-fetch1"><a class="header" href="#cargo-fetch1">cargo-fetch(1)</a></h1>
<h2 id="이름-9"><a class="header" href="#이름-9">이름</a></h2>
<p>cargo-fetch — 네트워크에서 패키지의 의존성 가져오기</p>
<h2 id="사용법-8"><a class="header" href="#사용법-8">사용법</a></h2>
<p><code>cargo fetch</code> [<em>옵션</em>]</p>
<h2 id="설명-9"><a class="header" href="#설명-9">설명</a></h2>
<p><code>Cargo.lock</code> 파일을 사용할 수 있는 경우, 이 명령어는 모든 git 의존성 및/또는 레지스트리 의존성이 다운로드되어 로컬에서 사용할 수 있도록 보장합니다. <code>cargo fetch</code> 후에는 잠금 파일이 변경되지 않는 한 후속 Cargo 명령어를 오프라인으로 실행할 수 있습니다.</p>
<p>잠금 파일을 사용할 수 없는 경우, 이 명령어는 의존성을 가져오기 전에 잠금 파일을 생성합니다.</p>
<p><code>--target</code> 이 지정되지 않은 경우, 모든 타겟 의존성을 가져옵니다.</p>
<p>인기 있는 크레이트를 다운로드하는 명령어를 추가하는 <a href="https://crates.io/crates/cargo-prefetch">cargo-prefetch</a> 플러그인도 참조하세요. <code>--offline</code> 플래그를 사용하여 네트워크 없이 Cargo를 사용할 계획이라면 유용할 수 있습니다.</p>
<h2 id="옵션-8"><a class="header" href="#옵션-8">옵션</a></h2>
<h3 id="fetch-옵션"><a class="header" href="#fetch-옵션">Fetch 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fetch---target"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---target"><code>--target</code> <em>triple</em></a></dt>
<dd class="option-desc"><p>Fetch for the specified target architecture. Flag may be specified multiple times. The default is all architectures. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>.</p>
<p>Possible values:</p>
<ul>
<li>Any supported target in <code>rustc --print target-list</code>.</li>
<li><code>"host-tuple"</code>, which will internally be substituted by the host’s target. This can be particularly useful if you’re cross-compiling some crates, and don’t want to specify your host’s machine as a target (for instance, an <code>xtask</code> in a shared project that may be worked on by many hosts).</li>
<li>A path to a custom target specification. See <a href="commands/../../rustc/targets/custom.html#custom-target-lookup-path">Custom Target Lookup Path</a> for more information.</li>
</ul>
<p>This may also be specified with the <code>build.target</code> <a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../reference/build-cache.html">build cache</a> documentation for more details.</p>
</dd>
</dl>
<h3 id="표시-옵션-7"><a class="header" href="#표시-옵션-7">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fetch--v"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-fetch---verbose"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-fetch--q"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-fetch---quiet"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-fetch---color"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="매니페스트-옵션-7"><a class="header" href="#매니페스트-옵션-7">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fetch---manifest-path"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-fetch---locked"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-fetch---offline"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-fetch---frozen"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션-7"><a class="header" href="#공통-옵션-7">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fetch-+toolchain"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-fetch---config"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-fetch--C"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-fetch--h"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-fetch---help"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-fetch--Z"><a class="option-anchor" href="commands/cargo-fetch.html#option-cargo-fetch--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-10"><a class="header" href="#환경-변수-10">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-7"><a class="header" href="#종료-상태-7">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-22"><a class="header" href="#예제-22">예제</a></h2>
<ol>
<li>
<p>모든 의존성 가져오기:</p>
<pre><code>cargo fetch
</code></pre>
</li>
</ol>
<h2 id="참고-항목-9"><a class="header" href="#참고-항목-9">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-update.html">cargo-update(1)</a>, <a href="commands/cargo-generate-lockfile.html">cargo-generate-lockfile(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-fix1"><a class="header" href="#cargo-fix1">cargo-fix(1)</a></h1>
<h2 id="이름-10"><a class="header" href="#이름-10">이름</a></h2>
<p>cargo-fix — rustc가 보고한 린트 경고를 자동으로 수정</p>
<h2 id="사용법-9"><a class="header" href="#사용법-9">사용법</a></h2>
<p><code>cargo fix</code> [<em>옵션</em>]</p>
<h2 id="설명-10"><a class="header" href="#설명-10">설명</a></h2>
<p>이 Cargo 하위 명령어는 경고와 같은 진단에서 rustc의 제안을 자동으로 가져와 소스 코드에 적용합니다. 이는 rustc가 이미 수정 방법을 알려주는 작업을 자동화하는 데 도움을 주기 위한 것입니다!</p>
<p><code>cargo fix</code> 를 실행하면 내부적으로 <a href="commands/cargo-check.html">cargo-check(1)</a> 이 실행됩니다. 크레이트에 적용 가능한 경고는 자동으로 수정되며(가능한 경우), 체크 프로세스가 완료되면 남은 모든 경고가 표시됩니다. 예를 들어 현재 패키지에 모든 수정을 적용하려면 다음을 실행할 수 있습니다:</p>
<pre><code>cargo fix
</code></pre>
<p>이는 <code>cargo check --all-targets</code> 와 동일하게 동작합니다.</p>
<p><code>cargo fix</code> 는 일반적으로 <code>cargo check</code> 로 컴파일되는 코드만 수정할 수 있습니다. 코드가 선택적 기능으로 조건부 활성화되는 경우 해당 코드를 분석하려면 해당 기능을 활성화해야 합니다:</p>
<pre><code>cargo fix --features foo
</code></pre>
<p>마찬가지로 플랫폼별 코드와 같은 다른 <code>cfg</code> 표현식은 주어진 타겟에 대한 코드를 수정하기 위해 <code>--target</code> 을 전달해야 합니다.</p>
<pre><code>cargo fix --target x86_64-pc-windows-gnu
</code></pre>
<p><code>cargo fix</code> 에 문제가 발생하거나 질문 또는 기능 요청이 있는 경우 주저하지 말고 <a href="https://github.com/rust-lang/cargo">https://github.com/rust-lang/cargo</a>에 이슈를 제기해 주세요.</p>
<h3 id="에디션-마이그레이션"><a class="header" href="#에디션-마이그레이션">에디션 마이그레이션</a></h3>
<p><code>cargo fix</code> 하위 명령어는 패키지를 한 <a href="https://doc.rust-lang.org/edition-guide/editions/transitioning-an-existing-project-to-a-new-edition.html">에디션</a> 에서 다음 에디션으로 마이그레이션하는 데에도 사용할 수 있습니다. 일반적인 절차는 다음과 같습니다:</p>
<ol>
<li><code>cargo fix --edition</code> 을 실행합니다. 프로젝트에 여러 기능이 있는 경우 <code>--all-features</code> 플래그를 사용하는 것도 고려하세요. 프로젝트에 <code>cfg</code> 속성으로 게이트된 플랫폼별 코드가 있는 경우 다른 <code>--target</code> 플래그를 사용하여 <code>cargo fix --edition</code> 을 여러 번 실행할 수도 있습니다.</li>
<li><a href="commands/../reference/manifest.html#the-edition-field">에디션 필드</a> 를 새 에디션으로 설정하도록 <code>Cargo.toml</code> 을 수정합니다.</li>
<li>프로젝트 테스트를 실행하여 모든 것이 여전히 작동하는지 확인합니다. 새로운 경고가 발생하면 <code>cargo fix</code> 를 다시 실행하여( <code>--edition</code> 플래그 없이) 컴파일러가 제공하는 제안을 적용하는 것을 고려할 수 있습니다.</li>
</ol>
<p>그리고 이것으로 끝이기를 바랍니다! <code>cargo fix</code> 가 비활성 기능이나 <code>cfg</code> 표현식에 대한 코드를 업데이트할 수 없다는 위에 언급된 주의 사항을 명심하세요. 또한 드문 경우지만 컴파일러가 모든 코드를 새 에디션으로 자동으로 마이그레이션할 수 없으며, 새 에디션으로 빌드한 후 수동 변경이 필요할 수 있습니다.</p>
<h2 id="옵션-9"><a class="header" href="#옵션-9">옵션</a></h2>
<h3 id="fix-옵션"><a class="header" href="#fix-옵션">Fix 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix---broken-code"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---broken-code"><code>--broken-code</code></a></dt>
<dd class="option-desc"><p>Fix code even if it already has compiler errors. This is useful if <code>cargo fix</code>
fails to apply the changes. It will apply the changes and leave the broken
code in the working directory for you to inspect and manually fix.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---edition"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---edition"><code>--edition</code></a></dt>
<dd class="option-desc"><p>Apply changes that will update the code to the next edition. This will not
update the edition in the <code>Cargo.toml</code> manifest, which must be updated
manually after <code>cargo fix --edition</code> has finished.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---edition-idioms"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---edition-idioms"><code>--edition-idioms</code></a></dt>
<dd class="option-desc"><p>Apply suggestions that will update code to the preferred style for the current
edition.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---allow-no-vcs"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---allow-no-vcs"><code>--allow-no-vcs</code></a></dt>
<dd class="option-desc"><p>Fix code even if a VCS was not detected.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---allow-dirty"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---allow-dirty"><code>--allow-dirty</code></a></dt>
<dd class="option-desc"><p>Fix code even if the working directory has changes (including staged changes).</p>
</dd>
<dt class="option-term" id="option-cargo-fix---allow-staged"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---allow-staged"><code>--allow-staged</code></a></dt>
<dd class="option-desc"><p>Fix code even if the working directory has staged changes.</p>
</dd>
</dl>
<h3 id="패키지-선택-6"><a class="header" href="#패키지-선택-6">패키지 선택</a></h3>
<p>기본적으로 패키지 선택 옵션이 주어지지 않으면, 선택된 패키지는 선택된 매니페스트 파일에 따라 달라집니다 (<code>--manifest-path</code> 가 주어지지 않은 경우 현재 작업 디렉토리를 기준으로 함). 매니페스트가 워크스페이스의 루트인 경우 워크스페이스의 기본 구성원들이 선택되고, 그렇지 않으면 매니페스트에 정의된 패키지만 선택됩니다.</p>
<p>워크스페이스의 기본 구성원은 루트 매니페스트의 <code>workspace.default-members</code> 키로 명시적으로 설정할 수 있습니다. 이 값이 설정되지 않은 경우, 가상 워크스페이스(virtual workspace)는 모든 워크스페이스 구성원을 포함하며(<code>--workspace</code>를 전달하는 것과 동일), 가상이 아닌 워크스페이스는 루트 크레이트 자체만 포함합니다.</p>
<dl>
<dt class="option-term" id="option-cargo-fix--p"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--p"><code>-p</code> <em>spec</em>…</a></dt>
<dt class="option-term" id="option-cargo-fix---package"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---package"><code>--package</code> <em>spec</em>…</a></dt>
<dd class="option-desc"><p>Fix only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---workspace"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---workspace"><code>--workspace</code></a></dt>
<dd class="option-desc"><p>Fix all members in the workspace.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---all"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---all"><code>--all</code></a></dt>
<dd class="option-desc"><p>Deprecated alias for <code>--workspace</code>.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---exclude"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---exclude"><code>--exclude</code> <em>SPEC</em>…</a></dt>
<dd class="option-desc"><p>Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</p>
</dd>
</dl>
<h3 id="타겟-선택-4"><a class="header" href="#타겟-선택-4">타겟 선택</a></h3>
<p>타겟 선택 옵션이 주어지지 않으면 <code>cargo fix</code> 는 모든 타겟을 수정합니다(<code>--all-targets</code> 가 암시됨). <code>required-features</code> 가 누락된 바이너리는 건너뜁니다.</p>
<p>타겟 선택 플래그를 전달하면 지정된 타겟만 수정됩니다.</p>
<p><code>--bin</code>, <code>--example</code>, <code>--test</code>, <code>--bench</code> 플래그는 <code>*</code>, <code>?</code>, <code>[]</code> 와 같은 일반적인 유닉스 글로브 패턴도 지원합니다. 하지만 Cargo가 처리하기 전에 셸이 실수로 글로브 패턴을 확장하는 것을 방지하기 위해, 각 글로브 패턴을 작은따옴표나 큰따옴표로 감싸야 합니다.</p>
<dl>
<dt class="option-term" id="option-cargo-fix---lib"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---lib"><code>--lib</code></a></dt>
<dd class="option-desc"><p>Fix the package’s library.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---bin"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---bin"><code>--bin</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Fix the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---bins"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---bins"><code>--bins</code></a></dt>
<dd class="option-desc"><p>Fix all binary targets.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---example"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---example"><code>--example</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Fix the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---examples"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---examples"><code>--examples</code></a></dt>
<dd class="option-desc"><p>Fix all example targets.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---test"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---test"><code>--test</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Fix the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---tests"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---tests"><code>--tests</code></a></dt>
<dd class="option-desc"><p>Fix all targets that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---bench"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---bench"><code>--bench</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Fix the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---benches"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---benches"><code>--benches</code></a></dt>
<dd class="option-desc"><p>Fix all targets that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---all-targets"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---all-targets"><code>--all-targets</code></a></dt>
<dd class="option-desc"><p>Fix all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</p>
</dd>
</dl>
<h3 id="기능-선택-4"><a class="header" href="#기능-선택-4">기능 선택</a></h3>
<p>기능 플래그를 통해 어떤 기능을 활성화할지 제어할 수 있습니다. 기능 옵션이 주어지지 않으면, 선택된 모든 패키지에 대해 <code>default</code> 기능이 활성화됩니다.</p>
<p>자세한 내용은 <a href="commands/../reference/features.html#command-line-feature-options">기능 문서</a>를 참조하세요.</p>
<dl>
<dt class="option-term" id="option-cargo-fix--F"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--F"><code>-F</code> <em>features</em></a></dt>
<dt class="option-term" id="option-cargo-fix---features"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---features"><code>--features</code> <em>features</em></a></dt>
<dd class="option-desc"><p>Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---all-features"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---all-features"><code>--all-features</code></a></dt>
<dd class="option-desc"><p>Activate all available features of all selected packages.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---no-default-features"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---no-default-features"><code>--no-default-features</code></a></dt>
<dd class="option-desc"><p>Do not activate the <code>default</code> feature of the selected packages.</p>
</dd>
</dl>
<h3 id="컴파일-옵션-4"><a class="header" href="#컴파일-옵션-4">컴파일 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix---target"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---target"><code>--target</code> <em>triple</em></a></dt>
<dd class="option-desc"><p>Fix for the specified target architecture. Flag may be specified multiple times. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>.</p>
<p>Possible values:</p>
<ul>
<li>Any supported target in <code>rustc --print target-list</code>.</li>
<li><code>"host-tuple"</code>, which will internally be substituted by the host’s target. This can be particularly useful if you’re cross-compiling some crates, and don’t want to specify your host’s machine as a target (for instance, an <code>xtask</code> in a shared project that may be worked on by many hosts).</li>
<li>A path to a custom target specification. See <a href="commands/../../rustc/targets/custom.html#custom-target-lookup-path">Custom Target Lookup Path</a> for more information.</li>
</ul>
<p>This may also be specified with the <code>build.target</code> <a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../reference/build-cache.html">build cache</a> documentation for more details.</p>
</dd>
<dt class="option-term" id="option-cargo-fix--r"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--r"><code>-r</code></a></dt>
<dt class="option-term" id="option-cargo-fix---release"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---release"><code>--release</code></a></dt>
<dd class="option-desc"><p>Fix optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---profile"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---profile"><code>--profile</code> <em>name</em></a></dt>
<dd class="option-desc"><p>Fix with the given profile.</p>
<p>As a special case, specifying the <code>test</code> profile will also enable checking in
test mode which will enable checking tests and enable the <code>test</code> cfg option.
See <a href="https://doc.rust-lang.org/rustc/tests/index.html">rustc tests</a> for more
detail.</p>
<p>See <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---timings"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---timings"><code>--timings</code></a></dt>
<dd class="option-desc"><p>Output information how long each compilation takes, and track concurrency
information over time.</p>
<p>A file <code>cargo-timing.html</code> will be written to the <code>target/cargo-timings</code>
directory at the end of the build. An additional report with a timestamp
in its filename is also written if you want to look at a previous run.
These reports are suitable for human consumption only, and do not provide
machine-readable timing data.</p>
</dd>
</dl>
<h3 id="출력-옵션-4"><a class="header" href="#출력-옵션-4">출력 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix---target-dir"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---target-dir"><code>--target-dir</code> <em>directory</em></a></dt>
<dd class="option-desc"><p>Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</p>
</dd>
</dl>
<h3 id="표시-옵션-8"><a class="header" href="#표시-옵션-8">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix--v"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-fix---verbose"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-fix--q"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-fix---quiet"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---color"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---message-format"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---message-format"><code>--message-format</code> <em>fmt</em></a></dt>
<dd class="option-desc"><p>The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the “short” rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc’s default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo’s own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul>
</dd>
</dl>
<h3 id="매니페스트-옵션-8"><a class="header" href="#매니페스트-옵션-8">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix---manifest-path"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---ignore-rust-version"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---ignore-rust-version"><code>--ignore-rust-version</code></a></dt>
<dd class="option-desc"><p>Ignore <code>rust-version</code> specification in packages.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---locked"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---offline"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---frozen"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션-8"><a class="header" href="#공통-옵션-8">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix-+toolchain"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---config"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-fix--C"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-fix--h"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-fix---help"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-fix--Z"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h3 id="기타-옵션-4"><a class="header" href="#기타-옵션-4">기타 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-fix--j"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix--j"><code>-j</code> <em>N</em></a></dt>
<dt class="option-term" id="option-cargo-fix---jobs"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---jobs"><code>--jobs</code> <em>N</em></a></dt>
<dd class="option-desc"><p>Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value. If
a string <code>default</code> is provided, it sets the value back to defaults.
Should not be 0.</p>
</dd>
<dt class="option-term" id="option-cargo-fix---keep-going"><a class="option-anchor" href="commands/cargo-fix.html#option-cargo-fix---keep-going"><code>--keep-going</code></a></dt>
<dd class="option-desc"><p>Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build.</p>
<p>For example if the current package depends on dependencies <code>fails</code> and <code>works</code>,
one of which fails to build, <code>cargo fix -j1</code> may or may not build the
one that succeeds (depending on which one of the two builds Cargo picked to run
first), whereas <code>cargo fix -j1 --keep-going</code> would definitely run both
builds, even if the one run first fails.</p>
</dd>
</dl>
<h2 id="환경-변수-11"><a class="header" href="#환경-변수-11">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-8"><a class="header" href="#종료-상태-8">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-23"><a class="header" href="#예제-23">예제</a></h2>
<ol>
<li>
<p>로컬 패키지에 컴파일러 제안 적용:</p>
<pre><code>cargo fix
</code></pre>
</li>
<li>
<p>다음 에디션을 준비하기 위해 패키지 업데이트:</p>
<pre><code>cargo fix --edition
</code></pre>
</li>
<li>
<p>현재 에디션에 대한 권장 관용구 적용:</p>
<pre><code>cargo fix --edition-idioms
</code></pre>
</li>
</ol>
<h2 id="참고-항목-10"><a class="header" href="#참고-항목-10">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-check.html">cargo-check(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-fmt1"><a class="header" href="#cargo-fmt1">cargo-fmt(1)</a></h1>
<h2 id="이름-11"><a class="header" href="#이름-11">이름</a></h2>
<p>cargo-fmt — rustfmt를 사용하여 현재 크레이트의 모든 bin 및 lib 파일 형식 지정</p>
<h2 id="설명-11"><a class="header" href="#설명-11">설명</a></h2>
<p>이것은 Rust 툴체인과 함께 배포되는 외부 명령어로, 선택적 구성 요소입니다. Cargo에 내장되어 있지 않으며 추가 설치가 필요할 수 있습니다.</p>
<p>사용법 및 설치에 대한 정보는 <a href="https://github.com/rust-lang/rustfmt">https://github.com/rust-lang/rustfmt</a>를 참조하세요.</p>
<h2 id="참고-항목-11"><a class="header" href="#참고-항목-11">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-fix.html">cargo-fix(1)</a>, <a href="commands/cargo-clippy.html">cargo-clippy(1)</a>, <a href="commands/../reference/external-tools.html#custom-subcommands">사용자 지정 하위 명령어</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-miri1"><a class="header" href="#cargo-miri1">cargo-miri(1)</a></h1>
<h2 id="이름-12"><a class="header" href="#이름-12">이름</a></h2>
<p>cargo-miri — Miri에서 바이너리 크레이트 및 테스트 실행</p>
<h2 id="설명-12"><a class="header" href="#설명-12">설명</a></h2>
<p>이것은 Rust 툴체인과 함께 배포되는 외부 명령어로, 선택적 구성 요소입니다. Cargo에 내장되어 있지 않으며 추가 설치가 필요할 수 있습니다.</p>
<p>이 명령어는 <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly</a> 채널에서만 사용할 수 있습니다.</p>
<p>사용법 및 설치에 대한 정보는 <a href="https://github.com/rust-lang/miri">https://github.com/rust-lang/miri</a>를 참조하세요.</p>
<h2 id="참고-항목-12"><a class="header" href="#참고-항목-12">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-run.html">cargo-run(1)</a>, <a href="commands/cargo-test.html">cargo-test(1)</a>, <a href="commands/../reference/external-tools.html#custom-subcommands">사용자 지정 하위 명령어</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-run1"><a class="header" href="#cargo-run1">cargo-run(1)</a></h1>
<h2 id="이름-13"><a class="header" href="#이름-13">이름</a></h2>
<p>cargo-run — 현재 패키지 실행</p>
<h2 id="사용법-10"><a class="header" href="#사용법-10">사용법</a></h2>
<p><code>cargo run</code> [<em>옵션</em>] [<code>--</code> <em>인수</em>]</p>
<h2 id="설명-13"><a class="header" href="#설명-13">설명</a></h2>
<p>로컬 패키지의 바이너리 또는 예제를 실행합니다.</p>
<p>두 개의 대시(<code>--</code>) 뒤에 오는 모든 인수는 실행할 바이너리로 전달됩니다. Cargo와 바이너리 모두에 인수를 전달하는 경우, <code>--</code> 뒤에 있는 인수는 바이너리로, 그 앞에 있는 인수는 Cargo로 전달됩니다.</p>
<p><a href="commands/cargo-test.html">cargo-test(1)</a> 및 <a href="commands/cargo-bench.html">cargo-bench(1)</a> 과 달리 <code>cargo run</code> 은 실행된 바이너리의 작업 디렉토리를 셸에서 직접 실행한 것과 동일하게 현재 작업 디렉토리로 설정합니다.</p>
<h2 id="옵션-10"><a class="header" href="#옵션-10">옵션</a></h2>
<h3 id="패키지-선택-7"><a class="header" href="#패키지-선택-7">패키지 선택</a></h3>
<p>기본적으로 현재 작업 디렉토리의 패키지가 선택됩니다. <code>-p</code> 플래그를 사용하여 워크스페이스의 다른 패키지를 선택할 수 있습니다.</p>
<dl>
<dt class="option-term" id="option-cargo-run--p"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--p"><code>-p</code> <em>spec</em></a></dt>
<dt class="option-term" id="option-cargo-run---package"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---package"><code>--package</code> <em>spec</em></a></dt>
<dd class="option-desc"><p>The package to run. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC
format.</p>
</dd>
</dl>
<h3 id="타겟-선택-5"><a class="header" href="#타겟-선택-5">타겟 선택</a></h3>
<p>타겟 선택 옵션이 주어지지 않으면 <code>cargo run</code> 은 바이너리 타겟을 실행합니다. 바이너리 타겟이 여러 개인 경우 타겟 플래그를 전달하여 하나를 선택해야 합니다. 또는 <code>Cargo.toml</code> 의 <code>[package]</code> 섹션에 <code>default-run</code> 필드를 지정하여 기본적으로 실행할 바이너리 이름을 선택할 수 있습니다.</p>
<dl>
<dt class="option-term" id="option-cargo-run---bin"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---bin"><code>--bin</code> <em>name</em></a></dt>
<dd class="option-desc"><p>Run the specified binary.</p>
</dd>
<dt class="option-term" id="option-cargo-run---example"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---example"><code>--example</code> <em>name</em></a></dt>
<dd class="option-desc"><p>Run the specified example.</p>
</dd>
</dl>
<h3 id="기능-선택-5"><a class="header" href="#기능-선택-5">기능 선택</a></h3>
<p>기능 플래그를 통해 어떤 기능을 활성화할지 제어할 수 있습니다. 기능 옵션이 주어지지 않으면, 선택된 모든 패키지에 대해 <code>default</code> 기능이 활성화됩니다.</p>
<p>자세한 내용은 <a href="commands/../reference/features.html#command-line-feature-options">기능 문서</a>를 참조하세요.</p>
<dl>
<dt class="option-term" id="option-cargo-run--F"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--F"><code>-F</code> <em>features</em></a></dt>
<dt class="option-term" id="option-cargo-run---features"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---features"><code>--features</code> <em>features</em></a></dt>
<dd class="option-desc"><p>Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</p>
</dd>
<dt class="option-term" id="option-cargo-run---all-features"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---all-features"><code>--all-features</code></a></dt>
<dd class="option-desc"><p>Activate all available features of all selected packages.</p>
</dd>
<dt class="option-term" id="option-cargo-run---no-default-features"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---no-default-features"><code>--no-default-features</code></a></dt>
<dd class="option-desc"><p>Do not activate the <code>default</code> feature of the selected packages.</p>
</dd>
</dl>
<h3 id="컴파일-옵션-5"><a class="header" href="#컴파일-옵션-5">컴파일 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run---target"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---target"><code>--target</code> <em>triple</em></a></dt>
<dd class="option-desc"><p>Run for the specified target architecture. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>.</p>
<p>Possible values:</p>
<ul>
<li>Any supported target in <code>rustc --print target-list</code>.</li>
<li><code>"host-tuple"</code>, which will internally be substituted by the host’s target. This can be particularly useful if you’re cross-compiling some crates, and don’t want to specify your host’s machine as a target (for instance, an <code>xtask</code> in a shared project that may be worked on by many hosts).</li>
<li>A path to a custom target specification. See <a href="commands/../../rustc/targets/custom.html#custom-target-lookup-path">Custom Target Lookup Path</a> for more information.</li>
</ul>
<p>This may also be specified with the <code>build.target</code> <a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../reference/build-cache.html">build cache</a> documentation for more details.</p>
</dd>
<dt class="option-term" id="option-cargo-run--r"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--r"><code>-r</code></a></dt>
<dt class="option-term" id="option-cargo-run---release"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---release"><code>--release</code></a></dt>
<dd class="option-desc"><p>Run optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</p>
</dd>
<dt class="option-term" id="option-cargo-run---profile"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---profile"><code>--profile</code> <em>name</em></a></dt>
<dd class="option-desc"><p>Run with the given profile.
See <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</p>
</dd>
<dt class="option-term" id="option-cargo-run---timings"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---timings"><code>--timings</code></a></dt>
<dd class="option-desc"><p>Output information how long each compilation takes, and track concurrency
information over time.</p>
<p>A file <code>cargo-timing.html</code> will be written to the <code>target/cargo-timings</code>
directory at the end of the build. An additional report with a timestamp
in its filename is also written if you want to look at a previous run.
These reports are suitable for human consumption only, and do not provide
machine-readable timing data.</p>
</dd>
</dl>
<h3 id="출력-옵션-5"><a class="header" href="#출력-옵션-5">출력 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run---target-dir"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---target-dir"><code>--target-dir</code> <em>directory</em></a></dt>
<dd class="option-desc"><p>Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</p>
</dd>
</dl>
<h3 id="표시-옵션-9"><a class="header" href="#표시-옵션-9">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run--v"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-run---verbose"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-run--q"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-run---quiet"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-run---color"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-run---message-format"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---message-format"><code>--message-format</code> <em>fmt</em></a></dt>
<dd class="option-desc"><p>The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the “short” rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc’s default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo’s own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul>
</dd>
</dl>
<h3 id="매니페스트-옵션-9"><a class="header" href="#매니페스트-옵션-9">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run---manifest-path"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-run---ignore-rust-version"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---ignore-rust-version"><code>--ignore-rust-version</code></a></dt>
<dd class="option-desc"><p>Ignore <code>rust-version</code> specification in packages.</p>
</dd>
<dt class="option-term" id="option-cargo-run---locked"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-run---offline"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-run---frozen"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션-9"><a class="header" href="#공통-옵션-9">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run-+toolchain"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-run---config"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-run--C"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-run--h"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-run---help"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-run--Z"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h3 id="기타-옵션-5"><a class="header" href="#기타-옵션-5">기타 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-run--j"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run--j"><code>-j</code> <em>N</em></a></dt>
<dt class="option-term" id="option-cargo-run---jobs"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---jobs"><code>--jobs</code> <em>N</em></a></dt>
<dd class="option-desc"><p>Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value. If
a string <code>default</code> is provided, it sets the value back to defaults.
Should not be 0.</p>
</dd>
<dt class="option-term" id="option-cargo-run---keep-going"><a class="option-anchor" href="commands/cargo-run.html#option-cargo-run---keep-going"><code>--keep-going</code></a></dt>
<dd class="option-desc"><p>Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build.</p>
<p>For example if the current package depends on dependencies <code>fails</code> and <code>works</code>,
one of which fails to build, <code>cargo run -j1</code> may or may not build the
one that succeeds (depending on which one of the two builds Cargo picked to run
first), whereas <code>cargo run -j1 --keep-going</code> would definitely run both
builds, even if the one run first fails.</p>
</dd>
</dl>
<h2 id="환경-변수-12"><a class="header" href="#환경-변수-12">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-9"><a class="header" href="#종료-상태-9">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-24"><a class="header" href="#예제-24">예제</a></h2>
<ol>
<li>
<p>로컬 패키지를 빌드하고 메인 타겟을 실행합니다(바이너리가 하나만 있다고 가정):</p>
<pre><code>cargo run
</code></pre>
</li>
<li>
<p>추가 인수와 함께 예제 실행:</p>
<pre><code>cargo run --example exname -- --exoption exarg1 exarg2
</code></pre>
</li>
</ol>
<h2 id="참고-항목-13"><a class="header" href="#참고-항목-13">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-build.html">cargo-build(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-rustc1"><a class="header" href="#cargo-rustc1">cargo-rustc(1)</a></h1>
<h2 id="이름-14"><a class="header" href="#이름-14">이름</a></h2>
<p>cargo-rustc — 현재 패키지를 컴파일하고 컴파일러에 추가 옵션을 전달</p>
<h2 id="사용법-11"><a class="header" href="#사용법-11">사용법</a></h2>
<p><code>cargo rustc</code> [<em>옵션</em>] [<code>--</code> <em>인수</em>]</p>
<h2 id="설명-14"><a class="header" href="#설명-14">설명</a></h2>
<p>현재 패키지(또는 제공된 경우 <code>-p</code> 로 지정된 패키지)의 지정된 타겟은 모든 의존성과 함께 컴파일됩니다. 지정된 <em>인수</em> 는 모두 의존성이 아닌 최종 컴파일러 호출에 전달됩니다. 컴파일러는 여전히 <code>-L</code>, <code>--extern</code> 및 <code>--crate-type</code> 과 같은 인수를 무조건 수신하며, 지정된 <em>인수</em> 는 단순히 컴파일러 호출에 추가됩니다.</p>
<p>rustc 플래그에 대한 문서는 <a href="https://doc.rust-lang.org/rustc/index.html">https://doc.rust-lang.org/rustc/index.html</a>을 참조하세요.</p>
<p>이 명령어는 추가 인수가 제공될 때 하나의 타겟만 컴파일되어야 합니다. 현재 패키지에 둘 이상의 타겟을 사용할 수 있는 경우 <code>--lib</code>, <code>--bin</code> 등의 필터를 사용하여 컴파일할 타겟을 선택해야 합니다.</p>
<p>Cargo에 의해 생성된 모든 컴파일러 프로세스에 플래그를 전달하려면 <code>RUSTFLAGS</code> <a href="commands/../reference/environment-variables.html">환경 변수</a> 또는 <code>build.rustflags</code> <a href="commands/../reference/config.html">설정 값</a> 을 사용하세요.</p>
<h2 id="옵션-11"><a class="header" href="#옵션-11">옵션</a></h2>
<h3 id="패키지-선택-8"><a class="header" href="#패키지-선택-8">패키지 선택</a></h3>
<p>기본적으로 현재 작업 디렉토리의 패키지가 선택됩니다. <code>-p</code> 플래그를 사용하여 워크스페이스의 다른 패키지를 선택할 수 있습니다.</p>
<dl>
<dt class="option-term" id="option-cargo-rustc--p"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--p"><code>-p</code> <em>spec</em></a></dt>
<dt class="option-term" id="option-cargo-rustc---package"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---package"><code>--package</code> <em>spec</em></a></dt>
<dd class="option-desc"><p>The package to build. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC
format.</p>
</dd>
</dl>
<h3 id="타겟-선택-6"><a class="header" href="#타겟-선택-6">타겟 선택</a></h3>
<p>타겟 선택 옵션이 주어지지 않으면 <code>cargo rustc</code> 는 선택된 패키지의 모든 바이너리 및 라이브러리 타겟을 빌드합니다.</p>
<p>Binary targets are automatically built if there is an integration test or benchmark being selected to build. This allows an integration test to execute the binary to exercise and test its behavior. The <code>CARGO_BIN_EXE_&lt;name&gt;</code> <a href="commands/../reference/environment-variables.html#environment-variables-cargo-sets-for-crates">environment variable</a> is set when the integration test is built and run so that it can use the <a href="https://doc.rust-lang.org/std/macro.env.html"><code>env</code> macro</a> or the <a href="https://doc.rust-lang.org/std/env/fn.var.html"><code>var</code> function</a> to locate the executable.</p>
<p>타겟 선택 플래그를 전달하면 지정된 타겟만 빌드합니다.</p>
<p><code>--bin</code>, <code>--example</code>, <code>--test</code>, <code>--bench</code> 플래그는 <code>*</code>, <code>?</code>, <code>[]</code> 와 같은 일반적인 유닉스 글로브 패턴도 지원합니다. 하지만 Cargo가 처리하기 전에 셸이 실수로 글로브 패턴을 확장하는 것을 방지하기 위해, 각 글로브 패턴을 작은따옴표나 큰따옴표로 감싸야 합니다.</p>
<dl>
<dt class="option-term" id="option-cargo-rustc---lib"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---lib"><code>--lib</code></a></dt>
<dd class="option-desc"><p>Build the package’s library.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---bin"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---bin"><code>--bin</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Build the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---bins"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---bins"><code>--bins</code></a></dt>
<dd class="option-desc"><p>Build all binary targets.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---example"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---example"><code>--example</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Build the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---examples"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---examples"><code>--examples</code></a></dt>
<dd class="option-desc"><p>Build all example targets.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---test"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---test"><code>--test</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Build the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---tests"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---tests"><code>--tests</code></a></dt>
<dd class="option-desc"><p>Build all targets that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---bench"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---bench"><code>--bench</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Build the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---benches"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---benches"><code>--benches</code></a></dt>
<dd class="option-desc"><p>Build all targets that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---all-targets"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---all-targets"><code>--all-targets</code></a></dt>
<dd class="option-desc"><p>Build all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</p>
</dd>
</dl>
<h3 id="기능-선택-6"><a class="header" href="#기능-선택-6">기능 선택</a></h3>
<p>기능 플래그를 통해 어떤 기능을 활성화할지 제어할 수 있습니다. 기능 옵션이 주어지지 않으면, 선택된 모든 패키지에 대해 <code>default</code> 기능이 활성화됩니다.</p>
<p>자세한 내용은 <a href="commands/../reference/features.html#command-line-feature-options">기능 문서</a>를 참조하세요.</p>
<dl>
<dt class="option-term" id="option-cargo-rustc--F"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--F"><code>-F</code> <em>features</em></a></dt>
<dt class="option-term" id="option-cargo-rustc---features"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---features"><code>--features</code> <em>features</em></a></dt>
<dd class="option-desc"><p>Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---all-features"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---all-features"><code>--all-features</code></a></dt>
<dd class="option-desc"><p>Activate all available features of all selected packages.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---no-default-features"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---no-default-features"><code>--no-default-features</code></a></dt>
<dd class="option-desc"><p>Do not activate the <code>default</code> feature of the selected packages.</p>
</dd>
</dl>
<h3 id="컴파일-옵션-6"><a class="header" href="#컴파일-옵션-6">컴파일 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc---target"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---target"><code>--target</code> <em>triple</em></a></dt>
<dd class="option-desc"><p>Build for the specified target architecture. Flag may be specified multiple times. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>.</p>
<p>Possible values:</p>
<ul>
<li>Any supported target in <code>rustc --print target-list</code>.</li>
<li><code>"host-tuple"</code>, which will internally be substituted by the host’s target. This can be particularly useful if you’re cross-compiling some crates, and don’t want to specify your host’s machine as a target (for instance, an <code>xtask</code> in a shared project that may be worked on by many hosts).</li>
<li>A path to a custom target specification. See <a href="commands/../../rustc/targets/custom.html#custom-target-lookup-path">Custom Target Lookup Path</a> for more information.</li>
</ul>
<p>This may also be specified with the <code>build.target</code> <a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../reference/build-cache.html">build cache</a> documentation for more details.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc--r"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--r"><code>-r</code></a></dt>
<dt class="option-term" id="option-cargo-rustc---release"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---release"><code>--release</code></a></dt>
<dd class="option-desc"><p>Build optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---profile"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---profile"><code>--profile</code> <em>name</em></a></dt>
<dd class="option-desc"><p>Build with the given profile.</p>
<p>The <code>rustc</code> subcommand will treat the following named profiles with special behaviors:</p>
<ul>
<li><code>check</code> — Builds in the same way as the <a href="commands/cargo-check.html">cargo-check(1)</a> command with
the <code>dev</code> profile.</li>
<li><code>test</code> — Builds in the same way as the <a href="commands/cargo-test.html">cargo-test(1)</a> command,
enabling building in test mode which will enable tests and enable the <code>test</code>
cfg option. See <a href="https://doc.rust-lang.org/rustc/tests/index.html">rustc
tests</a> for more detail.</li>
<li><code>bench</code> — Builds in the same was as the <a href="commands/cargo-bench.html">cargo-bench(1)</a> command,
similar to the <code>test</code> profile.</li>
</ul>
<p>See <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---timings"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---timings"><code>--timings</code></a></dt>
<dd class="option-desc"><p>Output information how long each compilation takes, and track concurrency
information over time.</p>
<p>A file <code>cargo-timing.html</code> will be written to the <code>target/cargo-timings</code>
directory at the end of the build. An additional report with a timestamp
in its filename is also written if you want to look at a previous run.
These reports are suitable for human consumption only, and do not provide
machine-readable timing data.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---crate-type"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---crate-type"><code>--crate-type</code> <em>crate-type</em></a></dt>
<dd class="option-desc"><p>Build for the given crate type. This flag accepts a comma-separated list of
1 or more crate types, of which the allowed values are the same as <code>crate-type</code>
field in the manifest for configuring a Cargo target. See
<a href="commands/../reference/cargo-targets.html#the-crate-type-field"><code>crate-type</code> field</a>
for possible values.</p>
<p>If the manifest contains a list, and <code>--crate-type</code> is provided,
the command-line argument value will override what is in the manifest.</p>
<p>This flag only works when building a <code>lib</code> or <code>example</code> library target.</p>
</dd>
</dl>
<h3 id="출력-옵션-6"><a class="header" href="#출력-옵션-6">출력 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc---target-dir"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---target-dir"><code>--target-dir</code> <em>directory</em></a></dt>
<dd class="option-desc"><p>Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</p>
</dd>
</dl>
<h3 id="표시-옵션-10"><a class="header" href="#표시-옵션-10">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc--v"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-rustc---verbose"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc--q"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-rustc---quiet"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---color"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---message-format"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---message-format"><code>--message-format</code> <em>fmt</em></a></dt>
<dd class="option-desc"><p>The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the “short” rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc’s default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo’s own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul>
</dd>
</dl>
<h3 id="매니페스트-옵션-10"><a class="header" href="#매니페스트-옵션-10">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc---manifest-path"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---ignore-rust-version"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---ignore-rust-version"><code>--ignore-rust-version</code></a></dt>
<dd class="option-desc"><p>Ignore <code>rust-version</code> specification in packages.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---locked"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---offline"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---frozen"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션-10"><a class="header" href="#공통-옵션-10">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc-+toolchain"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---config"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc--C"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-rustc--h"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-rustc---help"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc--Z"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h3 id="기타-옵션-6"><a class="header" href="#기타-옵션-6">기타 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustc--j"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc--j"><code>-j</code> <em>N</em></a></dt>
<dt class="option-term" id="option-cargo-rustc---jobs"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---jobs"><code>--jobs</code> <em>N</em></a></dt>
<dd class="option-desc"><p>Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value. If
a string <code>default</code> is provided, it sets the value back to defaults.
Should not be 0.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---keep-going"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---keep-going"><code>--keep-going</code></a></dt>
<dd class="option-desc"><p>Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build.</p>
<p>For example if the current package depends on dependencies <code>fails</code> and <code>works</code>,
one of which fails to build, <code>cargo rustc -j1</code> may or may not build the
one that succeeds (depending on which one of the two builds Cargo picked to run
first), whereas <code>cargo rustc -j1 --keep-going</code> would definitely run both
builds, even if the one run first fails.</p>
</dd>
<dt class="option-term" id="option-cargo-rustc---future-incompat-report"><a class="option-anchor" href="commands/cargo-rustc.html#option-cargo-rustc---future-incompat-report"><code>--future-incompat-report</code></a></dt>
<dd class="option-desc"><p>Displays a future-incompat report for any future-incompatible warnings
produced during execution of this command</p>
<p>See <a href="commands/cargo-report.html">cargo-report(1)</a></p>
</dd>
</dl>
<h2 id="환경-변수-13"><a class="header" href="#환경-변수-13">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-10"><a class="header" href="#종료-상태-10">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-25"><a class="header" href="#예제-25">예제</a></h2>
<ol>
<li>
<p>패키지(의존성 제외)가 안전하지 않은 코드를 사용하는지 확인:</p>
<pre><code>cargo rustc --lib -- -D unsafe-code
</code></pre>
</li>
<li>
<p>모든 타입의 크기를 출력하는 다음과 같은 실험적 플래그를 나이틀리 컴파일러에서 시도해 보세요:</p>
<pre><code>cargo rustc --lib -- -Z print-type-sizes
</code></pre>
</li>
<li>
<p>명령줄 옵션으로 Cargo.toml의 <code>crate-type</code> 필드 재정의:</p>
<pre><code>cargo rustc --lib --crate-type lib,cdylib
</code></pre>
</li>
</ol>
<h2 id="참고-항목-14"><a class="header" href="#참고-항목-14">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-build.html">cargo-build(1)</a>, <a href="https://doc.rust-lang.org/rustc/index.html">rustc(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-rustdoc1"><a class="header" href="#cargo-rustdoc1">cargo-rustdoc(1)</a></h1>
<h2 id="이름-15"><a class="header" href="#이름-15">이름</a></h2>
<p>cargo-rustdoc — 지정된 사용자 정의 플래그를 사용하여 패키지 문서 빌드</p>
<h2 id="사용법-12"><a class="header" href="#사용법-12">사용법</a></h2>
<p><code>cargo rustdoc</code> [<em>옵션</em>] [<code>--</code> <em>인수</em>]</p>
<h2 id="설명-15"><a class="header" href="#설명-15">설명</a></h2>
<p>현재 패키지(또는 제공된 경우 <code>-p</code> 로 지정된 패키지)의 지정된 타겟은 지정된 <em>인수</em> 가 최종 rustdoc 호출에 전달되어 문서화됩니다. 의존성은 이 명령의 일부로 문서화되지 않습니다. rustdoc은 여전히 <code>-L</code>, <code>--extern</code> 및 <code>--crate-type</code> 과 같은 인수를 무조건 수신하며, 지정된 <em>인수</em> 는 단순히 rustdoc 호출에 추가됩니다.</p>
<p>rustdoc 플래그에 대한 문서는 <a href="https://doc.rust-lang.org/rustdoc/index.html">https://doc.rust-lang.org/rustdoc/index.html</a>을 참조하세요.</p>
<p>이 명령어는 추가 인수가 제공될 때 하나의 타겟만 컴파일되어야 합니다. 현재 패키지에 둘 이상의 타겟을 사용할 수 있는 경우 <code>--lib</code>, <code>--bin</code> 등의 필터를 사용하여 컴파일할 타겟을 선택해야 합니다.</p>
<p>Cargo에 의해 생성된 모든 rustdoc 프로세스에 플래그를 전달하려면 <code>RUSTDOCFLAGS</code> <a href="commands/../reference/environment-variables.html">환경 변수</a> 또는 <code>build.rustdocflags</code> <a href="commands/../reference/config.html">설정 값</a> 을 사용하세요.</p>
<h2 id="옵션-12"><a class="header" href="#옵션-12">옵션</a></h2>
<h3 id="문서-옵션-1"><a class="header" href="#문서-옵션-1">문서 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---open"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---open"><code>--open</code></a></dt>
<dd class="option-desc"><p>Open the docs in a browser after building them. This will use your default
browser unless you define another one in the <code>BROWSER</code> environment variable
or use the <a href="commands/../reference/config.html#docbrowser"><code>doc.browser</code></a> configuration
option.</p>
</dd>
</dl>
<h3 id="패키지-선택-9"><a class="header" href="#패키지-선택-9">패키지 선택</a></h3>
<p>기본적으로 현재 작업 디렉토리의 패키지가 선택됩니다. <code>-p</code> 플래그를 사용하여 워크스페이스의 다른 패키지를 선택할 수 있습니다.</p>
<dl>
<dt class="option-term" id="option-cargo-rustdoc--p"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--p"><code>-p</code> <em>spec</em></a></dt>
<dt class="option-term" id="option-cargo-rustdoc---package"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---package"><code>--package</code> <em>spec</em></a></dt>
<dd class="option-desc"><p>The package to document. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC
format.</p>
</dd>
</dl>
<h3 id="타겟-선택-7"><a class="header" href="#타겟-선택-7">타겟 선택</a></h3>
<p>타겟 선택 옵션이 주어지지 않으면 <code>cargo rustdoc</code> 은 선택된 패키지의 모든 바이너리 및 라이브러리 타겟을 문서화합니다. 바이너리의 이름이 라이브러리 타겟과 같으면 바이너리는 건너뜁니다. <code>required-features</code> 가 누락된 경우 바이너리는 건너뜁니다.</p>
<p>타겟 선택 플래그를 전달하면 지정된 타겟만 문서화됩니다.</p>
<p><code>--bin</code>, <code>--example</code>, <code>--test</code>, <code>--bench</code> 플래그는 <code>*</code>, <code>?</code>, <code>[]</code> 와 같은 일반적인 유닉스 글로브 패턴도 지원합니다. 하지만 Cargo가 처리하기 전에 셸이 실수로 글로브 패턴을 확장하는 것을 방지하기 위해, 각 글로브 패턴을 작은따옴표나 큰따옴표로 감싸야 합니다.</p>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---lib"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---lib"><code>--lib</code></a></dt>
<dd class="option-desc"><p>Document the package’s library.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---bin"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---bin"><code>--bin</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Document the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---bins"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---bins"><code>--bins</code></a></dt>
<dd class="option-desc"><p>Document all binary targets.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---example"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---example"><code>--example</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Document the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---examples"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---examples"><code>--examples</code></a></dt>
<dd class="option-desc"><p>Document all example targets.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---test"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---test"><code>--test</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Document the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---tests"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---tests"><code>--tests</code></a></dt>
<dd class="option-desc"><p>Document all targets that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---bench"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---bench"><code>--bench</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Document the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---benches"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---benches"><code>--benches</code></a></dt>
<dd class="option-desc"><p>Document all targets that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---all-targets"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---all-targets"><code>--all-targets</code></a></dt>
<dd class="option-desc"><p>Document all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</p>
</dd>
</dl>
<h3 id="기능-선택-7"><a class="header" href="#기능-선택-7">기능 선택</a></h3>
<p>기능 플래그를 통해 어떤 기능을 활성화할지 제어할 수 있습니다. 기능 옵션이 주어지지 않으면, 선택된 모든 패키지에 대해 <code>default</code> 기능이 활성화됩니다.</p>
<p>자세한 내용은 <a href="commands/../reference/features.html#command-line-feature-options">기능 문서</a>를 참조하세요.</p>
<dl>
<dt class="option-term" id="option-cargo-rustdoc--F"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--F"><code>-F</code> <em>features</em></a></dt>
<dt class="option-term" id="option-cargo-rustdoc---features"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---features"><code>--features</code> <em>features</em></a></dt>
<dd class="option-desc"><p>Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---all-features"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---all-features"><code>--all-features</code></a></dt>
<dd class="option-desc"><p>Activate all available features of all selected packages.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---no-default-features"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---no-default-features"><code>--no-default-features</code></a></dt>
<dd class="option-desc"><p>Do not activate the <code>default</code> feature of the selected packages.</p>
</dd>
</dl>
<h3 id="컴파일-옵션-7"><a class="header" href="#컴파일-옵션-7">컴파일 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---target"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---target"><code>--target</code> <em>triple</em></a></dt>
<dd class="option-desc"><p>Document for the specified target architecture. Flag may be specified multiple times. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>.</p>
<p>Possible values:</p>
<ul>
<li>Any supported target in <code>rustc --print target-list</code>.</li>
<li><code>"host-tuple"</code>, which will internally be substituted by the host’s target. This can be particularly useful if you’re cross-compiling some crates, and don’t want to specify your host’s machine as a target (for instance, an <code>xtask</code> in a shared project that may be worked on by many hosts).</li>
<li>A path to a custom target specification. See <a href="commands/../../rustc/targets/custom.html#custom-target-lookup-path">Custom Target Lookup Path</a> for more information.</li>
</ul>
<p>This may also be specified with the <code>build.target</code> <a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../reference/build-cache.html">build cache</a> documentation for more details.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc--r"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--r"><code>-r</code></a></dt>
<dt class="option-term" id="option-cargo-rustdoc---release"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---release"><code>--release</code></a></dt>
<dd class="option-desc"><p>Document optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---profile"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---profile"><code>--profile</code> <em>name</em></a></dt>
<dd class="option-desc"><p>Document with the given profile.
See <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---timings"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---timings"><code>--timings</code></a></dt>
<dd class="option-desc"><p>Output information how long each compilation takes, and track concurrency
information over time.</p>
<p>A file <code>cargo-timing.html</code> will be written to the <code>target/cargo-timings</code>
directory at the end of the build. An additional report with a timestamp
in its filename is also written if you want to look at a previous run.
These reports are suitable for human consumption only, and do not provide
machine-readable timing data.</p>
</dd>
</dl>
<h3 id="출력-옵션-7"><a class="header" href="#출력-옵션-7">출력 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---target-dir"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---target-dir"><code>--target-dir</code> <em>directory</em></a></dt>
<dd class="option-desc"><p>Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</p>
</dd>
</dl>
<h3 id="표시-옵션-11"><a class="header" href="#표시-옵션-11">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc--v"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-rustdoc---verbose"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc--q"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-rustdoc---quiet"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---color"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---message-format"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---message-format"><code>--message-format</code> <em>fmt</em></a></dt>
<dd class="option-desc"><p>The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the “short” rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc’s default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo’s own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul>
</dd>
</dl>
<h3 id="매니페스트-옵션-11"><a class="header" href="#매니페스트-옵션-11">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc---manifest-path"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---ignore-rust-version"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---ignore-rust-version"><code>--ignore-rust-version</code></a></dt>
<dd class="option-desc"><p>Ignore <code>rust-version</code> specification in packages.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---locked"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---offline"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---frozen"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션-11"><a class="header" href="#공통-옵션-11">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc-+toolchain"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---config"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc--C"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc--h"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-rustdoc---help"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc--Z"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h3 id="기타-옵션-7"><a class="header" href="#기타-옵션-7">기타 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-rustdoc--j"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc--j"><code>-j</code> <em>N</em></a></dt>
<dt class="option-term" id="option-cargo-rustdoc---jobs"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---jobs"><code>--jobs</code> <em>N</em></a></dt>
<dd class="option-desc"><p>Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value. If
a string <code>default</code> is provided, it sets the value back to defaults.
Should not be 0.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---keep-going"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---keep-going"><code>--keep-going</code></a></dt>
<dd class="option-desc"><p>Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build.</p>
<p>For example if the current package depends on dependencies <code>fails</code> and <code>works</code>,
one of which fails to build, <code>cargo rustdoc -j1</code> may or may not build the
one that succeeds (depending on which one of the two builds Cargo picked to run
first), whereas <code>cargo rustdoc -j1 --keep-going</code> would definitely run both
builds, even if the one run first fails.</p>
</dd>
<dt class="option-term" id="option-cargo-rustdoc---output-format"><a class="option-anchor" href="commands/cargo-rustdoc.html#option-cargo-rustdoc---output-format"><code>--output-format</code></a></dt>
<dd class="option-desc"><p>The output type for the documentation emitted. Valid values:</p>
<ul>
<li><code>html</code> (default): Emit the documentation in HTML format.</li>
<li><code>json</code>: Emit the documentation in the <a href="https://doc.rust-lang.org/nightly/nightly-rustc/rustdoc_json_types">experimental JSON format</a>.</li>
</ul>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly channel</a>
and requires the <code>-Z unstable-options</code> flag to enable.</p>
</dd>
</dl>
<h2 id="환경-변수-14"><a class="header" href="#환경-변수-14">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-11"><a class="header" href="#종료-상태-11">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-26"><a class="header" href="#예제-26">예제</a></h2>
<ol>
<li>
<p>주어진 파일에서 포함된 사용자 정의 CSS로 문서 빌드:</p>
<pre><code>cargo rustdoc --lib -- --extend-css extra.css
</code></pre>
</li>
</ol>
<h2 id="참고-항목-15"><a class="header" href="#참고-항목-15">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-doc.html">cargo-doc(1)</a>, <a href="https://doc.rust-lang.org/rustdoc/index.html">rustdoc(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-test1"><a class="header" href="#cargo-test1">cargo-test(1)</a></h1>
<h2 id="이름-16"><a class="header" href="#이름-16">이름</a></h2>
<p>cargo-test — 패키지의 단위 및 통합 테스트 실행</p>
<h2 id="사용법-13"><a class="header" href="#사용법-13">사용법</a></h2>
<p><code>cargo test</code> [<em>옵션 <em>] [</em> 테스트이름</em>] [<code>--</code> <em>테스트-옵션</em>]</p>
<h2 id="설명-16"><a class="header" href="#설명-16">설명</a></h2>
<p>단위, 통합 및 문서 테스트를 컴파일하고 실행합니다.</p>
<p>테스트 필터링 인수 <code>TESTNAME</code> 과 두 개의 대시(<code>--</code>) 뒤에 오는 모든 인수는 테스트 바이너리로 전달되므로 <em>libtest</em>(rustc의 내장 단위 테스트 및 마이크로 벤치마킹 프레임워크)로 전달됩니다. Cargo와 바이너리 모두에 인수를 전달하는 경우, <code>--</code> 뒤에 있는 인수는 바이너리로, 그 앞에 있는 인수는 Cargo로 전달됩니다. libtest의 인수에 대한 자세한 내용은 <code>cargo test -- --help</code> 의 출력을 참조하고 <a href="https://doc.rust-lang.org/rustc/tests/index.html">https://doc.rust-lang.org/rustc/tests/index.html</a>에서 테스트 작동 방식에 대한 rustc 책의 장을 확인하세요.</p>
<p>예를 들어, 이름에 <code>foo</code> 가 포함된 테스트를 필터링하고 3개의 스레드에서 병렬로 실행합니다:</p>
<pre><code>cargo test foo -- --test-threads 3
</code></pre>
<p>테스트는 <code>rustc</code> 에 <code>--test</code> 옵션을 사용하여 빌드되며, 이는 libtest와 코드를 연결하여 특별한 실행 파일을 생성합니다. 실행 파일은 <code>#[test]</code> 속성으로 주석이 달린 모든 함수를 여러 스레드에서 자동으로 실행합니다. <code>#[bench]</code> 주석이 달린 함수도 기능하는지 확인하기 위해 1회 반복으로 실행됩니다.</p>
<p>패키지에 여러 테스트 타겟이 포함된 경우, 각 타겟은 앞서 언급한 대로 특별한 실행 파일로 컴파일된 다음 순차적으로 실행됩니다.</p>
<p>타겟 매니페스트 설정에서 <code>harness = false</code> 를 설정하여 libtest 하네스를 비활성화할 수 있으며, 이 경우 테스트 실행을 처리하기 위해 코드에서 자체 <code>main</code> 함수를 제공해야 합니다.</p>
<h3 id="문서-테스트"><a class="header" href="#문서-테스트">문서 테스트</a></h3>
<p>문서 테스트도 기본적으로 실행되며, <code>rustdoc</code> 에 의해 처리됩니다. 라이브러리 타겟의 문서 주석에서 코드 샘플을 추출한 다음 실행합니다.</p>
<p>일반 테스트 타겟과 달리 각 코드 블록은 <code>rustc</code> 를 사용하여 즉석에서 doctest 실행 파일로 컴파일됩니다. 이러한 실행 파일은 별도의 프로세스에서 병렬로 실행됩니다. 코드 블록의 컴파일은 사실 libtest에 의해 제어되는 테스트 함수의 일부이므로 <code>--jobs</code> 와 같은 일부 옵션은 적용되지 않을 수 있습니다. 이 doctest 실행 모델은 보장되지 않으며 향후 변경될 수 있으므로 이에 의존하지 않도록 주의하세요.</p>
<p>문서 테스트 작성에 대한 자세한 내용은 <a href="https://doc.rust-lang.org/rustdoc/">rustdoc 책</a> 을 참조하세요.</p>
<h3 id="테스트의-작업-디렉토리"><a class="header" href="#테스트의-작업-디렉토리">테스트의 작업 디렉토리</a></h3>
<p>각 단위 및 통합 테스트를 실행할 때의 작업 디렉토리는 테스트가 속한 패키지의 루트 디렉토리로 설정됩니다. 테스트의 작업 디렉토리를 패키지의 루트 디렉토리로 설정하면 <code>cargo test</code> 가 어디서 실행되었는지에 관계없이 테스트가 상대 경로를 사용하여 패키지의 파일에 안정적으로 액세스할 수 있습니다.</p>
<p>문서 테스트의 경우 <code>rustdoc</code> 을 호출할 때의 작업 디렉토리는 워크스페이스 루트 디렉토리로 설정되며, 이는 <code>rustdoc</code> 이 각 문서 테스트의 컴파일 디렉토리로 사용하는 디렉토리이기도 합니다. 각 문서 테스트를 실행할 때의 작업 디렉토리는 테스트가 속한 패키지의 루트 디렉토리로 설정되며, <code>rustdoc</code> 의 <code>--test-run-directory</code> 옵션을 통해 제어됩니다.</p>
<h2 id="옵션-13"><a class="header" href="#옵션-13">옵션</a></h2>
<h3 id="테스트-옵션"><a class="header" href="#테스트-옵션">테스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-test---no-run"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---no-run"><code>--no-run</code></a></dt>
<dd class="option-desc"><p>Compile, but don’t run tests.</p>
</dd>
<dt class="option-term" id="option-cargo-test---no-fail-fast"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---no-fail-fast"><code>--no-fail-fast</code></a></dt>
<dd class="option-desc"><p>Run all tests regardless of failure. Without this flag, Cargo will exit
after the first executable fails. The Rust test harness will run all tests
within the executable to completion, this flag only applies to the executable
as a whole.</p>
</dd>
</dl>
<h3 id="패키지-선택-10"><a class="header" href="#패키지-선택-10">패키지 선택</a></h3>
<p>기본적으로 패키지 선택 옵션이 주어지지 않으면, 선택된 패키지는 선택된 매니페스트 파일에 따라 달라집니다 (<code>--manifest-path</code> 가 주어지지 않은 경우 현재 작업 디렉토리를 기준으로 함). 매니페스트가 워크스페이스의 루트인 경우 워크스페이스의 기본 구성원들이 선택되고, 그렇지 않으면 매니페스트에 정의된 패키지만 선택됩니다.</p>
<p>워크스페이스의 기본 구성원은 루트 매니페스트의 <code>workspace.default-members</code> 키로 명시적으로 설정할 수 있습니다. 이 값이 설정되지 않은 경우, 가상 워크스페이스(virtual workspace)는 모든 워크스페이스 구성원을 포함하며(<code>--workspace</code>를 전달하는 것과 동일), 가상이 아닌 워크스페이스는 루트 크레이트 자체만 포함합니다.</p>
<dl>
<dt class="option-term" id="option-cargo-test--p"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--p"><code>-p</code> <em>spec</em>…</a></dt>
<dt class="option-term" id="option-cargo-test---package"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---package"><code>--package</code> <em>spec</em>…</a></dt>
<dd class="option-desc"><p>Test only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</p>
</dd>
<dt class="option-term" id="option-cargo-test---workspace"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---workspace"><code>--workspace</code></a></dt>
<dd class="option-desc"><p>Test all members in the workspace.</p>
</dd>
<dt class="option-term" id="option-cargo-test---all"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---all"><code>--all</code></a></dt>
<dd class="option-desc"><p>Deprecated alias for <code>--workspace</code>.</p>
</dd>
<dt class="option-term" id="option-cargo-test---exclude"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---exclude"><code>--exclude</code> <em>SPEC</em>…</a></dt>
<dd class="option-desc"><p>Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</p>
</dd>
</dl>
<h3 id="타겟-선택-8"><a class="header" href="#타겟-선택-8">타겟 선택</a></h3>
<p>타겟 선택 옵션이 주어지지 않으면 <code>cargo test</code> 는 선택된 패키지의 다음 타겟을 빌드합니다:</p>
<ul>
<li>lib — 바이너리, 예제, 통합 테스트 및 문서 테스트와 연결하는 데 사용됩니다</li>
<li>bins (통합 테스트가 빌드되고 필수 기능을 사용할 수 있는 경우에만)</li>
<li>examples — 컴파일되는지 확인하기 위해</li>
<li>단위 테스트로서의 lib</li>
<li>단위 테스트로서의 bins</li>
<li>통합 테스트</li>
<li>lib 타겟에 대한 문서 테스트</li>
</ul>
<p>기본 동작은 매니페스트 설정에서 타겟에 대한 <code>test</code> 플래그를 설정하여 변경할 수 있습니다. 예제를 <code>test = true</code> 로 설정하면 예제를 테스트로 빌드하고 실행하며, 예제의 <code>main</code> 함수를 libtest 하네스로 대체합니다. <code>main</code> 함수가 대체되는 것을 원하지 않으면 <code>harness = false</code> 도 포함하세요. 이 경우 예제는 그대로 빌드되고 실행됩니다.</p>
<p>타겟을 <code>test = false</code> 로 설정하면 기본적으로 테스트되지 않습니다. 이름으로 타겟을 선택하는 타겟 선택 옵션(예: <code>--example foo</code>)은 <code>test</code> 플래그를 무시하고 항상 주어진 타겟을 테스트합니다.</p>
<p>라이브러리에 대한 문서 테스트는 매니페스트에서 라이브러리에 대해 <code>doctest = false</code> 를 설정하여 비활성화할 수 있습니다.</p>
<p>타겟별 설정에 대한 자세한 내용은 <a href="commands/../reference/cargo-targets.html#configuring-a-target">타겟 구성하기</a>를 참조하세요.</p>
<p>Binary targets are automatically built if there is an integration test or benchmark being selected to test. This allows an integration test to execute the binary to exercise and test its behavior. The <code>CARGO_BIN_EXE_&lt;name&gt;</code> <a href="commands/../reference/environment-variables.html#environment-variables-cargo-sets-for-crates">environment variable</a> is set when the integration test is built and run so that it can use the <a href="https://doc.rust-lang.org/std/macro.env.html"><code>env</code> macro</a> or the <a href="https://doc.rust-lang.org/std/env/fn.var.html"><code>var</code> function</a> to locate the executable.</p>
<p>타겟 선택 플래그를 전달하면 지정된 타겟만 테스트합니다.</p>
<p><code>--bin</code>, <code>--example</code>, <code>--test</code>, <code>--bench</code> 플래그는 <code>*</code>, <code>?</code>, <code>[]</code> 와 같은 일반적인 유닉스 글로브 패턴도 지원합니다. 하지만 Cargo가 처리하기 전에 셸이 실수로 글로브 패턴을 확장하는 것을 방지하기 위해, 각 글로브 패턴을 작은따옴표나 큰따옴표로 감싸야 합니다.</p>
<dl>
<dt class="option-term" id="option-cargo-test---lib"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---lib"><code>--lib</code></a></dt>
<dd class="option-desc"><p>Test the package’s library.</p>
</dd>
<dt class="option-term" id="option-cargo-test---bin"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---bin"><code>--bin</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Test the specified binary. This flag may be specified multiple times
and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-test---bins"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---bins"><code>--bins</code></a></dt>
<dd class="option-desc"><p>Test all binary targets.</p>
</dd>
<dt class="option-term" id="option-cargo-test---example"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---example"><code>--example</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Test the specified example. This flag may be specified multiple times
and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-test---examples"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---examples"><code>--examples</code></a></dt>
<dd class="option-desc"><p>Test all example targets.</p>
</dd>
<dt class="option-term" id="option-cargo-test---test"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---test"><code>--test</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Test the specified integration test. This flag may be specified
multiple times and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-test---tests"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---tests"><code>--tests</code></a></dt>
<dd class="option-desc"><p>Test all targets that have the <code>test = true</code> manifest
flag set. By default this includes the library and binaries built as
unittests, and integration tests. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
unittest, and once as a dependency for binaries, integration tests, etc.).
Targets may be enabled or disabled by setting the <code>test</code> flag in the
manifest settings for the target.</p>
</dd>
<dt class="option-term" id="option-cargo-test---bench"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---bench"><code>--bench</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Test the specified benchmark. This flag may be specified multiple
times and supports common Unix glob patterns.</p>
</dd>
<dt class="option-term" id="option-cargo-test---benches"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---benches"><code>--benches</code></a></dt>
<dd class="option-desc"><p>Test all targets that have the <code>bench = true</code>
manifest flag set. By default this includes the library and binaries built
as benchmarks, and bench targets. Be aware that this will also build any
required dependencies, so the lib target may be built twice (once as a
benchmark, and once as a dependency for binaries, benchmarks, etc.).
Targets may be enabled or disabled by setting the <code>bench</code> flag in the
manifest settings for the target.</p>
</dd>
<dt class="option-term" id="option-cargo-test---all-targets"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---all-targets"><code>--all-targets</code></a></dt>
<dd class="option-desc"><p>Test all targets. This is equivalent to specifying <code>--lib --bins --tests --benches --examples</code>.</p>
</dd>
</dl>
<dl>
<dt class="option-term" id="option-cargo-test---doc"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---doc"><code>--doc</code></a></dt>
<dd class="option-desc"><p>Test only the library’s documentation. This cannot be mixed with other
target options.</p>
</dd>
</dl>
<h3 id="기능-선택-8"><a class="header" href="#기능-선택-8">기능 선택</a></h3>
<p>기능 플래그를 통해 어떤 기능을 활성화할지 제어할 수 있습니다. 기능 옵션이 주어지지 않으면, 선택된 모든 패키지에 대해 <code>default</code> 기능이 활성화됩니다.</p>
<p>자세한 내용은 <a href="commands/../reference/features.html#command-line-feature-options">기능 문서</a>를 참조하세요.</p>
<dl>
<dt class="option-term" id="option-cargo-test--F"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--F"><code>-F</code> <em>features</em></a></dt>
<dt class="option-term" id="option-cargo-test---features"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---features"><code>--features</code> <em>features</em></a></dt>
<dd class="option-desc"><p>Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</p>
</dd>
<dt class="option-term" id="option-cargo-test---all-features"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---all-features"><code>--all-features</code></a></dt>
<dd class="option-desc"><p>Activate all available features of all selected packages.</p>
</dd>
<dt class="option-term" id="option-cargo-test---no-default-features"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---no-default-features"><code>--no-default-features</code></a></dt>
<dd class="option-desc"><p>Do not activate the <code>default</code> feature of the selected packages.</p>
</dd>
</dl>
<h3 id="컴파일-옵션-8"><a class="header" href="#컴파일-옵션-8">컴파일 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-test---target"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---target"><code>--target</code> <em>triple</em></a></dt>
<dd class="option-desc"><p>Test for the specified target architecture. Flag may be specified multiple times. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>.</p>
<p>Possible values:</p>
<ul>
<li>Any supported target in <code>rustc --print target-list</code>.</li>
<li><code>"host-tuple"</code>, which will internally be substituted by the host’s target. This can be particularly useful if you’re cross-compiling some crates, and don’t want to specify your host’s machine as a target (for instance, an <code>xtask</code> in a shared project that may be worked on by many hosts).</li>
<li>A path to a custom target specification. See <a href="commands/../../rustc/targets/custom.html#custom-target-lookup-path">Custom Target Lookup Path</a> for more information.</li>
</ul>
<p>This may also be specified with the <code>build.target</code> <a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../reference/build-cache.html">build cache</a> documentation for more details.</p>
</dd>
<dt class="option-term" id="option-cargo-test--r"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--r"><code>-r</code></a></dt>
<dt class="option-term" id="option-cargo-test---release"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---release"><code>--release</code></a></dt>
<dd class="option-desc"><p>Test optimized artifacts with the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</p>
</dd>
<dt class="option-term" id="option-cargo-test---profile"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---profile"><code>--profile</code> <em>name</em></a></dt>
<dd class="option-desc"><p>Test with the given profile.
See <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</p>
</dd>
<dt class="option-term" id="option-cargo-test---timings"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---timings"><code>--timings</code></a></dt>
<dd class="option-desc"><p>Output information how long each compilation takes, and track concurrency
information over time.</p>
<p>A file <code>cargo-timing.html</code> will be written to the <code>target/cargo-timings</code>
directory at the end of the build. An additional report with a timestamp
in its filename is also written if you want to look at a previous run.
These reports are suitable for human consumption only, and do not provide
machine-readable timing data.</p>
</dd>
</dl>
<h3 id="출력-옵션-8"><a class="header" href="#출력-옵션-8">출력 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-test---target-dir"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---target-dir"><code>--target-dir</code> <em>directory</em></a></dt>
<dd class="option-desc"><p>Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</p>
</dd>
</dl>
<h3 id="표시-옵션-12"><a class="header" href="#표시-옵션-12">표시 옵션</a></h3>
<p>By default the Rust test harness hides output from test execution to keep results readable. Test output can be recovered (e.g., for debugging) by passing <code>--no-capture</code> to the test binaries:</p>
<pre><code>cargo test -- --no-capture
</code></pre>
<dl>
<dt class="option-term" id="option-cargo-test--v"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-test---verbose"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-test--q"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-test---quiet"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-test---color"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-test---message-format"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---message-format"><code>--message-format</code> <em>fmt</em></a></dt>
<dd class="option-desc"><p>The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the “short” rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc’s default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo’s own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul>
</dd>
</dl>
<h3 id="매니페스트-옵션-12"><a class="header" href="#매니페스트-옵션-12">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-test---manifest-path"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-test---ignore-rust-version"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---ignore-rust-version"><code>--ignore-rust-version</code></a></dt>
<dd class="option-desc"><p>Ignore <code>rust-version</code> specification in packages.</p>
</dd>
<dt class="option-term" id="option-cargo-test---locked"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-test---offline"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-test---frozen"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션-12"><a class="header" href="#공통-옵션-12">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-test-+toolchain"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-test---config"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-test--C"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-test--h"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-test---help"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-test--Z"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h3 id="기타-옵션-8"><a class="header" href="#기타-옵션-8">기타 옵션</a></h3>
<p><code>--jobs</code> 인수는 테스트 실행 파일 빌드에는 영향을 주지만 테스트 실행 시 사용되는 스레드 수에는 영향을 주지 않습니다. Rust 테스트 하네스에는 사용되는 스레드 수를 제어하는 옵션이 포함되어 있습니다:</p>
<pre><code>cargo test -j 2 -- --test-threads=2
</code></pre>
<dl>
<dt class="option-term" id="option-cargo-test--j"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test--j"><code>-j</code> <em>N</em></a></dt>
<dt class="option-term" id="option-cargo-test---jobs"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---jobs"><code>--jobs</code> <em>N</em></a></dt>
<dd class="option-desc"><p>Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value. If
a string <code>default</code> is provided, it sets the value back to defaults.
Should not be 0.</p>
</dd>
<dt class="option-term" id="option-cargo-test---future-incompat-report"><a class="option-anchor" href="commands/cargo-test.html#option-cargo-test---future-incompat-report"><code>--future-incompat-report</code></a></dt>
<dd class="option-desc"><p>Displays a future-incompat report for any future-incompatible warnings
produced during execution of this command</p>
<p>See <a href="commands/cargo-report.html">cargo-report(1)</a></p>
</dd>
</dl>
<p><code>cargo test</code> 는 컴파일을 포함하지만 <code>--keep-going</code> 플래그를 제공하지 않습니다. 첫 번째 실패에서 멈추지 않고 가능한 한 많은 테스트를 실행하려면 <code>--no-fail-fast</code> 를 사용하세요. 가능한 한 많은 테스트를 “컴파일“하려면 <code>--tests</code> 를 사용하여 테스트 바이너리를 별도로 빌드하세요. 예를 들어:</p>
<pre><code>cargo build --tests --keep-going
cargo test --tests --no-fail-fast
</code></pre>
<h2 id="환경-변수-15"><a class="header" href="#환경-변수-15">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-12"><a class="header" href="#종료-상태-12">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-27"><a class="header" href="#예제-27">예제</a></h2>
<ol>
<li>
<p>현재 패키지의 모든 단위 및 통합 테스트 실행:</p>
<pre><code>cargo test
</code></pre>
</li>
<li>
<p>이름이 필터 문자열과 일치하는 테스트만 실행:</p>
<pre><code>cargo test name_filter
</code></pre>
</li>
<li>
<p>특정 통합 테스트 내의 특정 테스트만 실행:</p>
<pre><code>cargo test --test int_test_name -- modname::test_name
</code></pre>
</li>
</ol>
<h2 id="참고-항목-16"><a class="header" href="#참고-항목-16">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-bench.html">cargo-bench(1)</a>, <a href="commands/../reference/cargo-targets.html#tests">테스트 유형</a>, <a href="https://doc.rust-lang.org/rustc/tests/index.html">테스트 작성 방법</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="매니페스트-명령어-1"><a class="header" href="#매니페스트-명령어-1">매니페스트 명령어</a></h1>
<ul>
<li><a href="commands/cargo-add.html">cargo add</a></li>
<li><a href="commands/cargo-info.html">cargo_info</a></li>
<li><a href="commands/cargo-generate-lockfile.html">cargo generate-lockfile</a></li>
<li><a href="commands/cargo-locate-project.html">cargo locate-project</a></li>
<li><a href="commands/cargo-metadata.html">cargo metadata</a></li>
<li><a href="commands/cargo-pkgid.html">cargo pkgid</a></li>
<li><a href="commands/cargo-remove.html">cargo remove</a></li>
<li><a href="commands/cargo-tree.html">cargo tree</a></li>
<li><a href="commands/cargo-update.html">cargo update</a></li>
<li><a href="commands/cargo-vendor.html">cargo vendor</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-add1"><a class="header" href="#cargo-add1">cargo-add(1)</a></h1>
<h2 id="이름-17"><a class="header" href="#이름-17">이름</a></h2>
<p>cargo-add — Cargo.toml 매니페스트 파일에 의존성 추가</p>
<h2 id="사용법-14"><a class="header" href="#사용법-14">사용법</a></h2>
<p><code>cargo add</code> [<em>옵션</em>] <em>크레이트</em>…<br />
<code>cargo add</code> [<em>옵션</em>] <code>--path</code> <em>경로</em><br />
<code>cargo add</code> [<em>옵션</em>] <code>--git</code> <em>url</em> [<em>크레이트</em>…]</p>
<h2 id="설명-17"><a class="header" href="#설명-17">설명</a></h2>
<p>이 명령어는 의존성을 추가하거나 수정할 수 있습니다.</p>
<p>의존성의 소스는 다음을 사용하여 지정할 수 있습니다:</p>
<ul>
<li><em>크레이트 <em><code>@</code></em> 버전 <em>: “</em> 버전</em>” 제약 조건으로 레지스트리에서 가져옵니다</li>
<li><code>--path</code> <em>경로</em>: 지정된 <em>경로</em> 에서 가져옵니다</li>
<li><code>--git</code> <em>url</em>: <em>url</em> 의 git 저장소에서 가져옵니다</li>
</ul>
<p>소스가 지정되지 않은 경우 다음을 포함하여 하나를 선택하기 위해 최선을 다합니다:</p>
<ul>
<li>다른 테이블의 기존 의존성(<code>dev-dependencies</code> 등)</li>
<li>워크스페이스 멤버</li>
<li>레지스트리의 최신 릴리스</li>
</ul>
<p>이미 존재하는 패키지를 추가하면 지정된 플래그로 기존 항목이 업데이트됩니다.</p>
<p>성공적으로 호출되면 지정된 의존성의 활성화된(<code>+</code>) 및 비활성화된(<code>-</code>) <a href="commands/../reference/features.html">기능</a> 이 명령의 출력에 나열됩니다.</p>
<h2 id="옵션-14"><a class="header" href="#옵션-14">옵션</a></h2>
<h3 id="소스-옵션"><a class="header" href="#소스-옵션">소스 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-add---git"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---git"><code>--git</code> <em>url</em></a></dt>
<dd class="option-desc"><p><a href="commands/../reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories">Git URL to add the specified crate from</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-add---branch"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---branch"><code>--branch</code> <em>branch</em></a></dt>
<dd class="option-desc"><p>Branch to use when adding from git.</p>
</dd>
<dt class="option-term" id="option-cargo-add---tag"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---tag"><code>--tag</code> <em>tag</em></a></dt>
<dd class="option-desc"><p>Tag to use when adding from git.</p>
</dd>
<dt class="option-term" id="option-cargo-add---rev"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---rev"><code>--rev</code> <em>sha</em></a></dt>
<dd class="option-desc"><p>Specific commit to use when adding from git.</p>
</dd>
<dt class="option-term" id="option-cargo-add---path"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---path"><code>--path</code> <em>path</em></a></dt>
<dd class="option-desc"><p><a href="commands/../reference/specifying-dependencies.html#specifying-path-dependencies">Filesystem path</a> to local crate to add.</p>
</dd>
<dt class="option-term" id="option-cargo-add---base"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---base"><code>--base</code> <em>base</em></a></dt>
<dd class="option-desc"><p>The <a href="commands/../reference/unstable.html#path-bases">path base</a> to use when adding a local crate.</p>
<p><a href="commands/../reference/unstable.html#path-bases">Unstable (nightly-only)</a></p>
</dd>
<dt class="option-term" id="option-cargo-add---registry"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---registry"><code>--registry</code> <em>registry</em></a></dt>
<dd class="option-desc"><p>Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</p>
</dd>
</dl>
<h3 id="섹션-옵션"><a class="header" href="#섹션-옵션">섹션 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-add---dev"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---dev"><code>--dev</code></a></dt>
<dd class="option-desc"><p>Add as a <a href="commands/../reference/specifying-dependencies.html#development-dependencies">development dependency</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-add---build"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---build"><code>--build</code></a></dt>
<dd class="option-desc"><p>Add as a <a href="commands/../reference/specifying-dependencies.html#build-dependencies">build dependency</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-add---target"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---target"><code>--target</code> <em>target</em></a></dt>
<dd class="option-desc"><p>Add as a dependency to the <a href="commands/../reference/specifying-dependencies.html#platform-specific-dependencies">given target platform</a>.</p>
<p>To avoid unexpected shell expansions, you may use quotes around each target, e.g., <code>--target 'cfg(unix)'</code>.</p>
</dd>
</dl>
<h3 id="의존성-옵션"><a class="header" href="#의존성-옵션">의존성 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-add---dry-run"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---dry-run"><code>--dry-run</code></a></dt>
<dd class="option-desc"><p>Don’t actually write the manifest</p>
</dd>
<dt class="option-term" id="option-cargo-add---rename"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---rename"><code>--rename</code> <em>name</em></a></dt>
<dd class="option-desc"><p><a href="commands/../reference/specifying-dependencies.html#renaming-dependencies-in-cargotoml">Rename</a> the dependency.</p>
</dd>
<dt class="option-term" id="option-cargo-add---optional"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---optional"><code>--optional</code></a></dt>
<dd class="option-desc"><p>Mark the dependency as <a href="commands/../reference/features.html#optional-dependencies">optional</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-add---no-optional"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---no-optional"><code>--no-optional</code></a></dt>
<dd class="option-desc"><p>Mark the dependency as <a href="commands/../reference/features.html#optional-dependencies">required</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-add---public"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---public"><code>--public</code></a></dt>
<dd class="option-desc"><p>Mark the dependency as public.</p>
<p>The dependency can be referenced in your library’s public API.</p>
<p><a href="commands/../reference/unstable.html#public-dependency">Unstable (nightly-only)</a></p>
</dd>
<dt class="option-term" id="option-cargo-add---no-public"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---no-public"><code>--no-public</code></a></dt>
<dd class="option-desc"><p>Mark the dependency as private.</p>
<p>While you can use the crate in your implementation, it cannot be referenced in your public API.</p>
<p><a href="commands/../reference/unstable.html#public-dependency">Unstable (nightly-only)</a></p>
</dd>
<dt class="option-term" id="option-cargo-add---no-default-features"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---no-default-features"><code>--no-default-features</code></a></dt>
<dd class="option-desc"><p>Disable the <a href="commands/../reference/features.html#dependency-features">default features</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-add---default-features"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---default-features"><code>--default-features</code></a></dt>
<dd class="option-desc"><p>Re-enable the <a href="commands/../reference/features.html#dependency-features">default features</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-add--F"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add--F"><code>-F</code> <em>features</em></a></dt>
<dt class="option-term" id="option-cargo-add---features"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---features"><code>--features</code> <em>features</em></a></dt>
<dd class="option-desc"><p>Space or comma separated list of <a href="commands/../reference/features.html#dependency-features">features to
activate</a>. When adding multiple
crates, the features for a specific crate may be enabled with
<code>package-name/feature-name</code> syntax. This flag may be specified multiple times,
which enables all specified features.</p>
</dd>
</dl>
<h3 id="표시-옵션-13"><a class="header" href="#표시-옵션-13">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-add--v"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-add---verbose"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-add--q"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-add---quiet"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-add---color"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="매니페스트-옵션-13"><a class="header" href="#매니페스트-옵션-13">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-add---manifest-path"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-add--p"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add--p"><code>-p</code> <em>spec</em></a></dt>
<dt class="option-term" id="option-cargo-add---package"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---package"><code>--package</code> <em>spec</em></a></dt>
<dd class="option-desc"><p>Add dependencies to only the specified package.</p>
</dd>
<dt class="option-term" id="option-cargo-add---ignore-rust-version"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---ignore-rust-version"><code>--ignore-rust-version</code></a></dt>
<dd class="option-desc"><p>Ignore <code>rust-version</code> specification in packages.</p>
</dd>
<dt class="option-term" id="option-cargo-add---locked"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-add---offline"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-add---frozen"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션-13"><a class="header" href="#공통-옵션-13">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-add-+toolchain"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-add---config"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-add--C"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-add--h"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-add---help"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-add--Z"><a class="option-anchor" href="commands/cargo-add.html#option-cargo-add--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-16"><a class="header" href="#환경-변수-16">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-13"><a class="header" href="#종료-상태-13">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-28"><a class="header" href="#예제-28">예제</a></h2>
<ol>
<li>
<p><code>regex</code> 를 의존성으로 추가</p>
<pre><code>cargo add regex
</code></pre>
</li>
<li>
<p><code>trybuild</code> 를 dev-dependency로 추가</p>
<pre><code>cargo add --dev trybuild
</code></pre>
</li>
<li>
<p><code>nom</code> 의 이전 버전을 의존성으로 추가</p>
<pre><code>cargo add nom@5
</code></pre>
</li>
<li>
<p><code>derive</code> 를 사용하여 데이터 구조를 json으로 직렬화하는 지원 추가</p>
<pre><code>cargo add serde serde_json -F serde/derive
</code></pre>
</li>
<li>
<p><code>windows</code> 를 <code>cfg(windows)</code> 의 플랫폼별 의존성으로 추가</p>
<pre><code>cargo add windows --target 'cfg(windows)'
</code></pre>
</li>
</ol>
<h2 id="참고-항목-17"><a class="header" href="#참고-항목-17">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-remove.html">cargo-remove(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-generate-lockfile1"><a class="header" href="#cargo-generate-lockfile1">cargo-generate-lockfile(1)</a></h1>
<h2 id="이름-18"><a class="header" href="#이름-18">이름</a></h2>
<p>cargo-generate-lockfile — 패키지의 잠금 파일 생성</p>
<h2 id="사용법-15"><a class="header" href="#사용법-15">사용법</a></h2>
<p><code>cargo generate-lockfile</code> [<em>옵션</em>]</p>
<h2 id="설명-18"><a class="header" href="#설명-18">설명</a></h2>
<p>이 명령어는 현재 패키지 또는 워크스페이스에 대한 <code>Cargo.lock</code> 잠금 파일을 생성합니다. 잠금 파일이 이미 존재하는 경우 모든 패키지의 사용 가능한 최신 버전으로 다시 빌드됩니다.</p>
<p><code>Cargo.lock</code> 잠금 파일을 생성할 수 있고 업데이트 동작을 제어하기 위한 더 많은 옵션이 있는 <a href="commands/cargo-update.html">cargo-update(1)</a> 도 참조하세요.</p>
<h2 id="옵션-15"><a class="header" href="#옵션-15">옵션</a></h2>
<h3 id="표시-옵션-14"><a class="header" href="#표시-옵션-14">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-generate-lockfile--v"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-generate-lockfile---verbose"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-generate-lockfile--q"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-generate-lockfile---quiet"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-generate-lockfile---color"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="매니페스트-옵션-14"><a class="header" href="#매니페스트-옵션-14">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-generate-lockfile---manifest-path"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-generate-lockfile---ignore-rust-version"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---ignore-rust-version"><code>--ignore-rust-version</code></a></dt>
<dd class="option-desc"><p>Ignore <code>rust-version</code> specification in packages.</p>
</dd>
<dt class="option-term" id="option-cargo-generate-lockfile---publish-time"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---publish-time"><code>--publish-time</code> <em>yyyy-mm-ddThh:mm:ssZ</em></a></dt>
<dd class="option-desc"><p>Latest publish time allowed for registry packages (Unstable)</p>
<p>This is a best-effort filter on allowed packages, including:</p>
<ul>
<li>packages from unsupported registries are always accepted</li>
<li>only the current yank state is respected, not the state as of <code>--publish-time</code></li>
<li>precision of the publish time</li>
</ul>
</dd>
<dt class="option-term" id="option-cargo-generate-lockfile---locked"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-generate-lockfile---offline"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-generate-lockfile---frozen"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션-14"><a class="header" href="#공통-옵션-14">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-generate-lockfile-+toolchain"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-generate-lockfile---config"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-generate-lockfile--C"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-generate-lockfile--h"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-generate-lockfile---help"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-generate-lockfile--Z"><a class="option-anchor" href="commands/cargo-generate-lockfile.html#option-cargo-generate-lockfile--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-17"><a class="header" href="#환경-변수-17">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-14"><a class="header" href="#종료-상태-14">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-29"><a class="header" href="#예제-29">예제</a></h2>
<ol>
<li>
<p>현재 패키지 또는 워크스페이스에 대한 잠금 파일 생성 또는 업데이트:</p>
<pre><code>cargo generate-lockfile
</code></pre>
</li>
</ol>
<h2 id="참고-항목-18"><a class="header" href="#참고-항목-18">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-update.html">cargo-update(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-info1"><a class="header" href="#cargo-info1">cargo-info(1)</a></h1>
<h2 id="이름-19"><a class="header" href="#이름-19">이름</a></h2>
<p>cargo-info — 패키지에 대한 정보 표시.</p>
<h2 id="사용법-16"><a class="header" href="#사용법-16">사용법</a></h2>
<p><code>cargo info</code> [<em>옵션</em>] <em>spec</em></p>
<h2 id="설명-19"><a class="header" href="#설명-19">설명</a></h2>
<p>이 명령어는 패키지에 대한 정보를 표시합니다. 패키지의 Cargo.toml 파일에서 데이터를 가져와 사람이 읽을 수 있는 형식으로 표시합니다.</p>
<h2 id="옵션-16"><a class="header" href="#옵션-16">옵션</a></h2>
<h3 id="정보-옵션"><a class="header" href="#정보-옵션">정보 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-info-spec"><a class="option-anchor" href="commands/cargo-info.html#option-cargo-info-spec"><em>spec</em></a></dt>
<dd class="option-desc"><p>Fetch information about the specified package. The <em>spec</em> can be a package ID, see <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC
format.
If the specified package is part of the current workspace, information from the local Cargo.toml file will be displayed.
If the <code>Cargo.lock</code> file does not exist, it will be created. If no version is specified, the appropriate version will be
selected based on the Minimum Supported Rust Version (MSRV).</p>
</dd>
<dt class="option-term" id="option-cargo-info---index"><a class="option-anchor" href="commands/cargo-info.html#option-cargo-info---index"><code>--index</code> <em>index</em></a></dt>
<dd class="option-desc"><p>The URL of the registry index to use.</p>
</dd>
<dt class="option-term" id="option-cargo-info---registry"><a class="option-anchor" href="commands/cargo-info.html#option-cargo-info---registry"><code>--registry</code> <em>registry</em></a></dt>
<dd class="option-desc"><p>Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</p>
</dd>
</dl>
<h3 id="표시-옵션-15"><a class="header" href="#표시-옵션-15">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-info--v"><a class="option-anchor" href="commands/cargo-info.html#option-cargo-info--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-info---verbose"><a class="option-anchor" href="commands/cargo-info.html#option-cargo-info---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-info--q"><a class="option-anchor" href="commands/cargo-info.html#option-cargo-info--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-info---quiet"><a class="option-anchor" href="commands/cargo-info.html#option-cargo-info---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-info---color"><a class="option-anchor" href="commands/cargo-info.html#option-cargo-info---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="매니페스트-옵션-15"><a class="header" href="#매니페스트-옵션-15">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-info---locked"><a class="option-anchor" href="commands/cargo-info.html#option-cargo-info---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-info---offline"><a class="option-anchor" href="commands/cargo-info.html#option-cargo-info---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-info---frozen"><a class="option-anchor" href="commands/cargo-info.html#option-cargo-info---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션-15"><a class="header" href="#공통-옵션-15">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-info-+toolchain"><a class="option-anchor" href="commands/cargo-info.html#option-cargo-info-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-info---config"><a class="option-anchor" href="commands/cargo-info.html#option-cargo-info---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-info--C"><a class="option-anchor" href="commands/cargo-info.html#option-cargo-info--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-info--h"><a class="option-anchor" href="commands/cargo-info.html#option-cargo-info--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-info---help"><a class="option-anchor" href="commands/cargo-info.html#option-cargo-info---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-info--Z"><a class="option-anchor" href="commands/cargo-info.html#option-cargo-info--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-18"><a class="header" href="#환경-변수-18">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-15"><a class="header" href="#종료-상태-15">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-30"><a class="header" href="#예제-30">예제</a></h2>
<ol>
<li>
<p>crates.io에서 <code>serde</code> 패키지 검사:</p>
<pre><code> cargo info serde
</code></pre>
</li>
<li>
<p><code>1.0.0</code> 버전의 <code>serde</code> 패키지 검사:</p>
<pre><code> cargo info serde@1.0.0
</code></pre>
</li>
<li>
<p>로컬 레지스트리에서 <code>serde</code> 패키지 검사:</p>
<pre><code> cargo info serde --registry my-registry
</code></pre>
</li>
</ol>
<h2 id="참고-항목-19"><a class="header" href="#참고-항목-19">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-search.html">cargo-search(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-locate-project1"><a class="header" href="#cargo-locate-project1">cargo-locate-project(1)</a></h1>
<h2 id="이름-20"><a class="header" href="#이름-20">이름</a></h2>
<p>cargo-locate-project — Cargo.toml 파일 위치의 JSON 표현 출력</p>
<h2 id="사용법-17"><a class="header" href="#사용법-17">사용법</a></h2>
<p><code>cargo locate-project</code> [<em>옵션</em>]</p>
<h2 id="설명-20"><a class="header" href="#설명-20">설명</a></h2>
<p>이 명령어는 매니페스트에 대한 전체 경로가 포함된 JSON 객체를 표준 출력으로 출력합니다. 매니페스트는 현재 작업 디렉토리에서 시작하여 위쪽으로 <code>Cargo.toml</code> 이라는 파일을 검색하여 찾습니다.</p>
<p>프로젝트가 워크스페이스의 일부인 경우, 워크스페이스 루트가 아닌 프로젝트의 매니페스트가 출력됩니다. 이는 <code>--workspace</code> 플래그로 재정의할 수 있습니다. 워크스페이스의 루트는 <code>--workspace</code> 플래그를 통해 찾을 수 있습니다.</p>
<h2 id="옵션-17"><a class="header" href="#옵션-17">옵션</a></h2>
<dl>
<dt class="option-term" id="option-cargo-locate-project---workspace"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---workspace"><code>--workspace</code></a></dt>
<dd class="option-desc"><p>Locate the <code>Cargo.toml</code> at the root of the workspace, as opposed to the current
workspace member.</p>
</dd>
</dl>
<h3 id="표시-옵션-16"><a class="header" href="#표시-옵션-16">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-locate-project---message-format"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---message-format"><code>--message-format</code> <em>fmt</em></a></dt>
<dd class="option-desc"><p>The representation in which to print the project location. Valid values:</p>
<ul>
<li><code>json</code> (default): JSON object with the path under the key “root”.</li>
<li><code>plain</code>: Just the path.</li>
</ul>
</dd>
<dt class="option-term" id="option-cargo-locate-project--v"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-locate-project---verbose"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-locate-project--q"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-locate-project---quiet"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-locate-project---color"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="매니페스트-옵션-16"><a class="header" href="#매니페스트-옵션-16">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-locate-project---manifest-path"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
</dl>
<h3 id="공통-옵션-16"><a class="header" href="#공통-옵션-16">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-locate-project-+toolchain"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-locate-project---config"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-locate-project--C"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-locate-project--h"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-locate-project---help"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-locate-project--Z"><a class="option-anchor" href="commands/cargo-locate-project.html#option-cargo-locate-project--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-19"><a class="header" href="#환경-변수-19">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-16"><a class="header" href="#종료-상태-16">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-31"><a class="header" href="#예제-31">예제</a></h2>
<ol>
<li>
<p>현재 디렉토리를 기준으로 매니페스트 경로 표시:</p>
<pre><code>cargo locate-project
</code></pre>
</li>
</ol>
<h2 id="참고-항목-20"><a class="header" href="#참고-항목-20">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-metadata.html">cargo-metadata(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-metadata1"><a class="header" href="#cargo-metadata1">cargo-metadata(1)</a></h1>
<h2 id="이름-21"><a class="header" href="#이름-21">이름</a></h2>
<p>cargo-metadata — 현재 패키지에 대한 기계 판독 가능한 메타데이터</p>
<h2 id="사용법-18"><a class="header" href="#사용법-18">사용법</a></h2>
<p><code>cargo metadata</code> [<em>옵션</em>]</p>
<h2 id="설명-21"><a class="header" href="#설명-21">설명</a></h2>
<p>현재 패키지의 워크스페이스 멤버 및 해결된 의존성에 대한 정보가 포함된 JSON을 표준 출력으로 출력합니다.</p>
<p>출력 형식은 Cargo의 향후 버전에서 변경될 수 있습니다. 코드가 미래에도 호환되도록 하고 예상하는 형식으로 출력되도록 하려면 <code>--format-version</code> 플래그를 포함하는 것이 좋습니다. 예상되는 내용에 대한 자세한 내용은 <a href="commands/cargo-metadata.html#compatibility">“호환성”</a> 을 참조하세요.</p>
<p>메타데이터를 읽기 위한 Rust API는 <a href="https://crates.io/crates/cargo_metadata">cargo_metadata 크레이트</a> 를 참조하세요.</p>
<h2 id="출력-형식"><a class="header" href="#출력-형식">출력 형식</a></h2>
<h3 id="호환성"><a class="header" href="#호환성">호환성</a></h3>
<p>동일한 출력 형식 버전 내에서는 일부 시나리오를 제외하고 호환성이 유지됩니다. 다음은 비호환으로 간주되지 않는 변경 사항의 일부 목록입니다:</p>
<ul>
<li><strong>새 필드 추가</strong> — 필요할 때 새 필드가 추가됩니다. 이것을 예약해 두면 Cargo가 형식 버전을 너무 자주 올리지 않고도 발전하는 데 도움이 됩니다.</li>
<li><strong>열거형 유사 필드에 새 값 추가</strong> — 새 필드를 추가하는 것과 같습니다. 메타데이터가 정체되지 않고 발전하도록 합니다.</li>
<li><strong>불투명한 표현 변경</strong> — 일부 필드의 내부 표현은 구현 세부 사항입니다. 예를 들어 “Source ID“와 관련된 필드는 패키지나 소스를 구별하기 위해 불투명한 식별자로 취급됩니다. 소비자는 명시되지 않는 한 이러한 표현에 의존해서는 안 됩니다.</li>
</ul>
<h3 id="json-형식"><a class="header" href="#json-형식">JSON 형식</a></h3>
<p>JSON 출력은 다음과 같은 형식입니다:</p>
<pre><code class="language-javascript">{
    /* 워크스페이스의 모든 패키지 배열입니다.
       --no-deps가 사용되지 않는 한 모든 기능이 활성화된 의존성도 포함됩니다.
    */
    "packages": [
        {
            /* 패키지의 이름입니다. */
            "name": "my-package",
            /* 패키지의 버전입니다. */
            "version": "0.1.0",
            /* 문서 내에서 패키지를 참조하고 많은 명령어에 `--package` 인수로 사용되는
               패키지 ID입니다.
            */
            "id": "file:///path/to/my-package#0.1.0",
            /* 매니페스트의 라이선스 값 또는 null입니다. */
            "license": "MIT/Apache-2.0",
            /* 매니페스트의 라이선스 파일 값 또는 null입니다. */
            "license_file": "LICENSE",
            /* 매니페스트의 설명 값 또는 null입니다. */
            "description": "Package description.",
            /* 패키지를 어디서 가져왔는지를 나타내는 "불투명" 식별자인 패키지의 소스 ID입니다.
               안정성 보장에 대해서는 위의 "호환성"을 참조하세요.

               경로 의존성 및 워크스페이스 멤버의 경우 null입니다.

               다른 의존성의 경우 다음 형식의 문자열입니다:
               - 레지스트리 기반 의존성의 경우 "registry+URL".
                 예: "registry+https://github.com/rust-lang/crates.io-index"
               - git 기반 의존성의 경우 "git+URL".
                 예: "git+https://github.com/rust-lang/cargo?rev=5e85ba14aaa20f8133863373404cb0af69eeef2c#5e85ba14aaa20f8133863373404cb0af69eeef2c"
               - 스파스 레지스트리 의존성의 경우 "sparse+URL"
                 예: "sparse+https://my-sparse-registry.org"

               `+` 뒤의 값은 명시적으로 정의되지 않았으며 Cargo 버전 간에 변경될 수 있으며,
               설정 파일의 레지스트리 정의와 같은 다른 것과 직접적인 관련이 없을 수 있습니다.
               향후 다른 `+` 접두사 식별자를 갖는 새로운 소스 종류가 추가될 수 있습니다.
            */
            "source": null,
            /* 패키지 매니페스트에 선언된 의존성 배열입니다. */
            "dependencies": [
                {
                    /* 의존성의 이름입니다. */
                    "name": "bitflags",
                    /* 의존성의 소스 ID입니다. null일 수 있으며, 패키지 소스에 대한
                       설명을 참조하세요.
                    */
                    "source": "registry+https://github.com/rust-lang/crates.io-index",
                    /* 의존성에 대한 버전 요구 사항입니다.
                       버전 요구 사항이 없는 의존성은 "*" 값을 가집니다.
                    */
                    "req": "^1.0",
                    /* 의존성의 종류입니다.
                       "dev", "build", 또는 일반 의존성의 경우 null입니다.
                    */
                    "kind": null,
                    /* 의존성 이름이 변경된 경우, 이는 변경된 의존성의 이름 문자열입니다.
                       이름이 변경되지 않은 경우 null입니다.
                    */
                    "rename": null,
                    /* 선택적 의존성인지 여부를 나타내는 불리언 값입니다. */
                    "optional": false,
                    /* 기본 기능이 활성화되었는지 여부를 나타내는 불리언 값입니다. */
                    "uses_default_features": true,
                    /* 활성화된 기능(feature)의 배열입니다. */
                    "features": [],
                    /* 의존성의 타겟 플랫폼입니다.
                       타겟 의존성이 아닌 경우 null입니다.
                    */
                    "target": "cfg(windows)",
                    /* 로컬 경로 의존성에 대한 파일 시스템 경로입니다.
                       경로 의존성이 아닌 경우 존재하지 않습니다.
                    */
                    "path": "/path/to/dep",
                    /* 이 의존성이 유래한 레지스트리의 URL 문자열입니다.
                       지정되지 않거나 null인 경우 의존성은 기본
                       레지스트리(crates.io)에서 가져온 것입니다.
                    */
                    "registry": null,
                    /* (불안정) 이것이 공개(public)
                       의존성인지 여부를 나타내는 불리언 플래그입니다. 이 필드는
                       `-Zpublic-dependency` 가 활성화된 경우에만 존재합니다.
                    */
                    "public": false
                }
            ],
            /* Cargo 타겟의 배열입니다. */
            "targets": [
                {
                    /* 타겟 종류의 배열입니다.
                       - 라이브러리 타겟은 "lib", "rlib", "dylib",
                         "proc-macro" 등과 같은 매니페스트의 `crate-type` 값을 나열합니다.
                         (기본값 ["lib"])
                       - 바이너리는 ["bin"] 입니다.
                       - 예제는 ["example"] 입니다.
                       - 통합 테스트는 ["test"] 입니다.
                       - 벤치마크는 ["bench"] 입니다.
                       - 빌드 스크립트는 ["custom-build"] 입니다.
                    */
                    "kind": [
                        "bin"
                    ],
                    /* 크레이트 타입의 배열입니다.
                       - 라이브러리 및 예제 라이브러리는 "lib", "rlib", "dylib",
                         "proc-macro" 등과 같은 매니페스트의 `crate-type` 값을 나열합니다.
                         (기본값 ["lib"])
                       - 다른 모든 타겟 종류는 ["bin"] 입니다.
                    */
                    "crate_types": [
                        "bin"
                    ],
                    /* 타겟의 이름입니다.
                       라이브러리 타겟의 경우 대시가 밑줄로 대체됩니다.
                    */
                    "name": "my-package",
                    /* 타겟의 루트 소스 파일에 대한 절대 경로입니다. */
                    "src_path": "/path/to/my-package/src/main.rs",
                    /* 타겟의 Rust 에디션입니다.
                       패키지 에디션이 기본값입니다.
                    */
                    "edition": "2018",
                    /* 필수 기능의 배열입니다.
                       필수 기능이 설정되지 않은 경우 이 속성은 포함되지 않습니다.
                    */
                    "required-features": ["feat1"],
                    /* `cargo doc` 에 의해 문서화되어야 하는 타겟인지 여부입니다. */
                    "doc": true,
                    /* 이 타겟의 문서 테스트가 활성화되어 있고,
                       타겟이 문서 테스트와 호환되는지 여부입니다.
                    */
                    "doctest": false,
                    /* 이 타겟이 `--test` 로 빌드되고 실행되어야 하는지 여부입니다.
                    */
                    "test": true
                }
            ],
            /* 패키지에 대해 정의된 기능 집합입니다.
               각 기능은 해당 기능이 활성화하는 기능 또는 의존성의 배열에 매핑됩니다.
            */
            "features": {
                "default": [
                    "feat1"
                ],
                "feat1": [],
                "feat2": []
            },
            /* 이 패키지의 매니페스트에 대한 절대 경로입니다. */
            "manifest_path": "/path/to/my-package/Cargo.toml",
            /* 패키지 메타데이터입니다.
               메타데이터가 지정되지 않은 경우 null입니다.
            */
            "metadata": {
                "docs": {
                    "rs": {
                        "all-features": true
                    }
                }
            },
            /* 이 패키지를 게시할 수 있는 레지스트리 목록입니다.
               null인 경우 제한 없이 게시할 수 있으며, 빈 배열인 경우 게시가 금지됩니다. */
            "publish": [
                "crates-io"
            ],
            /* 매니페스트의 저자 배열입니다.
               저자가 지정되지 않은 경우 빈 배열입니다.
            */
            "authors": [
                "Jane Doe &lt;user@example.com&gt;"
            ],
            /* 매니페스트의 카테고리 배열입니다. */
            "categories": [
                "command-line-utilities"
            ],
            /* cargo run이 선택하는 기본 바이너리인 선택적 문자열입니다. */
            "default_run": null,
            /* 지원되는 최소 rust 버전인 선택적 문자열입니다. */
            "rust_version": "1.56",
            /* 매니페스트의 키워드 배열입니다. */
            "keywords": [
                "cli"
            ],
            /* 매니페스트의 readme 값 또는 지정되지 않은 경우 null입니다. */
            "readme": "README.md",
            /* 매니페스트의 repository 값 또는 지정되지 않은 경우 null입니다. */
            "repository": "https://github.com/rust-lang/cargo",
            /* 매니페스트의 homepage 값 또는 지정되지 않은 경우 null입니다. */
            "homepage": "https://rust-lang.org",
            /* 매니페스트의 documentation 값 또는 지정되지 않은 경우 null입니다. */
            "documentation": "https://doc.rust-lang.org/stable/std",
            /* 패키지의 기본 에디션입니다.
               개별 타겟은 다른 에디션을 가질 수 있습니다.
            */
            "edition": "2018",
            /* 패키지가 연결되는 네이티브 라이브러리의 이름인
               선택적 문자열입니다.
            */
            "links": null,
        }
    ],
    /* 워크스페이스 멤버의 배열입니다.
       각 항목은 패키지의 패키지 ID입니다.
    */
    "workspace_members": [
        "file:///path/to/my-package#0.1.0",
    ],
    /* 워크스페이스의 기본 멤버 배열입니다.
       각 항목은 패키지의 패키지 ID입니다.
    */
    "workspace_default_members": [
        "file:///path/to/my-package#0.1.0",
    ],
    // 전체 워크스페이스에 대한 해결된 의존성 그래프입니다. 활성화된
    // 기능은 "현재" 패키지의 활성화된 기능을 기반으로 합니다.
    // 비활성화된 선택적 의존성은 나열되지 않습니다.
    //
    // --no-deps가 지정된 경우 null입니다.
    //
    // 기본적으로 모든 타겟 플랫폼에 대한 모든 의존성을 포함합니다.
    // `--filter-platform` 플래그를 사용하여 특정 타겟 트리플로 좁힐 수 있습니다.
    "resolve": {
        /* 의존성 그래프 내의 노드 배열입니다.
           각 노드는 패키지입니다.
        */
        "nodes": [
            {
                /* 이 노드의 패키지 ID입니다. */
                "id": "file:///path/to/my-package#0.1.0",
                /* 이 패키지의 의존성, 패키지 ID의 배열입니다. */
                "dependencies": [
                    "https://github.com/rust-lang/crates.io-index#bitflags@1.0.4"
                ],
                /* 이 패키지의 의존성입니다. 이것은 추가 정보를 포함하는
                   "dependencies"의 대안입니다. 특히,
                   이것은 이름이 변경된 의존성을 처리합니다.
                */
                "deps": [
                    {
                        /* 의존성의 라이브러리 타겟 이름입니다.
                           이름이 변경된 의존성인 경우, 이것은 새로운
                           이름입니다.
                        */
                        "name": "bitflags",
                        /* 의존성의 패키지 ID입니다. */
                        "pkg": "https://github.com/rust-lang/crates.io-index#bitflags@1.0.4"
                        /* 의존성 종류의 배열입니다. Cargo 1.40에 추가되었습니다. */
                        "dep_kinds": [
                            {
                                /* 의존성의 종류입니다.
                                   "dev", "build", 또는 일반 의존성의 경우 null입니다.
                                */
                                "kind": null,
                                /* 의존성의 타겟 플랫폼입니다.
                                   타겟 의존성이 아닌 경우 null입니다.
                                */
                                "target": "cfg(windows)"
                            }
                        ]
                    }
                ],
                /* 이 패키지에서 활성화된 기능 배열입니다. */
                "features": [
                    "default"
                ]
            }
        ],
        /* 현재 작업 디렉토리의 패키지입니다(--manifest-path가 주어지지 않은 경우).
           가상 워크스페이스가 있는 경우 null입니다. 그렇지 않으면
           패키지의 패키지 ID입니다.
        */
        "root": "file:///path/to/my-package#0.1.0",
    },
    /* The absolute path to the target directory where Cargo places its output. */
    "target_directory": "/path/to/my-package/target",
    /* The absolute path to the build directory where Cargo places intermediate build artifacts. (unstable) */
    "build_directory": "/path/to/my-package/build-dir",
    /* 이 메타데이터 구조의 스키마 버전입니다.
       호환되지 않는 변경이 이루어지는 경우 이 버전이 변경됩니다.
    */
    "version": 1,
    /* 워크스페이스 루트의 절대 경로입니다. */
    "workspace_root": "/path/to/my-package"
    /* 워크스페이스 메타데이터입니다.
       메타데이터가 지정되지 않은 경우 null입니다. */
    "metadata": {
        "docs": {
            "rs": {
                "all-features": true
            }
        }
    }
}
</code></pre>
<p>참고:</p>
<ul>
<li><code>"id"</code> 필드 구문에 대해서는 레퍼런스의 <a href="commands/../reference/pkgid-spec.html">패키지 ID 명세</a> 를 참조하세요.</li>
</ul>
<h2 id="옵션-18"><a class="header" href="#옵션-18">옵션</a></h2>
<h3 id="출력-옵션-9"><a class="header" href="#출력-옵션-9">출력 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-metadata---no-deps"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---no-deps"><code>--no-deps</code></a></dt>
<dd class="option-desc"><p>Output information only about the workspace members and don’t fetch
dependencies.</p>
</dd>
<dt class="option-term" id="option-cargo-metadata---format-version"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---format-version"><code>--format-version</code> <em>version</em></a></dt>
<dd class="option-desc"><p>Specify the version of the output format to use. Currently <code>1</code> is the only
possible value.</p>
</dd>
<dt class="option-term" id="option-cargo-metadata---filter-platform"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---filter-platform"><code>--filter-platform</code> <em>triple</em></a></dt>
<dd class="option-desc"><p>This filters the <code>resolve</code> output to only include dependencies for the
given <a href="commands/../appendix/glossary.html#target">target triple</a>.
A literal <code>"host-tuple"</code> can be used, which will internally be substituted by the host’s target.
Without this flag, the resolve includes all targets.</p>
<p>Note that the dependencies listed in the “packages” array still includes all
dependencies. Each package definition is intended to be an unaltered
reproduction of the information within <code>Cargo.toml</code>.</p>
</dd>
</dl>
<h3 id="기능-선택-9"><a class="header" href="#기능-선택-9">기능 선택</a></h3>
<p>기능 플래그를 통해 어떤 기능을 활성화할지 제어할 수 있습니다. 기능 옵션이 주어지지 않으면, 선택된 모든 패키지에 대해 <code>default</code> 기능이 활성화됩니다.</p>
<p>자세한 내용은 <a href="commands/../reference/features.html#command-line-feature-options">기능 문서</a>를 참조하세요.</p>
<dl>
<dt class="option-term" id="option-cargo-metadata--F"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata--F"><code>-F</code> <em>features</em></a></dt>
<dt class="option-term" id="option-cargo-metadata---features"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---features"><code>--features</code> <em>features</em></a></dt>
<dd class="option-desc"><p>Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</p>
</dd>
<dt class="option-term" id="option-cargo-metadata---all-features"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---all-features"><code>--all-features</code></a></dt>
<dd class="option-desc"><p>Activate all available features of all selected packages.</p>
</dd>
<dt class="option-term" id="option-cargo-metadata---no-default-features"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---no-default-features"><code>--no-default-features</code></a></dt>
<dd class="option-desc"><p>Do not activate the <code>default</code> feature of the selected packages.</p>
</dd>
</dl>
<h3 id="표시-옵션-17"><a class="header" href="#표시-옵션-17">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-metadata--v"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-metadata---verbose"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-metadata--q"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-metadata---quiet"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-metadata---color"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="매니페스트-옵션-17"><a class="header" href="#매니페스트-옵션-17">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-metadata---manifest-path"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-metadata---locked"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-metadata---offline"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-metadata---frozen"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션-17"><a class="header" href="#공통-옵션-17">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-metadata-+toolchain"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-metadata---config"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-metadata--C"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-metadata--h"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-metadata---help"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-metadata--Z"><a class="option-anchor" href="commands/cargo-metadata.html#option-cargo-metadata--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-20"><a class="header" href="#환경-변수-20">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-17"><a class="header" href="#종료-상태-17">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-32"><a class="header" href="#예제-32">예제</a></h2>
<ol>
<li>
<p>현재 패키지에 대한 JSON 출력:</p>
<pre><code>cargo metadata --format-version=1
</code></pre>
</li>
</ol>
<h2 id="참고-항목-21"><a class="header" href="#참고-항목-21">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a>, <a href="commands/../reference/pkgid-spec.html">패키지 ID 명세</a>, <a href="commands/../reference/external-tools.html#json-messages">JSON 메시지</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-pkgid1"><a class="header" href="#cargo-pkgid1">cargo-pkgid(1)</a></h1>
<h2 id="이름-22"><a class="header" href="#이름-22">이름</a></h2>
<p>cargo-pkgid — 정규화된 패키지 명세(package specification) 출력</p>
<h2 id="사용법-19"><a class="header" href="#사용법-19">사용법</a></h2>
<p><code>cargo pkgid</code> [_옵션 _] [<em>spec</em>]</p>
<h2 id="설명-22"><a class="header" href="#설명-22">설명</a></h2>
<p><em>spec</em> 인수가 주어지면, 현재 워크스페이스의 패키지 또는 의존성에 대한 정규화된 패키지 ID 식별자를 출력합니다. 이 명령어는 <em>spec</em> 이 의존성 그래프에서 어떤 패키지를 가리키는지 모호한 경우 오류를 발생시킵니다. <em>spec</em> 이 제공되지 않으면 로컬 패키지에 대한 식별자가 출력됩니다.</p>
<p>이 명령어를 사용하려면 잠금 파일이 있어야 하며 의존성을 가져온 상태여야 합니다.</p>
<p>패키지 지정자(specifier)는 이름, 버전, 소스 URL로 구성됩니다. 하나의 패키지만 매칭된다면 부분적인 지정자를 사용하여 특정 패키지를 간결하게 매칭할 수 있습니다. 이 지정자는 <a href="commands/cargo-metadata.html">cargo-metadata(1)</a> 나 Cargo가 내보내는 <a href="commands/../reference/external-tools.html#json-messages">JSON 메시지</a> 등 Cargo의 다른 부분에서도 사용됩니다.</p>
<p>지정자(<em>spec</em>)의 형식은 다음 중 하나일 수 있습니다:</p>
<div class="table-wrapper"><table><thead><tr><th>지정자 구조</th><th>지정자 예시</th></tr></thead><tbody>
<tr><td><em>이름</em></td><td><code>bitflags</code></td></tr>
<tr><td><em>이름 <em><code>@</code></em> 버전</em></td><td><code>bitflags@1.0.4</code></td></tr>
<tr><td><em>url</em></td><td><code>https://github.com/rust-lang/cargo</code></td></tr>
<tr><td><em>url</em><code>#</code>_ 버전_</td><td><code>https://github.com/rust-lang/cargo#0.33.0</code></td></tr>
<tr><td><em>url</em><code>#</code>_ 이름_</td><td><code>https://github.com/rust-lang/crates.io-index#bitflags</code></td></tr>
<tr><td><em>url</em><code>#</code>_ 이름 <em><code>@</code></em> 버전_</td><td><code>https://github.com/rust-lang/cargo#crates-io@0.21.0</code></td></tr>
</tbody></table>
</div>
<p>지정자 문법에 대해서는 <a href="commands/../reference/pkgid-spec.html">패키지 ID 명세</a> 장에서 확인할 수 있습니다.</p>
<h2 id="옵션-19"><a class="header" href="#옵션-19">옵션</a></h2>
<h3 id="패키지-선택-11"><a class="header" href="#패키지-선택-11">패키지 선택</a></h3>
<dl>
<dt class="option-term" id="option-cargo-pkgid--p"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid--p"><code>-p</code> <em>spec</em></a></dt>
<dt class="option-term" id="option-cargo-pkgid---package"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---package"><code>--package</code> <em>spec</em></a></dt>
<dd class="option-desc"><p>Get the package ID for the given package instead of the current package.</p>
</dd>
</dl>
<h3 id="표시-옵션-18"><a class="header" href="#표시-옵션-18">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-pkgid--v"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-pkgid---verbose"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-pkgid--q"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-pkgid---quiet"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-pkgid---color"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="매니페스트-옵션-18"><a class="header" href="#매니페스트-옵션-18">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-pkgid---manifest-path"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-pkgid---locked"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-pkgid---offline"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-pkgid---frozen"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션-18"><a class="header" href="#공통-옵션-18">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-pkgid-+toolchain"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-pkgid---config"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-pkgid--C"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-pkgid--h"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-pkgid---help"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-pkgid--Z"><a class="option-anchor" href="commands/cargo-pkgid.html#option-cargo-pkgid--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-21"><a class="header" href="#환경-변수-21">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-18"><a class="header" href="#종료-상태-18">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-33"><a class="header" href="#예제-33">예제</a></h2>
<ol>
<li>
<p><code>foo</code> 패키지의 패키지 지정자 가져오기:</p>
<pre><code>cargo pkgid foo
</code></pre>
</li>
<li>
<p><code>foo</code> 1.0.0 버전의 패키지 지정자 가져오기:</p>
<pre><code>cargo pkgid foo@1.0.0
</code></pre>
</li>
<li>
<p>crates.io에서 <code>foo</code> 의 패키지 지정자 가져오기:</p>
<pre><code>cargo pkgid https://github.com/rust-lang/crates.io-index#foo
</code></pre>
</li>
<li>
<p>로컬 패키지에서 <code>foo</code> 의 패키지 지정자 가져오기:</p>
<pre><code>cargo pkgid file:///path/to/local/package#foo
</code></pre>
</li>
</ol>
<h2 id="참고-항목-22"><a class="header" href="#참고-항목-22">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-generate-lockfile.html">cargo-generate-lockfile(1)</a>, <a href="commands/cargo-metadata.html">cargo-metadata(1)</a>, <a href="commands/../reference/pkgid-spec.html">패키지 ID 명세</a>, <a href="commands/../reference/external-tools.html#json-messages">JSON 메시지</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-remove1"><a class="header" href="#cargo-remove1">cargo-remove(1)</a></h1>
<h2 id="이름-23"><a class="header" href="#이름-23">이름</a></h2>
<p>cargo-remove — Cargo.toml 매니페스트 파일에서 의존성을 제거합니다</p>
<h2 id="사용법-20"><a class="header" href="#사용법-20">사용법</a></h2>
<p><code>cargo remove</code> [<em>options</em>] <em>dependency</em>…</p>
<h2 id="설명-23"><a class="header" href="#설명-23">설명</a></h2>
<p><code>Cargo.toml</code> 매니페스트에서 하나 이상의 의존성을 제거합니다.</p>
<h2 id="옵션-20"><a class="header" href="#옵션-20">옵션</a></h2>
<h3 id="섹션-옵션-1"><a class="header" href="#섹션-옵션-1">섹션 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-remove---dev"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---dev"><code>--dev</code></a></dt>
<dd class="option-desc"><p>Remove as a <a href="commands/../reference/specifying-dependencies.html#development-dependencies">development dependency</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-remove---build"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---build"><code>--build</code></a></dt>
<dd class="option-desc"><p>Remove as a <a href="commands/../reference/specifying-dependencies.html#build-dependencies">build dependency</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-remove---target"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---target"><code>--target</code> <em>target</em></a></dt>
<dd class="option-desc"><p>Remove as a dependency to the <a href="commands/../reference/specifying-dependencies.html#platform-specific-dependencies">given target platform</a>.</p>
<p>To avoid unexpected shell expansions, you may use quotes around each target, e.g., <code>--target 'cfg(unix)'</code>.</p>
</dd>
</dl>
<h3 id="기타-옵션-9"><a class="header" href="#기타-옵션-9">기타 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-remove---dry-run"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---dry-run"><code>--dry-run</code></a></dt>
<dd class="option-desc"><p>Don’t actually write to the manifest.</p>
</dd>
</dl>
<h3 id="표시-옵션-19"><a class="header" href="#표시-옵션-19">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-remove--v"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-remove---verbose"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-remove--q"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-remove---quiet"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-remove---color"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="매니페스트-옵션-19"><a class="header" href="#매니페스트-옵션-19">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-remove---manifest-path"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-remove---locked"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-remove---offline"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-remove---frozen"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="패키지-선택-12"><a class="header" href="#패키지-선택-12">패키지 선택</a></h3>
<dl>
<dt class="option-term" id="option-cargo-remove--p"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove--p"><code>-p</code> <em>spec</em>…</a></dt>
<dt class="option-term" id="option-cargo-remove---package"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---package"><code>--package</code> <em>spec</em>…</a></dt>
<dd class="option-desc"><p>Package to remove from.</p>
</dd>
</dl>
<h3 id="공통-옵션-19"><a class="header" href="#공통-옵션-19">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-remove-+toolchain"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-remove---config"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-remove--C"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-remove--h"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-remove---help"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-remove--Z"><a class="option-anchor" href="commands/cargo-remove.html#option-cargo-remove--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-22"><a class="header" href="#환경-변수-22">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-19"><a class="header" href="#종료-상태-19">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-34"><a class="header" href="#예제-34">예제</a></h2>
<ol>
<li>
<p>의존성에서 <code>regex</code> 제거:</p>
<pre><code>cargo remove regex
</code></pre>
</li>
<li>
<p>개발 의존성에서 <code>trybuild</code> 제거:</p>
<pre><code>cargo remove --dev trybuild
</code></pre>
</li>
<li>
<p>Remove <code>nom</code> from the <code>wasm32-unknown-unknown</code> dependencies table</p>
<pre><code>cargo remove --target wasm32-unknown-unknown nom
</code></pre>
</li>
</ol>
<h2 id="참고-항목-23"><a class="header" href="#참고-항목-23">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-add.html">cargo-add(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-tree1"><a class="header" href="#cargo-tree1">cargo-tree(1)</a></h1>
<h2 id="이름-24"><a class="header" href="#이름-24">이름</a></h2>
<p>cargo-tree — 의존성 그래프를 트리 시각화로 표시합니다</p>
<h2 id="사용법-21"><a class="header" href="#사용법-21">사용법</a></h2>
<p><code>cargo tree</code> [<em>options</em>]</p>
<h2 id="설명-24"><a class="header" href="#설명-24">설명</a></h2>
<p>이 명령어는 터미널에 의존성 트리를 표시합니다. “rand” 패키지에 의존하는 간단한 프로젝트의 예시입니다:</p>
<pre><code>myproject v0.1.0 (/myproject)
└── rand v0.7.3
    ├── getrandom v0.1.14
    │   ├── cfg-if v0.1.10
    │   └── libc v0.2.68
    ├── libc v0.2.68 (*)
    ├── rand_chacha v0.2.2
    │   ├── ppv-lite86 v0.2.6
    │   └── rand_core v0.5.1
    │       └── getrandom v0.1.14 (*)
    └── rand_core v0.5.1 (*)
[build-dependencies]
└── cc v1.0.50
</code></pre>
<p><code>(*)</code> 로 표시된 패키지는 “중복 제거(de-duplicated)“된 것입니다. 해당 패키지의 의존성은 이미 그래프의 다른 곳에서 표시되었으므로 반복되지 않습니다. 중복된 내용을 다시 표시하려면 <code>--no-dedupe</code> 옵션을 사용하세요.</p>
<p><code>-e</code> 플래그를 사용하여 표시할 의존성 종류를 선택할 수 있습니다. “features” 종류는 각 의존성에 의해 활성화된 기능을 표시하도록 출력을 변경합니다. 예를 들어, <code>cargo tree -e features</code> 를 실행하면 다음과 같습니다:</p>
<pre><code>myproject v0.1.0 (/myproject)
└── log feature "serde"
    └── log v0.4.8
        ├── serde v1.0.106
        └── cfg-if feature "default"
            └── cfg-if v0.1.10
</code></pre>
<p>이 트리에서 <code>myproject</code> 는 <code>serde</code> 기능이 활성화된 <code>log</code> 에 의존합니다. <code>log</code> 는 다시 “default” 기능이 활성화된 <code>cfg-if</code> 에 의존합니다. <code>-e features</code> 를 사용할 때 <code>-i</code> 플래그를 함께 사용하면 기능들이 패키지로 어떻게 흘러 들어가는지 보여주는 데 도움이 됩니다. 자세한 내용은 아래 예제를 참조하세요.</p>
<h3 id="기능-통합-feature-unification-1"><a class="header" href="#기능-통합-feature-unification-1">기능 통합 (Feature Unification)</a></h3>
<p>이 명령어는 <code>Cargo.toml</code> 에 나열된 내용보다는 Cargo가 실제로 빌드할 기능 통합 그래프에 훨씬 더 가까운 그래프를 보여줍니다. 예를 들어, <code>[dependencies]</code> 와 <code>[dev-dependencies]</code> 양쪽에 동일한 의존성을 지정하되 서로 다른 기능을 켠 경우를 생각해 봅시다. 이 명령어는 모든 기능을 병합하고 의존성 중 하나에 <code>(*)</code> 를 표시하여 중복임을 나타낼 수 있습니다.</p>
<p>결과적으로, <code>cargo build</code> 가 수행하는 작업에 대한 대체적인 개요로는 <code>cargo tree -e normal,build</code> 가 꽤 근접하며, <code>cargo test</code> 가 수행하는 작업에 대해서는 <code>cargo tree</code> 가 꽤 근접합니다. 하지만 컴파일 과정은 복잡하고 많은 다양한 요인에 따라 달라지므로, Cargo가 실제로 빌드할 내용과 정확히 일치한다고 보장할 수는 없습니다.</p>
<p>기능 통합에 대해 더 자세히 알아보려면 <a href="commands/../reference/features.html#feature-unification">관련 섹션</a>을 확인하세요.</p>
<h2 id="옵션-21"><a class="header" href="#옵션-21">옵션</a></h2>
<h3 id="트리-옵션"><a class="header" href="#트리-옵션">트리 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-tree--i"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--i"><code>-i</code> <em>spec</em></a></dt>
<dt class="option-term" id="option-cargo-tree---invert"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---invert"><code>--invert</code> <em>spec</em></a></dt>
<dd class="option-desc"><p>Show the reverse dependencies for the given package. This flag will invert
the tree and display the packages that depend on the given package.</p>
<p>Note that in a workspace, by default it will only display the package’s
reverse dependencies inside the tree of the workspace member in the current
directory. The <code>--workspace</code> flag can be used to extend it so that it will
show the package’s reverse dependencies across the entire workspace. The <code>-p</code>
flag can be used to display the package’s reverse dependencies only with the
subtree of the package given to <code>-p</code>.</p>
</dd>
<dt class="option-term" id="option-cargo-tree---prune"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---prune"><code>--prune</code> <em>spec</em></a></dt>
<dd class="option-desc"><p>Prune the given package from the display of the dependency tree.</p>
</dd>
<dt class="option-term" id="option-cargo-tree---depth"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---depth"><code>--depth</code> <em>depth</em></a></dt>
<dd class="option-desc"><p>Maximum display depth of the dependency tree. A depth of 1 displays the direct
dependencies, for example.</p>
<p>If the given value is <code>workspace</code>, only shows the dependencies that are member
of the current workspace, instead.</p>
</dd>
<dt class="option-term" id="option-cargo-tree---no-dedupe"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---no-dedupe"><code>--no-dedupe</code></a></dt>
<dd class="option-desc"><p>Do not de-duplicate repeated dependencies. Usually, when a package has already
displayed its dependencies, further occurrences will not re-display its
dependencies, and will include a <code>(*)</code> to indicate it has already been shown.
This flag will cause those duplicates to be repeated.</p>
</dd>
<dt class="option-term" id="option-cargo-tree--d"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--d"><code>-d</code></a></dt>
<dt class="option-term" id="option-cargo-tree---duplicates"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---duplicates"><code>--duplicates</code></a></dt>
<dd class="option-desc"><p>Show only dependencies which come in multiple versions (implies <code>--invert</code>).
When used with the <code>-p</code> flag, only shows duplicates within the subtree of the
given package.</p>
<p>It can be beneficial for build times and executable sizes to avoid building
that same package multiple times. This flag can help identify the offending
packages. You can then investigate if the package that depends on the
duplicate with the older version can be updated to the newer version so that
only one instance is built.</p>
</dd>
<dt class="option-term" id="option-cargo-tree--e"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--e"><code>-e</code> <em>kinds</em></a></dt>
<dt class="option-term" id="option-cargo-tree---edges"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---edges"><code>--edges</code> <em>kinds</em></a></dt>
<dd class="option-desc"><p>The dependency kinds to display. Takes a comma separated list of values:</p>
<ul>
<li><code>all</code> — Show all edge kinds.</li>
<li><code>normal</code> — Show normal dependencies.</li>
<li><code>build</code> — Show build dependencies.</li>
<li><code>dev</code> — Show development dependencies.</li>
<li><code>features</code> — Show features enabled by each dependency. If this is the only
kind given, then it will automatically include the other dependency kinds.</li>
<li><code>no-normal</code> — Do not include normal dependencies.</li>
<li><code>no-build</code> — Do not include build dependencies.</li>
<li><code>no-dev</code> — Do not include development dependencies.</li>
<li><code>no-proc-macro</code> — Do not include procedural macro dependencies.</li>
</ul>
<p>The <code>normal</code>, <code>build</code>, <code>dev</code>, and <code>all</code> dependency kinds cannot be mixed with
<code>no-normal</code>, <code>no-build</code>, or <code>no-dev</code> dependency kinds.</p>
<p>The default is <code>normal,build,dev</code>.</p>
</dd>
<dt class="option-term" id="option-cargo-tree---target"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---target"><code>--target</code> <em>triple</em></a></dt>
<dd class="option-desc"><p>Filter dependencies matching the given <a href="commands/../appendix/glossary.html#target">target triple</a>.
The default is the host platform. Use the value <code>all</code> to include <em>all</em> targets.</p>
</dd>
</dl>
<h3 id="트리-형식-옵션"><a class="header" href="#트리-형식-옵션">트리 형식 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-tree---charset"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---charset"><code>--charset</code> <em>charset</em></a></dt>
<dd class="option-desc"><p>Chooses the character set to use for the tree. Valid values are “utf8” or
“ascii”. When unspecified, cargo will auto-select a value.</p>
</dd>
<dt class="option-term" id="option-cargo-tree--f"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--f"><code>-f</code> <em>format</em></a></dt>
<dt class="option-term" id="option-cargo-tree---format"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---format"><code>--format</code> <em>format</em></a></dt>
<dd class="option-desc"><p>Set the format string for each package. The default is “{p}”.</p>
<p>This is an arbitrary string which will be used to display each package. The following
strings will be replaced with the corresponding value:</p>
<ul>
<li><code>{p}</code>, <code>{package}</code> — The package name.</li>
<li><code>{l}</code>, <code>{license}</code> — The package license.</li>
<li><code>{r}</code>, <code>{repository}</code> — The package repository URL.</li>
<li><code>{f}</code>, <code>{features}</code> — Comma-separated list of package features that are enabled.</li>
<li><code>{lib}</code> — The name, as used in a <code>use</code> statement, of the package’s library.</li>
</ul>
</dd>
<dt class="option-term" id="option-cargo-tree---prefix"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---prefix"><code>--prefix</code> <em>prefix</em></a></dt>
<dd class="option-desc"><p>Sets how each line is displayed. The <em>prefix</em> value can be one of:</p>
<ul>
<li><code>indent</code> (default) — Shows each line indented as a tree.</li>
<li><code>depth</code> — Show as a list, with the numeric depth printed before each entry.</li>
<li><code>none</code> — Show as a flat list.</li>
</ul>
</dd>
</dl>
<h3 id="패키지-선택-13"><a class="header" href="#패키지-선택-13">패키지 선택</a></h3>
<p>기본적으로 패키지 선택 옵션이 주어지지 않으면, 선택된 패키지는 선택된 매니페스트 파일에 따라 달라집니다 (<code>--manifest-path</code> 가 주어지지 않은 경우 현재 작업 디렉토리를 기준으로 함). 매니페스트가 워크스페이스의 루트인 경우 워크스페이스의 기본 구성원들이 선택되고, 그렇지 않으면 매니페스트에 정의된 패키지만 선택됩니다.</p>
<p>워크스페이스의 기본 구성원은 루트 매니페스트의 <code>workspace.default-members</code> 키로 명시적으로 설정할 수 있습니다. 이 값이 설정되지 않은 경우, 가상 워크스페이스(virtual workspace)는 모든 워크스페이스 구성원을 포함하며(<code>--workspace</code>를 전달하는 것과 동일), 가상이 아닌 워크스페이스는 루트 크레이트 자체만 포함합니다.</p>
<dl>
<dt class="option-term" id="option-cargo-tree--p"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--p"><code>-p</code> <em>spec</em>…</a></dt>
<dt class="option-term" id="option-cargo-tree---package"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---package"><code>--package</code> <em>spec</em>…</a></dt>
<dd class="option-desc"><p>Display only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</p>
</dd>
<dt class="option-term" id="option-cargo-tree---workspace"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---workspace"><code>--workspace</code></a></dt>
<dd class="option-desc"><p>Display all members in the workspace.</p>
</dd>
<dt class="option-term" id="option-cargo-tree---exclude"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---exclude"><code>--exclude</code> <em>SPEC</em>…</a></dt>
<dd class="option-desc"><p>Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</p>
</dd>
</dl>
<h3 id="매니페스트-옵션-20"><a class="header" href="#매니페스트-옵션-20">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-tree---manifest-path"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-tree---locked"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-tree---offline"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-tree---frozen"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="기능-선택-10"><a class="header" href="#기능-선택-10">기능 선택</a></h3>
<p>기능 플래그를 통해 어떤 기능을 활성화할지 제어할 수 있습니다. 기능 옵션이 주어지지 않으면, 선택된 모든 패키지에 대해 <code>default</code> 기능이 활성화됩니다.</p>
<p>자세한 내용은 <a href="commands/../reference/features.html#command-line-feature-options">기능 문서</a>를 참조하세요.</p>
<dl>
<dt class="option-term" id="option-cargo-tree--F"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--F"><code>-F</code> <em>features</em></a></dt>
<dt class="option-term" id="option-cargo-tree---features"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---features"><code>--features</code> <em>features</em></a></dt>
<dd class="option-desc"><p>Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</p>
</dd>
<dt class="option-term" id="option-cargo-tree---all-features"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---all-features"><code>--all-features</code></a></dt>
<dd class="option-desc"><p>Activate all available features of all selected packages.</p>
</dd>
<dt class="option-term" id="option-cargo-tree---no-default-features"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---no-default-features"><code>--no-default-features</code></a></dt>
<dd class="option-desc"><p>Do not activate the <code>default</code> feature of the selected packages.</p>
</dd>
</dl>
<h3 id="표시-옵션-20"><a class="header" href="#표시-옵션-20">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-tree--v"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-tree---verbose"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-tree--q"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-tree---quiet"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-tree---color"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="공통-옵션-20"><a class="header" href="#공통-옵션-20">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-tree-+toolchain"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-tree---config"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-tree--C"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-tree--h"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-tree---help"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-tree--Z"><a class="option-anchor" href="commands/cargo-tree.html#option-cargo-tree--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-23"><a class="header" href="#환경-변수-23">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-20"><a class="header" href="#종료-상태-20">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-35"><a class="header" href="#예제-35">예제</a></h2>
<ol>
<li>
<p>현재 디렉토리 패키지의 트리를 표시합니다:</p>
<pre><code>cargo tree
</code></pre>
</li>
<li>
<p><code>syn</code> 패키지에 의존하는 모든 패키지를 표시합니다:</p>
<pre><code>cargo tree -i syn
</code></pre>
</li>
<li>
<p>각 패키지에서 활성화된 기능을 보여줍니다:</p>
<pre><code>cargo tree --format "{p} {f}"
</code></pre>
</li>
<li>
<p>여러 번 빌드된 모든 패키지를 보여줍니다. 이는 트리 내에 (1.0.0과 2.0.0처럼) 시맨틱 버전 호환이 되지 않는 여러 버전이 나타날 때 발생할 수 있습니다.</p>
<pre><code>cargo tree -d
</code></pre>
</li>
<li>
<p><code>syn</code> 패키지에서 기능들이 왜 활성화되었는지 설명합니다:</p>
<pre><code>cargo tree -e features -i syn
</code></pre>
<p><code>-e features</code> 플래그는 기능을 보여주는 데 사용됩니다. <code>-i</code> 플래그는 그래프를 반전시켜 <code>syn</code> 에 의존하는 패키지들을 표시하게 합니다. 출력 예시는 다음과 같습니다:</p>
<pre><code>syn v1.0.17
├── syn feature "clone-impls"
│   └── syn feature "default"
│       └── rustversion v1.0.2
│           └── rustversion feature "default"
│               └── myproject v0.1.0 (/myproject)
│                   └── myproject feature "default" (command-line)
├── syn feature "default" (*)
├── syn feature "derive"
│   └── syn feature "default" (*)
├── syn feature "full"
│   └── rustversion v1.0.2 (*)
├── syn feature "parsing"
│   └── syn feature "default" (*)
├── syn feature "printing"
│   └── syn feature "default" (*)
├── syn feature "proc-macro"
│   └── syn feature "default" (*)
└── syn feature "quote"
    ├── syn feature "printing" (*)
    └── syn feature "proc-macro" (*)
</code></pre>
<p>이 그래프를 읽으려면, 루트에서 각 기능까지의 연결을 따라가며 왜 해당 기능이 포함되었는지 확인할 수 있습니다. 예를 들어, “full” 기능은 <code>myproject</code>(기본 기능 포함)에서 포함한 <code>rustversion</code> 크레이트에 의해 추가되었으며, <code>myproject</code> 는 명령줄에서 선택한 패키지입니다. <code>syn</code> 의 다른 모든 기능들은 “default” 기능에 의해 추가되었습니다 (“quote“는 “printing“과 “proc-macro“에 의해 추가되며, 이 둘 모두 기본 기능입니다).</p>
<p>중복 제거된 <code>(*)</code> 항목들을 상호 참조하는 데 어려움이 있다면, <code>--no-dedupe</code> 플래그를 사용하여 전체 출력을 확인해 보세요.</p>
</li>
</ol>
<h2 id="참고-항목-24"><a class="header" href="#참고-항목-24">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-metadata.html">cargo-metadata(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-update1"><a class="header" href="#cargo-update1">cargo-update(1)</a></h1>
<h2 id="이름-25"><a class="header" href="#이름-25">이름</a></h2>
<p>cargo-update — 로컬 잠금 파일에 기록된 의존성을 업데이트합니다</p>
<h2 id="사용법-22"><a class="header" href="#사용법-22">사용법</a></h2>
<p><code>cargo update</code> [<em>options</em>] <em>spec</em></p>
<h2 id="설명-25"><a class="header" href="#설명-25">설명</a></h2>
<p>이 명령어는 <code>Cargo.lock</code> 파일의 의존성을 최신 버전으로 업데이트합니다. <code>Cargo.lock</code> 파일이 존재하지 않는 경우, 사용 가능한 최신 버전으로 파일을 생성합니다.</p>
<h2 id="옵션-22"><a class="header" href="#옵션-22">옵션</a></h2>
<h3 id="업데이트-옵션"><a class="header" href="#업데이트-옵션">업데이트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-update-spec…"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update-spec…"><em>spec</em>…</a></dt>
<dd class="option-desc"><p>Update only the specified packages. This flag may be specified
multiple times. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC format.</p>
<p>If packages are specified with <em>spec</em>, then a conservative update of
the lockfile will be performed. This means that only the dependency specified
by SPEC will be updated. Its transitive dependencies will be updated only if
SPEC cannot be updated without updating dependencies.  All other dependencies
will remain locked at their currently recorded versions.</p>
<p>If <em>spec</em> is not specified, all dependencies are updated.</p>
</dd>
<dt class="option-term" id="option-cargo-update---recursive"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---recursive"><code>--recursive</code></a></dt>
<dd class="option-desc"><p>When used with <em>spec</em>, dependencies of <em>spec</em> are forced to update as well.
Cannot be used with <code>--precise</code>.</p>
</dd>
<dt class="option-term" id="option-cargo-update---precise"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---precise"><code>--precise</code> <em>precise</em></a></dt>
<dd class="option-desc"><p>When used with <em>spec</em>, allows you to specify a specific version number to set
the package to. If the package comes from a git repository, this can be a git
revision (such as a SHA hash or tag).</p>
<p>While not recommended, you can specify a yanked version of a package.
When possible, try other non-yanked SemVer-compatible versions or seek help
from the maintainers of the package.</p>
<p>A compatible <code>pre-release</code> version can also be specified even when the version
requirement in <code>Cargo.toml</code> doesn’t contain any pre-release identifier (nightly only).</p>
</dd>
<dt class="option-term" id="option-cargo-update---breaking"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---breaking"><code>--breaking</code> <em>directory</em></a></dt>
<dd class="option-desc"><p>Update <em>spec</em> to latest SemVer-breaking version.</p>
<p>Version requirements will be modified to allow this update.</p>
<p>This only applies to dependencies when</p>
<ul>
<li>The package is a dependency of a workspace member</li>
<li>The dependency is not renamed</li>
<li>A SemVer-incompatible version is available</li>
<li>The “SemVer operator” is used (<code>^</code> which is the default)</li>
</ul>
<p>This option is unstable and available only on the
<a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly channel</a>
and requires the <code>-Z unstable-options</code> flag to enable.
See <a href="https://github.com/rust-lang/cargo/issues/12425">https://github.com/rust-lang/cargo/issues/12425</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-update--w"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update--w"><code>-w</code></a></dt>
<dt class="option-term" id="option-cargo-update---workspace"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---workspace"><code>--workspace</code></a></dt>
<dd class="option-desc"><p>Attempt to update only packages defined in the workspace. Other packages
are updated only if they don’t already exist in the lockfile. This
option is useful for updating <code>Cargo.lock</code> after you’ve changed version
numbers in <code>Cargo.toml</code>.</p>
</dd>
<dt class="option-term" id="option-cargo-update---dry-run"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---dry-run"><code>--dry-run</code></a></dt>
<dd class="option-desc"><p>Displays what would be updated, but doesn’t actually write the lockfile.</p>
</dd>
</dl>
<h3 id="표시-옵션-21"><a class="header" href="#표시-옵션-21">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-update--v"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-update---verbose"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-update--q"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-update---quiet"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-update---color"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="매니페스트-옵션-21"><a class="header" href="#매니페스트-옵션-21">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-update---manifest-path"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-update---ignore-rust-version"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---ignore-rust-version"><code>--ignore-rust-version</code></a></dt>
<dd class="option-desc"><p>Ignore <code>rust-version</code> specification in packages.</p>
</dd>
<dt class="option-term" id="option-cargo-update---locked"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-update---offline"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-update---frozen"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션-21"><a class="header" href="#공통-옵션-21">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-update-+toolchain"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-update---config"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-update--C"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-update--h"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-update---help"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-update--Z"><a class="option-anchor" href="commands/cargo-update.html#option-cargo-update--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-24"><a class="header" href="#환경-변수-24">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-21"><a class="header" href="#종료-상태-21">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-36"><a class="header" href="#예제-36">예제</a></h2>
<ol>
<li>
<p>잠금 파일의 모든 의존성 업데이트:</p>
<pre><code>cargo update
</code></pre>
</li>
<li>
<p>특정 의존성만 업데이트:</p>
<pre><code>cargo update foo bar
</code></pre>
</li>
<li>
<p>특정 의존성을 특정 버전으로 설정:</p>
<pre><code>cargo update foo --precise 1.2.3
</code></pre>
</li>
</ol>
<h2 id="참고-항목-25"><a class="header" href="#참고-항목-25">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-generate-lockfile.html">cargo-generate-lockfile(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-vendor1"><a class="header" href="#cargo-vendor1">cargo-vendor(1)</a></h1>
<h2 id="이름-26"><a class="header" href="#이름-26">이름</a></h2>
<p>cargo-vendor — 모든 의존성을 로컬로 벤더링합니다</p>
<h2 id="사용법-23"><a class="header" href="#사용법-23">사용법</a></h2>
<p><code>cargo vendor</code> [<em>options</em>] [<em>path</em>]</p>
<h2 id="설명-26"><a class="header" href="#설명-26">설명</a></h2>
<p>이 Cargo 하위 명령어는 프로젝트의 모든 crates.io 및 git 의존성을 지정된 <code>&lt;path&gt;</code> 디렉토리로 벤더링합니다. 이 명령어가 완료되면 <code>&lt;path&gt;</code> 로 지정된 벤더 디렉토리에는 지정된 의존성들의 모든 원격 소스가 포함됩니다. <code>-s</code> 옵션을 사용하여 기본 매니페스트 외에 추가 매니페스트를 지정할 수 있습니다.</p>
<p>벤더링된 소스를 사용하는 데 필요한 설정은 <code>cargo vendor</code> 가 벤더링 과정을 마친 후 표준 출력(stdout)으로 인쇄됩니다. 이를 Cargo 설정 파일(보통 현재 패키지의 로컬 <code>.cargo/config.toml</code>)에 추가하거나 리다이렉션해야 합니다.</p>
<p>Cargo는 레지스트리 및 git 소스와 마찬가지로 벤더링된 소스를 읽기 전용으로 취급합니다. 원격 소스의 크레이트를 수정하려면, <code>[patch]</code> 를 사용하거나 해당 크레이트의 로컬 복사본을 가리키는 <code>path</code> 의존성을 사용하세요. 그러면 Cargo는 해당 크레이트가 더 이상 읽기 전용 의존성이 아님을 알게 되므로, 증분 재빌드 시 이를 올바르게 처리합니다.</p>
<h2 id="옵션-23"><a class="header" href="#옵션-23">옵션</a></h2>
<h3 id="벤더-옵션"><a class="header" href="#벤더-옵션">벤더 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-vendor--s"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor--s"><code>-s</code> <em>manifest</em></a></dt>
<dt class="option-term" id="option-cargo-vendor---sync"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---sync"><code>--sync</code> <em>manifest</em></a></dt>
<dd class="option-desc"><p>Specify an extra <code>Cargo.toml</code> manifest to workspaces which should also be
vendored and synced to the output. May be specified multiple times.</p>
</dd>
<dt class="option-term" id="option-cargo-vendor---no-delete"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---no-delete"><code>--no-delete</code></a></dt>
<dd class="option-desc"><p>Don’t delete the “vendor” directory when vendoring, but rather keep all
existing contents of the vendor directory</p>
</dd>
<dt class="option-term" id="option-cargo-vendor---respect-source-config"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---respect-source-config"><code>--respect-source-config</code></a></dt>
<dd class="option-desc"><p>Instead of ignoring <code>[source]</code> configuration by default in <code>.cargo/config.toml</code>
read it and use it when downloading crates from crates.io, for example</p>
</dd>
<dt class="option-term" id="option-cargo-vendor---versioned-dirs"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---versioned-dirs"><code>--versioned-dirs</code></a></dt>
<dd class="option-desc"><p>Normally versions are only added to disambiguate multiple versions of the
same package. This option causes all directories in the “vendor” directory
to be versioned, which makes it easier to track the history of vendored
packages over time, and can help with the performance of re-vendoring when
only a subset of the packages have changed.</p>
</dd>
</dl>
<h3 id="매니페스트-옵션-22"><a class="header" href="#매니페스트-옵션-22">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-vendor---manifest-path"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-vendor---locked"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-vendor---offline"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-vendor---frozen"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="표시-옵션-22"><a class="header" href="#표시-옵션-22">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-vendor--v"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-vendor---verbose"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-vendor--q"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-vendor---quiet"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-vendor---color"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="공통-옵션-22"><a class="header" href="#공통-옵션-22">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-vendor-+toolchain"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-vendor---config"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-vendor--C"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-vendor--h"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-vendor---help"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-vendor--Z"><a class="option-anchor" href="commands/cargo-vendor.html#option-cargo-vendor--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-25"><a class="header" href="#환경-변수-25">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-22"><a class="header" href="#종료-상태-22">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-37"><a class="header" href="#예제-37">예제</a></h2>
<ol>
<li>
<p>모든 의존성을 로컬 “vendor” 폴더로 벤더링합니다</p>
<pre><code>cargo vendor
</code></pre>
</li>
<li>
<p>모든 의존성을 로컬 “third-party/vendor” 폴더로 벤더링합니다</p>
<pre><code>cargo vendor third-party/vendor
</code></pre>
</li>
<li>
<p>현재 워크스페이스와 다른 워크스페이스를 함께 “vendor“로 벤더링합니다</p>
<pre><code>cargo vendor -s ../path/to/Cargo.toml
</code></pre>
</li>
<li>
<p>벤더링하고 필요한 벤더 설정을 설정 파일로 리다이렉션합니다.</p>
<pre><code>cargo vendor &gt; path/to/my/cargo/config.toml
</code></pre>
</li>
</ol>
<h2 id="참고-항목-26"><a class="header" href="#참고-항목-26">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="패키지-명령어-1"><a class="header" href="#패키지-명령어-1">패키지 명령어</a></h1>
<ul>
<li><a href="commands/cargo-init.html">cargo init</a></li>
<li><a href="commands/cargo-install.html">cargo install</a></li>
<li><a href="commands/cargo-new.html">cargo new</a></li>
<li><a href="commands/cargo-search.html">cargo search</a></li>
<li><a href="commands/cargo-uninstall.html">cargo uninstall</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-init1"><a class="header" href="#cargo-init1">cargo-init(1)</a></h1>
<h2 id="이름-27"><a class="header" href="#이름-27">이름</a></h2>
<p>cargo-init — 기존 디렉토리에 새로운 Cargo 패키지를 생성합니다</p>
<h2 id="사용법-24"><a class="header" href="#사용법-24">사용법</a></h2>
<p><code>cargo init</code> [<em>options</em>] [<em>path</em>]</p>
<h2 id="설명-27"><a class="header" href="#설명-27">설명</a></h2>
<p>이 명령어는 현재 디렉토리에 새로운 Cargo 매니페스트를 생성합니다. 인수로 경로를 전달하면 해당 디렉토리에 생성합니다.</p>
<p>디렉토리에 이미 전형적인 이름의 Rust 소스 파일이 있는 경우, 해당 파일들이 사용됩니다. 그렇지 않으면 샘플 <code>src/main.rs</code> 파일이 생성되며, <code>--lib</code> 가 전달된 경우 <code>src/lib.rs</code> 가 생성됩니다.</p>
<p>디렉토리가 아직 VCS 저장소 내에 있지 않은 경우, 새로운 저장소가 생성됩니다 (아래 <code>--vcs</code> 참조).</p>
<p>새로운 디렉토리에 새 패키지를 생성하는 유사한 명령어인 <a href="commands/cargo-new.html">cargo-new(1)</a>를 참조하세요.</p>
<h2 id="옵션-24"><a class="header" href="#옵션-24">옵션</a></h2>
<h3 id="초기화-옵션"><a class="header" href="#초기화-옵션">초기화 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-init---bin"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---bin"><code>--bin</code></a></dt>
<dd class="option-desc"><p>Create a package with a binary target (<code>src/main.rs</code>).
This is the default behavior.</p>
</dd>
<dt class="option-term" id="option-cargo-init---lib"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---lib"><code>--lib</code></a></dt>
<dd class="option-desc"><p>Create a package with a library target (<code>src/lib.rs</code>).</p>
</dd>
<dt class="option-term" id="option-cargo-init---edition"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---edition"><code>--edition</code> <em>edition</em></a></dt>
<dd class="option-desc"><p>Specify the Rust edition to use. Default is 2024.
Possible values: 2015, 2018, 2021, 2024</p>
</dd>
<dt class="option-term" id="option-cargo-init---name"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---name"><code>--name</code> <em>name</em></a></dt>
<dd class="option-desc"><p>Set the package name. Defaults to the directory name.</p>
</dd>
<dt class="option-term" id="option-cargo-init---vcs"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---vcs"><code>--vcs</code> <em>vcs</em></a></dt>
<dd class="option-desc"><p>Initialize a new VCS repository for the given version control system (git,
hg, pijul, or fossil) or do not initialize any version control at all
(none). If not specified, defaults to <code>git</code> or the configuration value
<code>cargo-new.vcs</code>, or <code>none</code> if already inside a VCS repository.</p>
</dd>
<dt class="option-term" id="option-cargo-init---registry"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---registry"><code>--registry</code> <em>registry</em></a></dt>
<dd class="option-desc"><p>This sets the <code>publish</code> field in <code>Cargo.toml</code> to the given registry name
which will restrict publishing only to that registry.</p>
<p>Registry names are defined in <a href="commands/../reference/config.html">Cargo config files</a>.
If not specified, the default registry defined by the <code>registry.default</code>
config key is used. If the default registry is not set and <code>--registry</code> is not
used, the <code>publish</code> field will not be set which means that publishing will not
be restricted.</p>
</dd>
</dl>
<h3 id="표시-옵션-23"><a class="header" href="#표시-옵션-23">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-init--v"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-init---verbose"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-init--q"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-init---quiet"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-init---color"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="공통-옵션-23"><a class="header" href="#공통-옵션-23">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-init-+toolchain"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-init---config"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-init--C"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-init--h"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-init---help"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-init--Z"><a class="option-anchor" href="commands/cargo-init.html#option-cargo-init--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-26"><a class="header" href="#환경-변수-26">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-23"><a class="header" href="#종료-상태-23">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-38"><a class="header" href="#예제-38">예제</a></h2>
<ol>
<li>
<p>현재 디렉토리에 바이너리 Cargo 패키지 생성:</p>
<pre><code>cargo init
</code></pre>
</li>
</ol>
<h2 id="참고-항목-27"><a class="header" href="#참고-항목-27">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-new.html">cargo-new(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-install1"><a class="header" href="#cargo-install1">cargo-install(1)</a></h1>
<h2 id="이름-28"><a class="header" href="#이름-28">이름</a></h2>
<p>cargo-install — 러스트 바이너리를 빌드하고 설치합니다</p>
<h2 id="사용법-25"><a class="header" href="#사용법-25">사용법</a></h2>
<p><code>cargo install</code> [<em>options</em>] <em>crate</em>[@<em>version</em>]…<br />
<code>cargo install</code> [<em>options</em>] <code>--path</code> <em>path</em><br />
<code>cargo install</code> [<em>options</em>] <code>--git</code> <em>url</em> [<em>crate</em>…]<br />
<code>cargo install</code> [<em>options</em>] <code>--list</code></p>
<h2 id="설명-28"><a class="header" href="#설명-28">설명</a></h2>
<p>이 명령어는 Cargo의 설치된 바이너리 크레이트의 로컬 집합을 관리합니다. 실행 가능한 <code>[[bin]]</code> 또는 <code>[[example]]</code> 타겟을 가진 패키지만 설치할 수 있으며, 모든 실행 파일은 설치 루트의 <code>bin</code> 폴더에 설치됩니다. 기본적으로 예제가 아닌 바이너리만 설치됩니다.</p>
<p>설치 루트는 다음 우선순위에 따라 결정됩니다:</p>
<ul>
<li><code>--root</code> 옵션</li>
<li><code>CARGO_INSTALL_ROOT</code> 환경 변수</li>
<li><code>install.root</code> Cargo <a href="commands/../reference/config.html">설정 값</a></li>
<li><code>CARGO_HOME</code> 환경 변수</li>
<li><code>$HOME/.cargo</code></li>
</ul>
<p>크레이트를 설치할 수 있는 여러 소스가 있습니다. 기본 소스 위치는 crates.io이지만, <code>--git</code>, <code>--path</code>, <code>--registry</code> 플래그를 사용하여 이 소스를 변경할 수 있습니다. 소스에 둘 이상의 패키지가 포함된 경우 (예: crates.io 또는 여러 크레이트가 포함된 git 저장소), 어떤 크레이트를 설치할지 나타내기 위해 <em>crate</em> 인수가 필요합니다.</p>
<p>crates.io의 크레이트는 선택적으로 <code>--version</code> 플래그를 통해 설치하고자 하는 버전을 지정할 수 있으며, 이와 유사하게 git 저장소의 패키지는 설치할 브랜치, 태그 또는 리비전을 지정할 수 있습니다. 크레이트에 여러 바이너리가 있는 경우, <code>--bin</code> 인수를 사용하여 그중 하나만 선택적으로 설치할 수 있으며, 예제를 설치하고 싶은 경우 <code>--example</code> 인수를 사용할 수도 있습니다.</p>
<p>패키지가 이미 설치되어 있는 경우, 설치된 버전이 최신이 아닌 것처럼 보이면 Cargo는 이를 재설치합니다. 다음 값 중 하나라도 변경되면 Cargo는 패키지를 재설치합니다:</p>
<ul>
<li>패키지 버전 및 소스.</li>
<li>설치된 바이너리 이름 집합.</li>
<li>선택된 기능(features).</li>
<li>프로파일 (<code>--profile</code>).</li>
<li>타겟 (<code>--target</code>).</li>
</ul>
<p><code>--path</code> 를 사용하여 설치하면 다른 패키지의 바이너리와 충돌하지 않는 한 항상 빌드 및 설치됩니다. <code>--force</code> 플래그를 사용하면 Cargo가 항상 패키지를 재설치하도록 강제할 수 있습니다.</p>
<p>소스가 crates.io이거나 <code>--git</code> 인 경우, 기본적으로 크레이트는 임시 타겟 디렉토리에서 빌드됩니다. 이를 방지하려면 <code>CARGO_TARGET_DIR</code> 환경 변수를 상대 경로로 설정하여 타겟 디렉토리를 지정할 수 있습니다. 특히 이는 지속적 통합(CI) 시스템에서 빌드 결과물을 캐싱하는 데 유용할 수 있습니다.</p>
<h3 id="잠금-파일-처리"><a class="header" href="#잠금-파일-처리">잠금 파일 처리</a></h3>
<p>기본적으로 패키지에 포함된 <code>Cargo.lock</code> 파일은 무시됩니다. 이는 Cargo가 사용할 의존성 버전을 다시 계산하며, 패키지가 게시된 이후 릴리스된 최신 버전을 사용할 수도 있음을 의미합니다. <code>--locked</code> 플래그를 사용하면 사용 가능한 경우 패키지화된 <code>Cargo.lock</code> 파일을 사용하도록 강제할 수 있습니다. 이는 패키지가 게시되었을 때 사용 가능했던 정확히 동일한 의존성 집합을 사용하여 재현 가능한 빌드를 보장하는 데 유용할 수 있습니다. 또한 의존성의 최신 버전이 시스템에서 빌드되지 않거나 다른 문제가 있는 경우에도 유용할 수 있습니다. <code>--locked</code> 를 사용하는 것의 단점은 의존성에 대한 어떠한 수정 사항이나 업데이트도 받지 못한다는 것입니다. Cargo는 1.37 버전부터 <code>Cargo.lock</code> 파일을 게시하기 시작했으므로, 그 이전 버전에 게시된 패키지는 사용할 수 있는 <code>Cargo.lock</code> 파일이 없음을 유의하세요.</p>
<h3 id="설정-탐색"><a class="header" href="#설정-탐색">설정 탐색</a></h3>
<p>이 명령어는 프로젝트 수준이 아니라 시스템 또는 사용자 수준에서 작동합니다. 즉, 로컬 <a href="commands/../reference/config.html#hierarchical-structure">설정 탐색</a> 이 무시됩니다. 대신 <code>$CARGO_HOME/config.toml</code> 에서 설정 탐색을 시작합니다. 패키지가 <code>--path $PATH</code> 로 설치된 경우, 로컬 설정이 사용되며 <code>$PATH/.cargo/config.toml</code>에서 탐색을 시작합니다.</p>
<h2 id="옵션-25"><a class="header" href="#옵션-25">옵션</a></h2>
<h3 id="설치-옵션"><a class="header" href="#설치-옵션">설치 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install---vers"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---vers"><code>--vers</code> <em>version</em></a></dt>
<dt class="option-term" id="option-cargo-install---version"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---version"><code>--version</code> <em>version</em></a></dt>
<dd class="option-desc"><p>Specify a version to install. This may be a <a href="commands/../reference/specifying-dependencies.html">version
requirement</a>, like <code>~1.2</code>, to have Cargo
select the newest version from the given requirement. If the version does not
have a requirement operator (such as <code>^</code> or <code>~</code>), then it must be in the form
<em>MAJOR.MINOR.PATCH</em>, and will install exactly that version; it is <em>not</em>
treated as a caret requirement like Cargo dependencies are.</p>
</dd>
<dt class="option-term" id="option-cargo-install---git"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---git"><code>--git</code> <em>url</em></a></dt>
<dd class="option-desc"><p>Git URL to install the specified crate from.</p>
</dd>
<dt class="option-term" id="option-cargo-install---branch"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---branch"><code>--branch</code> <em>branch</em></a></dt>
<dd class="option-desc"><p>Branch to use when installing from git.</p>
</dd>
<dt class="option-term" id="option-cargo-install---tag"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---tag"><code>--tag</code> <em>tag</em></a></dt>
<dd class="option-desc"><p>Tag to use when installing from git.</p>
</dd>
<dt class="option-term" id="option-cargo-install---rev"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---rev"><code>--rev</code> <em>sha</em></a></dt>
<dd class="option-desc"><p>Specific commit to use when installing from git.</p>
</dd>
<dt class="option-term" id="option-cargo-install---path"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---path"><code>--path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Filesystem path to local crate to install from.</p>
</dd>
<dt class="option-term" id="option-cargo-install---list"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---list"><code>--list</code></a></dt>
<dd class="option-desc"><p>List all installed packages and their versions.</p>
</dd>
<dt class="option-term" id="option-cargo-install--n"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--n"><code>-n</code></a></dt>
<dt class="option-term" id="option-cargo-install---dry-run"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---dry-run"><code>--dry-run</code></a></dt>
<dd class="option-desc"><p>(unstable) Perform all checks without installing.</p>
</dd>
<dt class="option-term" id="option-cargo-install--f"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--f"><code>-f</code></a></dt>
<dt class="option-term" id="option-cargo-install---force"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---force"><code>--force</code></a></dt>
<dd class="option-desc"><p>Force overwriting existing crates or binaries. This can be used if a package
has installed a binary with the same name as another package. This is also
useful if something has changed on the system that you want to rebuild with,
such as a newer version of <code>rustc</code>.</p>
</dd>
<dt class="option-term" id="option-cargo-install---no-track"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---no-track"><code>--no-track</code></a></dt>
<dd class="option-desc"><p>By default, Cargo keeps track of the installed packages with a metadata file
stored in the installation root directory. This flag tells Cargo not to use or
create that file. With this flag, Cargo will refuse to overwrite any existing
files unless the <code>--force</code> flag is used. This also disables Cargo’s ability to
protect against multiple concurrent invocations of Cargo installing at the
same time.</p>
</dd>
<dt class="option-term" id="option-cargo-install---bin"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---bin"><code>--bin</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Install only the specified binary.</p>
</dd>
<dt class="option-term" id="option-cargo-install---bins"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---bins"><code>--bins</code></a></dt>
<dd class="option-desc"><p>Install all binaries. This is the default behavior.</p>
</dd>
<dt class="option-term" id="option-cargo-install---example"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---example"><code>--example</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Install only the specified example.</p>
</dd>
<dt class="option-term" id="option-cargo-install---examples"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---examples"><code>--examples</code></a></dt>
<dd class="option-desc"><p>Install all examples.</p>
</dd>
<dt class="option-term" id="option-cargo-install---root"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---root"><code>--root</code> <em>dir</em></a></dt>
<dd class="option-desc"><p>Directory to install packages into.</p>
</dd>
<dt class="option-term" id="option-cargo-install---registry"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---registry"><code>--registry</code> <em>registry</em></a></dt>
<dd class="option-desc"><p>Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</p>
</dd>
<dt class="option-term" id="option-cargo-install---index"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---index"><code>--index</code> <em>index</em></a></dt>
<dd class="option-desc"><p>The URL of the registry index to use.</p>
</dd>
</dl>
<h3 id="기능-선택-11"><a class="header" href="#기능-선택-11">기능 선택</a></h3>
<p>기능 플래그를 통해 어떤 기능을 활성화할지 제어할 수 있습니다. 기능 옵션이 주어지지 않으면, 선택된 모든 패키지에 대해 <code>default</code> 기능이 활성화됩니다.</p>
<p>자세한 내용은 <a href="commands/../reference/features.html#command-line-feature-options">기능 문서</a>를 참조하세요.</p>
<dl>
<dt class="option-term" id="option-cargo-install--F"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--F"><code>-F</code> <em>features</em></a></dt>
<dt class="option-term" id="option-cargo-install---features"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---features"><code>--features</code> <em>features</em></a></dt>
<dd class="option-desc"><p>Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</p>
</dd>
<dt class="option-term" id="option-cargo-install---all-features"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---all-features"><code>--all-features</code></a></dt>
<dd class="option-desc"><p>Activate all available features of all selected packages.</p>
</dd>
<dt class="option-term" id="option-cargo-install---no-default-features"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---no-default-features"><code>--no-default-features</code></a></dt>
<dd class="option-desc"><p>Do not activate the <code>default</code> feature of the selected packages.</p>
</dd>
</dl>
<h3 id="컴파일-옵션-9"><a class="header" href="#컴파일-옵션-9">컴파일 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install---target"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---target"><code>--target</code> <em>triple</em></a></dt>
<dd class="option-desc"><p>Install for the specified target architecture. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>.</p>
<p>Possible values:</p>
<ul>
<li>Any supported target in <code>rustc --print target-list</code>.</li>
<li><code>"host-tuple"</code>, which will internally be substituted by the host’s target. This can be particularly useful if you’re cross-compiling some crates, and don’t want to specify your host’s machine as a target (for instance, an <code>xtask</code> in a shared project that may be worked on by many hosts).</li>
<li>A path to a custom target specification. See <a href="commands/../../rustc/targets/custom.html#custom-target-lookup-path">Custom Target Lookup Path</a> for more information.</li>
</ul>
<p>This may also be specified with the <code>build.target</code> <a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../reference/build-cache.html">build cache</a> documentation for more details.</p>
</dd>
<dt class="option-term" id="option-cargo-install---target-dir"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---target-dir"><code>--target-dir</code> <em>directory</em></a></dt>
<dd class="option-desc"><p>Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to a new temporary folder located in the
temporary directory of the platform.</p>
<p>When using <code>--path</code>, by default it will use <code>target</code> directory in the workspace
of the local crate unless <code>--target-dir</code>
is specified.</p>
</dd>
<dt class="option-term" id="option-cargo-install---debug"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---debug"><code>--debug</code></a></dt>
<dd class="option-desc"><p>Build with the <code>dev</code> profile instead of the <code>release</code> profile.
See also the <code>--profile</code> option for choosing a specific profile by name.</p>
</dd>
<dt class="option-term" id="option-cargo-install---profile"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---profile"><code>--profile</code> <em>name</em></a></dt>
<dd class="option-desc"><p>Install with the given profile.
See <a href="commands/../reference/profiles.html">the reference</a> for more details on profiles.</p>
</dd>
<dt class="option-term" id="option-cargo-install---timings"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---timings"><code>--timings</code></a></dt>
<dd class="option-desc"><p>Output information how long each compilation takes, and track concurrency
information over time.</p>
<p>A file <code>cargo-timing.html</code> will be written to the <code>target/cargo-timings</code>
directory at the end of the build. An additional report with a timestamp
in its filename is also written if you want to look at a previous run.
These reports are suitable for human consumption only, and do not provide
machine-readable timing data.</p>
</dd>
</dl>
<h3 id="매니페스트-옵션-23"><a class="header" href="#매니페스트-옵션-23">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install---ignore-rust-version"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---ignore-rust-version"><code>--ignore-rust-version</code></a></dt>
<dd class="option-desc"><p>Ignore <code>rust-version</code> specification in packages.</p>
</dd>
<dt class="option-term" id="option-cargo-install---locked"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-install---offline"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-install---frozen"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="기타-옵션-10"><a class="header" href="#기타-옵션-10">기타 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install--j"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--j"><code>-j</code> <em>N</em></a></dt>
<dt class="option-term" id="option-cargo-install---jobs"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---jobs"><code>--jobs</code> <em>N</em></a></dt>
<dd class="option-desc"><p>Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value. If
a string <code>default</code> is provided, it sets the value back to defaults.
Should not be 0.</p>
</dd>
<dt class="option-term" id="option-cargo-install---keep-going"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---keep-going"><code>--keep-going</code></a></dt>
<dd class="option-desc"><p>Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build.</p>
<p>For example if the current package depends on dependencies <code>fails</code> and <code>works</code>,
one of which fails to build, <code>cargo install -j1</code> may or may not build the
one that succeeds (depending on which one of the two builds Cargo picked to run
first), whereas <code>cargo install -j1 --keep-going</code> would definitely run both
builds, even if the one run first fails.</p>
</dd>
</dl>
<h3 id="표시-옵션-24"><a class="header" href="#표시-옵션-24">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install--v"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-install---verbose"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-install--q"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-install---quiet"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-install---color"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-install---message-format"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---message-format"><code>--message-format</code> <em>fmt</em></a></dt>
<dd class="option-desc"><p>The output format for diagnostic messages. Can be specified multiple times
and consists of comma-separated values. Valid values:</p>
<ul>
<li><code>human</code> (default): Display in a human-readable text format. Conflicts with
<code>short</code> and <code>json</code>.</li>
<li><code>short</code>: Emit shorter, human-readable text messages. Conflicts with <code>human</code>
and <code>json</code>.</li>
<li><code>json</code>: Emit JSON messages to stdout. See
<a href="commands/../reference/external-tools.html#json-messages">the reference</a>
for more details. Conflicts with <code>human</code> and <code>short</code>.</li>
<li><code>json-diagnostic-short</code>: Ensure the <code>rendered</code> field of JSON messages contains
the “short” rendering from rustc. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-diagnostic-rendered-ansi</code>: Ensure the <code>rendered</code> field of JSON messages
contains embedded ANSI color codes for respecting rustc’s default color
scheme. Cannot be used with <code>human</code> or <code>short</code>.</li>
<li><code>json-render-diagnostics</code>: Instruct Cargo to not include rustc diagnostics
in JSON messages printed, but instead Cargo itself should render the
JSON diagnostics coming from rustc. Cargo’s own JSON diagnostics and others
coming from rustc are still emitted. Cannot be used with <code>human</code> or <code>short</code>.</li>
</ul>
</dd>
</dl>
<h3 id="공통-옵션-24"><a class="header" href="#공통-옵션-24">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-install-+toolchain"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-install---config"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-install--C"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-install--h"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-install---help"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-install--Z"><a class="option-anchor" href="commands/cargo-install.html#option-cargo-install--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-27"><a class="header" href="#환경-변수-27">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-24"><a class="header" href="#종료-상태-24">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-39"><a class="header" href="#예제-39">예제</a></h2>
<ol>
<li>
<p>crates.io에서 패키지를 설치하거나 업그레이드합니다:</p>
<pre><code>cargo install ripgrep
</code></pre>
</li>
<li>
<p>현재 디렉토리의 패키지를 설치하거나 재설치합니다:</p>
<pre><code>cargo install --path .
</code></pre>
</li>
<li>
<p>설치된 패키지 목록 보기:</p>
<pre><code>cargo install --list
</code></pre>
</li>
</ol>
<h2 id="참고-항목-28"><a class="header" href="#참고-항목-28">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-uninstall.html">cargo-uninstall(1)</a>, <a href="commands/cargo-search.html">cargo-search(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-new1"><a class="header" href="#cargo-new1">cargo-new(1)</a></h1>
<h2 id="이름-29"><a class="header" href="#이름-29">이름</a></h2>
<p>cargo-new — 새로운 Cargo 패키지를 생성합니다</p>
<h2 id="사용법-26"><a class="header" href="#사용법-26">사용법</a></h2>
<p><code>cargo new</code> [<em>options</em>] <em>path</em></p>
<h2 id="설명-29"><a class="header" href="#설명-29">설명</a></h2>
<p>이 명령어는 지정된 디렉토리에 새로운 Cargo 패키지를 생성합니다. 여기에는 <code>Cargo.toml</code> 매니페스트, 샘플 소스 파일, 그리고 VCS 무시 파일이 포함된 간단한 템플릿이 포함됩니다. 디렉토리가 아직 VCS 저장소 내에 있지 않은 경우, 새로운 저장소가 생성됩니다 (아래 <code>--vcs</code> 참조).</p>
<p>기존 디렉토리에 새로운 매니페스트를 생성하는 유사한 명령어인 <a href="commands/cargo-init.html">cargo-init(1)</a>를 참조하세요.</p>
<h2 id="옵션-26"><a class="header" href="#옵션-26">옵션</a></h2>
<h3 id="새-패키지-옵션"><a class="header" href="#새-패키지-옵션">새 패키지 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-new---bin"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---bin"><code>--bin</code></a></dt>
<dd class="option-desc"><p>Create a package with a binary target (<code>src/main.rs</code>).
This is the default behavior.</p>
</dd>
<dt class="option-term" id="option-cargo-new---lib"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---lib"><code>--lib</code></a></dt>
<dd class="option-desc"><p>Create a package with a library target (<code>src/lib.rs</code>).</p>
</dd>
<dt class="option-term" id="option-cargo-new---edition"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---edition"><code>--edition</code> <em>edition</em></a></dt>
<dd class="option-desc"><p>Specify the Rust edition to use. Default is 2024.
Possible values: 2015, 2018, 2021, 2024</p>
</dd>
<dt class="option-term" id="option-cargo-new---name"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---name"><code>--name</code> <em>name</em></a></dt>
<dd class="option-desc"><p>Set the package name. Defaults to the directory name.</p>
</dd>
<dt class="option-term" id="option-cargo-new---vcs"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---vcs"><code>--vcs</code> <em>vcs</em></a></dt>
<dd class="option-desc"><p>Initialize a new VCS repository for the given version control system (git,
hg, pijul, or fossil) or do not initialize any version control at all
(none). If not specified, defaults to <code>git</code> or the configuration value
<code>cargo-new.vcs</code>, or <code>none</code> if already inside a VCS repository.</p>
</dd>
<dt class="option-term" id="option-cargo-new---registry"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---registry"><code>--registry</code> <em>registry</em></a></dt>
<dd class="option-desc"><p>This sets the <code>publish</code> field in <code>Cargo.toml</code> to the given registry name
which will restrict publishing only to that registry.</p>
<p>Registry names are defined in <a href="commands/../reference/config.html">Cargo config files</a>.
If not specified, the default registry defined by the <code>registry.default</code>
config key is used. If the default registry is not set and <code>--registry</code> is not
used, the <code>publish</code> field will not be set which means that publishing will not
be restricted.</p>
</dd>
</dl>
<h3 id="표시-옵션-25"><a class="header" href="#표시-옵션-25">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-new--v"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-new---verbose"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-new--q"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-new---quiet"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-new---color"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="공통-옵션-25"><a class="header" href="#공통-옵션-25">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-new-+toolchain"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-new---config"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-new--C"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-new--h"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-new---help"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-new--Z"><a class="option-anchor" href="commands/cargo-new.html#option-cargo-new--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-28"><a class="header" href="#환경-변수-28">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-25"><a class="header" href="#종료-상태-25">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-40"><a class="header" href="#예제-40">예제</a></h2>
<ol>
<li>
<p>지정된 디렉토리에 바이너리 Cargo 패키지 생성:</p>
<pre><code>cargo new foo
</code></pre>
</li>
</ol>
<h2 id="참고-항목-29"><a class="header" href="#참고-항목-29">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-init.html">cargo-init(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-search1"><a class="header" href="#cargo-search1">cargo-search(1)</a></h1>
<h2 id="이름-30"><a class="header" href="#이름-30">이름</a></h2>
<p>cargo-search — 레지스트리에서 패키지를 검색합니다. 기본 레지스트리는 crates.io입니다</p>
<h2 id="사용법-27"><a class="header" href="#사용법-27">사용법</a></h2>
<p><code>cargo search</code> [<em>options</em>] [<em>query</em>…]</p>
<h2 id="설명-30"><a class="header" href="#설명-30">설명</a></h2>
<p>이 명령어는 <a href="https://crates.io">https://crates.io</a>에서 크레이트에 대한 텍스트 검색을 수행합니다. 매칭되는 크레이트들은 <code>Cargo.toml</code> 매니페스트에 복사하기 적합한 TOML 형식의 설명과 함께 표시됩니다.</p>
<h2 id="옵션-27"><a class="header" href="#옵션-27">옵션</a></h2>
<h3 id="검색-옵션"><a class="header" href="#검색-옵션">검색 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-search---limit"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---limit"><code>--limit</code> <em>limit</em></a></dt>
<dd class="option-desc"><p>Limit the number of results (default: 10, max: 100).</p>
</dd>
<dt class="option-term" id="option-cargo-search---index"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---index"><code>--index</code> <em>index</em></a></dt>
<dd class="option-desc"><p>The URL of the registry index to use.</p>
</dd>
<dt class="option-term" id="option-cargo-search---registry"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---registry"><code>--registry</code> <em>registry</em></a></dt>
<dd class="option-desc"><p>Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</p>
</dd>
</dl>
<h3 id="표시-옵션-26"><a class="header" href="#표시-옵션-26">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-search--v"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-search---verbose"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-search--q"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-search---quiet"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-search---color"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="공통-옵션-26"><a class="header" href="#공통-옵션-26">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-search-+toolchain"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-search---config"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-search--C"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-search--h"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-search---help"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-search--Z"><a class="option-anchor" href="commands/cargo-search.html#option-cargo-search--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-29"><a class="header" href="#환경-변수-29">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-26"><a class="header" href="#종료-상태-26">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-41"><a class="header" href="#예제-41">예제</a></h2>
<ol>
<li>
<p>crates.io에서 패키지 검색:</p>
<pre><code>cargo search serde
</code></pre>
</li>
</ol>
<h2 id="참고-항목-30"><a class="header" href="#참고-항목-30">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-install.html">cargo-install(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-uninstall1"><a class="header" href="#cargo-uninstall1">cargo-uninstall(1)</a></h1>
<h2 id="이름-31"><a class="header" href="#이름-31">이름</a></h2>
<p>cargo-uninstall — 러스트 바이너리를 제거합니다</p>
<h2 id="사용법-28"><a class="header" href="#사용법-28">사용법</a></h2>
<p><code>cargo uninstall</code> [<em>options</em>] [<em>spec</em>…]</p>
<h2 id="설명-31"><a class="header" href="#설명-31">설명</a></h2>
<p>이 명령어는 <a href="commands/cargo-install.html">cargo-install(1)</a> 로 설치된 패키지를 제거합니다. <em>spec</em> 인수는 제거할 패키지의 패키지 ID 명세입니다 (<a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> 참조).</p>
<p>기본적으로 한 크레이트의 모든 바이너리가 제거되지만, <code>--bin</code> 및 <code>--example</code> 플래그를 사용하여 특정 바이너리만 제거할 수도 있습니다.</p>
<p>설치 루트는 다음 우선순위에 따라 결정됩니다:</p>
<ul>
<li><code>--root</code> 옵션</li>
<li><code>CARGO_INSTALL_ROOT</code> 환경 변수</li>
<li><code>install.root</code> Cargo <a href="commands/../reference/config.html">설정 값</a></li>
<li><code>CARGO_HOME</code> 환경 변수</li>
<li><code>$HOME/.cargo</code></li>
</ul>
<h2 id="옵션-28"><a class="header" href="#옵션-28">옵션</a></h2>
<h3 id="제거-옵션"><a class="header" href="#제거-옵션">제거 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-uninstall--p"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall--p"><code>-p</code></a></dt>
<dt class="option-term" id="option-cargo-uninstall---package"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---package"><code>--package</code> <em>spec</em>…</a></dt>
<dd class="option-desc"><p>Package to uninstall.</p>
</dd>
<dt class="option-term" id="option-cargo-uninstall---bin"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---bin"><code>--bin</code> <em>name</em>…</a></dt>
<dd class="option-desc"><p>Only uninstall the binary <em>name</em>.</p>
</dd>
<dt class="option-term" id="option-cargo-uninstall---root"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---root"><code>--root</code> <em>dir</em></a></dt>
<dd class="option-desc"><p>Directory to uninstall packages from.</p>
</dd>
</dl>
<h3 id="표시-옵션-27"><a class="header" href="#표시-옵션-27">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-uninstall--v"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-uninstall---verbose"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-uninstall--q"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-uninstall---quiet"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-uninstall---color"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="공통-옵션-27"><a class="header" href="#공통-옵션-27">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-uninstall-+toolchain"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-uninstall---config"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-uninstall--C"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-uninstall--h"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-uninstall---help"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-uninstall--Z"><a class="option-anchor" href="commands/cargo-uninstall.html#option-cargo-uninstall--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-30"><a class="header" href="#환경-변수-30">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-27"><a class="header" href="#종료-상태-27">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-42"><a class="header" href="#예제-42">예제</a></h2>
<ol>
<li>
<p>이전에 설치된 패키지를 제거합니다.</p>
<pre><code>cargo uninstall ripgrep
</code></pre>
</li>
</ol>
<h2 id="참고-항목-31"><a class="header" href="#참고-항목-31">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-install.html">cargo-install(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="게시-명령어-1"><a class="header" href="#게시-명령어-1">게시 명령어</a></h1>
<ul>
<li><a href="commands/cargo-login.html">cargo login</a></li>
<li><a href="commands/cargo-logout.html">cargo logout</a></li>
<li><a href="commands/cargo-owner.html">cargo owner</a></li>
<li><a href="commands/cargo-package.html">cargo package</a></li>
<li><a href="commands/cargo-publish.html">cargo publish</a></li>
<li><a href="commands/cargo-yank.html">cargo yank</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-login1"><a class="header" href="#cargo-login1">cargo-login(1)</a></h1>
<h2 id="이름-32"><a class="header" href="#이름-32">이름</a></h2>
<p>cargo-login — 레지스트리에 로그인합니다</p>
<h2 id="사용법-29"><a class="header" href="#사용법-29">사용법</a></h2>
<p><code>cargo login</code> [<em>options</em>] [<code>--</code> <em>args</em>]</p>
<h2 id="설명-32"><a class="header" href="#설명-32">설명</a></h2>
<p>이 명령어는 자격 증명 제공자(credential provider)를 실행하여 토큰을 저장함으로써, <a href="commands/cargo-publish.html">cargo-publish(1)</a> 와 같이 인증이 필요한 명령어가 자동으로 인증되도록 합니다.</p>
<p>두 개의 대시(<code>--</code>) 뒤에 오는 모든 인수는 자격 증명 제공자에게 전달됩니다.</p>
<p>기본 <code>cargo:token</code> 자격 증명 제공자의 경우, 토큰은 <code>$CARGO_HOME/credentials.toml</code>에 저장됩니다. <code>CARGO_HOME</code> 은 기본적으로 홈 디렉토리의 <code>.cargo</code> 입니다.</p>
<p>레지스트리에 자격 증명 제공자가 지정되어 있으면 해당 제공자가 사용됩니다. 그렇지 않으면 설정 값 <code>registry.global-credential-providers</code> 에 있는 제공자들이 목록의 끝에서부터 시도됩니다.</p>
<p>토큰(<em>token</em>)은 표준 입력(stdin)에서 읽어들입니다.</p>
<p>crates.io의 API 토큰은 <a href="https://crates.io/me">https://crates.io/me</a>에서 얻을 수 있습니다.</p>
<p>토큰이 노출되지 않도록 주의하세요. 다른 사람과 공유해서는 안 됩니다.</p>
<h2 id="옵션-29"><a class="header" href="#옵션-29">옵션</a></h2>
<h3 id="로그인-옵션"><a class="header" href="#로그인-옵션">로그인 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-login---registry"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login---registry"><code>--registry</code> <em>registry</em></a></dt>
<dd class="option-desc"><p>Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</p>
</dd>
</dl>
<h3 id="표시-옵션-28"><a class="header" href="#표시-옵션-28">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-login--v"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-login---verbose"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-login--q"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-login---quiet"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-login---color"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="공통-옵션-28"><a class="header" href="#공통-옵션-28">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-login-+toolchain"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-login---config"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-login--C"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-login--h"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-login---help"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-login--Z"><a class="option-anchor" href="commands/cargo-login.html#option-cargo-login--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-31"><a class="header" href="#환경-변수-31">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-28"><a class="header" href="#종료-상태-28">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-43"><a class="header" href="#예제-43">예제</a></h2>
<ol>
<li>
<p>기본 레지스트리의 토큰 저장:</p>
<pre><code>cargo login
</code></pre>
</li>
<li>
<p>특정 레지스트리의 토큰 저장:</p>
<pre><code>cargo login --registry my-registry
</code></pre>
</li>
</ol>
<h2 id="참고-항목-32"><a class="header" href="#참고-항목-32">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-logout.html">cargo-logout(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-logout1"><a class="header" href="#cargo-logout1">cargo-logout(1)</a></h1>
<h2 id="이름-33"><a class="header" href="#이름-33">이름</a></h2>
<p>cargo-logout — 로컬 레지스트리에서 API 토큰을 제거합니다</p>
<h2 id="사용법-30"><a class="header" href="#사용법-30">사용법</a></h2>
<p><code>cargo logout</code> [<em>options</em>]</p>
<h2 id="설명-33"><a class="header" href="#설명-33">설명</a></h2>
<p>이 명령어는 자격 증명 제공자를 실행하여 저장된 토큰을 제거합니다.</p>
<p>기본 <code>cargo:token</code> 자격 증명 제공자의 경우, 자격 증명은 <code>$CARGO_HOME/credentials.toml</code>에 저장됩니다. <code>$CARGO_HOME</code> 은 기본적으로 홈 디렉토리의 <code>.cargo</code> 입니다.</p>
<p>레지스트리에 자격 증명 제공자가 지정되어 있으면 해당 제공자가 사용됩니다. 그렇지 않으면 설정 값 <code>registry.global-credential-providers</code> 에 있는 제공자들이 목록의 끝에서부터 시도됩니다.</p>
<p><code>--registry</code> 가 지정되지 않으면, 기본 레지스트리(기본값은 <a href="https://crates.io/">https://crates.io/</a>이며, <a href="commands/../reference/config.html#registrydefault"><code>registry.default</code></a> 로 설정 가능)의 자격 증명이 제거됩니다.</p>
<p>이 명령어는 서버의 토큰을 무효화(revoke)하지 않습니다. 토큰을 무효화해야 하는 경우, 레지스트리 웹사이트를 방문하여 안내를 따르세요 (<a href="https://crates.io/">https://crates.io/</a> 토큰 무효화는 <a href="https://crates.io/me">https://crates.io/me</a> 참조).</p>
<h2 id="옵션-30"><a class="header" href="#옵션-30">옵션</a></h2>
<h3 id="로그아웃-옵션"><a class="header" href="#로그아웃-옵션">로그아웃 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-logout---registry"><a class="option-anchor" href="commands/cargo-logout.html#option-cargo-logout---registry"><code>--registry</code> <em>registry</em></a></dt>
<dd class="option-desc"><p>Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</p>
</dd>
</dl>
<h3 id="표시-옵션-29"><a class="header" href="#표시-옵션-29">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-logout--v"><a class="option-anchor" href="commands/cargo-logout.html#option-cargo-logout--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-logout---verbose"><a class="option-anchor" href="commands/cargo-logout.html#option-cargo-logout---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-logout--q"><a class="option-anchor" href="commands/cargo-logout.html#option-cargo-logout--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-logout---quiet"><a class="option-anchor" href="commands/cargo-logout.html#option-cargo-logout---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-logout---color"><a class="option-anchor" href="commands/cargo-logout.html#option-cargo-logout---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="공통-옵션-29"><a class="header" href="#공통-옵션-29">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-logout-+toolchain"><a class="option-anchor" href="commands/cargo-logout.html#option-cargo-logout-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-logout---config"><a class="option-anchor" href="commands/cargo-logout.html#option-cargo-logout---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-logout--C"><a class="option-anchor" href="commands/cargo-logout.html#option-cargo-logout--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-logout--h"><a class="option-anchor" href="commands/cargo-logout.html#option-cargo-logout--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-logout---help"><a class="option-anchor" href="commands/cargo-logout.html#option-cargo-logout---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-logout--Z"><a class="option-anchor" href="commands/cargo-logout.html#option-cargo-logout--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-32"><a class="header" href="#환경-변수-32">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-29"><a class="header" href="#종료-상태-29">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-44"><a class="header" href="#예제-44">예제</a></h2>
<ol>
<li>
<p>기본 레지스트리 토큰 제거:</p>
<pre><code>cargo logout
</code></pre>
</li>
<li>
<p>특정 레지스트리 토큰 제거:</p>
<pre><code>cargo logout --registry my-registry
</code></pre>
</li>
</ol>
<h2 id="참고-항목-33"><a class="header" href="#참고-항목-33">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-login.html">cargo-login(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-owner1"><a class="header" href="#cargo-owner1">cargo-owner(1)</a></h1>
<h2 id="이름-34"><a class="header" href="#이름-34">이름</a></h2>
<p>cargo-owner — 레지스트리 상의 크레이트 소유자를 관리합니다</p>
<h2 id="사용법-31"><a class="header" href="#사용법-31">사용법</a></h2>
<p><code>cargo owner</code> [<em>options</em>] <code>--add</code> <em>login</em> [<em>crate</em>]<br />
<code>cargo owner</code> [<em>options</em>] <code>--remove</code> <em>login</em> [<em>crate</em>]<br />
<code>cargo owner</code> [<em>options</em>] <code>--list</code> [<em>crate</em>]</p>
<h2 id="설명-34"><a class="header" href="#설명-34">설명</a></h2>
<p>이 명령어는 레지스트리 상의 크레이트 소유자를 수정합니다. 크레이트 소유자는 새로운 버전을 업로드하고 이전 버전을 제거(yank)할 수 있습니다. 팀 소유자가 아닌 소유자들은 소유자 집합을 수정할 수도 있으므로 주의하세요!</p>
<p>이 명령어는 <code>--token</code> 옵션을 통하거나 <a href="commands/cargo-login.html">cargo-login(1)</a> 을 사용하여 인증을 받아야 합니다.</p>
<p>크레이트 이름이 지정되지 않으면, 현재 디렉토리의 패키지 이름을 사용합니다.</p>
<p>소유자 및 게시에 대한 자세한 내용은 <a href="commands/../reference/publishing.html#cargo-owner">레퍼런스</a>를 참조하세요.</p>
<h2 id="옵션-31"><a class="header" href="#옵션-31">옵션</a></h2>
<h3 id="소유자-옵션"><a class="header" href="#소유자-옵션">소유자 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-owner--a"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--a"><code>-a</code></a></dt>
<dt class="option-term" id="option-cargo-owner---add"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---add"><code>--add</code> <em>login</em>…</a></dt>
<dd class="option-desc"><p>Invite the given user or team as an owner.</p>
</dd>
<dt class="option-term" id="option-cargo-owner--r"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--r"><code>-r</code></a></dt>
<dt class="option-term" id="option-cargo-owner---remove"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---remove"><code>--remove</code> <em>login</em>…</a></dt>
<dd class="option-desc"><p>Remove the given user or team as an owner.</p>
</dd>
<dt class="option-term" id="option-cargo-owner--l"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--l"><code>-l</code></a></dt>
<dt class="option-term" id="option-cargo-owner---list"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---list"><code>--list</code></a></dt>
<dd class="option-desc"><p>List owners of a crate.</p>
</dd>
<dt class="option-term" id="option-cargo-owner---token"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---token"><code>--token</code> <em>token</em></a></dt>
<dd class="option-desc"><p>API token to use when authenticating. This overrides the token stored in
the credentials file (which is created by <a href="commands/cargo-login.html">cargo-login(1)</a>).</p>
<p><a href="commands/../reference/config.html">Cargo config</a> environment variables can be
used to override the tokens stored in the credentials file. The token for
crates.io may be specified with the <code>CARGO_REGISTRY_TOKEN</code> environment
variable. Tokens for other registries may be specified with environment
variables of the form <code>CARGO_REGISTRIES_NAME_TOKEN</code> where <code>NAME</code> is the name
of the registry in all capital letters.</p>
</dd>
<dt class="option-term" id="option-cargo-owner---index"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---index"><code>--index</code> <em>index</em></a></dt>
<dd class="option-desc"><p>The URL of the registry index to use.</p>
</dd>
<dt class="option-term" id="option-cargo-owner---registry"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---registry"><code>--registry</code> <em>registry</em></a></dt>
<dd class="option-desc"><p>Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</p>
</dd>
</dl>
<h3 id="표시-옵션-30"><a class="header" href="#표시-옵션-30">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-owner--v"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-owner---verbose"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-owner--q"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-owner---quiet"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-owner---color"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="공통-옵션-30"><a class="header" href="#공통-옵션-30">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-owner-+toolchain"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-owner---config"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-owner--C"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-owner--h"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-owner---help"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-owner--Z"><a class="option-anchor" href="commands/cargo-owner.html#option-cargo-owner--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-33"><a class="header" href="#환경-변수-33">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-30"><a class="header" href="#종료-상태-30">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-45"><a class="header" href="#예제-45">예제</a></h2>
<ol>
<li>
<p>패키지 소유자 목록 보기:</p>
<pre><code>cargo owner --list foo
</code></pre>
</li>
<li>
<p>패키지에 소유자 초대:</p>
<pre><code>cargo owner --add username foo
</code></pre>
</li>
<li>
<p>패키지에서 소유자 제거:</p>
<pre><code>cargo owner --remove username foo
</code></pre>
</li>
</ol>
<h2 id="참고-항목-34"><a class="header" href="#참고-항목-34">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-login.html">cargo-login(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-package1"><a class="header" href="#cargo-package1">cargo-package(1)</a></h1>
<h2 id="이름-35"><a class="header" href="#이름-35">이름</a></h2>
<p>cargo-package — 로컬 패키지를 배포 가능한 tarball로 조립합니다</p>
<h2 id="사용법-32"><a class="header" href="#사용법-32">사용법</a></h2>
<p><code>cargo package</code> [<em>options</em>]</p>
<h2 id="설명-35"><a class="header" href="#설명-35">설명</a></h2>
<p>이 명령어는 현재 디렉토리에 있는 패키지의 소스 코드를 포함하는 배포 가능한 압축된 <code>.crate</code> 파일을 생성합니다. 생성된 파일은 <code>target/package</code> 디렉토리에 저장됩니다. 이 명령어는 다음 단계들을 수행합니다:</p>
<ol>
<li>
<p>현재 워크스페이스를 로드하고 확인하며, 몇 가지 기본적인 검사를 수행합니다.</p>
<ul>
<li>경로(path) 의존성은 버전 키가 있는 경우에만 허용됩니다. Cargo는 게시된 패키지의 의존성에서 경로 키를 무시합니다. <code>dev-dependencies</code> 에는 이 제한이 적용되지 않습니다.</li>
</ul>
</li>
<li>
<p>압축된 <code>.crate</code> 파일을 생성합니다.</p>
<ul>
<li>원본 <code>Cargo.toml</code> 파일이 다시 작성되고 정규화됩니다.</li>
<li>매니페스트에서 <code>[patch]</code>, <code>[replace]</code>, 및 <code>[workspace]</code> 섹션이 제거됩니다.</li>
<li><code>Cargo.lock</code> is always included. When missing, a new lock file will be generated unless the <code>--exclude-lockfile</code> flag is used. <a href="commands/cargo-install.html">cargo-install(1)</a> will use the packaged lock file if the <code>--locked</code> flag is used.</li>
<li>사용 가능한 경우 현재 VCS 체크아웃 해시 정보와 워킹 트리가 더러운지(dirty) 여부를 나타내는 플래그를 포함하는 <code>.cargo_vcs_info.json</code> 파일이 포함됩니다.</li>
<li>심볼릭 링크는 타겟 파일로 대체되어 포함됩니다.</li>
<li><a href="commands/../reference/manifest.html#the-exclude-and-include-fields"><code>[include]</code> 및 <code>[exclude]</code> 필드</a>에 언급된 규칙에 따라 파일과 디렉토리가 포함되거나 제외됩니다.</li>
</ul>
</li>
<li>
<p>생성된 <code>.crate</code> 파일을 압축 해제하고 빌드하여 정상적으로 빌드되는지 확인합니다.</p>
<ul>
<li>이는 깨끗한 상태에서 빌드될 수 있는지 확인하기 위해 패키지를 처음부터 다시 빌드합니다. <code>--no-verify</code> 플래그를 사용하여 이 단계를 건너뛸 수 있습니다.</li>
</ul>
</li>
<li>
<p>빌드 스크립트가 소스 파일을 수정하지 않았는지 확인합니다.</p>
</li>
</ol>
<p>포함되는 파일 목록은 매니페스트의 <code>include</code> 및 <code>exclude</code> 필드로 제어할 수 있습니다.</p>
<p>패키징 및 게시에 대한 자세한 내용은 <a href="commands/../reference/publishing.html">레퍼런스</a> 를 참조하세요.</p>
<h3 id="cargo_vcs_infojson-형식"><a class="header" href="#cargo_vcs_infojson-형식">.cargo_vcs_info.json 형식</a></h3>
<p>다음과 같은 형식으로 <code>.cargo_vcs_info.json</code> 파일을 생성합니다</p>
<pre><code class="language-javascript">{
 "git": {
   "sha1": "aac20b6e7e543e6dd4118b246c77225e3a3a1302",
   "dirty": true
 },
 "path_in_vcs": ""
}
</code></pre>
<p><code>dirty</code> 는 패키지가 빌드될 때 Git 작업 트리가 지저분(dirty)했음을 나타냅니다.</p>
<p><code>path_in_vcs</code> 는 버전 관리 저장소의 하위 디렉토리에 있는 패키지에 대해 저장소 상대 경로로 설정됩니다.</p>
<p>이 파일의 호환성은 <a href="commands/cargo-metadata.html">cargo-metadata(1)</a> 의 JSON 출력과 동일한 정책에 따라 유지됩니다.</p>
<p>이 파일은 VCS 정보의 최선의 스냅샷을 제공합니다. 그러나 패키지의 출처는 확인되지 않습니다. 타르볼의 소스 코드가 VCS 정보와 일치한다는 보장은 없습니다.</p>
<h2 id="옵션-32"><a class="header" href="#옵션-32">옵션</a></h2>
<h3 id="패키지-옵션"><a class="header" href="#패키지-옵션">패키지 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package--l"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--l"><code>-l</code></a></dt>
<dt class="option-term" id="option-cargo-package---list"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---list"><code>--list</code></a></dt>
<dd class="option-desc"><p>Print files included in a package without making one.</p>
</dd>
<dt class="option-term" id="option-cargo-package---no-verify"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---no-verify"><code>--no-verify</code></a></dt>
<dd class="option-desc"><p>Don’t verify the contents by building them.</p>
</dd>
<dt class="option-term" id="option-cargo-package---no-metadata"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---no-metadata"><code>--no-metadata</code></a></dt>
<dd class="option-desc"><p>Ignore warnings about a lack of human-usable metadata (such as the description
or the license).</p>
</dd>
<dt class="option-term" id="option-cargo-package---allow-dirty"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---allow-dirty"><code>--allow-dirty</code></a></dt>
<dd class="option-desc"><p>Allow working directories with uncommitted VCS changes to be packaged.</p>
</dd>
<dt class="option-term" id="option-cargo-package---exclude-lockfile"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---exclude-lockfile"><code>--exclude-lockfile</code></a></dt>
<dd class="option-desc"><p>Don’t include the lock file when packaging.</p>
<p>This flag is not for general use.
Some tools may expect a lock file to be present (e.g. <code>cargo install --locked</code>).
Consider other options before using this.</p>
</dd>
<dt class="option-term" id="option-cargo-package---index"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---index"><code>--index</code> <em>index</em></a></dt>
<dd class="option-desc"><p>The URL of the registry index to use.</p>
</dd>
<dt class="option-term" id="option-cargo-package---registry"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---registry"><code>--registry</code> <em>registry</em></a></dt>
<dd class="option-desc"><p>Name of the registry to package for; see <code>cargo publish --help</code> for more details
about configuration of registry names. The packages will not be published
to this registry, but if we are packaging multiple inter-dependent crates,
lock-files will be generated under the assumption that dependencies will be
published to this registry.</p>
</dd>
<dt class="option-term" id="option-cargo-package---message-format"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---message-format"><code>--message-format</code> <em>fmt</em></a></dt>
<dd class="option-desc"><p>Specifies the output message format.
Currently, it only works with <code>--list</code> and affects the file listing format.
This is unstable and requires <code>-Zunstable-options</code>.
Valid output formats:</p>
<ul>
<li><code>human</code> (default): Display in a file-per-line format.</li>
<li><code>json</code>: Emit machine-readable JSON information about each package.
One package per JSON line (Newline delimited JSON).
<pre><code class="language-javascript">{
  /* The Package ID Spec of the package. */
  "id": "path+file:///home/foo#0.0.0",
  /* Files of this package */
  "files" {
    /* Relative path in the archive file. */
    "Cargo.toml.orig": {
      /* Where the file is from.
         - "generate" for file being generated during packaging
         - "copy" for file being copied from another location.
      */
      "kind": "copy",
      /* For the "copy" kind,
         it is an absolute path to the actual file content.
         For the "generate" kind,
         it is the original file the generated one is based on.
      */
      "path": "/home/foo/Cargo.toml"
    },
    "Cargo.toml": {
      "kind": "generate",
      "path": "/home/foo/Cargo.toml"
    },
    "src/main.rs": {
      "kind": "copy",
      "path": "/home/foo/src/main.rs"
    }
  }
}
</code></pre>
</li>
</ul>
</dd>
</dl>
<h3 id="패키지-선택-14"><a class="header" href="#패키지-선택-14">패키지 선택</a></h3>
<p>기본적으로 패키지 선택 옵션이 주어지지 않으면, 선택된 패키지는 선택된 매니페스트 파일에 따라 달라집니다 (<code>--manifest-path</code> 가 주어지지 않은 경우 현재 작업 디렉토리를 기준으로 함). 매니페스트가 워크스페이스의 루트인 경우 워크스페이스의 기본 구성원들이 선택되고, 그렇지 않으면 매니페스트에 정의된 패키지만 선택됩니다.</p>
<p>워크스페이스의 기본 구성원은 루트 매니페스트의 <code>workspace.default-members</code> 키로 명시적으로 설정할 수 있습니다. 이 값이 설정되지 않은 경우, 가상 워크스페이스(virtual workspace)는 모든 워크스페이스 구성원을 포함하며(<code>--workspace</code>를 전달하는 것과 동일), 가상이 아닌 워크스페이스는 루트 크레이트 자체만 포함합니다.</p>
<dl>
<dt class="option-term" id="option-cargo-package--p"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--p"><code>-p</code> <em>spec</em>…</a></dt>
<dt class="option-term" id="option-cargo-package---package"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---package"><code>--package</code> <em>spec</em>…</a></dt>
<dd class="option-desc"><p>Package only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</p>
</dd>
<dt class="option-term" id="option-cargo-package---workspace"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---workspace"><code>--workspace</code></a></dt>
<dd class="option-desc"><p>Package all members in the workspace.</p>
</dd>
<dt class="option-term" id="option-cargo-package---exclude"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---exclude"><code>--exclude</code> <em>SPEC</em>…</a></dt>
<dd class="option-desc"><p>Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</p>
</dd>
</dl>
<h3 id="컴파일-옵션-10"><a class="header" href="#컴파일-옵션-10">컴파일 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package---target"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---target"><code>--target</code> <em>triple</em></a></dt>
<dd class="option-desc"><p>Package for the specified target architecture. Flag may be specified multiple times. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>.</p>
<p>Possible values:</p>
<ul>
<li>Any supported target in <code>rustc --print target-list</code>.</li>
<li><code>"host-tuple"</code>, which will internally be substituted by the host’s target. This can be particularly useful if you’re cross-compiling some crates, and don’t want to specify your host’s machine as a target (for instance, an <code>xtask</code> in a shared project that may be worked on by many hosts).</li>
<li>A path to a custom target specification. See <a href="commands/../../rustc/targets/custom.html#custom-target-lookup-path">Custom Target Lookup Path</a> for more information.</li>
</ul>
<p>This may also be specified with the <code>build.target</code> <a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../reference/build-cache.html">build cache</a> documentation for more details.</p>
</dd>
<dt class="option-term" id="option-cargo-package---target-dir"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---target-dir"><code>--target-dir</code> <em>directory</em></a></dt>
<dd class="option-desc"><p>Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</p>
</dd>
</dl>
<h3 id="기능-선택-12"><a class="header" href="#기능-선택-12">기능 선택</a></h3>
<p>기능 플래그를 통해 어떤 기능을 활성화할지 제어할 수 있습니다. 기능 옵션이 주어지지 않으면, 선택된 모든 패키지에 대해 <code>default</code> 기능이 활성화됩니다.</p>
<p>자세한 내용은 <a href="commands/../reference/features.html#command-line-feature-options">기능 문서</a>를 참조하세요.</p>
<dl>
<dt class="option-term" id="option-cargo-package--F"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--F"><code>-F</code> <em>features</em></a></dt>
<dt class="option-term" id="option-cargo-package---features"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---features"><code>--features</code> <em>features</em></a></dt>
<dd class="option-desc"><p>Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</p>
</dd>
<dt class="option-term" id="option-cargo-package---all-features"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---all-features"><code>--all-features</code></a></dt>
<dd class="option-desc"><p>Activate all available features of all selected packages.</p>
</dd>
<dt class="option-term" id="option-cargo-package---no-default-features"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---no-default-features"><code>--no-default-features</code></a></dt>
<dd class="option-desc"><p>Do not activate the <code>default</code> feature of the selected packages.</p>
</dd>
</dl>
<h3 id="매니페스트-옵션-24"><a class="header" href="#매니페스트-옵션-24">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package---manifest-path"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-package---locked"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-package---offline"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-package---frozen"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="기타-옵션-11"><a class="header" href="#기타-옵션-11">기타 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package--j"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--j"><code>-j</code> <em>N</em></a></dt>
<dt class="option-term" id="option-cargo-package---jobs"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---jobs"><code>--jobs</code> <em>N</em></a></dt>
<dd class="option-desc"><p>Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value. If
a string <code>default</code> is provided, it sets the value back to defaults.
Should not be 0.</p>
</dd>
<dt class="option-term" id="option-cargo-package---keep-going"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---keep-going"><code>--keep-going</code></a></dt>
<dd class="option-desc"><p>Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build.</p>
<p>For example if the current package depends on dependencies <code>fails</code> and <code>works</code>,
one of which fails to build, <code>cargo package -j1</code> may or may not build the
one that succeeds (depending on which one of the two builds Cargo picked to run
first), whereas <code>cargo package -j1 --keep-going</code> would definitely run both
builds, even if the one run first fails.</p>
</dd>
</dl>
<h3 id="표시-옵션-31"><a class="header" href="#표시-옵션-31">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package--v"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-package---verbose"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-package--q"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-package---quiet"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-package---color"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="공통-옵션-31"><a class="header" href="#공통-옵션-31">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-package-+toolchain"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-package---config"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-package--C"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-package--h"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-package---help"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-package--Z"><a class="option-anchor" href="commands/cargo-package.html#option-cargo-package--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-34"><a class="header" href="#환경-변수-34">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-31"><a class="header" href="#종료-상태-31">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-46"><a class="header" href="#예제-46">예제</a></h2>
<ol>
<li>
<p>현재 패키지의 압축된 <code>.crate</code> 파일 생성:</p>
<pre><code>cargo package
</code></pre>
</li>
</ol>
<h2 id="참고-항목-35"><a class="header" href="#참고-항목-35">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-publish1"><a class="header" href="#cargo-publish1">cargo-publish(1)</a></h1>
<h2 id="이름-36"><a class="header" href="#이름-36">이름</a></h2>
<p>cargo-publish — 레지스트리에 패키지 업로드</p>
<h2 id="사용법-33"><a class="header" href="#사용법-33">사용법</a></h2>
<p><code>cargo publish</code> [<em>옵션</em>]</p>
<h2 id="설명-36"><a class="header" href="#설명-36">설명</a></h2>
<p>이 명령어는 현재 디렉토리에 있는 패키지의 소스 코드로 배포 가능한 압축된 <code>.crate</code> 파일을 생성하고 이를 레지스트리에 업로드합니다. 기본 레지스트리는 <a href="https://crates.io">https://crates.io</a>입니다. 이 명령어는 다음 단계를 수행합니다:</p>
<ol>
<li>다음을 포함하여 몇 가지 확인을 수행합니다:
<ul>
<li>매니페스트의 <code>package.publish</code> 키를 확인하여 게시가 허용된 레지스트리에 대한 제한 사항을 확인합니다.</li>
</ul>
</li>
<li><a href="commands/cargo-package.html">cargo-package(1)</a> 의 단계를 따라 <code>.crate</code> 파일을 생성합니다.</li>
<li>크레이트를 레지스트리에 업로드합니다. 서버는 크레이트에 대해 추가 확인을 수행합니다.</li>
<li>클라이언트는 패키지가 인덱스에 나타날 때까지 폴링하며 대기하며, 타임아웃이 발생할 수 있습니다. 이 경우 완료 여부를 수동으로 확인해야 합니다. 이 타임아웃은 업로드에 영향을 주지 않습니다.</li>
</ol>
<p>This command requires you to be authenticated using <a href="commands/cargo-login.html">cargo-login(1)</a> or environment variables of the <a href="commands/../reference/config.html#registrytoken"><code>registry.token</code></a> and <a href="commands/../reference/config.html#registriesnametoken"><code>registries.&lt;name&gt;.token</code></a> config fields.</p>
<p>패키징 및 게시에 대한 자세한 내용은 <a href="commands/../reference/publishing.html">레퍼런스</a> 를 참조하세요.</p>
<h2 id="옵션-33"><a class="header" href="#옵션-33">옵션</a></h2>
<h3 id="게시-옵션"><a class="header" href="#게시-옵션">게시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish---dry-run"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---dry-run"><code>--dry-run</code></a></dt>
<dd class="option-desc"><p>Perform all checks without uploading.</p>
</dd>
<dt class="option-term" id="option-cargo-publish---no-verify"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---no-verify"><code>--no-verify</code></a></dt>
<dd class="option-desc"><p>Don’t verify the contents by building them.</p>
</dd>
<dt class="option-term" id="option-cargo-publish---allow-dirty"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---allow-dirty"><code>--allow-dirty</code></a></dt>
<dd class="option-desc"><p>Allow working directories with uncommitted VCS changes to be packaged.</p>
</dd>
<dt class="option-term" id="option-cargo-publish---index"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---index"><code>--index</code> <em>index</em></a></dt>
<dd class="option-desc"><p>The URL of the registry index to use.</p>
</dd>
<dt class="option-term" id="option-cargo-publish---registry"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---registry"><code>--registry</code> <em>registry</em></a></dt>
<dd class="option-desc"><p>Name of the registry to publish to. Registry names are defined in <a href="commands/../reference/config.html">Cargo
config files</a>. If not specified, and there is a
<a href="commands/../reference/manifest.html#the-publish-field"><code>package.publish</code></a> field in
<code>Cargo.toml</code> with a single registry, then it will publish to that registry.
Otherwise it will use the default registry, which is defined by the
<a href="commands/../reference/config.html#registrydefault"><code>registry.default</code></a> config key
which defaults to <code>crates-io</code>.</p>
</dd>
</dl>
<h3 id="패키지-선택-15"><a class="header" href="#패키지-선택-15">패키지 선택</a></h3>
<p>기본적으로 패키지 선택 옵션이 주어지지 않으면, 선택된 패키지는 선택된 매니페스트 파일에 따라 달라집니다 (<code>--manifest-path</code> 가 주어지지 않은 경우 현재 작업 디렉토리를 기준으로 함). 매니페스트가 워크스페이스의 루트인 경우 워크스페이스의 기본 구성원들이 선택되고, 그렇지 않으면 매니페스트에 정의된 패키지만 선택됩니다.</p>
<p>워크스페이스의 기본 구성원은 루트 매니페스트의 <code>workspace.default-members</code> 키로 명시적으로 설정할 수 있습니다. 이 값이 설정되지 않은 경우, 가상 워크스페이스(virtual workspace)는 모든 워크스페이스 구성원을 포함하며(<code>--workspace</code>를 전달하는 것과 동일), 가상이 아닌 워크스페이스는 루트 크레이트 자체만 포함합니다.</p>
<dl>
<dt class="option-term" id="option-cargo-publish--p"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--p"><code>-p</code> <em>spec</em>…</a></dt>
<dt class="option-term" id="option-cargo-publish---package"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---package"><code>--package</code> <em>spec</em>…</a></dt>
<dd class="option-desc"><p>Publish only the specified packages. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the
SPEC format. This flag may be specified multiple times and supports common Unix
glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell accidentally
expanding glob patterns before Cargo handles them, you must use single quotes or
double quotes around each pattern.</p>
</dd>
<dt class="option-term" id="option-cargo-publish---workspace"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---workspace"><code>--workspace</code></a></dt>
<dd class="option-desc"><p>Publish all members in the workspace.</p>
</dd>
<dt class="option-term" id="option-cargo-publish---all"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---all"><code>--all</code></a></dt>
<dd class="option-desc"><p>Deprecated alias for <code>--workspace</code>.</p>
</dd>
<dt class="option-term" id="option-cargo-publish---exclude"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---exclude"><code>--exclude</code> <em>SPEC</em>…</a></dt>
<dd class="option-desc"><p>Exclude the specified packages. Must be used in conjunction with the
<code>--workspace</code> flag. This flag may be specified multiple times and supports
common Unix glob patterns like <code>*</code>, <code>?</code> and <code>[]</code>. However, to avoid your shell
accidentally expanding glob patterns before Cargo handles them, you must use
single quotes or double quotes around each pattern.</p>
</dd>
</dl>
<h3 id="컴파일-옵션-11"><a class="header" href="#컴파일-옵션-11">컴파일 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish---target"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---target"><code>--target</code> <em>triple</em></a></dt>
<dd class="option-desc"><p>Publish for the specified target architecture. Flag may be specified multiple times. The default is the host architecture. The general format of the triple is
<code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code>.</p>
<p>Possible values:</p>
<ul>
<li>Any supported target in <code>rustc --print target-list</code>.</li>
<li><code>"host-tuple"</code>, which will internally be substituted by the host’s target. This can be particularly useful if you’re cross-compiling some crates, and don’t want to specify your host’s machine as a target (for instance, an <code>xtask</code> in a shared project that may be worked on by many hosts).</li>
<li>A path to a custom target specification. See <a href="commands/../../rustc/targets/custom.html#custom-target-lookup-path">Custom Target Lookup Path</a> for more information.</li>
</ul>
<p>This may also be specified with the <code>build.target</code> <a href="commands/../reference/config.html">config value</a>.</p>
<p>Note that specifying this flag makes Cargo run in a different mode where the
target artifacts are placed in a separate directory. See the
<a href="commands/../reference/build-cache.html">build cache</a> documentation for more details.</p>
</dd>
<dt class="option-term" id="option-cargo-publish---target-dir"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---target-dir"><code>--target-dir</code> <em>directory</em></a></dt>
<dd class="option-desc"><p>Directory for all generated artifacts and intermediate files. May also be
specified with the <code>CARGO_TARGET_DIR</code> environment variable, or the
<code>build.target-dir</code> <a href="commands/../reference/config.html">config value</a>.
Defaults to <code>target</code> in the root of the workspace.</p>
</dd>
</dl>
<h3 id="기능-선택-13"><a class="header" href="#기능-선택-13">기능 선택</a></h3>
<p>기능 플래그를 통해 어떤 기능을 활성화할지 제어할 수 있습니다. 기능 옵션이 주어지지 않으면, 선택된 모든 패키지에 대해 <code>default</code> 기능이 활성화됩니다.</p>
<p>자세한 내용은 <a href="commands/../reference/features.html#command-line-feature-options">기능 문서</a>를 참조하세요.</p>
<dl>
<dt class="option-term" id="option-cargo-publish--F"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--F"><code>-F</code> <em>features</em></a></dt>
<dt class="option-term" id="option-cargo-publish---features"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---features"><code>--features</code> <em>features</em></a></dt>
<dd class="option-desc"><p>Space or comma separated list of features to activate. Features of workspace
members may be enabled with <code>package-name/feature-name</code> syntax. This flag may
be specified multiple times, which enables all specified features.</p>
</dd>
<dt class="option-term" id="option-cargo-publish---all-features"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---all-features"><code>--all-features</code></a></dt>
<dd class="option-desc"><p>Activate all available features of all selected packages.</p>
</dd>
<dt class="option-term" id="option-cargo-publish---no-default-features"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---no-default-features"><code>--no-default-features</code></a></dt>
<dd class="option-desc"><p>Do not activate the <code>default</code> feature of the selected packages.</p>
</dd>
</dl>
<h3 id="매니페스트-옵션-25"><a class="header" href="#매니페스트-옵션-25">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish---manifest-path"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---manifest-path"><code>--manifest-path</code> <em>path</em></a></dt>
<dd class="option-desc"><p>Path to the <code>Cargo.toml</code> file. By default, Cargo searches for the
<code>Cargo.toml</code> file in the current directory or any parent directory.</p>
</dd>
<dt class="option-term" id="option-cargo-publish---locked"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-publish---offline"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-publish---frozen"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="기타-옵션-12"><a class="header" href="#기타-옵션-12">기타 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish--j"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--j"><code>-j</code> <em>N</em></a></dt>
<dt class="option-term" id="option-cargo-publish---jobs"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---jobs"><code>--jobs</code> <em>N</em></a></dt>
<dd class="option-desc"><p>Number of parallel jobs to run. May also be specified with the
<code>build.jobs</code> <a href="commands/../reference/config.html">config value</a>. Defaults to
the number of logical CPUs. If negative, it sets the maximum number of
parallel jobs to the number of logical CPUs plus provided value. If
a string <code>default</code> is provided, it sets the value back to defaults.
Should not be 0.</p>
</dd>
<dt class="option-term" id="option-cargo-publish---keep-going"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---keep-going"><code>--keep-going</code></a></dt>
<dd class="option-desc"><p>Build as many crates in the dependency graph as possible, rather than aborting
the build on the first one that fails to build.</p>
<p>For example if the current package depends on dependencies <code>fails</code> and <code>works</code>,
one of which fails to build, <code>cargo publish -j1</code> may or may not build the
one that succeeds (depending on which one of the two builds Cargo picked to run
first), whereas <code>cargo publish -j1 --keep-going</code> would definitely run both
builds, even if the one run first fails.</p>
</dd>
</dl>
<h3 id="표시-옵션-32"><a class="header" href="#표시-옵션-32">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish--v"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-publish---verbose"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-publish--q"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-publish---quiet"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-publish---color"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="공통-옵션-32"><a class="header" href="#공통-옵션-32">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-publish-+toolchain"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-publish---config"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-publish--C"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-publish--h"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-publish---help"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-publish--Z"><a class="option-anchor" href="commands/cargo-publish.html#option-cargo-publish--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-35"><a class="header" href="#환경-변수-35">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-32"><a class="header" href="#종료-상태-32">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-47"><a class="header" href="#예제-47">예제</a></h2>
<ol>
<li>
<p>현재 패키지를 게시합니다:</p>
<pre><code>cargo publish
</code></pre>
</li>
</ol>
<h2 id="참고-항목-36"><a class="header" href="#참고-항목-36">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-package.html">cargo-package(1)</a>, <a href="commands/cargo-login.html">cargo-login(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-yank1"><a class="header" href="#cargo-yank1">cargo-yank(1)</a></h1>
<h2 id="이름-37"><a class="header" href="#이름-37">이름</a></h2>
<p>cargo-yank — 인덱스에서 푸시된 크레이트를 제거(yank)</p>
<h2 id="사용법-34"><a class="header" href="#사용법-34">사용법</a></h2>
<p><code>cargo yank</code> [<em>옵션</em>] <em>크레이트 <em>@</em> 버전</em><br />
<code>cargo yank</code> [<em>옵션</em>] <code>--version</code> <em>버전</em> [<em>크레이트</em>]</p>
<h2 id="설명-37"><a class="header" href="#설명-37">설명</a></h2>
<p>yank 명령어는 이전에 게시된 크레이트 버전을 서버 인덱스에서 제거합니다. 이 명령어는 데이터를 삭제하지 않으며, 크레이트는 레지스트리의 다운로드 링크를 통해 여전히 다운로드할 수 있습니다.</p>
<p>Cargo는 기존 잠금 파일이 없는 새로운 프로젝트나 체크아웃에 대해 yank된 버전을 사용하지 않으며, 해당 크레이트에 대해 더 이상 호환되는 버전이 없으면 오류를 발생시킵니다.</p>
<p>이 명령어는 <code>--token</code> 옵션을 통하거나 <a href="commands/cargo-login.html">cargo-login(1)</a> 을 사용하여 인증을 받아야 합니다.</p>
<p>크레이트 이름이 지정되지 않으면, 현재 디렉토리의 패키지 이름을 사용합니다.</p>
<h3 id="yank-작동-방식"><a class="header" href="#yank-작동-방식">yank 작동 방식</a></h3>
<p>예를 들어, <code>foo</code> 크레이트가 <code>1.5.0</code> 버전을 게시했고 다른 크레이트 <code>bar</code> 가 <code>foo = "1.5"</code> 버전에 대한 의존성을 선언했다고 가정해 봅시다. 이제 <code>foo</code> 가 의미적 버전(SemVer) 호환이 되지 않는 새로운 버전 <code>2.0.0</code> 을 릴리스하고 <code>1.5.0</code> 에서 심각한 문제를 발견했습니다. 만약 <code>1.5.0</code> 이 yank되면, 기존 잠금 파일이 없는 새로운 프로젝트나 체크아웃은 <code>1.5</code> 에 의존하는 <code>bar</code> 크레이트를 사용할 수 없게 됩니다.</p>
<p>이 경우 <code>foo</code> 유지 관리자는 <code>1.5.0</code> 을 yank하기 전에 먼저 <code>1.5.1</code> 과 같이 의미적 버전 호환이 되는 버전을 게시해야 <code>bar</code> 와 <code>bar</code> 에 의존하는 모든 프로젝트가 계속 작동할 수 있습니다.</p>
<p>또 다른 예로, 게시된 버전이 <code>1.5.0</code>, <code>1.5.1</code>, <code>1.5.2</code>, <code>2.0.0</code>, <code>3.0.0</code> 인 크레이트 <code>bar</code> 를 생각해 봅시다. 다음 표는 특정 릴리스가 yank된 후, 잠금 파일이 없는 상태에서 다양한 의미적 버전 요구 사항에 대해 Cargo가 사용할 수 있는 버전을 나타냅니다.</p>
<div class="table-wrapper"><table><thead><tr><th>yank된 버전 / 의미적 버전(SemVer) 요구 사항</th><th><code>bar = "1.5.0"</code></th><th><code>bar = "=1.5.0"</code></th><th><code>bar = "2.0.0"</code></th></tr></thead><tbody>
<tr><td><code>1.5.0</code></td><td><code>1.5.1</code> 또는 <code>1.5.2</code> 사용</td><td><strong>오류 반환</strong></td><td><code>2.0.0</code> 사용</td></tr>
<tr><td><code>1.5.1</code></td><td><code>1.5.0</code> 또는 <code>1.5.2</code> 사용</td><td><code>1.5.0</code> 사용</td><td><code>2.0.0</code> 사용</td></tr>
<tr><td><code>2.0.0</code></td><td><code>1.5.0</code>, <code>1.5.1</code> 또는 <code>1.5.2</code> 사용</td><td><code>1.5.0</code> 사용</td><td><strong>오류 반환</strong></td></tr>
</tbody></table>
</div>
<h3 id="언제-yank를-해야-하는가"><a class="header" href="#언제-yank를-해야-하는가">언제 yank를 해야 하는가</a></h3>
<p>크레이트는 실수로 인한 게시, 의도하지 않은 SemVer 파괴, 또는 심각하게 망가져 사용할 수 없는 크레이트와 같은 예외적인 상황에서만 yank해야 합니다. 보안 취약점의 경우, <a href="https://rustsec.org/">RustSec</a> 은 일반적으로 사용자에게 알리고 업그레이드를 권장하는 데 있어 덜 파괴적인 메커니즘이며, 해당 취약점에 대한 영향 여부와 관계없이 하류(downstream)에서의 중대한 혼란 가능성을 방지합니다.</p>
<p>일반적인 워크플로는 의존하는 크레이트들이 컴파일되지 않는 확률을 줄이기 위해, 이미 의미적 버전 호환 버전을 게시한 후에 크레이트를 yank하는 것입니다.</p>
<p>게시된 크레이트의 저작권, 라이선스 또는 개인 정보 문제를 해결할 때는 단순히 yank하는 것만으로는 충분하지 않을 수 있습니다. 그러한 경우 사용한 레지스트리의 유지 관리자에게 문의하세요. crates.io의 경우 <a href="https://crates.io/policies">정책</a> 을 참조하고 <a href="mailto:commands/help@crates.io">help@crates.io</a>로 문의하세요.</p>
<p>If credentials have been leaked, the recommended course of action is to revoke them immediately. Once a crate has been published, it is impossible to determine if the leaked credentials have been copied. Yanking only prevents Cargo from selecting this version when resolving dependencies by default. Existing lock files or direct downloads are not affected, so yanking cannot stop further spreading of the leaked credentials.</p>
<h2 id="옵션-34"><a class="header" href="#옵션-34">옵션</a></h2>
<h3 id="yank-옵션"><a class="header" href="#yank-옵션">Yank 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-yank---vers"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---vers"><code>--vers</code> <em>version</em></a></dt>
<dt class="option-term" id="option-cargo-yank---version"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---version"><code>--version</code> <em>version</em></a></dt>
<dd class="option-desc"><p>The version to yank or un-yank.</p>
</dd>
<dt class="option-term" id="option-cargo-yank---undo"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---undo"><code>--undo</code></a></dt>
<dd class="option-desc"><p>Undo a yank, putting a version back into the index.</p>
</dd>
<dt class="option-term" id="option-cargo-yank---token"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---token"><code>--token</code> <em>token</em></a></dt>
<dd class="option-desc"><p>API token to use when authenticating. This overrides the token stored in
the credentials file (which is created by <a href="commands/cargo-login.html">cargo-login(1)</a>).</p>
<p><a href="commands/../reference/config.html">Cargo config</a> environment variables can be
used to override the tokens stored in the credentials file. The token for
crates.io may be specified with the <code>CARGO_REGISTRY_TOKEN</code> environment
variable. Tokens for other registries may be specified with environment
variables of the form <code>CARGO_REGISTRIES_NAME_TOKEN</code> where <code>NAME</code> is the name
of the registry in all capital letters.</p>
</dd>
<dt class="option-term" id="option-cargo-yank---index"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---index"><code>--index</code> <em>index</em></a></dt>
<dd class="option-desc"><p>The URL of the registry index to use.</p>
</dd>
<dt class="option-term" id="option-cargo-yank---registry"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---registry"><code>--registry</code> <em>registry</em></a></dt>
<dd class="option-desc"><p>Name of the registry to use. Registry names are defined in <a href="commands/../reference/config.html">Cargo config
files</a>. If not specified, the default registry is used,
which is defined by the <code>registry.default</code> config key which defaults to
<code>crates-io</code>.</p>
</dd>
</dl>
<h3 id="표시-옵션-33"><a class="header" href="#표시-옵션-33">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-yank--v"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-yank---verbose"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-yank--q"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-yank---quiet"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-yank---color"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="공통-옵션-33"><a class="header" href="#공통-옵션-33">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-yank-+toolchain"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-yank---config"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-yank--C"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-yank--h"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-yank---help"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-yank--Z"><a class="option-anchor" href="commands/cargo-yank.html#option-cargo-yank--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-36"><a class="header" href="#환경-변수-36">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-33"><a class="header" href="#종료-상태-33">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-48"><a class="header" href="#예제-48">예제</a></h2>
<ol>
<li>
<p>인덱스에서 크레이트를 제거(yank)합니다:</p>
<pre><code>cargo yank foo@1.0.7
</code></pre>
</li>
</ol>
<h2 id="참고-항목-37"><a class="header" href="#참고-항목-37">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-login.html">cargo-login(1)</a>, <a href="commands/cargo-publish.html">cargo-publish(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="report-commands-1"><a class="header" href="#report-commands-1">Report Commands</a></h1>
<ul>
<li><a href="commands/cargo-report.html">cargo report</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-report1"><a class="header" href="#cargo-report1">cargo-report(1)</a></h1>
<h2 id="이름-38"><a class="header" href="#이름-38">이름</a></h2>
<p>cargo-report — 다양한 종류의 보고서 생성 및 표시</p>
<h2 id="사용법-35"><a class="header" href="#사용법-35">사용법</a></h2>
<p><code>cargo report</code> <em>유형</em> [<em>옵션</em>]</p>
<h2 id="설명-38"><a class="header" href="#설명-38">설명</a></h2>
<p>주어진 <em>유형</em> 의 보고서를 표시합니다 — 현재는 <code>future-incompat</code> 만 지원됩니다</p>
<h2 id="옵션-35"><a class="header" href="#옵션-35">옵션</a></h2>
<h3 id="표시-옵션-34"><a class="header" href="#표시-옵션-34">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-report--v"><a class="option-anchor" href="commands/cargo-report.html#option-cargo-report--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-report---verbose"><a class="option-anchor" href="commands/cargo-report.html#option-cargo-report---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-report--q"><a class="option-anchor" href="commands/cargo-report.html#option-cargo-report--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-report---quiet"><a class="option-anchor" href="commands/cargo-report.html#option-cargo-report---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-report---color"><a class="option-anchor" href="commands/cargo-report.html#option-cargo-report---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="매니페스트-옵션-26"><a class="header" href="#매니페스트-옵션-26">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-report---locked"><a class="option-anchor" href="commands/cargo-report.html#option-cargo-report---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-report---offline"><a class="option-anchor" href="commands/cargo-report.html#option-cargo-report---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-report---frozen"><a class="option-anchor" href="commands/cargo-report.html#option-cargo-report---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션-34"><a class="header" href="#공통-옵션-34">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-report-+toolchain"><a class="option-anchor" href="commands/cargo-report.html#option-cargo-report-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-report---config"><a class="option-anchor" href="commands/cargo-report.html#option-cargo-report---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-report--C"><a class="option-anchor" href="commands/cargo-report.html#option-cargo-report--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-report--h"><a class="option-anchor" href="commands/cargo-report.html#option-cargo-report--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-report---help"><a class="option-anchor" href="commands/cargo-report.html#option-cargo-report---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-report--Z"><a class="option-anchor" href="commands/cargo-report.html#option-cargo-report--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-37"><a class="header" href="#환경-변수-37">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-34"><a class="header" href="#종료-상태-34">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-49"><a class="header" href="#예제-49">예제</a></h2>
<ol>
<li>
<p>Display the available kinds of reports:</p>
<pre><code>cargo report --help
</code></pre>
</li>
</ol>
<h2 id="참고-항목-38"><a class="header" href="#참고-항목-38">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-report-future-incompatibilities.html">cargo-report-future-incompatibilities(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cargo-report-future-incompatibilities1"><a class="header" href="#cargo-report-future-incompatibilities1">cargo-report-future-incompatibilities(1)</a></h1>
<h2 id="이름-39"><a class="header" href="#이름-39">이름</a></h2>
<p>cargo-report-future-incompatibilities — Reports any crates which will eventually stop compiling</p>
<h2 id="사용법-36"><a class="header" href="#사용법-36">사용법</a></h2>
<p><code>cargo report future-incompatibilities</code> [<em>options</em>]</p>
<h2 id="설명-39"><a class="header" href="#설명-39">설명</a></h2>
<p>Displays a report of future-incompatible warnings that were emitted during previous builds. These are warnings for changes that may become hard errors in the future, causing dependencies to stop building in a future version of rustc.</p>
<p>For more, see the chapter on <a href="commands/../reference/future-incompat-report.html">Future incompat report</a>.</p>
<h2 id="옵션-36"><a class="header" href="#옵션-36">옵션</a></h2>
<dl>
<dt class="option-term" id="option-cargo-report-future-incompatibilities---id"><a class="option-anchor" href="commands/cargo-report-future-incompatibilities.html#option-cargo-report-future-incompatibilities---id"><code>--id</code> <em>id</em></a></dt>
<dd class="option-desc"><p>Show the report with the specified Cargo-generated id.
If not specified, shows the most recent report.</p>
</dd>
</dl>
<h3 id="패키지-선택-16"><a class="header" href="#패키지-선택-16">패키지 선택</a></h3>
<p>기본적으로 현재 작업 디렉토리의 패키지가 선택됩니다. <code>-p</code> 플래그를 사용하여 워크스페이스의 다른 패키지를 선택할 수 있습니다.</p>
<dl>
<dt class="option-term" id="option-cargo-report-future-incompatibilities--p"><a class="option-anchor" href="commands/cargo-report-future-incompatibilities.html#option-cargo-report-future-incompatibilities--p"><code>-p</code> <em>spec</em></a></dt>
<dt class="option-term" id="option-cargo-report-future-incompatibilities---package"><a class="option-anchor" href="commands/cargo-report-future-incompatibilities.html#option-cargo-report-future-incompatibilities---package"><code>--package</code> <em>spec</em></a></dt>
<dd class="option-desc"><p>The package to display a report for. See <a href="commands/cargo-pkgid.html">cargo-pkgid(1)</a> for the SPEC
format.</p>
</dd>
</dl>
<h3 id="표시-옵션-35"><a class="header" href="#표시-옵션-35">표시 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-report-future-incompatibilities--v"><a class="option-anchor" href="commands/cargo-report-future-incompatibilities.html#option-cargo-report-future-incompatibilities--v"><code>-v</code></a></dt>
<dt class="option-term" id="option-cargo-report-future-incompatibilities---verbose"><a class="option-anchor" href="commands/cargo-report-future-incompatibilities.html#option-cargo-report-future-incompatibilities---verbose"><code>--verbose</code></a></dt>
<dd class="option-desc"><p>Use verbose output. May be specified twice for “very verbose” output which
includes extra output such as dependency warnings and build script output.
May also be specified with the <code>term.verbose</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-report-future-incompatibilities--q"><a class="option-anchor" href="commands/cargo-report-future-incompatibilities.html#option-cargo-report-future-incompatibilities--q"><code>-q</code></a></dt>
<dt class="option-term" id="option-cargo-report-future-incompatibilities---quiet"><a class="option-anchor" href="commands/cargo-report-future-incompatibilities.html#option-cargo-report-future-incompatibilities---quiet"><code>--quiet</code></a></dt>
<dd class="option-desc"><p>Do not print cargo log messages.
May also be specified with the <code>term.quiet</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-report-future-incompatibilities---color"><a class="option-anchor" href="commands/cargo-report-future-incompatibilities.html#option-cargo-report-future-incompatibilities---color"><code>--color</code> <em>when</em></a></dt>
<dd class="option-desc"><p>Control when colored output is used. Valid values:</p>
<ul>
<li><code>auto</code> (default): Automatically detect if color support is available on the
terminal.</li>
<li><code>always</code>: Always display colors.</li>
<li><code>never</code>: Never display colors.</li>
</ul>
<p>May also be specified with the <code>term.color</code>
<a href="commands/../reference/config.html">config value</a>.</p>
</dd>
</dl>
<h3 id="매니페스트-옵션-27"><a class="header" href="#매니페스트-옵션-27">매니페스트 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-report-future-incompatibilities---locked"><a class="option-anchor" href="commands/cargo-report-future-incompatibilities.html#option-cargo-report-future-incompatibilities---locked"><code>--locked</code></a></dt>
<dd class="option-desc"><p>Asserts that the exact same dependencies and versions are used as when the
existing <code>Cargo.lock</code> file was originally generated. Cargo will exit with an
error when either of the following scenarios arises:</p>
<ul>
<li>The lock file is missing.</li>
<li>Cargo attempted to change the lock file due to a different dependency resolution.</li>
</ul>
<p>It may be used in environments where deterministic builds are desired,
such as in CI pipelines.</p>
</dd>
<dt class="option-term" id="option-cargo-report-future-incompatibilities---offline"><a class="option-anchor" href="commands/cargo-report-future-incompatibilities.html#option-cargo-report-future-incompatibilities---offline"><code>--offline</code></a></dt>
<dd class="option-desc"><p>Prevents Cargo from accessing the network for any reason. Without this
flag, Cargo will stop with an error if it needs to access the network and
the network is not available. With this flag, Cargo will attempt to
proceed without the network if possible.</p>
<p>Beware that this may result in different dependency resolution than online
mode. Cargo will restrict itself to crates that are downloaded locally, even
if there might be a newer version as indicated in the local copy of the index.
See the <a href="commands/cargo-fetch.html">cargo-fetch(1)</a> command to download dependencies before going
offline.</p>
<p>May also be specified with the <code>net.offline</code> <a href="commands/../reference/config.html">config value</a>.</p>
</dd>
<dt class="option-term" id="option-cargo-report-future-incompatibilities---frozen"><a class="option-anchor" href="commands/cargo-report-future-incompatibilities.html#option-cargo-report-future-incompatibilities---frozen"><code>--frozen</code></a></dt>
<dd class="option-desc"><p>Equivalent to specifying both <code>--locked</code> and <code>--offline</code>.</p>
</dd>
</dl>
<h3 id="공통-옵션-35"><a class="header" href="#공통-옵션-35">공통 옵션</a></h3>
<dl>
<dt class="option-term" id="option-cargo-report-future-incompatibilities-+toolchain"><a class="option-anchor" href="commands/cargo-report-future-incompatibilities.html#option-cargo-report-future-incompatibilities-+toolchain"><code>+</code><em>toolchain</em></a></dt>
<dd class="option-desc"><p>If Cargo has been installed with rustup, and the first argument to <code>cargo</code>
begins with <code>+</code>, it will be interpreted as a rustup toolchain name (such
as <code>+stable</code> or <code>+nightly</code>).
See the <a href="https://rust-lang.github.io/rustup/overrides.html">rustup documentation</a>
for more information about how toolchain overrides work.</p>
</dd>
<dt class="option-term" id="option-cargo-report-future-incompatibilities---config"><a class="option-anchor" href="commands/cargo-report-future-incompatibilities.html#option-cargo-report-future-incompatibilities---config"><code>--config</code> <em>KEY=VALUE</em> or <em>PATH</em></a></dt>
<dd class="option-desc"><p>Overrides a Cargo configuration value. The argument should be in TOML syntax of <code>KEY=VALUE</code>,
or provided as a path to an extra configuration file. This flag may be specified multiple times.
See the <a href="commands/../reference/config.html#command-line-overrides">command-line overrides section</a> for more information.</p>
</dd>
<dt class="option-term" id="option-cargo-report-future-incompatibilities--C"><a class="option-anchor" href="commands/cargo-report-future-incompatibilities.html#option-cargo-report-future-incompatibilities--C"><code>-C</code> <em>PATH</em></a></dt>
<dd class="option-desc"><p>Changes the current working directory before executing any specified operations. This affects
things like where cargo looks by default for the project manifest (<code>Cargo.toml</code>), as well as
the directories searched for discovering <code>.cargo/config.toml</code>, for example. This option must
appear before the command name, for example <code>cargo -C path/to/my-project build</code>.</p>
<p>This option is only available on the <a href="https://doc.rust-lang.org/book/appendix-07-nightly-rust.html">nightly
channel</a> and
requires the <code>-Z unstable-options</code> flag to enable (see
<a href="https://github.com/rust-lang/cargo/issues/10098">#10098</a>).</p>
</dd>
<dt class="option-term" id="option-cargo-report-future-incompatibilities--h"><a class="option-anchor" href="commands/cargo-report-future-incompatibilities.html#option-cargo-report-future-incompatibilities--h"><code>-h</code></a></dt>
<dt class="option-term" id="option-cargo-report-future-incompatibilities---help"><a class="option-anchor" href="commands/cargo-report-future-incompatibilities.html#option-cargo-report-future-incompatibilities---help"><code>--help</code></a></dt>
<dd class="option-desc"><p>Prints help information.</p>
</dd>
<dt class="option-term" id="option-cargo-report-future-incompatibilities--Z"><a class="option-anchor" href="commands/cargo-report-future-incompatibilities.html#option-cargo-report-future-incompatibilities--Z"><code>-Z</code> <em>flag</em></a></dt>
<dd class="option-desc"><p>Unstable (nightly-only) flags to Cargo. Run <code>cargo -Z help</code> for details.</p>
</dd>
</dl>
<h2 id="환경-변수-38"><a class="header" href="#환경-변수-38">환경 변수</a></h2>
<p>Cargo가 읽는 환경 변수에 대한 자세한 내용은 <a href="commands/../reference/environment-variables.html">레퍼런스</a>를 참조하세요.</p>
<h2 id="종료-상태-35"><a class="header" href="#종료-상태-35">종료 상태</a></h2>
<ul>
<li><code>0</code>: Cargo가 성공했습니다.</li>
<li><code>101</code>: Cargo가 완료하지 못했습니다.</li>
</ul>
<h2 id="예제-50"><a class="header" href="#예제-50">예제</a></h2>
<ol>
<li>
<p>최신 미래 비호환성 보고서 표시:</p>
<pre><code>cargo report future-incompat
</code></pre>
</li>
<li>
<p>특정 패키지에 대한 최신 미래 비호환성 보고서 표시:</p>
<pre><code>cargo report future-incompat --package my-dep@0.0.1
</code></pre>
</li>
</ol>
<h2 id="참고-항목-39"><a class="header" href="#참고-항목-39">참고 항목</a></h2>
<p><a href="commands/cargo.html">cargo(1)</a>, <a href="commands/cargo-report.html">cargo-report(1)</a>, <a href="commands/cargo-build.html">cargo-build(1)</a></p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="사용-중단-및-제거된-명령어"><a class="header" href="#사용-중단-및-제거된-명령어">사용 중단 및 제거된 명령어</a></h2>
<p>이 명령어들은 초기 Rust 릴리스에서 사용 중단되거나 제거되었습니다. 사용 중단된 명령어는 중요한 버그 수정만 받으며 향후 버전에서 제거될 수 있습니다. 제거된 명령어는 더 이상 작동하지 않으며 지원되지 않습니다.</p>
<ul>
<li><code>read-manifest</code> — Rust 1.13부터 사용 중단됨</li>
<li><code>git-checkout</code> — Rust 1.44부터 제거됨</li>
<li><code>verify-project</code> — Rust 1.84부터 사용 중단됨</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="자주-묻는-질문"><a class="header" href="#자주-묻는-질문">자주 묻는 질문</a></h1>
<h2 id="github을-패키지-저장소로-사용할-계획입니까"><a class="header" href="#github을-패키지-저장소로-사용할-계획입니까">GitHub을 패키지 저장소로 사용할 계획입니까?</a></h2>
<p>아니요. Cargo의 계획은 npm이 <a href="https://www.npmjs.com">npmjs.com</a> 을 사용하고 Rubygems가 <a href="https://rubygems.org">rubygems.org</a> 를 사용하는 것처럼 <a href="https://crates.io/">crates.io</a> 를 사용하는 것입니다.</p>
<p>사람들이 레지스트리를 패키지의 기본 소스로 사용하더라도 초기 개발 및 임시 패치에 사용될 수 있기 때문에, 패키지 소스로서의 git 저장소는 영원히 지원할 계획입니다.</p>
<h2 id="github를-레지스트리로-사용하는-대신-왜-cratesio를-만드나요"><a class="header" href="#github를-레지스트리로-사용하는-대신-왜-cratesio를-만드나요">GitHub를 레지스트리로 사용하는 대신 왜 crates.io를 만드나요?</a></h2>
<p>우리는 GitHub에서 다운로드하거나 패키지 자체에 패키지를 복사하는 것을 포함하여 패키지를 다운로드하는 여러 방법을 지원하는 것이 매우 중요하다고 생각합니다.</p>
<p>그렇긴 하지만, 우리는 <a href="https://crates.io/">crates.io</a> 가 여러 가지 중요한 이점을 제공하며 사람들이 Cargo에서 패키지를 다운로드하는 주요 방법이 될 가능성이 높다고 생각합니다.</p>
<p>선례를 보면 Node.js의 <a href="https://www.npmjs.com">npm</a> 과 Ruby의 <a href="https://bundler.io">bundler</a> 모두 중앙 레지스트리 모델과 Git 기반 모델을 모두 지원하며, 해당 생태계에서 대부분의 패키지는 레지스트리를 통해 다운로드되고 중요한 소수의 패키지가 Git 기반 패키지를 활용합니다.</p>
<p>중앙 레지스트리가 다른 언어에서 인기 있는 이유 중 몇 가지 장점은 다음과 같습니다:</p>
<ul>
<li><strong>발견 용이성(Discoverability)</strong>. 중앙 레지스트리는 기존 패키지를 찾기 쉬운 장소를 제공합니다. 태깅과 결합하여 레지스트리가 가장 인기 있는 패키지 목록이나 가장 많이 의존되는 패키지 목록과 같은 생태계 전반의 정보를 제공할 수도 있습니다.</li>
<li><strong>속도(Speed)</strong>. 중앙 레지스트리를 사용하면 패키지의 메타데이터만 쉽고 빠르고 효율적으로 가져올 수 있으며, 저장소에 존재하는 다른 불필요한 데이터가 아닌 게시된 패키지만 효율적으로 다운로드할 수 있습니다. 이는 의존성 해결 및 가져오기 속도를 크게 향상시킵니다. 의존성 그래프가 커짐에 따라 모든 Git 저장소를 다운로드하는 것은 금방 느려집니다. 또한 모든 사람이 고속의 저지연 인터넷 연결을 가지고 있지는 않다는 점을 기억하세요.</li>
</ul>
<h2 id="cargo가-c-코드또는-다른-언어와-연동되나요"><a class="header" href="#cargo가-c-코드또는-다른-언어와-연동되나요">Cargo가 C 코드(또는 다른 언어)와 연동되나요?</a></h2>
<p>네!</p>
<p>Cargo는 Rust 코드 컴파일을 처리하지만, 많은 Rust 패키지가 C 코드와 연결된다는 것을 알고 있습니다. 또한 Rust 이외의 언어를 컴파일하는 것과 관련하여 수십 년 동안 구축된 도구들이 있다는 것도 알고 있습니다.</p>
<p>우리의 솔루션: Cargo는 패키지가 <code>rustc</code> 를 호출하기 전에 실행할 <a href="reference/build-scripts.html">스크립트를 지정</a>(Rust로 작성됨)할 수 있도록 합니다. Rust는 플랫폼별 구성을 구현하고 패키지 간의 공통 빌드 기능을 리팩토링하는 데 활용됩니다.</p>
<h2 id="make또는-ninja-등-내부에서-cargo를-사용할-수-있나요"><a class="header" href="#make또는-ninja-등-내부에서-cargo를-사용할-수-있나요"><code>make</code>(또는 <code>ninja</code> 등) 내부에서 Cargo를 사용할 수 있나요?</a></h2>
<p>그렇습니다. Cargo가 최상위 수준에서 Rust 패키지를 컴파일하는 독립적인 방법으로 유용하게 사용되기를 의도하지만, 일부 사람들이 다른 빌드 도구에서 Cargo를 호출하기를 원할 것이라는 점도 알고 있습니다.</p>
<p>우리는 에러 코드와 기계 판독 가능한 출력 모드와 같은 것들에 주의를 기울여 Cargo가 그러한 문맥에서 잘 작동하도록 설계했습니다. 아직 해야 할 일이 좀 더 남아있지만, 전통적인 스크립트 문맥에서 Cargo를 사용하는 것은 우리가 처음부터 설계한 부분이며 앞으로도 계속 우선순위를 둘 것입니다.</p>
<h2 id="cargo는-멀티-플랫폼-패키지나-교차-컴파일cross-compilation을-처리하나요"><a class="header" href="#cargo는-멀티-플랫폼-패키지나-교차-컴파일cross-compilation을-처리하나요">Cargo는 멀티 플랫폼 패키지나 교차 컴파일(cross-compilation)을 처리하나요?</a></h2>
<p>Rust 자체적으로 플랫폼에 따라 코드 섹션을 구성하는 기능을 제공합니다. Cargo 또한 <a href="reference/specifying-dependencies.html#platform-specific-dependencies">플랫폼별 의존성</a> 을 지원하며, 향후 <code>Cargo.toml</code> 에서 더 많은 플랫폼별 구성을 지원할 계획입니다.</p>
<p>장기적으로는 Cargo를 사용하여 패키지를 편리하게 교차 컴파일하는 방법을 모색하고 있습니다.</p>
<h2 id="cargo는-production-이나-test-와-같은-환경을-지원하나요"><a class="header" href="#cargo는-production-이나-test-와-같은-환경을-지원하나요">Cargo는 <code>production</code> 이나 <code>test</code> 와 같은 환경을 지원하나요?</a></h2>
<p>우리는 다음을 지원하기 위해 <a href="reference/profiles.html">프로파일</a> 을 사용하여 환경을 지원합니다:</p>
<ul>
<li>환경별 플래그(예: 개발용 <code>-g --opt-level=0</code>, 운영용 <code>--opt-level=3</code> 등).</li>
<li>환경별 의존성(예: 테스트 단언을 위한 <code>hamcrest</code>).</li>
<li>환경별 <code>#[cfg]</code></li>
<li><code>cargo test</code> 명령어</li>
</ul>
<h2 id="cargo는-windows에서-작동하나요"><a class="header" href="#cargo는-windows에서-작동하나요">Cargo는 Windows에서 작동하나요?</a></h2>
<p>네!</p>
<p>Cargo에 대한 모든 커밋은 Windows에서 로컬 테스트 스위트를 통과해야 합니다. Windows에서 실행 중에 문제가 발생하면 이를 버그로 간주하므로, <a href="https://github.com/rust-lang/cargo/issues">이슈를 제기해 주세요</a>.</p>
<h2 id="왜-cargolock-을-버전-관리에-두어야-하나요"><a class="header" href="#왜-cargolock-을-버전-관리에-두어야-하나요">왜 <code>Cargo.lock</code> 을 버전 관리에 두어야 하나요?</a></h2>
<p><a href="commands/cargo-new.html"><code>cargo new</code></a> 는 기본적으로 버전 관리에서 <code>Cargo.lock</code> 을 추적하도록 설정되지만, 그렇게 할지 여부는 패키지의 필요에 따라 다릅니다.</p>
<p><code>Cargo.lock</code> 잠금 파일의 목적은 성공적인 빌드 시점의 상태를 기술하는 것입니다. Cargo는 이 잠금 파일을 사용하여 <code>Cargo.lock</code> 파일이 처음 생성되었을 때와 정확히 동일한 의존성과 버전이 사용되도록 보장함으로써, 서로 다른 시점과 서로 다른 시스템에서 결정론적인 빌드를 제공합니다.</p>
<p>결정론적인 빌드는 다음에 도움이 됩니다:</p>
<ul>
<li>버그의 근본 원인을 찾기 위해 <code>git bisect</code> 실행하기</li>
<li>외부 요인이 아닌 새로운 커밋으로 인해서만 CI가 실패하도록 보장하기</li>
<li>기여자가 다른 기여자나 CI와 비교하여 다른 동작을 볼 때 발생하는 혼란 줄이기</li>
</ul>
<p>의존성의 스냅샷을 갖는 것은 다음과 같이 프로젝트를 일관된 버전의 의존성에 대해 검증해야 할 때도 도움이 됩니다.</p>
<ul>
<li>의존성의 최신 버전이 지원하는 버전보다 낮은 최소 지원 Rust 버전(MSRV)을 검증할 때</li>
<li>호환성이 보장되지 않는 사람이 읽을 수 있는 출력을 검증할 때(예: 에러 메시지가 “이해하기 쉬운지” 확인하기 위한 스냅샷 테스트. 이는 자동화하기에는 너무 모호한 지표임)</li>
</ul>
<p>하지만 이러한 결정론은 잘못된 보안감을 줄 수 있습니다. <code>Cargo.lock</code> 은 패키지 사용자에게 영향을 미치지 않고 <code>Cargo.toml</code> 만 영향을 미치기 때문입니다. 예를 들어:</p>
<ul>
<li><a href="commands/cargo.html#option-cargo---locked"><code>--locked</code></a> 를 전달하지 않는 한 <a href="commands/cargo-install.html"><code>cargo install</code></a> 은 최신 의존성을 선택합니다.</li>
<li><a href="commands/cargo-add.html"><code>cargo add</code></a> 로 추가된 것과 같은 새로운 의존성은 최신 버전으로 고정됩니다.</li>
</ul>
<p>잠금 파일은 머지 충돌의 원인이 될 수도 있습니다.</p>
<p>CI를 통해 최신 버전의 의존성을 검증하는 전략에 대해서는 <a href="guide/continuous-integration.html#verifying-latest-dependencies">최신 의존성 확인</a> 을 참조하세요.</p>
<h2 id="라이브러리가-의존성-버전으로--를-사용할-수-있나요"><a class="header" href="#라이브러리가-의존성-버전으로--를-사용할-수-있나요">라이브러리가 의존성 버전으로 <code>*</code> 를 사용할 수 있나요?</a></h2>
<p><strong>2016년 1월 22일부로, <a href="https://crates.io/">crates.io</a> 는 와일드카드 의존성 제약 조건이 있는 모든 패키지(라이브러리뿐만 아니라)를 거부합니다.</strong></p>
<p>엄밀히 말해 라이브러리가 사용할 수는 있지만, 사용해서는 안 됩니다. <code>*</code> 버전 요구 사항은 “이것은 지금까지 나온 모든 버전과 연동됩니다“라고 말하는 것과 같으며, 이는 결코 사실일 수 없습니다. 라이브러리는 “모든 1.x.y 버전“과 같이 일반적인 것이라도 항상 연동되는 범위를 지정해야 합니다.</p>
<h2 id="왜-cargotoml-인가요"><a class="header" href="#왜-cargotoml-인가요">왜 <code>Cargo.toml</code> 인가요?</a></h2>
<p>Cargo를 사용하면서 가장 자주 접하는 질문 중 하나가 왜 설정 파일 이름이 <code>Cargo.toml</code> 인가 하는 것입니다. 맨 앞의 대문자 <code>C</code> 는 디렉토리 목록에서 매니페스트가 다른 유사한 설정 파일들과 함께 묶이도록 선택되었습니다. 파일을 정렬할 때 종종 대문자가 소문자보다 앞에 오기 때문에, <code>Makefile</code> 과 <code>Cargo.toml</code> 같은 파일들이 함께 놓이게 됩니다. 뒤의 <code>.toml</code> 은 이 파일이 <a href="https://toml.io/">TOML 설정 형식</a> 임을 강조하기 위해 선택되었습니다.</p>
<p>Cargo는 저장소를 쉽게 식별할 수 있도록 <code>cargo.toml</code> 이나 <code>Cargofile</code> 과 같은 다른 이름을 허용하지 않습니다. 다양한 이름을 허용할 경우 과거에 한 가지 경우는 처리되었지만 다른 경우는 실수로 잊혀지는 등의 혼란이 발생했기 때문입니다.</p>
<h2 id="cargo를-어떻게-오프라인에서-사용할-수-있나요"><a class="header" href="#cargo를-어떻게-오프라인에서-사용할-수-있나요">Cargo를 어떻게 오프라인에서 사용할 수 있나요?</a></h2>
<p><a href="commands/cargo.html#option-cargo---offline"><code>--offline</code></a> 또는 <a href="commands/cargo.html#option-cargo---frozen"><code>--frozen</code></a> 플래그는 Cargo가 네트워크에 접속하지 않도록 합니다. 네트워크에 접속해야 하는 경우 에러를 반환합니다. 오프라인으로 전환하기 전에 한 프로젝트에서 <a href="commands/cargo-fetch.html"><code>cargo fetch</code></a> 를 사용하여 의존성을 다운로드한 다음, 다른 프로젝트에서 동일한 의존성을 사용할 수 있습니다. Cargo 설정을 통해 이를 설정하려면 <a href="reference/config.html#netoffline">설정 값</a> 을 참조하세요.</p>
<p>벤더링(Vendoring)도 이와 관련이 있습니다. 자세한 내용은 <a href="reference/source-replacement.html">소스 교체(source replacement)</a> 문서를 참조하세요.</p>
<h2 id="왜-cargo가-제-코드를-다시-빌드하나요"><a class="header" href="#왜-cargo가-제-코드를-다시-빌드하나요">왜 Cargo가 제 코드를 다시 빌드하나요?</a></h2>
<p>Cargo는 프로젝트의 크레이트를 점진적으로 컴파일할 책임이 있습니다. 이는 예를 들어 <code>cargo build</code> 를 두 번 입력했을 때 두 번째 빌드에서는 crates.io 의존성을 다시 빌드하지 않아야 함을 의미합니다. 그럼에도 불구하고 버그가 발생할 수 있으며, Cargo가 예상치 못한 시점에 코드를 다시 빌드할 수도 있습니다.</p>
<p>우리는 오랫동안 <a href="https://github.com/rust-lang/cargo/issues/2904">이에 대해 더 나은 진단 기능을 제공하기를 원해 왔지만</a>, 불행히도 꽤 오랫동안 해당 이슈에서 진전을 보지 못했습니다. 하지만 그동안 <code>CARGO_LOG</code> 환경 변수를 설정하여 재빌드 문제를 어느 정도 디버깅할 수 있습니다.</p>
<pre><code class="language-sh">$ CARGO_LOG=cargo::core::compiler::fingerprint=info cargo build
</code></pre>
<p>이렇게 하면 Cargo가 진단 및 재빌드에 대한 많은 정보를 출력합니다. 이 출력에는 프로젝트가 왜 다시 빌드되는지에 대한 단서가 포함되어 있을 수 있지만, 출력이 아직 읽기 쉽지 않기 때문에 직접 단서들을 연결해 보아야 할 수도 있습니다. <code>CARGO_LOG</code> 는 재빌드되지 않아야 한다고 생각되는 명령을 실행할 때 설정되어야 한다는 점에 유의하세요. 안타깝게도 현재 Cargo에는 사후에 “왜 그것이 다시 빌드되었는가?“를 디버깅할 수 있는 방법이 없습니다.</p>
<p>역사적으로 크레이트가 다시 빌드되게 만든 몇 가지 이슈들은 다음과 같습니다:</p>
<ul>
<li>
<p>빌드 스크립트가 존재하지 않고 아무것도 생성하지 않는 파일 <code>foo</code> 에 대해 <code>cargo::rerun-if-changed=foo</code> 를 출력하는 경우입니다. 이 경우 Cargo는 스크립트가 해당 파일을 생성할 것이라고 생각하여 빌드 스크립트를 계속 실행하지만, 실제로는 아무것도 생성되지 않습니다. 해결 방법은 이러한 시나리오에서 <code>rerun-if-changed</code> 를 출력하지 않는 것입니다.</p>
</li>
<li>
<p>두 번의 연속된 Cargo 빌드에서 일부 의존성에 대해 활성화된 기능(feature) 집합이 다를 수 있습니다. 예를 들어, 첫 번째 빌드 명령이 전체 워크스페이스를 빌드하고 두 번째 명령이 하나의 크레이트만 빌드하는 경우, crates.io의 의존성에 대해 다른 기능 집합이 활성화되어 해당 의존성과 이를 의존하는 모든 것이 다시 빌드될 수 있습니다. 안타깝게도 이에 대한 완벽한 해결책은 없지만, 가능하다면 워크스페이스에서 무엇을 빌드하든 크레이트에 활성화된 기능 집합을 일정하게 유지하는 것이 최선입니다.</p>
</li>
<li>
<p>일부 파일 시스템은 타임스탬프와 관련하여 특이한 동작을 보입니다. Cargo는 주로 파일의 타임스탬프를 사용하여 재빌드 여부를 결정하지만, 비표준 파일 시스템을 사용하는 경우 타임스탬프에 영향을 줄 수 있습니다(예: 타임스탬프 잘림, 드리프트 발생 등). 이러한 시나리오에서는 자유롭게 이슈를 제기해 주시면 파일 시스템을 지원할 수 있는 방법을 찾아보겠습니다.</p>
</li>
<li>
<p>동시 빌드 프로세스가 결과물을 삭제하거나 파일을 수정하고 있는 경우입니다. 때때로 프로젝트를 빌드하거나 체크하려고 시도하는 백그라운드 프로세스가 있을 수 있습니다. 이러한 백그라운드 프로세스가 예상치 못하게 빌드 결과물을 삭제하거나 파일을 건드려서(또는 실수로) 재빌드가 불필요해 보이게 만들 수 있습니다! 여기서 최선의 해결책은 백그라운드 프로세스가 작업과 충돌하지 않도록 조정하는 것입니다.</p>
</li>
</ul>
<p>하지만 문제를 디버깅해 본 후에도 여전히 문제가 발생한다면, 언제든지 <a href="https://github.com/rust-lang/cargo/issues/new">이슈를 제기해 주세요</a>!</p>
<h2 id="버전-충돌이-무엇을-의미하며-어떻게-해결하나요"><a class="header" href="#버전-충돌이-무엇을-의미하며-어떻게-해결하나요">“버전 충돌“이 무엇을 의미하며 어떻게 해결하나요?</a></h2>
<blockquote>
<p><code>x</code> 에 대해 이 충돌을 해결할 수 있는 버전을 선택하는 데 실패했습니다</p>
</blockquote>
<p>위와 같은 에러 메시지를 본 적이 있으신가요?</p>
<p>This is one of the most annoying error messages for Cargo users. There are several situations which may lead to a version conflict. Below we’ll walk through possible causes and provide diagnostic techniques to help you out there:</p>
<ul>
<li>
<p>The project and its dependencies use <a href="reference/resolver.html#links">links</a> to repeatedly link the local library. Cargo forbids linking two packages with the same native library, so even with multiple layers of dependencies it is not allowed. In this case, the error message will prompt: <code>Only one package in the dependency graph may specify the same links value</code>, you may need to manually check and delete duplicate link values. The community also have <a href="reference/build-scripts.html#-sys-packages">conventions in place</a> to alleviate this.</p>
</li>
<li>
<p>프로젝트에서 서로 다른 크레이트에 의존할 때, 이 크레이트들이 동일한 라이브러리를 의존하지만 사용되는 버전이 제한되어 있어 올바른 버전을 결정할 수 없는 경우에도 충돌이 발생합니다. 에러 메시지는 <code>all possible versions conflict with previously selected packages</code> 라고 안내합니다. 버전 요구 사항을 일관되게 수정해야 할 수 있습니다.</p>
</li>
<li>
<p>프로젝트에 여러 버전의 의존성이 있을 때, <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#direct-minimal-versions"><code>direct-minimal-versions</code></a> 를 사용하면 최소 버전 요구 사항을 충족할 수 없어 충돌이 발생할 수 있습니다. 이에 맞춰 최소 SemVer 버전을 충족하도록 직접 의존성의 버전 요구 사항을 수정해야 할 수 있습니다.</p>
</li>
<li>
<p>의존하는 크레이트에 선택한 기능(feature)이 없는 경우에도 충돌이 발생합니다. 이 경우 의존하는 버전과 해당 기능을 확인해야 합니다.</p>
</li>
<li>
<p>브랜치나 PR을 머지할 때 충돌이 발생할 수 있습니다. 복잡한 충돌이 있는 경우 “자신의(yours)” 변경 사항을 모두 리셋하고 브랜치의 다른 모든 충돌을 해결한 다음, <code>cargo tree</code> 나 <code>cargo check</code> 와 같은 명령어를 실행하면 로컬 변경 사항으로 잠금 파일을 다시 업데이트합니다. 이전에 브랜치에서 <code>cargo update</code> 명령을 실행했다면 지금 다시 실행하면 됩니다. 커뮤니티에서는 <a href="https://github.com/rust-lang/cargo/issues/1818">커스텀 머지 도구</a> 를 사용하여 <code>Cargo.lock</code> 및 <code>Cargo.toml</code> 의 머지 충돌을 해결하는 방법을 모색해 왔습니다.</p>
</li>
</ul>
<h2 id="why-does-my-build-take-up-so-much-space"><a class="header" href="#why-does-my-build-take-up-so-much-space">Why does my build take up so much space?</a></h2>
<p>Cargo trades off disk space for faster builds including:</p>
<ul>
<li>Maintaining a <a href="reference/build-cache.html">cache</a> of intermediate build artifacts to avoid rebuilding everything when making changes to one package</li>
<li>Maintaining distinct <a href="reference/build-cache.html">cache</a> entries for different combinations of toolchain versions, package versions, features, etc to avoid rebuilding packages when switching back and forth between configurations</li>
<li>Enabling <a href="reference/profiles.html#incremental">incremental compilation</a> for local packages for faster rebuilds for the package that changed</li>
<li>Enabling <a href="reference/profiles.html#debug">debuginfo</a> in the <a href="reference/profiles.html#dev"><code>dev</code> profile</a> in case you use a debugger</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="변경-로그"><a class="header" href="#변경-로그">변경 로그</a></h1>
<h2 id="cargo-195-2026-04-16"><a class="header" href="#cargo-195-2026-04-16">Cargo 1.95 (2026-04-16)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/85eff7c8...HEAD">85eff7c8…HEAD</a></p>
<h3 id="추가됨"><a class="header" href="#추가됨">추가됨</a></h3>
<h3 id="변경됨"><a class="header" href="#변경됨">변경됨</a></h3>
<ul>
<li>cargo-remove: Suggest <code>--dev</code>, <code>--build</code>, or <code>--target</code> flags when removing a dependency that exists in a different table. <a href="https://github.com/rust-lang/cargo/pull/16533">#16533</a></li>
<li>Improve patch-related error messages to follow rustc diagnostic style. <a href="https://github.com/rust-lang/cargo/pull/16498">#16498</a></li>
</ul>
<h3 id="수정됨"><a class="header" href="#수정됨">수정됨</a></h3>
<ul>
<li>Fixed <code>cargo test --frozen</code> attempting to download dependencies that are not actually required for the specified tests. <a href="https://github.com/rust-lang/cargo/pull/16221">#16221</a></li>
</ul>
<h3 id="나이틀리nightly-전용"><a class="header" href="#나이틀리nightly-전용">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><code>-Ztrim-paths</code>: use stabilized <code>-Cremap-path-scope</code> rustc flag. <a href="https://github.com/rust-lang/cargo/pull/16536">#16536</a></li>
<li><code>-Zcargo-lints</code>: new <code>non_kebab_case_bin</code> lint to warn when binary names contain underscores instead of hyphens. <a href="https://github.com/rust-lang/cargo/pull/16524">#16524</a></li>
<li><code>-Zcargo-lints</code>: show <code>implicit_minimum_version_req</code> lint source once per package. <a href="https://github.com/rust-lang/cargo/pull/16535">#16535</a></li>
<li><code>-Zbuild-dir-new-layout</code>: store artifact dependencies in build unit directory. <a href="https://github.com/rust-lang/cargo/pull/16519">#16519</a></li>
</ul>
<h3 id="문서"><a class="header" href="#문서">문서</a></h3>
<h3 id="내부-변경"><a class="header" href="#내부-변경">내부 변경</a></h3>
<ul>
<li>Reuse timing metric collection logic between <code>--timings</code> and <code>-Zbuild-analysis</code>. <a href="https://github.com/rust-lang/cargo/pull/16497">#16497</a></li>
</ul>
<h2 id="cargo-194-2026-03-05"><a class="header" href="#cargo-194-2026-03-05">Cargo 1.94 (2026-03-05)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/2c283a9a...rust-1.94.0">2c283a9a…rust-1.94.0</a></p>
<h3 id="추가됨-1"><a class="header" href="#추가됨-1">추가됨</a></h3>
<ul>
<li>🎉 Stabilize the config <code>include</code> key. The top-level <code>include</code> config key allows loading additional config files, enabling better organization, sharing, and management of Cargo configurations across projects and environments. <a href="https://doc.rust-lang.org/nightly/cargo/reference/config.html#including-extra-configuration-files">docs</a> <a href="https://github.com/rust-lang/cargo/pull/16284">#16284</a></li>
<li>🎉 Stabilize the <code>pubtime</code> field in registry index. This records when a crate version was published and enables time-based dependency resolution in the future. Note that crates.io will gradually backfill existing packages when a new version is published. Not all crates have <code>pubtime</code> yet. <a href="https://github.com/rust-lang/cargo/pull/16369">#16369</a> <a href="https://github.com/rust-lang/cargo/pull/16372">#16372</a></li>
<li>Cargo now parses <a href="https://toml.io/en/v1.1.0">TOML v1.1</a> for manifests and configuration files. Note that using these features in <code>Cargo.toml</code> will raise your development MSRV, but the published manifest remains compatible with older parsers. <a href="https://github.com/rust-lang/cargo/pull/16415">#16415</a></li>
<li>The timing HTML report now has a new SVG rendering option for a better rendering performance with large builds. Canvas rendering is still available but will be phased out. <a href="https://github.com/rust-lang/cargo/pull/15091">#15091</a></li>
<li>The <code>CARGO_BIN_EXE_&lt;name&gt;</code> environment variable is now available at runtime not just compile time. <a href="https://github.com/rust-lang/cargo/pull/16421">#16421</a></li>
<li>perf: Optimize <code>cargo clean</code> with multiple <code>--package</code> specifiers. <a href="https://github.com/rust-lang/cargo/pull/16264">#16264</a></li>
<li>perf: Optimize <code>cargo locate-project --workspace</code> by avoiding full workspace loading when only the workspace root path is needed. <a href="https://github.com/rust-lang/cargo/pull/16423">#16423</a></li>
</ul>
<h3 id="변경됨-1"><a class="header" href="#변경됨-1">변경됨</a></h3>
<ul>
<li>Improve error message when Cargo build target source files are missing. <a href="https://github.com/rust-lang/cargo/pull/16338">#16338</a></li>
<li>Improve error message for missing dependencies using rustc diagnostic style. <a href="https://github.com/rust-lang/cargo/pull/16500">#16500</a></li>
<li>Display where the patch was defined in patch-related error messages. <a href="https://github.com/rust-lang/cargo/pull/16407">#16407</a></li>
<li>List all available features when the requested feature has no close match. <a href="https://github.com/rust-lang/cargo/pull/16445">#16445</a></li>
<li>Display lockfile path in very verbose mode <code>-vv</code>) when waiting on a file lock. <a href="https://github.com/rust-lang/cargo/pull/16491">#16491</a></li>
<li>cargo-new: Improve quality of package name error messages. <a href="https://github.com/rust-lang/cargo/pull/16398">#16398</a></li>
</ul>
<h3 id="수정됨-1"><a class="header" href="#수정됨-1">수정됨</a></h3>
<ul>
<li>Don’t read config file twice when <code>$CARGO_HOME</code> is a symlinked directory. <a href="https://github.com/rust-lang/cargo/pull/16325">#16325</a></li>
<li>cargo-info: default to inspecting local package when no registry is explicitly specified. <a href="https://github.com/rust-lang/cargo/pull/16358">#16358</a></li>
<li>cargo-info: resolve underscore vs hyphen mismatch in schema lookup. <a href="https://github.com/rust-lang/cargo/pull/16455">#16455</a></li>
<li>cargo-package: skip registry verification when using <code>--list</code>. <a href="https://github.com/rust-lang/cargo/pull/16341">#16341</a></li>
<li>cargo-package: detect dirty files when run from workspace member directory. <a href="https://github.com/rust-lang/cargo/pull/16479">#16479</a></li>
<li>cargo-vendor: recursively filter <code>.gitattributes</code> and <code>.gitignores</code> in subdirectories. Previously only top-level Git files were filtered, causing checksum failures when vendored code is committed to a Git repository. <a href="https://github.com/rust-lang/cargo/pull/16439">#16439</a></li>
<li>cargo-vendor: unpack from local-registry cache path correctly. <a href="https://github.com/rust-lang/cargo/pull/16435">#16435</a></li>
</ul>
<h3 id="나이틀리nightly-전용-1"><a class="header" href="#나이틀리nightly-전용-1">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>🔥 <code>-Zany-build-script-metadata</code>: Allow any build script to emit <code>cargo::metadata=KEY=VALUE</code> and expose it to dependents via <code>CARGO_DEP_&lt;name&gt;_&lt;key&gt;</code> environment variables. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#any-build-script-metadata">docs</a> <a href="https://github.com/rust-lang/cargo/pull/16436">#16436</a> <a href="https://github.com/rust-lang/cargo/pull/16486">#16486</a> <a href="https://github.com/rust-lang/cargo/pull/16489">#16489</a> <a href="https://github.com/rust-lang/cargo/pull/16494">#16494</a> <a href="https://github.com/rust-lang/cargo/pull/16496">#16496</a></li>
<li><code>timings</code>: Remove <code>--timings=&lt;FMT&gt;</code> optional format values. The <code>-Zbuild-analysis</code> logging is now the recommended approach for machine-readable timing data. Use the unstable <code>cargo report timings</code> to generate HTML reports. <a href="https://github.com/rust-lang/cargo/pull/16420">#16420</a></li>
<li><code>-Zlockfile-path</code>: Add new <code>resolver.lockfile-path</code> config to replace CLI <code>--lockfile-path</code> option. <code>--lockfile-path</code> CLI option will be removed in a future release. <a href="https://github.com/rust-lang/cargo/pull/16510">#16510</a></li>
<li><code>-Zbuild-analysis</code>: new <code>cargo report rebuilds</code> command to analyze rebuild reasons from previous sessions. <a href="https://github.com/rust-lang/cargo/pull/16408">#16408</a> <a href="https://github.com/rust-lang/cargo/pull/16456">#16456</a></li>
<li><code>-Zbuild-analysis</code>: new <code>cargo report sessions</code> command to list build session IDs. <a href="https://github.com/rust-lang/cargo/pull/16428">#16428</a></li>
<li><code>-Zbuild-analysis</code>: new <code>cargo report timings</code> command for HTML replay. <a href="https://github.com/rust-lang/cargo/pull/16346">#16346</a> <a href="https://github.com/rust-lang/cargo/pull/16350">#16350</a> <a href="https://github.com/rust-lang/cargo/pull/16352">#16352</a> <a href="https://github.com/rust-lang/cargo/pull/16377">#16377</a> <a href="https://github.com/rust-lang/cargo/pull/16378">#16378</a> <a href="https://github.com/rust-lang/cargo/pull/16382">#16382</a> <a href="https://github.com/rust-lang/cargo/pull/16390">#16390</a> <a href="https://github.com/rust-lang/cargo/pull/16414">#16414</a> <a href="https://github.com/rust-lang/cargo/pull/16441">#16441</a> <a href="https://github.com/rust-lang/cargo/pull/16448">#16448</a> <a href="https://github.com/rust-lang/cargo/pull/16485">#16485</a> <a href="https://github.com/rust-lang/cargo/pull/16490">#16490</a></li>
<li><code>-Zbuild-dir</code>: implement fine-grained unit-level locking for build cache. <a href="https://github.com/rust-lang/cargo/pull/16155">#16155</a></li>
<li><code>-Zbuild-dir-new-layout</code>: move build script binaries to <code>deps</code> directory. <a href="https://github.com/rust-lang/cargo/pull/16515">#16515</a></li>
<li><code>-Zbuild-dir-new-layout</code>: do not create <code>examples</code> dir when using new layout. <a href="https://github.com/rust-lang/cargo/pull/16514">#16514</a></li>
<li><code>-Zbuild-dir-new-layout</code>: remove hashes from bins in new layout. <a href="https://github.com/rust-lang/cargo/pull/16351">#16351</a></li>
<li><code>-Zbuild-dir-new-layout</code>: use unit_id, not pkg hash, for bin/lib pkg_dirs. <a href="https://github.com/rust-lang/cargo/pull/16345">#16345</a></li>
<li><code>-Zbuild-dir-new-layout</code>: include all search paths with new build layout. <a href="https://github.com/rust-lang/cargo/pull/16348">#16348</a></li>
<li><code>-Zcargo-lints</code>: add Clippy-like lint groups. <a href="https://github.com/rust-lang/cargo/pull/16464">#16464</a></li>
<li><code>-Zcargo-lints</code>: new <code>implicit_minimum_version_req</code> lint. <a href="https://github.com/rust-lang/cargo/pull/16321">#16321</a></li>
<li><code>-Zno-embed-metadata</code>: invalidate the whole build cache when the flag changes. <a href="https://github.com/rust-lang/cargo/pull/16513">#16513</a></li>
<li><code>-Zsbom</code>: don’t set <code>CARGO_SBOM_PATH</code> when empty. <a href="https://github.com/rust-lang/cargo/pull/16419">#16419</a></li>
</ul>
<h3 id="문서-1"><a class="header" href="#문서-1">문서</a></h3>
<ul>
<li>Clarify that <code>OUT_DIR</code> is not cleaned between builds. <a href="https://github.com/rust-lang/cargo/pull/16437">#16437</a></li>
<li>Document the only possible values for <code>DEBUG</code> in build scripts. <a href="https://github.com/rust-lang/cargo/pull/16413">#16413</a></li>
<li>Add best practice for how to check in generated files. <a href="https://github.com/rust-lang/cargo/pull/16405">#16405</a></li>
<li>Document more services and permissions of the Cargo team. <a href="https://github.com/rust-lang/cargo/pull/16402">#16402</a></li>
<li>FAQ: Include an entry on disk space. <a href="https://github.com/rust-lang/cargo/pull/16349">#16349</a></li>
</ul>
<h3 id="내부-변경-1"><a class="header" href="#내부-변경-1">내부 변경</a></h3>
<ul>
<li>Cache Git submodules into the Git database for faster subsequent fetches. <a href="https://github.com/rust-lang/cargo/pull/16246">#16246</a></li>
<li>Fixed Git partial OIDs being incorrectly zero-padded. <a href="https://github.com/rust-lang/cargo/pull/16511">#16511</a></li>
<li>Migrate some cases to expect/reason. <a href="https://github.com/rust-lang/cargo/pull/16461">#16461</a></li>
<li>Support in-memory only <code>Manifest</code> for libcargo <a href="https://github.com/rust-lang/cargo/pull/16409">#16409</a></li>
<li>cargo-test-support: Use test name for dir when running tests. <a href="https://github.com/rust-lang/cargo/pull/16121">#16121</a></li>
<li>test: Use a larger default term width. <a href="https://github.com/rust-lang/cargo/pull/16403">#16403</a> <a href="https://github.com/rust-lang/cargo/pull/16391">#16391</a></li>
<li>test: Adjust output for out-of-tree build-dir. <a href="https://github.com/rust-lang/cargo/pull/16343">#16343</a></li>
<li>test: update to <code>proc_macro::tracked::path</code>. <a href="https://github.com/rust-lang/cargo/pull/16380">#16380</a></li>
<li>test: Remove unused build script. <a href="https://github.com/rust-lang/cargo/pull/16344">#16344</a></li>
<li>Update dependencies. <a href="https://github.com/rust-lang/cargo/pull/16379">#16379</a> <a href="https://github.com/rust-lang/cargo/pull/16381">#16381</a> <a href="https://github.com/rust-lang/cargo/pull/16460">#16460</a> <a href="https://github.com/rust-lang/cargo/pull/16457">#16457</a> <a href="https://github.com/rust-lang/cargo/pull/16454">#16454</a> <a href="https://github.com/rust-lang/cargo/pull/16507">#16507</a></li>
</ul>
<h2 id="cargo-193-2026-01-22"><a class="header" href="#cargo-193-2026-01-22">Cargo 1.93 (2026-01-22)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/344c4567...rust-1.93.0">344c4567…rust-1.93.0</a></p>
<h3 id="추가됨-2"><a class="header" href="#추가됨-2">추가됨</a></h3>
<ul>
<li>Enable <code>CARGO_CFG_DEBUG_ASSERTIONS</code> environment variable in build scripts based on profile settings. <a href="https://github.com/rust-lang/cargo/pull/16160">#16160</a></li>
<li>Add support for completing <code>--config</code> values in Bash <a href="https://github.com/rust-lang/cargo/pull/16245">#16245</a></li>
<li>cargo-clean: Add <code>--workspace</code> flag to clean artifacts of the workspace members. <a href="https://github.com/rust-lang/cargo/pull/16263">#16263</a></li>
<li>cargo-tree: Support long forms for <code>--format</code> variables <a href="https://github.com/rust-lang/cargo/pull/16204">#16204</a></li>
</ul>
<h3 id="변경됨-2"><a class="header" href="#변경됨-2">변경됨</a></h3>
<ul>
<li>❗️ <code>cargo publish</code> no longer keeps <code>.crate</code> tarballs as final build artifacts even when the <code>build.build-dir</code> config is unset. <a href="https://github.com/rust-lang/cargo/pull/15915">#15915</a></li>
<li>Migrate more diagnostic formatting to rustc-like style (annotate-snippets style) <a href="https://github.com/rust-lang/cargo/pull/16143">#16143</a></li>
<li>Point out when a key belongs to Cargo configuration when seeing an unused field in Cargo manifest. <a href="https://github.com/rust-lang/cargo/pull/16256">#16256</a></li>
<li>When failing to update or create lockfile, provide clearer context and suggested user actions to help resolve it. <a href="https://github.com/rust-lang/cargo/pull/16233">#16233</a> <a href="https://github.com/rust-lang/cargo/pull/16227">#16227</a></li>
<li>Emit helpful error messages when GitHub pull request URLs are used as dependencies in the manifest. <a href="https://github.com/rust-lang/cargo/pull/16207">#16207</a></li>
<li>Avoid unnecessary artifact directory locking for <code>check</code> builds. <a href="https://github.com/rust-lang/cargo/pull/16230">#16230</a> <a href="https://github.com/rust-lang/cargo/pull/16299">#16299</a> <a href="https://github.com/rust-lang/cargo/pull/16307">#16307</a> <a href="https://github.com/rust-lang/cargo/pull/16385">#16385</a> <a href="https://github.com/rust-lang/cargo/pull/16386">#16386</a></li>
<li>Refer to commands, not subcommands in CLI help text. <a href="https://github.com/rust-lang/cargo/pull/16226">#16226</a></li>
<li>cargo-install: Cargo treated a relative path in <code>install.root</code> without a trailing slash as relative path to the current working directory. This case will now get a deprecation warning. It was an oversight and will be changed to config-relative path like other config fields in the future. <a href="https://github.com/rust-lang/cargo/pull/16125">#16125</a></li>
<li>cargo-package: Suppress missing metadata warnings for non-crates.io publishable packages <a href="https://github.com/rust-lang/cargo/pull/16241">#16241</a></li>
<li>cargo-publish: emit a warning when both <code>package.publish</code> and <code>--index</code> are specified <a href="https://github.com/rust-lang/cargo/pull/16268">#16268</a></li>
<li>cargo-run: in help text, teach how to escape arguments to be forwarded literally to an underlying program <a href="https://github.com/rust-lang/cargo/pull/16225">#16225</a></li>
</ul>
<h3 id="수정됨-2"><a class="header" href="#수정됨-2">수정됨</a></h3>
<ul>
<li>Zsh shell completion variables no longer leak into user’s environment <a href="https://github.com/rust-lang/cargo/pull/16144">#16144</a></li>
<li>Fixed Cargo generating dep-info file with invalid trailing backslashes on Windows. <a href="https://github.com/rust-lang/cargo/pull/16223">#16223</a></li>
<li>Fixed non-mergeable list from <code>--config</code> CLI being overridden by environment variables. <a href="https://github.com/rust-lang/cargo/pull/16220">#16220</a></li>
<li>Fixed nested non-mergeable list from <code>--config</code> CLI got merged with other configurations. <a href="https://github.com/rust-lang/cargo/pull/16219">#16219</a></li>
<li>Cargo now updates mtime for files generated by <code>cargo package</code> after unpacking <code>.crate</code> source tarballs. This ensures files do not have overly old mtime that some zip tools can’t handle. <a href="https://github.com/rust-lang/cargo/pull/16250">#16250</a></li>
<li>Shift mtime for <code>cargo check</code> artifacts (.rmeta files). This addresses a regression in rustc incremental compilation skipping unnecessary rmeta generation but didn’t update mtime for existing rmeta files. <a href="https://github.com/rust-lang/cargo/pull/16262">#16262</a></li>
<li>cargo-doc: clean generated doc directories for only requested targets. Previously when rustc version mismatches, Cargo removes all generated doc directories including target platforms that are not part of the build. <a href="https://github.com/rust-lang/cargo/pull/16331">#16331</a></li>
<li>cargo-install: fix out-of-bound error in crate name validation <a href="https://github.com/rust-lang/cargo/pull/16314">#16314</a></li>
<li>cargo-package: generated files in tarball should have deterministic timestamp. <a href="https://github.com/rust-lang/cargo/pull/16242">#16242</a></li>
<li>cargo-package: exclude <code>target/package</code> directory from backups via <code>CACHEDIR.TAG</code>. <a href="https://github.com/rust-lang/cargo/pull/16272">#16272</a></li>
<li>cargo-vendor: fix panic on Windows caused by fallback of <code>fs::rename</code>. <a href="https://github.com/rust-lang/cargo/pull/16214">#16214</a></li>
</ul>
<h3 id="나이틀리nightly-전용-2"><a class="header" href="#나이틀리nightly-전용-2">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>🔥 <code>-Zrustc-unicode</code> enables <code>rustc</code>’s unicode error format in Cargo’s error messages. <a href="https://github.com/rust-lang/cargo/pull/16243">#16243</a></li>
<li>🔥 <code>-Zrustdoc-mergeable-info</code> leverages rustdoc’s mergeable crate info, so <code>cargo doc</code> can merge cross-crate information (like the search index, source files index) from separate output directories, and run <code>rustdoc</code> in parallel. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#rustdoc-mergeable-info">docs</a> <a href="https://github.com/rust-lang/cargo/pull/16309">#16309</a></li>
<li>🔥 <code>cargo generate-lockfile</code> now has an unstable <code>--publish-time</code> flag that package resolution will not consider any package newer than the specified time. <em>This is not useful until registry index starts including the <code>pubtime</code> field.</em> <a href="https://github.com/rust-lang/cargo/pull/16265">#16265</a></li>
<li><code>build-plan</code>: Remove the unstable feature <code>build-plan</code> entirely. The Cargo team are looking forward to other alternatives like <a href="https://github.com/crate-ci/cargo-plumbing">plumbing commands</a>, <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#unit-graph">`--unit-graph</a>, and <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-analysis">structured logging</a> helping to fill the gap. <a href="https://github.com/rust-lang/cargo/pull/16212">#16212</a></li>
<li><code>native-completions</code>: Put host-tuple before actual tuples <a href="https://github.com/rust-lang/cargo/pull/16327">#16327</a></li>
<li><code>native-completions</code>: include <code>all</code> in <code>cargo tree --target</code> candidates <a href="https://github.com/rust-lang/cargo/pull/16322">#16322</a></li>
<li><code>native-completions</code>: don’t wrap completion item help in parenthesis <a href="https://github.com/rust-lang/cargo/pull/16215">#16215</a></li>
<li><code>native-completions</code>: Add more native completions  for <code>cargo tree</code> <a href="https://github.com/rust-lang/cargo/pull/16296">#16296</a></li>
<li><code>native-completions</code>: <code>--package</code> on various commands <a href="https://github.com/rust-lang/cargo/pull/16210">#16210</a></li>
<li><code>update-breaking</code>: silent failure on non-matching package specs with –breaking <a href="https://github.com/rust-lang/cargo/pull/16276">#16276</a></li>
<li><code>-Zbindeps</code>: do not propagate artifact dependency to proc macro or build deps <a href="https://github.com/rust-lang/cargo/pull/15788">#15788</a></li>
<li><code>-Zbuild-analysis</code>: Emit timing-info logs with JSONL-based logging infrastructure. Logs are stored in <code>~/.cargo/log/</code> with unique files per cargo invocation. <a href="https://github.com/rust-lang/cargo/pull/16150">#16150</a> <a href="https://github.com/rust-lang/cargo/pull/16179">#16179</a> <a href="https://github.com/rust-lang/cargo/pull/16303">#16303</a> <a href="https://github.com/rust-lang/cargo/pull/16337">#16337</a></li>
<li><code>-Zbuild-analysis</code>: emit rebuild reason log entry. <a href="https://github.com/rust-lang/cargo/pull/16203">#16203</a></li>
<li><code>-Zbuild-build</code>: Add test for LTO <a href="https://github.com/rust-lang/cargo/pull/16277">#16277</a></li>
<li><code>-Zbuild-dir-new-layout</code>: Better divide old / new layout <a href="https://github.com/rust-lang/cargo/pull/16304">#16304</a></li>
<li><code>-Zbuild-dir-new-layout</code>: Clean hosts builds with new layout <a href="https://github.com/rust-lang/cargo/pull/16300">#16300</a></li>
<li><code>-Zbuild-dir-new-layout</code>: Put examples in their unit dir in new layout <a href="https://github.com/rust-lang/cargo/pull/16335">#16335</a></li>
<li><code>-Zcargo-lints</code>: show lint error number <a href="https://github.com/rust-lang/cargo/pull/16320">#16320</a> <a href="https://github.com/rust-lang/cargo/pull/16324">#16324</a></li>
<li><code>-Zconfig-include</code>: Allow using <code>optional = true</code> to silently skip missing config files. <a href="https://github.com/rust-lang/cargo/pull/16103">#16103</a> <a href="https://github.com/rust-lang/cargo/pull/16174">#16174</a> <a href="https://github.com/rust-lang/cargo/pull/16180">#16180</a></li>
<li><code>-Zconfig-include</code>: disallow glob and template syntax in <code>include.path</code> <a href="https://github.com/rust-lang/cargo/pull/16285">#16285</a></li>
<li><code>-Zconfig-include</code>: remove support of single string shorthand <a href="https://github.com/rust-lang/cargo/pull/16298">#16298</a></li>
<li><code>-Zgit</code>: Support shallow fetch for Git CLI backend (<code>net.git-fetch-with-cli</code>) <a href="https://github.com/rust-lang/cargo/pull/16156">#16156</a></li>
<li><code>-Zgit</code>: Add more git fetch-index backend interop tests <a href="https://github.com/rust-lang/cargo/pull/16162">#16162</a></li>
<li><code>-Zscript</code>: Update script tests from rustc’s test suite <a href="https://github.com/rust-lang/cargo/pull/16169">#16169</a> <a href="https://github.com/rust-lang/cargo/pull/16334">#16334</a></li>
<li><code>-Zscript</code>: Fallback to non-canonical path for workspace-path-hash. This ensure script paths that cannot be canonicalized, like <code>memfd</code>, still work. <a href="https://github.com/rust-lang/cargo/pull/16248">#16248</a></li>
<li><code>-Zwarnings</code>: build.warnings=deny shouldn’t block hard warnings <a href="https://github.com/rust-lang/cargo/pull/16213">#16213</a></li>
</ul>
<h3 id="문서-2"><a class="header" href="#문서-2">문서</a></h3>
<ul>
<li>Move <code>compile-time-deps</code> out of Stabilized section <a href="https://github.com/rust-lang/cargo/pull/16211">#16211</a></li>
<li>Rename <code>DEP_NAME_KEY</code> to <code>DEP_LINKS_KEY</code> to make the association of the <code>package.links</code> field clearer <a href="https://github.com/rust-lang/cargo/pull/16205">#16205</a></li>
<li>Clarify <code>cargo yank</code> only affects Cargo’s dependency resolution, not crate availability <a href="https://github.com/rust-lang/cargo/pull/16274">#16274</a></li>
<li>In build performance guide, when suggesting alt dev profile, link to related issue. <a href="https://github.com/rust-lang/cargo/pull/16275">#16275</a></li>
<li>cargo-metadata: document the <code>"host-tuple"</code> literal is also supported for <code>-filter-platform</code>. <a href="https://github.com/rust-lang/cargo/pull/16312">#16312</a></li>
<li>contrib: Link out to rustc diagnostic style guide <a href="https://github.com/rust-lang/cargo/pull/16216">#16216</a></li>
<li>resolver: fix compile errors in pseudocode <a href="https://github.com/rust-lang/cargo/pull/16333">#16333</a></li>
</ul>
<h3 id="내부-변경-2"><a class="header" href="#내부-변경-2">내부 변경</a></h3>
<ul>
<li>Make disabling locking on NFS mounts explicit <a href="https://github.com/rust-lang/cargo/pull/16177">#16177</a></li>
<li>Extract ConfigValue and config schemas to their own separate modules <a href="https://github.com/rust-lang/cargo/pull/16222">#16222</a> <a href="https://github.com/rust-lang/cargo/pull/16195">#16195</a></li>
<li>Embed deserialize validation logic in <code>ProgressConfig</code> <a href="https://github.com/rust-lang/cargo/pull/16194">#16194</a></li>
<li>Separate Cargo timings data collection and presentation <a href="https://github.com/rust-lang/cargo/pull/16282">#16282</a></li>
<li>cargo-util-schemas: add into_value utility function for inheritableField <a href="https://github.com/rust-lang/cargo/pull/16234">#16234</a></li>
<li>ci: Add a typos/spellcheck CI job <a href="https://github.com/rust-lang/cargo/pull/16122">#16122</a></li>
<li>ci: Run clippy CI on more targets <a href="https://github.com/rust-lang/cargo/pull/16340">#16340</a></li>
<li>mdman: Fix mdman to not incorrectly strip <code>&lt;p&gt;</code> tags <a href="https://github.com/rust-lang/cargo/pull/16158">#16158</a> <a href="https://github.com/rust-lang/cargo/pull/16172">#16172</a></li>
<li>test: re-enable Windows reserved name test since not flaky anymore <a href="https://github.com/rust-lang/cargo/pull/16287">#16287</a></li>
<li>test: Remove legacy tmpdir support <a href="https://github.com/rust-lang/cargo/pull/16342">#16342</a></li>
<li>Update to mdbook 0.5. <a href="https://github.com/rust-lang/cargo/pull/16292">#16292</a></li>
<li>Update dependencies. <a href="https://github.com/rust-lang/cargo/pull/16137">#16137</a> <a href="https://github.com/rust-lang/cargo/pull/16140">#16140</a> <a href="https://github.com/rust-lang/cargo/pull/16178">#16178</a> <a href="https://github.com/rust-lang/cargo/pull/16186">#16186</a> <a href="https://github.com/rust-lang/cargo/pull/16190">#16190</a> <a href="https://github.com/rust-lang/cargo/pull/16200">#16200</a> <a href="https://github.com/rust-lang/cargo/pull/16224">#16224</a> <a href="https://github.com/rust-lang/cargo/pull/16316">#16316</a> <a href="https://github.com/rust-lang/cargo/pull/16318">#16318</a></li>
</ul>
<h2 id="cargo-192-2025-12-11"><a class="header" href="#cargo-192-2025-12-11">Cargo 1.92 (2025-12-11)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/24bb93c3...rust-1.92.0">24bb93c3…rust-1.92.0</a></p>
<h3 id="추가됨-3"><a class="header" href="#추가됨-3">추가됨</a></h3>
<ul>
<li>Add Ghostty as a supported terminal for term integration (OSC 9;4) <a href="https://github.com/rust-lang/cargo/pull/15977">#15977</a></li>
<li>Add retry for <code>git fetch</code> failures in <code>net.git-fetch-with-cli</code> path <a href="https://github.com/rust-lang/cargo/pull/16016">#16016</a></li>
</ul>
<h3 id="변경됨-3"><a class="header" href="#변경됨-3">변경됨</a></h3>
<ul>
<li>Migrate some diagnostic formatting to rustc-like style (annotate-snippets style) <a href="https://github.com/rust-lang/cargo/pull/15943">#15943</a> <a href="https://github.com/rust-lang/cargo/pull/15945">#15945</a> <a href="https://github.com/rust-lang/cargo/pull/16019">#16019</a> <a href="https://github.com/rust-lang/cargo/pull/16035">#16035</a> <a href="https://github.com/rust-lang/cargo/pull/16066">#16066</a> <a href="https://github.com/rust-lang/cargo/pull/16113">#16113</a> <a href="https://github.com/rust-lang/cargo/pull/16126">#16126</a></li>
<li>Suggested <code>cargo fix</code> command from compilation diagnostics is now more accurate. <a href="https://github.com/rust-lang/cargo/pull/16127">#16127</a></li>
<li>Prefer unicode ellipses when truncating progress <a href="https://github.com/rust-lang/cargo/pull/15955">#15955</a></li>
<li>Eliminate the last three “did you mean” warning phrasings <a href="https://github.com/rust-lang/cargo/pull/15356">#15356</a></li>
<li>Clarify warning for using <code>features</code> or <code>default-features</code> in <code>patch</code> <a href="https://github.com/rust-lang/cargo/pull/15953">#15953</a></li>
<li>Config parsing errors now show more precise key path with array index <a href="https://github.com/rust-lang/cargo/pull/16004">#16004</a></li>
<li>Improve error message for <code>rust-version</code> incompatibility diagnostics <a href="https://github.com/rust-lang/cargo/pull/16021">#16021</a></li>
<li>cargo-add: Report a missing source error for workspace dependencies <a href="https://github.com/rust-lang/cargo/pull/16063">#16063</a></li>
<li>cargo-info: Suggest a more universal <code>cargo tree</code> command <a href="https://github.com/rust-lang/cargo/pull/15954">#15954</a></li>
<li>cargo-publish: Switch the ‘ctrl-c on wait’ line to a help message <a href="https://github.com/rust-lang/cargo/pull/15942">#15942</a></li>
<li>cargo-publish: soft-deprecate the <code>--token</code> option <a href="https://github.com/rust-lang/cargo/pull/16046">#16046</a></li>
</ul>
<h3 id="수정됨-3"><a class="header" href="#수정됨-3">수정됨</a></h3>
<h3 id="나이틀리nightly-전용-3"><a class="header" href="#나이틀리nightly-전용-3">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>🔥 <code>immediate-abort</code>: Add <code>panic=immediate-abort</code> support <a href="https://github.com/rust-lang/cargo/pull/16041">#16041</a> <a href="https://github.com/rust-lang/cargo/pull/16054">#16054</a></li>
<li><code>-Zbuild-dir-new-layout</code>: Reorganize build-dir layout <a href="https://github.com/rust-lang/cargo/pull/15947">#15947</a></li>
<li><code>-Zbuild-std</code>: test move away from panic_immediate_abort <a href="https://github.com/rust-lang/cargo/pull/16006">#16006</a></li>
<li><code>-Zcargo-lints</code>: Add lint for global use of <code>hint-mostly-unused</code> <a href="https://github.com/rust-lang/cargo/pull/15995">#15995</a></li>
<li><code>-Zpublic-dependency</code>: <code>cargo add</code> now considers public dependencies when choosing a version <a href="https://github.com/rust-lang/cargo/pull/15966">#15966</a></li>
<li><code>-Zpublic-dependency</code>: Switch from <code>--depth public</code> to <code>--edges public</code> for <code>cargo tree</code> to display public dependencies <a href="https://github.com/rust-lang/cargo/pull/16081">#16081</a></li>
<li><code>-Zpublic-dependency</code>: Improve public-in-private manifest errors <a href="https://github.com/rust-lang/cargo/pull/16002">#16002</a> <a href="https://github.com/rust-lang/cargo/pull/16075">#16075</a></li>
<li><code>-Zscript</code>: Improve frontmatter parsing error quality <a href="https://github.com/rust-lang/cargo/pull/15972">#15972</a> <a href="https://github.com/rust-lang/cargo/pull/15939">#15939</a> <a href="https://github.com/rust-lang/cargo/pull/15952">#15952</a></li>
<li><code>-Zscript</code>: Only allow horizontal whitespace after fences <a href="https://github.com/rust-lang/cargo/pull/15975">#15975</a></li>
<li><code>-Zscript</code>: Override arg0 for cargo scripts <a href="https://github.com/rust-lang/cargo/pull/16027">#16027</a></li>
<li><code>-Zscript</code>: Tweak cargo script build-dir / target-dir <a href="https://github.com/rust-lang/cargo/pull/16086">#16086</a></li>
<li><code>-Zscript</code>: Remove name sanitiztion outside what is strictly required <a href="https://github.com/rust-lang/cargo/pull/16120">#16120</a></li>
<li><code>-Zscript</code>: Store cargo script lockfiles in build-dir <a href="https://github.com/rust-lang/cargo/pull/16087">#16087</a></li>
<li><code>-Zscript</code>: Define cargo script’s target-dir using build-dir templating <a href="https://github.com/rust-lang/cargo/pull/16073">#16073</a></li>
<li><code>-Zscript</code>: Prevent non-script fields in Cargo scripts <a href="https://github.com/rust-lang/cargo/pull/16026">#16026</a></li>
<li><code>-Zscript</code>: Default bin.name to package.name <a href="https://github.com/rust-lang/cargo/pull/16064">#16064</a></li>
<li><code>multiple-build-scripts</code>: Access each build script’s <code>OUT_DIR</code> via <code>&lt;script-name&gt;_OUT_DIR</code> <a href="https://github.com/rust-lang/cargo/pull/15891">#15891</a></li>
<li><code>native-completions</code>: Added completion for <code>--features</code> flag <a href="https://github.com/rust-lang/cargo/pull/15309">#15309</a></li>
<li><code>native-completions</code>: Show local crates/features over other members <a href="https://github.com/rust-lang/cargo/pull/15956">#15956</a></li>
<li><code>native-completions</code>: Allow completions for third-party subcommand names <a href="https://github.com/rust-lang/cargo/pull/15961">#15961</a></li>
</ul>
<h3 id="문서-3"><a class="header" href="#문서-3">문서</a></h3>
<ul>
<li>🎉 Add a new “Optimizing Build Performance” chapter <a href="https://github.com/rust-lang/cargo/pull/15924">#15924</a> <a href="https://github.com/rust-lang/cargo/pull/15970">#15970</a> <a href="https://github.com/rust-lang/cargo/pull/15991">#15991</a> <a href="https://github.com/rust-lang/cargo/pull/16078">#16078</a> <a href="https://github.com/rust-lang/cargo/pull/16085">#16085</a> <a href="https://github.com/rust-lang/cargo/pull/16107">#16107</a> <a href="https://github.com/rust-lang/cargo/pull/16108">#16108</a></li>
<li>Clarify git sources vs git registries in source replacement documentation <a href="https://github.com/rust-lang/cargo/pull/15974">#15974</a></li>
<li>Clarify what we mean by omitting features in registry index documentation <a href="https://github.com/rust-lang/cargo/pull/15957">#15957</a></li>
<li>Clarify the role of the lockfile in dependency resolution <a href="https://github.com/rust-lang/cargo/pull/15958">#15958</a></li>
<li>Clarify multiple version requirement behavior <a href="https://github.com/rust-lang/cargo/pull/15979">#15979</a></li>
<li>Clarify that <code>target.&lt;cfg&gt;.linker</code> is supported <a href="https://github.com/rust-lang/cargo/pull/16112">#16112</a></li>
<li>Explain Cargo config deserialization internals <a href="https://github.com/rust-lang/cargo/pull/16105">#16105</a> <a href="https://github.com/rust-lang/cargo/pull/16094">#16094</a></li>
<li>contrib: Move docs building process to contributor guide <a href="https://github.com/rust-lang/cargo/pull/15854">#15854</a></li>
<li>SemVer: Recommend <code>package.rust-version</code> in the Rust version section <a href="https://github.com/rust-lang/cargo/pull/15806">#15806</a></li>
</ul>
<h3 id="내부-변경-3"><a class="header" href="#내부-변경-3">내부 변경</a></h3>
<ul>
<li>Make GlobalContext Sync <a href="https://github.com/rust-lang/cargo/pull/15967">#15967</a></li>
<li>Centralize Cargo console output styling <a href="https://github.com/rust-lang/cargo/pull/16124">#16124</a> <a href="https://github.com/rust-lang/cargo/pull/16135">#16135</a></li>
<li>Refactor <code>Layout</code> into <code>BuildDirLayout</code> and <code>ArtifactDirLayout</code> <a href="https://github.com/rust-lang/cargo/pull/16092">#16092</a></li>
<li>cargo-test-support: Add track_caller to know the actual failure <a href="https://github.com/rust-lang/cargo/pull/16069">#16069</a></li>
<li>cargo-test-support: Added better filesystem layout testing harness <a href="https://github.com/rust-lang/cargo/pull/15874">#15874</a></li>
<li>cargo-util-schemas: Move lockfile schemas in <a href="https://github.com/rust-lang/cargo/pull/15980">#15980</a> <a href="https://github.com/rust-lang/cargo/pull/15990">#15990</a> <a href="https://github.com/rust-lang/cargo/pull/16039">#16039</a></li>
<li>ci: Skip check-version-bump ci job in forks <a href="https://github.com/rust-lang/cargo/pull/15959">#15959</a></li>
<li>config: various internal cleanup and refactor for <code>ConfigValue</code> <a href="https://github.com/rust-lang/cargo/pull/16067">#16067</a> <a href="https://github.com/rust-lang/cargo/pull/16084">#16084</a> <a href="https://github.com/rust-lang/cargo/pull/16091">#16091</a> <a href="https://github.com/rust-lang/cargo/pull/16100">#16100</a> <a href="https://github.com/rust-lang/cargo/pull/16109">#16109</a></li>
<li>perf: JSON message with less allocations <a href="https://github.com/rust-lang/cargo/pull/16130">#16130</a></li>
<li>test: null-terminated path for reserved windows name detection <a href="https://github.com/rust-lang/cargo/pull/16052">#16052</a></li>
<li>test: Don’t look for a specific ANSI color <a href="https://github.com/rust-lang/cargo/pull/16118">#16118</a></li>
<li>test: Fix test that assumes <code>CARGO_CFG_TARGET_FAMILY</code> is a single value <a href="https://github.com/rust-lang/cargo/pull/16079">#16079</a></li>
<li>Update dependencies. <a href="https://github.com/rust-lang/cargo/pull/15988">#15988</a> <a href="https://github.com/rust-lang/cargo/pull/15984">#15984</a> <a href="https://github.com/rust-lang/cargo/pull/15989">#15989</a> <a href="https://github.com/rust-lang/cargo/pull/15992">#15992</a> <a href="https://github.com/rust-lang/cargo/pull/15993">#15993</a> <a href="https://github.com/rust-lang/cargo/pull/16009">#16009</a> <a href="https://github.com/rust-lang/cargo/pull/16031">#16031</a> <a href="https://github.com/rust-lang/cargo/pull/16034">#16034</a></li>
</ul>
<h2 id="cargo-191-2025-10-30"><a class="header" href="#cargo-191-2025-10-30">Cargo 1.91 (2025-10-30)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/840b83a1...rust-1.91.0">840b83a1…rust-1.91.0</a></p>
<h3 id="추가됨-4"><a class="header" href="#추가됨-4">추가됨</a></h3>
<ul>
<li>🎉 Stabilize <code>build.build-dir</code>. This config sets the directory where intermediate build artifacts are stored. These artifacts are produced by Cargo and rustc during the build process. End users usually won’t need to interact with them, and the layout inside <code>build-dir</code> is an implementation detail that may change without notice. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/config.html#buildbuild-dir">config doc</a>) (<a href="https://doc.rust-lang.org/nightly/cargo/reference/build-cache.html">build cache doc</a>) <a href="https://github.com/rust-lang/cargo/pull/15833">#15833</a> <a href="https://github.com/rust-lang/cargo/pull/15840">#15840</a></li>
<li>The <code>--target</code> flag and the <code>build.target</code> configuration can now take literal <code>"host-tuple"</code> string, which will internally be substituted by the host machine’s target triple. <a href="https://github.com/rust-lang/cargo/pull/15838">#15838</a> <a href="https://github.com/rust-lang/cargo/pull/16003">#16003</a> <a href="https://github.com/rust-lang/cargo/pull/16032">#16032</a></li>
</ul>
<h3 id="변경됨-4"><a class="header" href="#변경됨-4">변경됨</a></h3>
<ul>
<li>❗️ <code>cargo publish</code> no longer keeps <code>.crate</code> tarballs as final build artifacts when <code>build.build-dir</code> is set. These tarballs were previously included due to an oversight and are now treated as intermediate artifacts. To get <code>.crate</code> tarballs as final artifacts, use <code>cargo package</code>. In a future version, this change will apply regardless of <code>build.build-dir</code>. <a href="https://github.com/rust-lang/cargo/pull/15910">#15910</a></li>
<li>Adjust Cargo messages to match rustc diagnostic style <a href="https://github.com/rust-lang/cargo/pull/15928">#15928</a></li>
<li>More helpful error for invalid <code>cargo-features = []</code> <a href="https://github.com/rust-lang/cargo/pull/15781">#15781</a></li>
<li>Don’t stop at first error when emitting lints and warnings <a href="https://github.com/rust-lang/cargo/pull/15889">#15889</a></li>
<li>Show the bad manifest path in the error message <a href="https://github.com/rust-lang/cargo/pull/15896">#15896</a></li>
<li>Suggest workspace hints for invalid boolean dependencies <a href="https://github.com/rust-lang/cargo/pull/15507">#15507</a></li>
<li>cargo-package: Always reuse the workspace’s target-dir during the package verification. Previously Cargo created a new standalone target directory within the unpacked source. <a href="https://github.com/rust-lang/cargo/pull/15783">#15783</a></li>
<li>cargo-publish: Add more context to publish-failed error message <a href="https://github.com/rust-lang/cargo/pull/15879">#15879</a></li>
</ul>
<h3 id="수정됨-4"><a class="header" href="#수정됨-4">수정됨</a></h3>
<h3 id="나이틀리nightly-전용-4"><a class="header" href="#나이틀리nightly-전용-4">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>🔥 <code>-Zsection-timings</code> extend the output of <code>cargo build --timings</code>. It tells rustc to produce timings of individual compilation sections, which will be then displayed in the timings HTML/JSON output. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#section-timings">docs</a>) <a href="https://github.com/rust-lang/cargo/pull/15780">#15780</a> <a href="https://github.com/rust-lang/cargo/pull/15923">#15923</a></li>
<li>🔥 <code>-Zbuild-dir-new-layout</code> enables the new build-dir filesystem layout, which unblocks work towards caching and locking improvements. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-dir-new-layout">docs</a>) (<a href="https://rust-lang.github.io/rust-project-goals/2025h2/cargo-build-dir-layout.html">project goal</a>) <a href="https://github.com/rust-lang/cargo/pull/15848">#15848</a></li>
<li>🔥 <code>-Zbuild-analysis</code> records and persists detailed build metrics (timings, rebuild reasons, etc.) across runs, with new commands to query past builds. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-analysis">docs</a>) (<a href="https://rust-lang.github.io/rust-project-goals/2025h2/cargo-build-analysis.html">project goal</a>) <a href="https://github.com/rust-lang/cargo/pull/15845">#15845</a></li>
<li><code>multiple-build-scripts</code>:  Accessing each build script’s <code>OUT_DIR</code> and in the correct order <a href="https://github.com/rust-lang/cargo/pull/15776">#15776</a></li>
<li><code>-Zcargo-lints</code>: Linting system infra improvement <a href="https://github.com/rust-lang/cargo/pull/15865">#15865</a></li>
<li><code>-Zscript</code>: Cover some frontmatter corner cases <a href="https://github.com/rust-lang/cargo/pull/15886">#15886</a></li>
<li><code>-Zscript</code>: Match test updates in rustc <a href="https://github.com/rust-lang/cargo/pull/15878">#15878</a></li>
<li><code>-Zscript</code>: Switch frontmatter tests to end-to-end <a href="https://github.com/rust-lang/cargo/pull/15899">#15899</a></li>
<li><code>-Zscript</code>: Report script manifest errors for the right line number <a href="https://github.com/rust-lang/cargo/pull/15927">#15927</a></li>
<li><code>-Zscript</code>: Pull out as a dedicated mod <a href="https://github.com/rust-lang/cargo/pull/15914">#15914</a></li>
</ul>
<h3 id="문서-4"><a class="header" href="#문서-4">문서</a></h3>
<ul>
<li>Clarify that <code>cargo doc --no-deps</code> is cumulative and won’t delete prev <a href="https://github.com/rust-lang/cargo/pull/15800">#15800</a></li>
<li>Switch from <code>--nocapture</code> to <code>--no-capture</code> in docs and help text. <a href="https://github.com/rust-lang/cargo/pull/15930">#15930</a></li>
<li>Mention how Cargo fetch git submodules <a href="https://github.com/rust-lang/cargo/pull/15853">#15853</a> <a href="https://github.com/rust-lang/cargo/pull/15860">#15860</a></li>
<li>Link out to the Plumbing commands effort <a href="https://github.com/rust-lang/cargo/pull/15821">#15821</a></li>
<li>Switch to using native mdbook fragment redirects <a href="https://github.com/rust-lang/cargo/pull/15861">#15861</a></li>
<li>Reorder <code>lto</code> options in profiles <a href="https://github.com/rust-lang/cargo/pull/15841">#15841</a> <a href="https://github.com/rust-lang/cargo/pull/15855">#15855</a></li>
</ul>
<h3 id="내부-변경-4"><a class="header" href="#내부-변경-4">내부 변경</a></h3>
<ul>
<li>Replace ad-hoc flock implementation with std flock <a href="https://github.com/rust-lang/cargo/pull/15935">#15935</a> <a href="https://github.com/rust-lang/cargo/pull/15941">#15941</a></li>
<li>Prepare for annotate-snippets <code>Report</code>s being generated in more places <a href="https://github.com/rust-lang/cargo/pull/15920">#15920</a> <a href="https://github.com/rust-lang/cargo/pull/15926">#15926</a></li>
<li>test: avoid hardcoded target spec json <a href="https://github.com/rust-lang/cargo/pull/15880">#15880</a></li>
<li>test: Ensure consistent behavior regardless of rustup use <a href="https://github.com/rust-lang/cargo/pull/15949">#15949</a></li>
<li>test: Switch more expected results to snapshots for credential process <a href="https://github.com/rust-lang/cargo/pull/15929">#15929</a></li>
<li>ci: Add Arm64 Windows CI jobs <a href="https://github.com/rust-lang/cargo/pull/15790">#15790</a></li>
<li>ci: remove x86_64-apple-darwin from CI and tests <a href="https://github.com/rust-lang/cargo/pull/15831">#15831</a></li>
<li>Update dependencies. <a href="https://github.com/rust-lang/cargo/pull/15795">#15795</a> <a href="https://github.com/rust-lang/cargo/pull/15804">#15804</a> <a href="https://github.com/rust-lang/cargo/pull/15815">#15815</a> <a href="https://github.com/rust-lang/cargo/pull/15816">#15816</a> <a href="https://github.com/rust-lang/cargo/pull/15819">#15819</a> <a href="https://github.com/rust-lang/cargo/pull/15825">#15825</a> <a href="https://github.com/rust-lang/cargo/pull/15832">#15832</a> <a href="https://github.com/rust-lang/cargo/pull/15851">#15851</a> <a href="https://github.com/rust-lang/cargo/pull/15898">#15898</a> <a href="https://github.com/rust-lang/cargo/pull/15904">#15904</a> <a href="https://github.com/rust-lang/cargo/pull/15909">#15909</a> <a href="https://github.com/rust-lang/cargo/pull/15918">#15918</a> <a href="https://github.com/rust-lang/cargo/pull/15950">#15950</a></li>
</ul>
<h2 id="cargo-190-2025-09-18"><a class="header" href="#cargo-190-2025-09-18">Cargo 1.90 (2025-09-18)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/c24e1064...rust-1.90.0">c24e1064…rust-1.90.0</a></p>
<h3 id="추가됨-5"><a class="header" href="#추가됨-5">추가됨</a></h3>
<ul>
<li>🎉 Stabilize multi-package publishing. This allows cargo to publish multiple crates in a workspace, even if they have inter-dependencies. For example, <code>cargo publish --workspace</code> or <code>cargo publish -p foo -p bar</code>. Note that <code>cargo publish</code> is still non-atomic at this time. If there is a server side error during the publish, the workspace will be left in a partially published state. <a href="https://github.com/rust-lang/cargo/pull/15636">#15636</a> <a href="https://github.com/rust-lang/cargo/pull/15711">#15711</a></li>
<li>Added <code>http.proxy-cainfo</code> config for proxy TLS certificates. <a href="https://doc.rust-lang.org/nightly/cargo/reference/config.html#httpproxy-cainfo">docs</a> <a href="https://github.com/rust-lang/cargo/pull/15374">#15374</a></li>
</ul>
<h3 id="변경됨-5"><a class="header" href="#변경됨-5">변경됨</a></h3>
<ul>
<li>cargo-package: Use <code>gix</code> to speed up Git status check by 10-20%. <a href="https://github.com/rust-lang/cargo/pull/15534">#15534</a></li>
<li>Make timings graphs scalable to user’s window. <a href="https://github.com/rust-lang/cargo/pull/15766">#15766</a></li>
<li>Report valid file name when we can’t find a build target for <code>name = "foo.rs"</code> <a href="https://github.com/rust-lang/cargo/pull/15707">#15707</a></li>
</ul>
<h3 id="수정됨-5"><a class="header" href="#수정됨-5">수정됨</a></h3>
<ul>
<li>cargo-credential-libsecret: give FFI correctly-sized object <a href="https://github.com/rust-lang/cargo/pull/15767">#15767</a></li>
<li>cargo-publish: includes manifest paths in errors when verifying <a href="https://github.com/rust-lang/cargo/pull/15705">#15705</a></li>
<li>cargo-tree: Fixed <code>no-proc-macro</code> being overridden by subsequent edges. <a href="https://github.com/rust-lang/cargo/pull/15764">#15764</a></li>
</ul>
<h3 id="나이틀리nightly-전용-5"><a class="header" href="#나이틀리nightly-전용-5">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>🔥 <code>multiple-build-scripts</code>: Allows you to have multiple build scripts in your package. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#multiple-build-scripts">docs</a> <a href="https://github.com/rust-lang/cargo/pull/15630">#15630</a> <a href="https://github.com/rust-lang/cargo/pull/15704">#15704</a></li>
<li>🔥 <code>-Zprofile-hint-mostly-unused</code>: Add <code>[hints]</code> table in <code>Cargo.toml</code>, and a <code>hints.mostly-unused</code> hint. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#profile-hint-mostly-unused-option">docs</a> <a href="https://github.com/rust-lang/cargo/pull/15673">#15673</a></li>
<li><code>-Zfeature-unification</code>: implemented per-package feature unification <a href="https://github.com/rust-lang/cargo/pull/15684">#15684</a></li>
<li><code>-Zsbom</code>: Clarify package ID specifications in SBOMs are fully qualified <a href="https://github.com/rust-lang/cargo/pull/15731">#15731</a></li>
</ul>
<h3 id="문서-5"><a class="header" href="#문서-5">문서</a></h3>
<h3 id="내부-변경-5"><a class="header" href="#내부-변경-5">내부 변경</a></h3>
<ul>
<li>build-rs: auto-publish on toolchain release <a href="https://github.com/rust-lang/cargo/pull/15708">#15708</a></li>
<li>cargo-util-schemas: Expose <code>IndexPackage</code>, the description of a package within a Registry Index <a href="https://github.com/rust-lang/cargo/pull/15770">#15770</a></li>
<li>ci: update cargo-semver-checks to v0.42.0 <a href="https://github.com/rust-lang/cargo/pull/15730">#15730</a></li>
<li>perf: Speed up TOML parsing by upgrading toml <a href="https://github.com/rust-lang/cargo/pull/15736">#15736</a> <a href="https://github.com/rust-lang/cargo/pull/15779">#15779</a></li>
<li>test: Rework <code>cargo-test-support</code> &amp; <code>testsuite</code> to use <code>CARGO_BIN_EXE_*</code> for Cargo <a href="https://github.com/rust-lang/cargo/pull/15692">#15692</a></li>
<li>test: Use a different lint to simulate diagnostic duplicates <a href="https://github.com/rust-lang/cargo/pull/15713">#15713</a> <a href="https://github.com/rust-lang/cargo/pull/15717">#15717</a></li>
<li>test: Switch config tests to use snapshots <a href="https://github.com/rust-lang/cargo/pull/15729">#15729</a></li>
<li>test: Remove unnecessary target-c-int-width from target specs <a href="https://github.com/rust-lang/cargo/pull/15759">#15759</a></li>
<li>test: Mark cachelock tests that rely on interprocess blocking behaviour as unsupported on AIX. <a href="https://github.com/rust-lang/cargo/pull/15734">#15734</a></li>
<li>Expose artifact dependency getters in cargo-as-a-library <a href="https://github.com/rust-lang/cargo/pull/15753">#15753</a></li>
<li>Allow using Cargo-as-a-library with gix’s reqwest backend <a href="https://github.com/rust-lang/cargo/pull/15653">#15653</a></li>
<li>Update to Rust 2024 <a href="https://github.com/rust-lang/cargo/pull/15732">#15732</a></li>
<li>Update dependencies. <a href="https://github.com/rust-lang/cargo/pull/15706">#15706</a> <a href="https://github.com/rust-lang/cargo/pull/15709">#15709</a> <a href="https://github.com/rust-lang/cargo/pull/15722">#15722</a></li>
</ul>
<h2 id="cargo-189-2025-08-07"><a class="header" href="#cargo-189-2025-08-07">Cargo 1.89 (2025-08-07)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/873a0649...rust-1.89.0">873a0649…rust-1.89.0</a></p>
<h3 id="추가됨-6"><a class="header" href="#추가됨-6">추가됨</a></h3>
<ul>
<li>Add <code>*</code> and <code>?</code> pattern support for SSH known hosts matching. <a href="https://github.com/rust-lang/cargo/pull/15508">#15508</a></li>
<li>Stabilize doctest-xcompile. Doctests will now automatically be tested when cross-compiling to a target that is different from the host, just like other tests. <a href="https://github.com/rust-lang/cargo/pull/15462">#15462</a></li>
</ul>
<h3 id="변경됨-6"><a class="header" href="#변경됨-6">변경됨</a></h3>
<ul>
<li>❗️ <code>cargo fix</code> and <code>cargo clippy --fix</code> now run only on the default Cargo targets by default, matching the behavior of <code>cargo check</code>. To run on all Cargo targets, use the <code>--all-targets</code> flag. This change aligns the behavior with other commands. Edition flags like <code>--edition</code> and <code>--edition-idioms</code> remain implying <code>--all-targets</code> by default. <a href="https://github.com/rust-lang/cargo/pull/15192">#15192</a></li>
<li>Respect <code>Retry-After</code> header for HTTP 429 responses when talking to registries. <a href="https://github.com/rust-lang/cargo/pull/15463">#15463</a></li>
<li>Improved error message for the <code>CRATE[@&lt;VER&gt;]</code> argument prefixed with <code>v</code>. <a href="https://github.com/rust-lang/cargo/pull/15484">#15484</a></li>
<li>Improved error message for the <code>CRATE[@&lt;VER&gt;]</code> argument with invalid package name characters. <a href="https://github.com/rust-lang/cargo/pull/15441">#15441</a></li>
<li>cargo-add: suggest similarly named features <a href="https://github.com/rust-lang/cargo/pull/15438">#15438</a></li>
</ul>
<h3 id="수정됨-6"><a class="header" href="#수정됨-6">수정됨</a></h3>
<ul>
<li>Fixed potential deadlock in <code>CacheState::lock</code> <a href="https://github.com/rust-lang/cargo/pull/15698">#15698</a> <a href="https://github.com/rust-lang/cargo/pull/15699">#15699</a></li>
<li>Fixed the <code>--manifest-path</code> arg being ignored in <code>cargo fix</code> <a href="https://github.com/rust-lang/cargo/pull/15633">#15633</a></li>
<li>When publishing, don’t tell people to ctrl-c without knowing consequences. <a href="https://github.com/rust-lang/cargo/pull/15632">#15632</a></li>
<li>Added missing <code>--offline</code> in shell completions. <a href="https://github.com/rust-lang/cargo/pull/15623">#15623</a></li>
<li>cargo-credential-libsecret: load libsecret only once <a href="https://github.com/rust-lang/cargo/pull/15295">#15295</a></li>
<li>When failing to find the mtime of a file for rebuild detection, report an explicit reason rather than “stale; unknown reason”. <a href="https://github.com/rust-lang/cargo/pull/15617">#15617</a></li>
<li>Fixed cargo add overwriting symlinked Cargo.toml files <a href="https://github.com/rust-lang/cargo/pull/15281">#15281</a></li>
<li>Vendor files with .rej/.orig suffix <a href="https://github.com/rust-lang/cargo/pull/15569">#15569</a></li>
<li>Vendor using direct extraction for registry sources. This should ensure that vendored files now always match the originals. <a href="https://github.com/rust-lang/cargo/pull/15514">#15514</a></li>
<li>In the network retry message, use singular “try” for the last retry. <a href="https://github.com/rust-lang/cargo/pull/15328">#15328</a></li>
</ul>
<h3 id="나이틀리nightly-전용-6"><a class="header" href="#나이틀리nightly-전용-6">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>🔥 <code>-Zno-embed-metadata</code>: This tells Cargo to pass the <code>-Zembed-metadata=no</code> flag to the compiler, which instructs it not to embed metadata within rlib and dylib artifacts. In this case, the metadata will only be stored in <code>.rmeta</code> files. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#no-embed-metadata">docs</a>) <a href="https://github.com/rust-lang/cargo/pull/15378">#15378</a></li>
<li>🔥 Plumb rustc <code>-Zhint-mostly-unused</code> flag through as a profile option (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#profile-hint-mostly-unused-option">docs</a>) <a href="https://github.com/rust-lang/cargo/pull/15643">#15643</a></li>
<li>Added the “future” edition <a href="https://github.com/rust-lang/cargo/pull/15595">#15595</a></li>
<li>Added <code>-Zfix-edition</code> <a href="https://github.com/rust-lang/cargo/pull/15596">#15596</a></li>
<li>Added perma unstable <code>--compile-time-deps</code> option for <code>cargo build</code> <a href="https://github.com/rust-lang/cargo/pull/15674">#15674</a></li>
<li><code>-Zscript</code>: Make cargo script ignore workspaces. <a href="https://github.com/rust-lang/cargo/pull/15496">#15496</a></li>
<li><code>-Zpackage-workspace</code>: keep dev-dependencies if they have a version. <a href="https://github.com/rust-lang/cargo/pull/15470">#15470</a></li>
<li>Added custom completer for <code>cargo remove &lt;TAB&gt;</code> <a href="https://github.com/rust-lang/cargo/pull/15662">#15662</a></li>
<li>Test improvements in prep for <code>-Zpackage-workspace</code> stabilization <a href="https://github.com/rust-lang/cargo/pull/15628">#15628</a></li>
<li>Allow packaging of self-cycles with <code>-Zpackage-workspace</code> <a href="https://github.com/rust-lang/cargo/pull/15626">#15626</a></li>
<li>With trim-paths, remap all paths to <code>build.build-dir</code> <a href="https://github.com/rust-lang/cargo/pull/15614">#15614</a></li>
<li>Enable more trim-paths tests for windows-msvc <a href="https://github.com/rust-lang/cargo/pull/15621">#15621</a></li>
<li>Fix doc rebuild detection by passing <code>toolchain-shared-resources</code> to get doc styled for rustdoc-depinfo tracking <a href="https://github.com/rust-lang/cargo/pull/15605">#15605</a></li>
<li>Resolve multiple bugs in frontmatter parser for <code>-Zscript</code> <a href="https://github.com/rust-lang/cargo/pull/15573">#15573</a></li>
<li>Remove workaround for rustc frontmatter support for <code>-Zscript</code> <a href="https://github.com/rust-lang/cargo/pull/15570">#15570</a></li>
<li>Allow configuring arbitrary codegen backends <a href="https://github.com/rust-lang/cargo/pull/15562">#15562</a></li>
<li>skip <code>publish=false</code> pkg when publishing entire workspace for <code>-Zpackage-workspace</code>. <a href="https://github.com/rust-lang/cargo/pull/15525">#15525</a></li>
<li>Update instructions on using native-completions <a href="https://github.com/rust-lang/cargo/pull/15480">#15480</a></li>
<li>Skip registry check if its not needed with <code>-Zpackage-workspace</code>. <a href="https://github.com/rust-lang/cargo/pull/15629">#15629</a></li>
</ul>
<h3 id="문서-6"><a class="header" href="#문서-6">문서</a></h3>
<ul>
<li>Clarify what commands need and remove confusing example <a href="https://github.com/rust-lang/cargo/pull/15457">#15457</a></li>
<li>Update fingerprint footnote <a href="https://github.com/rust-lang/cargo/pull/15478">#15478</a></li>
<li>home: update version notice for deprecation removal <a href="https://github.com/rust-lang/cargo/pull/15511">#15511</a></li>
<li>docs(contrib): change clap URL to docs.rs/clap <a href="https://github.com/rust-lang/cargo/pull/15682">#15682</a></li>
<li>Update links in contrib docs <a href="https://github.com/rust-lang/cargo/pull/15659">#15659</a></li>
<li>docs: clarify <code>--all-features</code> not available for all commands <a href="https://github.com/rust-lang/cargo/pull/15572">#15572</a></li>
<li>docs(README): fix the link to the changelog in the Cargo book <a href="https://github.com/rust-lang/cargo/pull/15597">#15597</a></li>
</ul>
<h3 id="내부-변경-6"><a class="header" href="#내부-변경-6">내부 변경</a></h3>
<ul>
<li>Refactor artifact deps in FeatureResolver::deps <a href="https://github.com/rust-lang/cargo/pull/15492">#15492</a></li>
<li>Added tracing spans for rustc invocations <a href="https://github.com/rust-lang/cargo/pull/15464">#15464</a></li>
<li>ci: migrate renovate config <a href="https://github.com/rust-lang/cargo/pull/15501">#15501</a></li>
<li>ci: Require schema job to pass <a href="https://github.com/rust-lang/cargo/pull/15504">#15504</a></li>
<li>test: Remove unused nightly requirements <a href="https://github.com/rust-lang/cargo/pull/15498">#15498</a></li>
<li>Update dependencies. <a href="https://github.com/rust-lang/cargo/pull/15456">#15456</a></li>
<li>refactor: replace InternedString with Cow in IndexPackage <a href="https://github.com/rust-lang/cargo/pull/15559">#15559</a></li>
<li>Use <code>Not::not</code> rather than a custom <code>is_false</code> function <a href="https://github.com/rust-lang/cargo/pull/15645">#15645</a></li>
<li>fix: Make UI tests handle hyperlinks consistently <a href="https://github.com/rust-lang/cargo/pull/15640">#15640</a></li>
<li>Update dependencies <a href="https://github.com/rust-lang/cargo/pull/15635">#15635</a> <a href="https://github.com/rust-lang/cargo/pull/15557">#15557</a></li>
<li>refactor: clean up <code>clippy::perf</code> lint warnings <a href="https://github.com/rust-lang/cargo/pull/15631">#15631</a></li>
<li>chore(deps): update alpine docker tag to v3.22 <a href="https://github.com/rust-lang/cargo/pull/15616">#15616</a></li>
<li>chore: remove HTML comments in PR template and inline guide <a href="https://github.com/rust-lang/cargo/pull/15613">#15613</a></li>
<li>Added .git-blame-ignore-revs <a href="https://github.com/rust-lang/cargo/pull/15612">#15612</a></li>
<li>refactor: cleanup for <code>CompileMode</code> <a href="https://github.com/rust-lang/cargo/pull/15608">#15608</a></li>
<li>refactor: separate “global” mode from CompileMode <a href="https://github.com/rust-lang/cargo/pull/15601">#15601</a></li>
<li>chore: Upgrade schemars <a href="https://github.com/rust-lang/cargo/pull/15602">#15602</a></li>
<li>Update gix &amp; socket2 <a href="https://github.com/rust-lang/cargo/pull/15600">#15600</a></li>
<li>chore(toml): disable <code>toml</code>’s default features, unless necessary, to reduce cargo-util-schemas build time <a href="https://github.com/rust-lang/cargo/pull/15598">#15598</a></li>
<li>chore(gh): Add new-lint issue template <a href="https://github.com/rust-lang/cargo/pull/15575">#15575</a></li>
<li>Fix comment for cargo/core/compiler/fingerprint/mod.rs <a href="https://github.com/rust-lang/cargo/pull/15565">#15565</a></li>
</ul>
<h2 id="cargo-188-2025-06-26"><a class="header" href="#cargo-188-2025-06-26">Cargo 1.88 (2025-06-26)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/a6c604d1...rust-1.88.0">a6c604d1…rust-1.88.0</a></p>
<h3 id="추가됨-7"><a class="header" href="#추가됨-7">추가됨</a></h3>
<ul>
<li>
<p>🎉 Stabilize automatic garbage collection for global caches.</p>
<p>When building, Cargo downloads and caches crates needed as dependencies. Historically, these downloaded files would never be cleaned up, leading to an unbounded amount of disk usage in Cargo’s home directory. In this version, Cargo introduces a garbage collection mechanism to automatically clean up old files (e.g. .crate files). Cargo will remove files downloaded from the network if not accessed in 3 months, and files obtained from the local system if not accessed in 1 month. Note that this automatic garbage collection will not take place if running offline (using <code>--offline</code> or <code>--frozen</code>).</p>
<p>Cargo 1.78 and newer track the access information needed for this garbage collection. If you regularly use versions of Cargo older than 1.78, in addition to running current versions of Cargo, and you expect to have some crates accessed exclusively by the older versions of Cargo and don’t want to re-download those crates every ~3 months, you may wish to set <code>cache.auto-clean-frequency = "never"</code> in the Cargo configuration. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/config.html#cache">docs</a>) <a href="https://github.com/rust-lang/cargo/pull/14287">#14287</a></p>
</li>
<li>
<p>Allow boolean literals as cfg predicates in Cargo.toml and configurations. For example, <code>[target.'cfg(not(false))'.dependencies]</code> is a valid cfg predicate. (<a href="https://github.com/rust-lang/rfcs/pull/3695">RFC 3695</a>) <a href="https://github.com/rust-lang/cargo/pull/14649">#14649</a></p>
</li>
</ul>
<h3 id="변경됨-7"><a class="header" href="#변경됨-7">변경됨</a></h3>
<ul>
<li>Don’t canonicalize executable path for the <code>CARGO</code> environment variable. <a href="https://github.com/rust-lang/cargo/pull/15355">#15355</a></li>
<li>Print target and package names formatted as file hyperlinks. <a href="https://github.com/rust-lang/cargo/pull/15405">#15405</a></li>
<li>Make sure library search paths inside <code>OUT_DIR</code> precede external paths. <a href="https://github.com/rust-lang/cargo/pull/15221">#15221</a></li>
<li>Suggest similar looking feature names when feature is missing. <a href="https://github.com/rust-lang/cargo/pull/15454">#15454</a></li>
<li>Use <code>zlib-rs</code> for gzip (de)compression for <code>.crate</code> tarballs. <a href="https://github.com/rust-lang/cargo/pull/15417">#15417</a></li>
</ul>
<h3 id="수정됨-7"><a class="header" href="#수정됨-7">수정됨</a></h3>
<ul>
<li>build-rs: Correct name of <code>CARGO_CFG_FEATURE</code> <a href="https://github.com/rust-lang/cargo/pull/15420">#15420</a></li>
<li>cargo-tree: Make output more deterministic <a href="https://github.com/rust-lang/cargo/pull/15369">#15369</a></li>
<li>cargo-package: dont fail the entire command when the dirtiness check failed, as git status check is mostly informational. <a href="https://github.com/rust-lang/cargo/pull/15416">#15416</a> <a href="https://github.com/rust-lang/cargo/pull/15419">#15419</a></li>
<li>Fixed <code>cargo rustc --bin</code> panicking on unknown bin names <a href="https://github.com/rust-lang/cargo/pull/15515">#15515</a> <a href="https://github.com/rust-lang/cargo/pull/15497">#15497</a></li>
</ul>
<h3 id="나이틀리nightly-전용-7"><a class="header" href="#나이틀리nightly-전용-7">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>🔥 <code>-Zrustdoc-depinfo</code>: A new unstable flag leveraging rustdoc’s dep-info files to determine whether documentations are required to re-generate. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#rustdoc-depinfo">docs</a>) <a href="https://github.com/rust-lang/cargo/pull/15359">#15359</a> <a href="https://github.com/rust-lang/cargo/pull/15371">#15371</a></li>
<li><code>build-dir</code>: Added validation for unmatched brackets in build-dir template <a href="https://github.com/rust-lang/cargo/pull/15414">#15414</a></li>
<li><code>build-dir</code>: Improved error message when build-dir template var is invalid <a href="https://github.com/rust-lang/cargo/pull/15418">#15418</a></li>
<li><code>build-dir</code>: Added <code>build_directory</code> field to cargo metadata output <a href="https://github.com/rust-lang/cargo/pull/15377">#15377</a></li>
<li><code>build-dir</code>: Added symlink resolution for <code>workspace-path-hash</code> <a href="https://github.com/rust-lang/cargo/pull/15400">#15400</a></li>
<li><code>build-dir</code>: Added build_directory to cargo metadata documentation <a href="https://github.com/rust-lang/cargo/pull/15410">#15410</a></li>
<li><code>unit-graph</code>: switch to Package ID Spec. <a href="https://github.com/rust-lang/cargo/pull/15447">#15447</a></li>
<li><code>-Zgc</code>: Rename the <code>gc</code> config table to <code>[cache]</code>. Low-level settings is now under <code>[cache.global-clean]</code>. <a href="https://github.com/rust-lang/cargo/pull/15367">#15367</a></li>
<li><code>-Zdoctest-xcompile</code>: Update doctest xcompile flags. <a href="https://github.com/rust-lang/cargo/pull/15455">#15455</a></li>
</ul>
<h3 id="문서-7"><a class="header" href="#문서-7">문서</a></h3>
<ul>
<li>Mention the convention of kebab-case for Cargo targets naming. <a href="https://github.com/rust-lang/cargo/pull/14439">#14439</a></li>
<li>Use better example value in <code>CARGO_CFG_TARGET_ABI</code> <a href="https://github.com/rust-lang/cargo/pull/15404">#15404</a></li>
</ul>
<h3 id="내부-변경-7"><a class="header" href="#내부-변경-7">내부 변경</a></h3>
<ul>
<li>Fix formatting of CliUnstable parsing <a href="https://github.com/rust-lang/cargo/pull/15434">#15434</a></li>
<li>ci: restore semver-checks for cargo-util <a href="https://github.com/rust-lang/cargo/pull/15389">#15389</a></li>
<li>ci: add aarch64 linux runner <a href="https://github.com/rust-lang/cargo/pull/15077">#15077</a></li>
<li>rustfix: Use <code>snapbox</code> for snapshot testing <a href="https://github.com/rust-lang/cargo/pull/15429">#15429</a></li>
<li>test:Prevent undeclared public network access <a href="https://github.com/rust-lang/cargo/pull/15368">#15368</a></li>
<li>Update dependencies. <a href="https://github.com/rust-lang/cargo/pull/15373">#15373</a> <a href="https://github.com/rust-lang/cargo/pull/15381">#15381</a> <a href="https://github.com/rust-lang/cargo/pull/15391">#15391</a> <a href="https://github.com/rust-lang/cargo/pull/15394">#15394</a> <a href="https://github.com/rust-lang/cargo/pull/15403">#15403</a> <a href="https://github.com/rust-lang/cargo/pull/15415">#15415</a> <a href="https://github.com/rust-lang/cargo/pull/15421">#15421</a> <a href="https://github.com/rust-lang/cargo/pull/15446">#15446</a></li>
</ul>
<h2 id="cargo-187-2025-05-15"><a class="header" href="#cargo-187-2025-05-15">Cargo 1.87 (2025-05-15)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/ce948f46...rust-1.87.0">ce948f46…rust-1.87.0</a></p>
<h3 id="추가됨-8"><a class="header" href="#추가됨-8">추가됨</a></h3>
<ul>
<li>Add terminal integration via ANSI OSC 9;4 sequences via the <code>term.progress.term-integration</code> configuration field. This reports progress to the terminal emulator for display in places like the task bar. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/config.html#termprogressterm-integration">docs</a>) <a href="https://github.com/rust-lang/cargo/pull/14615">#14615</a></li>
<li>Forward bash completions of third party subcommands <a href="https://github.com/rust-lang/cargo/pull/15247">#15247</a></li>
<li>cargo-tree: Color the output. <a href="https://github.com/rust-lang/cargo/pull/15242">#15242</a></li>
<li>cargo-package: add <code>--exclude-lockfile</code> flag, which will stop verifying the lock file if present. <a href="https://github.com/rust-lang/cargo/pull/15234">#15234</a></li>
</ul>
<h3 id="변경됨-8"><a class="header" href="#변경됨-8">변경됨</a></h3>
<ul>
<li>❗️ Cargo now depends on OpenSSL v3. This implies that Cargo in the official Rust distribution will have a hard dependency on libatomic on 32-bit platforms. <a href="https://github.com/rust-lang/cargo/pull/15232">#15232</a></li>
<li>Report <code>&lt;target&gt;.edition</code> deprecation to users. <a href="https://github.com/rust-lang/cargo/pull/15321">#15321</a></li>
<li>Leverage clap for providing default values for <code>--vcs</code>, <code>--color</code>, and <code>--message-format</code> flags. <a href="https://github.com/rust-lang/cargo/pull/15322">#15322</a></li>
<li>Mention “3” as a valid value for “resolver” field in error message <a href="https://github.com/rust-lang/cargo/pull/15215">#15215</a></li>
<li>Uplift windows Cygwin DLL import libraries <a href="https://github.com/rust-lang/cargo/pull/15193">#15193</a></li>
<li>Include the package name also in the target hint message. <a href="https://github.com/rust-lang/cargo/pull/15199">#15199</a></li>
<li>cargo-add: 긴 기능 목록 접기 <a href="https://github.com/rust-lang/cargo/pull/15200">#15200</a></li>
<li>cargo-vendor: Add context which workspace failed to resolve <a href="https://github.com/rust-lang/cargo/pull/15297">#15297</a></li>
</ul>
<h3 id="수정됨-8"><a class="header" href="#수정됨-8">수정됨</a></h3>
<ul>
<li>Do not pass cdylib link args from <code>cargo::rustc-link-arg-cdylib</code> to tests. <a href="https://github.com/rust-lang/cargo/pull/15317">#15317</a> <a href="https://github.com/rust-lang/cargo/pull/15326">#15326</a></li>
<li>Don’t use <code>$CARGO_BUILD_TARGET</code> in <code>cargo metadata</code>. <a href="https://github.com/rust-lang/cargo/pull/15271">#15271</a></li>
<li>Allow <code>term.progress.when</code> to have default values. <code>CARGO_TERM_PROGRESS_WIDTH</code> can now be correctly set even when other settings are missing. <a href="https://github.com/rust-lang/cargo/pull/15287">#15287</a></li>
<li>Fix the <code>CARGO</code> environment variable setting for external subcommands pointing to the wrong Cargo binary path . Note that the environment variable is never designed as a general Cargo wrapper. <a href="https://github.com/rust-lang/cargo/pull/15208">#15208</a></li>
<li>Fix some issues with future-incompat report generation. <a href="https://github.com/rust-lang/cargo/pull/15345">#15345</a></li>
<li>Respect <code>--frozen</code> everywhere <code>--offline</code> or <code>--locked</code> is accepted. <a href="https://github.com/rust-lang/cargo/pull/15263">#15263</a></li>
<li>cargo-package: report also the VCS status of the workspace manifest if dirty. <a href="https://github.com/rust-lang/cargo/pull/15276">#15276</a> <a href="https://github.com/rust-lang/cargo/pull/15341">#15341</a></li>
<li>cargo-publish: 잘못된 형식의 <code>{{#options}}</code> 블록이 포함된 맨 페이지 수정 <a href="https://github.com/rust-lang/cargo/pull/15191">#15191</a></li>
<li>cargo-run: Disambiguate bins from different packages that share a name. <a href="https://github.com/rust-lang/cargo/pull/15298">#15298</a></li>
<li>cargo-rustc: de-duplicate crate types. <a href="https://github.com/rust-lang/cargo/pull/15314">#15314</a></li>
<li>cargo-vendor: dont remove non-cached sources. <a href="https://github.com/rust-lang/cargo/pull/15260">#15260</a></li>
</ul>
<h3 id="나이틀리nightly-전용-8"><a class="header" href="#나이틀리nightly-전용-8">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>🔥 cargo-package: add unstable <code>--message-format</code> flag. The flag is providing an alternative JSON output format for file listing of the <code>--list</code> flag. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#package-message-format">docs</a>) <a href="https://github.com/rust-lang/cargo/pull/15311">#15311</a> <a href="https://github.com/rust-lang/cargo/pull/15354">#15354</a></li>
<li>🔥 <code>build-dir</code>: the <code>build.build-dir</code> config option to set the directory where intermediate build artifacts will be stored. Intermediate artifacts are produced by Rustc/Cargo during the build process. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-dir">docs</a>) <a href="https://github.com/rust-lang/cargo/pull/15104">#15104</a> <a href="https://github.com/rust-lang/cargo/pull/15236">#15236</a> <a href="https://github.com/rust-lang/cargo/pull/15334">#15334</a></li>
<li>🔥 <code>-Zsbom</code>: The <code>build.sbom</code> config allows to generate so-called SBOM pre-cursor files alongside each compiled artifact. (<a href="https://github.com/rust-lang/rfcs/pull/3553">RFC 3553</a>) (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#sbom">docs</a>) <a href="https://github.com/rust-lang/cargo/pull/13709">#13709</a></li>
<li>🔥 <code>-Zpublic-dependency</code>: new <code>--depth public</code> value for <code>cargo tree</code> to display public dependencies. <a href="https://github.com/rust-lang/cargo/pull/15243">#15243</a></li>
<li><code>-Zscript</code>: 더 많은 프론트매터 파싱의 엣지 케이스 처리 <a href="https://github.com/rust-lang/cargo/pull/15187">#15187</a></li>
<li><code>-Zpackage-workspace</code>: Fix lookups to capitalized workspace member’s index entry <a href="https://github.com/rust-lang/cargo/pull/15216">#15216</a></li>
<li><code>-Zpackage-workspace</code>: Register workspace member renames in overlay <a href="https://github.com/rust-lang/cargo/pull/15228">#15228</a></li>
<li><code>-Zpackage-workspace</code>: Ensure we can package directories ending with ‘.rs’ <a href="https://github.com/rust-lang/cargo/pull/15240">#15240</a></li>
<li><code>native-completions</code>: add completions for <code>--profile</code> <a href="https://github.com/rust-lang/cargo/pull/15308">#15308</a></li>
<li><code>native-completions</code>: add completions for aliases <a href="https://github.com/rust-lang/cargo/pull/15319">#15319</a></li>
<li><code>native-completions</code>: add completions for <code>cargo add --path</code> <a href="https://github.com/rust-lang/cargo/pull/15288">#15288</a></li>
<li><code>native-completions</code>: add completions for <code>--manifest-path</code> <a href="https://github.com/rust-lang/cargo/pull/15225">#15225</a></li>
<li><code>native-completions</code>: add completions for <code>--lockfile-path</code> <a href="https://github.com/rust-lang/cargo/pull/15238">#15238</a></li>
<li><code>native-completions</code>: add completions for <code>cargo install --path</code> <a href="https://github.com/rust-lang/cargo/pull/15266">#15266</a></li>
<li><code>native-completions</code>: add completions fro <code>+&lt;toolchain&gt;</code> <a href="https://github.com/rust-lang/cargo/pull/15301">#15301</a></li>
</ul>
<h3 id="문서-8"><a class="header" href="#문서-8">문서</a></h3>
<ul>
<li>Note that target-edition is deprecated <a href="https://github.com/rust-lang/cargo/pull/15292">#15292</a></li>
<li>Mention wrong URLs as a cause of git authentication errors <a href="https://github.com/rust-lang/cargo/pull/15304">#15304</a></li>
<li>Shift focus to resolver v3 <a href="https://github.com/rust-lang/cargo/pull/15213">#15213</a></li>
<li>Lockfile is always included since 1.84 <a href="https://github.com/rust-lang/cargo/pull/15257">#15257</a></li>
<li>Remove <code>Cargo.toml</code> from <code>package.include</code> in example <a href="https://github.com/rust-lang/cargo/pull/15253">#15253</a></li>
<li>Make it clearer that <code>rust_version</code> is enforced during compile <a href="https://github.com/rust-lang/cargo/pull/15303">#15303</a></li>
<li>Fix <code>[env]</code> <code>relative</code> description in reference <a href="https://github.com/rust-lang/cargo/pull/15332">#15332</a></li>
<li>Add <code>unsafe</code> to <code>extern</code> while using build scripts in Cargo Book <a href="https://github.com/rust-lang/cargo/pull/15294">#15294</a></li>
<li>Mention <code>x.y.*</code> as a kind of version requirement to avoid. <a href="https://github.com/rust-lang/cargo/pull/15310">#15310</a></li>
<li>contrib: Expand the description of team meetings <a href="https://github.com/rust-lang/cargo/pull/15349">#15349</a></li>
</ul>
<h3 id="내부-변경-8"><a class="header" href="#내부-변경-8">내부 변경</a></h3>
<ul>
<li>Show extra build description from bootstrap via the <code>CFG_VER_DESCRIPTION</code> env var. <a href="https://github.com/rust-lang/cargo/pull/15269">#15269</a></li>
<li>Control byte display precision with <code>std::fmt</code> options. <a href="https://github.com/rust-lang/cargo/pull/15246">#15246</a></li>
<li>Replace humantime crate with jiff. <a href="https://github.com/rust-lang/cargo/pull/15290">#15290</a></li>
<li>Dont check cargo-util semver until 1.86 is released <a href="https://github.com/rust-lang/cargo/pull/15222">#15222</a></li>
<li>Redox OS is part of the unix family <a href="https://github.com/rust-lang/cargo/pull/15307">#15307</a></li>
<li>cargo-tree: Abstract the concept of a NodeId <a href="https://github.com/rust-lang/cargo/pull/15237">#15237</a></li>
<li>cargo-tree: Abstract the concept of an edge <a href="https://github.com/rust-lang/cargo/pull/15233">#15233</a></li>
<li>ci: Auto-update cargo-semver-checks <a href="https://github.com/rust-lang/cargo/pull/15212">#15212</a></li>
<li>ci: Visually group output in Github <a href="https://github.com/rust-lang/cargo/pull/15218">#15218</a></li>
<li>manifest: Centralize Cargo target descriptions <a href="https://github.com/rust-lang/cargo/pull/15291">#15291</a></li>
<li>Update dependencies. <a href="https://github.com/rust-lang/cargo/pull/15250">#15250</a> <a href="https://github.com/rust-lang/cargo/pull/15249">#15249</a> <a href="https://github.com/rust-lang/cargo/pull/15245">#15245</a> <a href="https://github.com/rust-lang/cargo/pull/15224">#15224</a> <a href="https://github.com/rust-lang/cargo/pull/15282">#15282</a> <a href="https://github.com/rust-lang/cargo/pull/15211">#15211</a> <a href="https://github.com/rust-lang/cargo/pull/15217">#15217</a> <a href="https://github.com/rust-lang/cargo/pull/15268">#15268</a></li>
</ul>
<h2 id="cargo-186-2025-04-03"><a class="header" href="#cargo-186-2025-04-03">Cargo 1.86 (2025-04-03)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/d73d2caf...rust-1.86.0">d73d2caf…rust-1.86.0</a></p>
<h3 id="추가됨-9"><a class="header" href="#추가됨-9">추가됨</a></h3>
<h3 id="변경됨-9"><a class="header" href="#변경됨-9">변경됨</a></h3>
<ul>
<li>❗️ 병합할 때 프로그램 경로와 해당 인수를 참조하는 설정 키는 결합하는 대신 대체합니다. <a href="https://github.com/rust-lang/cargo/pull/15066">#15066</a><br />
이러한 키에는 다음이 포함됩니다.
<ul>
<li><code>registry.credential-provider</code></li>
<li><code>registries.*.credential-provider</code></li>
<li><code>target.*.runner</code></li>
<li><code>host.runner</code></li>
<li><code>credential-alias.*</code></li>
<li><code>doc.browser</code></li>
</ul>
</li>
<li>❗️ <code>--package</code> 와 <code>--workspace</code> 가 모두 전달되었지만 요청된 패키지가 누락된 경우 에러가 발생합니다. 이전에는 이를 자동으로 무시했으나, 누락된 패키지는 보고되어야 하므로 버그로 간주되었습니다. <a href="https://github.com/rust-lang/cargo/pull/15071">#15071</a></li>
<li>인덱스 캐시 업데이트 실패 시 경고를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/15014">#15014</a></li>
<li>에러 메시지에서 “did you mean“을 사용하지 마세요. 제안 사항이 무엇인지 바로 명시하세요. <a href="https://github.com/rust-lang/cargo/pull/15138">#15138</a></li>
<li>의존성 소스에서 유효하지 않은 SSH URL에 대해 더 나은 에러 메시지를 제공합니다. <a href="https://github.com/rust-lang/cargo/pull/15185">#15185</a></li>
<li>패키지에 지정된 기능이 없는 경우 유사한 기능 이름을 제안합니다. <a href="https://github.com/rust-lang/cargo/pull/15133">#15133</a></li>
<li>워크스페이스 멤버를 찾을 수 없는 경우 글로브(globs)를 출력합니다. <a href="https://github.com/rust-lang/cargo/pull/15093">#15093</a></li>
<li>cargo-fix: <code>--allow-dirty</code> 가 <code>--allow-staged</code> 를 함축하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/15013">#15013</a></li>
<li>cargo-login: 사용 중단(deprecation) 준비를 위해 CLI 도움말에서 <code>token</code> 인수를 숨깁니다. <a href="https://github.com/rust-lang/cargo/pull/15057">#15057</a></li>
<li>cargo-login: 호환되지 않는 자격 증명 제공자를 사용할 때 <code>cargo login</code> 을 제안하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/15124">#15124</a></li>
<li>cargo-package: 특정 경로 접두사를 pathspec과 매칭하여 VCS 상태 확인 성능을 향상시켰습니다. <a href="https://github.com/rust-lang/cargo/pull/14997">#14997</a></li>
</ul>
<h3 id="수정됨-9"><a class="header" href="#수정됨-9">수정됨</a></h3>
<ul>
<li>빌드 스크립트의 <code>rerun-if-env-changed</code> 지시어가 이제 <code>[env]</code> 설정 테이블의 변경 사항을 올바르게 감지할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/14756">#14756</a></li>
<li>지원되지 않는 크레이트 유형에 대한 Rust 타겟 정보를 학습할 때 경고를 경고로 강제 출력하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/15036">#15036</a></li>
<li>cargo-package: 심볼릭 링크가 현재 패키지 루트 외부의 경로를 가리킬 때 VCS 상태를 검증하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14981">#14981</a></li>
</ul>
<h3 id="나이틀리nightly-전용-9"><a class="header" href="#나이틀리nightly-전용-9">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>🔥 <code>-Z feature-unification</code>: 이 새로운 불안정 플래그는 워크스페이스 전반에서 기능이 통합되는 방식을 제어하기 위해 <code>resolver.feature-unification</code> 설정 옵션을 활성화합니다. (<a href="https://github.com/rust-lang/rfcs/blob/master/text/3692-feature-unification.md">RFC 3529</a>) (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#feature-unification">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/15157">#15157</a></li>
<li>cargo-util-schemas: JSON 스키마를 수정 및 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/15000">#15000</a></li>
<li>cargo-util-schemas: <code>[lints]</code> JSON 스키마를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/15035">#15035</a></li>
<li>cargo-util-schemas: ‘metadata’ JSON 스키마를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/15033">#15033</a></li>
<li><code>cargo rustc --print</code>: <code>cargo rustc --print</code> 를 위한 cargo 환경을 설정합니다. <a href="https://github.com/rust-lang/cargo/pull/15026">#15026</a></li>
<li><code>-Zbuild-std</code>: 값을 쉼표로 구분된 리스트로 파싱하며, 이 동작을 <code>build-std-features</code> 까지 확장했습니다. <a href="https://github.com/rust-lang/cargo/pull/15065">#15065</a></li>
<li><code>-Zgc</code>: 캐시 추적이 예상치 못한 파일에 대해 회복력을 갖도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/15147">#15147</a></li>
<li><code>-Zscript</code>: 매니페스트 경로로부터 SourceId 생성을 통합했습니다. <a href="https://github.com/rust-lang/cargo/pull/15172">#15172</a></li>
<li><code>-Zscript</code>: cargo-script 로직을 메인 파서에 통합했습니다. <a href="https://github.com/rust-lang/cargo/pull/15168">#15168</a></li>
<li><code>-Zscript</code>: cargo-script에 대해 <code>cargo pkgid</code> 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/14961">#14961</a></li>
<li><code>-Zpackage-workspace</code>: 게시할 수 없는 모든 패키지를 보고합니다. <a href="https://github.com/rust-lang/cargo/pull/15070">#15070</a></li>
</ul>
<h3 id="문서-9"><a class="header" href="#문서-9">문서</a></h3>
<ul>
<li>1.46 버전부터 Cargo가 <code>env!</code> 매크로에 사용된 변수를 재빌드 트리거로 자동 등록함을 문서화했습니다. <a href="https://github.com/rust-lang/cargo/pull/15062">#15062</a></li>
<li>변경 로그를 Cargo 북으로 옮겼습니다. <a href="https://github.com/rust-lang/cargo/pull/15119">#15119</a> <a href="https://github.com/rust-lang/cargo/pull/15123">#15123</a> <a href="https://github.com/rust-lang/cargo/pull/15142">#15142</a></li>
<li><code>package.authors</code> 가 사용 중단됨을 명시했습니다. <a href="https://github.com/rust-lang/cargo/pull/15068">#15068</a></li>
<li>패키지 ID 명세의 잘못된 문법을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/15049">#15049</a></li>
<li>MSRV에 대한 반전된 로직을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/15044">#15044</a></li>
<li>cargo-metadata: <code>"root"</code> 필드의 설명을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/15182">#15182</a></li>
<li>cargo-package: 잠금 파일이 항상 포함됨을 명시했습니다. <a href="https://github.com/rust-lang/cargo/pull/15067">#15067</a></li>
<li>contrib: 스키마 설계를 위한 가이드라인을 시작했습니다. <a href="https://github.com/rust-lang/cargo/pull/15037">#15037</a></li>
</ul>
<h3 id="내부-변경-9"><a class="header" href="#내부-변경-9">내부 변경</a></h3>
<ul>
<li>Solaris에서 <code>libc::LOCK_*</code> 를 사용하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/15143">#15143</a></li>
<li>필드에서 환경 변수로의 처리 로직을 정리했습니다. <a href="https://github.com/rust-lang/cargo/pull/15008">#15008</a></li>
<li>SourceID의 Ord/Eq 구현을 단순화했습니다. <a href="https://github.com/rust-lang/cargo/pull/14980">#14980</a> <a href="https://github.com/rust-lang/cargo/pull/15103">#15103</a></li>
<li>SourceKind에 수동 Hash 구현을 추가하고 그 이유를 문서화했습니다. <a href="https://github.com/rust-lang/cargo/pull/15029">#15029</a></li>
<li>ci: CI에서 Windows 예약어 이름을 허용하도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/15135">#15135</a></li>
<li>cargo-test-macro: <code>RUSTUP_WINDOWS_PATH_ADD_BIN</code> 에 대한 조건을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/15017">#15017</a></li>
<li>resolver: 백트랙(backtrack) 로직을 단순화했습니다. <a href="https://github.com/rust-lang/cargo/pull/15150">#15150</a></li>
<li>resolver: 소소한 정리 작업을 수행했습니다. <a href="https://github.com/rust-lang/cargo/pull/15040">#15040</a></li>
<li>test: 얕은 페치(shallow fetch) 테스트를 정리했습니다. <a href="https://github.com/rust-lang/cargo/pull/15002">#15002</a></li>
<li>test: macOS에서 <code>https::self_signed_should_fail</code> 를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/15016">#15016</a></li>
<li>test: 최신 버전의 git에서 발생하는 benchsuite 이슈를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/15069">#15069</a></li>
<li>test: Windows에서 실행되는 shared_std_dependency_rebuild를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/15111">#15111</a></li>
<li>test: 나이틀리 에러를 수정하기 위해 테스트를 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/15110">#15110</a></li>
<li>test: 사용되지 않는 <code>-C link-arg=-fuse-ld=lld</code> 를 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/15097">#15097</a></li>
<li>test: <code>LazyLock</code> 을 사용하여 <code>unsafe</code> 를 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/15096">#15096</a></li>
<li>test: 불필요한 into 변환을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/15042">#15042</a></li>
<li>test: panic_abort_tests의 레이스 컨디션을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/15169">#15169</a></li>
<li>deny.toml을 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/15164">#15164</a></li>
<li>의존성을 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/14995">#14995</a> <a href="https://github.com/rust-lang/cargo/pull/14996">#14996</a> <a href="https://github.com/rust-lang/cargo/pull/14998">#14998</a> <a href="https://github.com/rust-lang/cargo/pull/15012">#15012</a> <a href="https://github.com/rust-lang/cargo/pull/15018">#15018</a> <a href="https://github.com/rust-lang/cargo/pull/15041">#15041</a> <a href="https://github.com/rust-lang/cargo/pull/15050">#15050</a> <a href="https://github.com/rust-lang/cargo/pull/15121">#15121</a> <a href="https://github.com/rust-lang/cargo/pull/15128">#15128</a> <a href="https://github.com/rust-lang/cargo/pull/15129">#15129</a> <a href="https://github.com/rust-lang/cargo/pull/15162">#15162</a> <a href="https://github.com/rust-lang/cargo/pull/15163">#15163</a> <a href="https://github.com/rust-lang/cargo/pull/15165">#15165</a> <a href="https://github.com/rust-lang/cargo/pull/15166">#15166</a></li>
</ul>
<h2 id="cargo-185-2025-02-20"><a class="header" href="#cargo-185-2025-02-20">Cargo 1.85 (2025-02-20)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/66221abd...rust-1.85.0">66221abd…rust-1.85.0</a></p>
<h3 id="추가됨-10"><a class="header" href="#추가됨-10">추가됨</a></h3>
<ul>
<li>🎉 Cargo가 이제 2024 에디션을 지원합니다. 자세한 정보는 <a href="https://doc.rust-lang.org/nightly/edition-guide/rust-2024/index.html">에디션 가이드</a> 에서 확인할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/14828">#14828</a></li>
<li>cargo-tree: <code>--depth</code> 플래그가 이제 <code>workspace</code> 를 허용하여 현재 워크스페이스의 멤버인 의존성만 보여줍니다. <a href="https://github.com/rust-lang/cargo/pull/14928">#14928</a></li>
<li>빌드 스크립트가 이제 새로운 환경 변수인 <code>CARGO_CFG_FEATURE</code> 를 받으며, 여기에는 빌드 중인 패키지의 각 활성화된 기능이 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/14902">#14902</a></li>
<li>성능: <code>ActivationsKey</code> 에 더 효율적인 해시를 사용하여 의존성 해결이 더 빨라졌습니다. <a href="https://github.com/rust-lang/cargo/pull/14915">#14915</a></li>
</ul>
<h3 id="변경됨-10"><a class="header" href="#변경됨-10">변경됨</a></h3>
<ul>
<li>❗️ cargo-rustc: 뒤에 오는 플래그들이 이제 더 높은 우선순위를 가집니다. 이 동작은 1.83부터 나이틀리 전용이었으며 이제 안정화되었습니다. <a href="https://github.com/rust-lang/cargo/pull/14900">#14900</a></li>
<li>❗️ Cargo가 이제 <code>rustc-stable-hash</code> 의 크로스 플랫폼 해시 알고리즘을 사용합니다. 결과적으로 의존성 캐시 경로의 해시 부분(예: <code>$CARGO_HOME/registry/index/index.crates.io-&lt;hash&gt;</code>)이 변경됩니다. 이로 인해 레지스트리 인덱스와 <code>.crate</code> 타르볼의 재다운로드 및 Git 의존성의 재클론이 트리거됩니다. <a href="https://github.com/rust-lang/cargo/pull/14917">#14917</a></li>
<li>Cargo.toml 및 Cargo 설정의 <code>cfg</code> 에서 키워드 사용에 대한 미래 비호환성 경고를 추가했습니다. <code>cfg(true)</code> 및 <code>cfg(false)</code> 와 같이 키워드가 포함된 <code>cfg</code> 가 잘못 허용되었습니다. 하위 호환성을 위해 원시 식별자(raw identifier) 지원이 도입되었습니다. 예를 들어, 대신 <code>cfg(r#true)</code> 를 사용하세요. <a href="https://github.com/rust-lang/cargo/pull/14671">#14671</a></li>
<li>의존성 해결 시 일부 버전이 거부되거나 일치하지 않거나 유효하지 않은 이유를 설명하는 더 풍부한 에러 메시지를 제공합니다. <a href="https://github.com/rust-lang/cargo/pull/14897">#14897</a> <a href="https://github.com/rust-lang/cargo/pull/14921">#14921</a> <a href="https://github.com/rust-lang/cargo/pull/14923">#14923</a> <a href="https://github.com/rust-lang/cargo/pull/14927">#14927</a></li>
<li>cargo-doc: 문서가 생성되지 않은 상태에서 <code>--open</code> 으로 문서를 열려고 할 때의 에러 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/14969">#14969</a></li>
<li>cargo-package: 심볼릭 링크가 일반 텍스트 파일로 체크아웃된 경우 경고를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/14994">#14994</a></li>
<li>cargo-package: 지저분한(dirty) 파일 경로를 Git 작업 디렉토리에 대한 상대 경로로 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/14968">#14968</a> <a href="https://github.com/rust-lang/cargo/pull/14970">#14970</a></li>
</ul>
<h3 id="수정됨-10"><a class="header" href="#수정됨-10">수정됨</a></h3>
<ul>
<li><code>net.git-fetch-with-cli=true</code> 설정 시 베어(bare) 저장소와의 호환성을 보장하기 위해 <code>GIT_DIR</code> 을 설정합니다. <a href="https://github.com/rust-lang/cargo/pull/14860">#14860</a></li>
<li>워크스페이스의 Cargo.toml 수정이 빌드 캐시를 무효화하지 않던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14973">#14973</a></li>
<li><code>RUSTFLAGS</code> 변경 후 빌드 캐시가 폐기되지 않도록 방지했습니다. <a href="https://github.com/rust-lang/cargo/pull/14830">#14830</a> <a href="https://github.com/rust-lang/cargo/pull/14898">#14898</a></li>
<li>cargo-add: 이름을 정규화할 때 yank된 버전을 선택하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14895">#14895</a></li>
<li>cargo-fix: 가상 매니페스트(virtual manifest)에 대해서도 워크스페이스 의존성을 2024 에디션으로 마이그레이션합니다. <a href="https://github.com/rust-lang/cargo/pull/14890">#14890</a></li>
<li>cargo-package: <code>package.readme</code> 및 <code>package.license-file</code> 이 현재 패키지 루트 외부의 경로를 가리킬 때 VCS 상태를 검증합니다. <a href="https://github.com/rust-lang/cargo/pull/14966">#14966</a></li>
<li>cargo-package: 차단 가능성이 있는 비파일(예: FIFO)이 게시에 포함되지 않도록 보장합니다. <a href="https://github.com/rust-lang/cargo/pull/14977">#14977</a></li>
</ul>
<h3 id="나이틀리nightly-전용-10"><a class="header" href="#나이틀리nightly-전용-10">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><code>path-bases</code>: 가상 매니페스트의 <code>[patch]</code> 섹션에서 베이스를 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/14931">#14931</a></li>
<li><code>unit-graph</code>: 설정을 통해 지정된 셸을 사용하여 출력을 프린트합니다. <a href="https://github.com/rust-lang/cargo/pull/14926">#14926</a></li>
<li><code>-Zbuild-std</code>: 타겟 명세 JSON의 <code>metadata.std</code> 필드를 조사하여 빌드 타겟이 <code>std</code> 를 지원하는지 확인합니다. <a href="https://github.com/rust-lang/cargo/pull/14183">#14183</a> <a href="https://github.com/rust-lang/cargo/pull/14938">#14938</a> <a href="https://github.com/rust-lang/cargo/pull/14899">#14899</a></li>
<li><code>-Zbuild-std</code>: 절차적 매크로(proc-macro)를 테스트할 때 항상 std에 링크합니다. <a href="https://github.com/rust-lang/cargo/pull/14850">#14850</a> <a href="https://github.com/rust-lang/cargo/pull/14861">#14861</a></li>
<li><code>-Zbuild-std</code>: build-std 테스트를 정리했습니다. <a href="https://github.com/rust-lang/cargo/pull/14943">#14943</a> <a href="https://github.com/rust-lang/cargo/pull/14933">#14933</a> <a href="https://github.com/rust-lang/cargo/pull/14896">#14896</a></li>
<li><code>-Zbuild-std</code>: 절대 경로 대신 std 워크스페이스에 대한 상대 경로를 해싱합니다. <a href="https://github.com/rust-lang/cargo/pull/14951">#14951</a></li>
<li><code>-Zpackage-workspace</code>: 버전이 올라가지 않은 워크스페이스의 드라이 런(dry-run)을 허용합니다. <a href="https://github.com/rust-lang/cargo/pull/14847">#14847</a></li>
<li><code>-Zscript</code>: cargo 스크립트에서 의존성을 추가/제거할 수 있도록 허용합니다. <a href="https://github.com/rust-lang/cargo/pull/14857">#14857</a></li>
<li><code>-Zscript</code>: 여러 에디션에 걸쳐 cargo 스크립트 매니페스트를 마이그레이션합니다. <a href="https://github.com/rust-lang/cargo/pull/14864">#14864</a></li>
<li><code>-Zscript</code>: 릴리스 프로파일을 재정의하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/14925">#14925</a></li>
<li><code>-Ztrim-paths</code>: <code>remap-path-prefix</code> 플래그를 생성하기 위해 <code>Path::push</code> 를 사용합니다. <a href="https://github.com/rust-lang/cargo/pull/14908">#14908</a></li>
</ul>
<h3 id="문서-10"><a class="header" href="#문서-10">문서</a></h3>
<ul>
<li><code>cargo::metadata</code> 환경 변수가 선택되는 방식을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/14842">#14842</a></li>
<li>cargo-info: <code>cargo-info</code> 문서에서 기본 레지스트리에 대한 참조를 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/14880">#14880</a></li>
<li>contrib: Rustup Cargo 우회책에 누락된 인수를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/14954">#14954</a></li>
<li>SemVer: RPIT 캡처에 대한 섹션을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/14849">#14849</a></li>
</ul>
<h3 id="내부-변경-10"><a class="header" href="#내부-변경-10">내부 변경</a></h3>
<ul>
<li>컴파일러 변경 전에 <code>test</code> cfg를 잘 알려진(well known) cfg로 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/14963">#14963</a></li>
<li>triagebot 머지 충돌 알림을 활성화했습니다. <a href="https://github.com/rust-lang/cargo/pull/14972">#14972</a></li>
<li>릴리스 트리거를 <code>0.*</code> 태그로 제한했습니다. <a href="https://github.com/rust-lang/cargo/pull/14940">#14940</a></li>
<li><code>SourceID</code> 해시를 단순화했습니다. <a href="https://github.com/rust-lang/cargo/pull/14800">#14800</a></li>
<li>build-rs: 빌드 스크립트 실행을 위해 Cargo가 설정하는 환경 변수에 액세스할 때 <code>rerun-if-env-changed</code> 를 자동으로 출력합니다. <a href="https://github.com/rust-lang/cargo/pull/14911">#14911</a></li>
<li>build-rs: assert 내의 항목을 올바르게 참조하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14913">#14913</a></li>
<li>build-rs: ‘error’ 지시어를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/14910">#14910</a></li>
<li>build-rs: 의미 없는 ’cargo_cfg_debug_assertions’를 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/14901">#14901</a></li>
<li>cargo-package: <code>cargo_package</code> 를 모듈로 분리했습니다. <a href="https://github.com/rust-lang/cargo/pull/14959">#14959</a> <a href="https://github.com/rust-lang/cargo/pull/14982">#14982</a></li>
<li>cargo-test-support: <code>requires</code> 속성이 명령어에 대해 문자열 리터럴을 허용합니다. <a href="https://github.com/rust-lang/cargo/pull/14875">#14875</a></li>
<li>cargo-test-support: ’exec_with_output’에서 ’run’으로 전환했습니다. <a href="https://github.com/rust-lang/cargo/pull/14848">#14848</a></li>
<li>cargo-test-support: <code>.crate</code> 파일 게시 검증을 위해 호출자(caller)를 추적합니다. <a href="https://github.com/rust-lang/cargo/pull/14992">#14992</a></li>
<li>test: <code>-Cextra-filename</code> 을 통하지 않고 <code>-Cmetadata</code> 를 직접 검증합니다. <a href="https://github.com/rust-lang/cargo/pull/14846">#14846</a></li>
<li>test: PGO가 작동하는지 보장합니다. <a href="https://github.com/rust-lang/cargo/pull/14859">#14859</a> <a href="https://github.com/rust-lang/cargo/pull/14874">#14874</a> <a href="https://github.com/rust-lang/cargo/pull/14887">#14887</a></li>
<li>의존성을 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/14867">#14867</a> <a href="https://github.com/rust-lang/cargo/pull/14871">#14871</a> <a href="https://github.com/rust-lang/cargo/pull/14878">#14878</a> <a href="https://github.com/rust-lang/cargo/pull/14879">#14879</a> <a href="https://github.com/rust-lang/cargo/pull/14975">#14975</a></li>
</ul>
<h2 id="cargo-184-2025-01-09"><a class="header" href="#cargo-184-2025-01-09">Cargo 1.84 (2025-01-09)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/15fbd2f6...rust-1.84.0">15fbd2f6…rust-1.84.0</a></p>
<h3 id="추가됨-11"><a class="header" href="#추가됨-11">추가됨</a></h3>
<ul>
<li>🎉 resolver v3(일명 MSRV 인식 의존성 해결사)를 안정화했습니다. 이번 안정화에는 Cargo.toml의 <code>package.resolver = "3"</code> 과 Cargo 설정의 <code>[resolver]</code> 테이블이 포함됩니다. (<a href="https://github.com/rust-lang/rfcs/blob/master/text/3537-msrv-resolver.md">RFC 3537</a>) (<a href="https://doc.rust-lang.org/nightly/cargo/reference/resolver.html#resolver-versions">매니페스트 문서</a>) (<a href="https://doc.rust-lang.org/nightly/cargo/reference/config.html#resolver">설정 문서</a>) <a href="https://github.com/rust-lang/cargo/pull/14639">#14639</a> <a href="https://github.com/rust-lang/cargo/pull/14662">#14662</a> <a href="https://github.com/rust-lang/cargo/pull/14711">#14711</a> <a href="https://github.com/rust-lang/cargo/pull/14725">#14725</a> <a href="https://github.com/rust-lang/cargo/pull/14748">#14748</a> <a href="https://github.com/rust-lang/cargo/pull/14753">#14753</a> <a href="https://github.com/rust-lang/cargo/pull/14754">#14754</a></li>
<li>에러 메시지를 보고하기 위해 새로운 빌드 스크립트 호출 방식인 <code>cargo::error=MESSAGE</code> 를 추가했습니다. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/build-scripts.html#cargo-error">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/14743">#14743</a></li>
</ul>
<h3 id="변경됨-11"><a class="header" href="#변경됨-11">변경됨</a></h3>
<ul>
<li>❗️ cargo-publish: 게시되는 크레이트에 항상 Cargo.lock을 포함합니다. 원래는 <code>cargo install</code> 과 함께 사용되는 실행 파일이나 예제가 있는 패키지에만 포함되었습니다. <a href="https://github.com/rust-lang/cargo/pull/14815">#14815</a></li>
<li>공유 캐싱, 반복 오버헤드 감소, 불필요한 페치 및 클론 제거 등 의존성 해결사의 성능이 개선되었습니다. <a href="https://github.com/rust-lang/cargo/pull/14663">#14663</a> <a href="https://github.com/rust-lang/cargo/pull/14690">#14690</a> <a href="https://github.com/rust-lang/cargo/pull/14692">#14692</a> <a href="https://github.com/rust-lang/cargo/pull/14694">#14694</a></li>
<li><code>cargo verify-project</code> 를 사용 중단했습니다. <a href="https://github.com/rust-lang/cargo/pull/14736">#14736</a></li>
<li>의존성 해결 중 일치하는 패키지를 찾을 수 없을 때 소스 교체(source replacement) 정보를 추가합니다. <a href="https://github.com/rust-lang/cargo/pull/14715">#14715</a></li>
<li><code>[patch.crates.io]</code> 가 발견되었을 때 <code>crates-io</code> 사용에 대한 힌트를 제공합니다. <a href="https://github.com/rust-lang/cargo/pull/14700">#14700</a></li>
<li>더 나은 진단을 위해 Cargo 타겟의 소스 경로를 정규화합니다. <a href="https://github.com/rust-lang/cargo/pull/14497">#14497</a> <a href="https://github.com/rust-lang/cargo/pull/14750">#14750</a></li>
<li>레지스트리가 인덱스 메타데이터 JSON에서 빈 필드나 기본 필드를 생략할 수 있도록 허용합니다. 하위 호환성을 위해 crates.io는 계속해서 이를 출력합니다. <a href="https://github.com/rust-lang/cargo/pull/14838">#14838</a> <a href="https://github.com/rust-lang/cargo/pull/14839">#14839</a></li>
<li>cargo-doc: 추가 상세(extra verbose) 모드에서 환경 변수를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/14812">#14812</a></li>
<li>cargo-fix: 중복된 삽입 전용(insert-only) 교체의 특수 사례 처리를 대체했습니다. <a href="https://github.com/rust-lang/cargo/pull/14765">#14765</a> <a href="https://github.com/rust-lang/cargo/pull/14782">#14782</a></li>
<li>cargo-remove: 의존성을 찾을 수 없을 때 이름이 비슷한 다른 의존성을 제안합니다. <a href="https://github.com/rust-lang/cargo/pull/14818">#14818</a></li>
<li>git: Git 의존성의 신규 체크아웃에 대해 불필요한 서브모듈 검증을 건너뜁니다. <a href="https://github.com/rust-lang/cargo/pull/14605">#14605</a></li>
<li>git: refspec을 찾을 수 없을 때 Git 의존성을 가져오는 과정의 에러 메시지를 강화했습니다. <a href="https://github.com/rust-lang/cargo/pull/14806">#14806</a></li>
<li>git: <code>net.git-fetch-with-cli = true</code> 인 경우 git CLI에 기본적으로 <code>--no-tags</code> 를 전달합니다. <a href="https://github.com/rust-lang/cargo/pull/14688">#14688</a></li>
</ul>
<h3 id="수정됨-11"><a class="header" href="#수정됨-11">수정됨</a></h3>
<ul>
<li>이전 버전의 Cargo가 빌드 캐시의 새로운 dep-info 형식을 읽지 못하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14751">#14751</a> <a href="https://github.com/rust-lang/cargo/pull/14745">#14745</a></li>
<li><code>[env]</code> 테이블의 변경 사항이 재빌드 감지에 반영되지 않던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14701">#14701</a> <a href="https://github.com/rust-lang/cargo/pull/14730">#14730</a></li>
<li>cargo-fix: 여러 제안이 겹치는 영역을 포함할 때 코드 수정을 유효한 상태로 유지하기 위해 <code>rustfix</code> 에 트랜잭션 시맨틱을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/14747">#14747</a></li>
</ul>
<h3 id="나이틀리nightly-전용-11"><a class="header" href="#나이틀리nightly-전용-11">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>불안정 환경 변수인 <code>CARGO_RUSTC_CURRENT_DIR</code> 이 제거되었습니다. <a href="https://github.com/rust-lang/cargo/pull/14799">#14799</a></li>
<li>🔥 Cargo 소스 코드에 <code>Cargo.toml</code> 을 위한 실험적인 JSON 스키마 파일이 포함되었습니다. 외부 도구에서 매니페스트의 스키마를 검증하거나 자동 완성하는 데 도움이 됩니다. (<a href="https://github.com/rust-lang/cargo/blob/master/crates/cargo-util-schemas/manifest.schema.json">manifest.schema.json</a>) <a href="https://github.com/rust-lang/cargo/pull/14683">#14683</a></li>
<li>🔥 <code>Zroot-dir</code>: rustc가 호출되어야 하는 경로를 구성하기 위한 새로운 불안정 플래그 <code>-Zroot-dir</code> 이 추가되었습니다. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#root-dir">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/14752">#14752</a></li>
<li>🔥 <code>-Zwarnings</code>: <code>build.warnings</code> 설정 필드를 통해 Cargo가 경고를 처리하는 방식을 제어하는 새로운 불안정 기능이 추가되었습니다. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#warnings">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/14388">#14388</a> <a href="https://github.com/rust-lang/cargo/pull/14827">#14827</a> <a href="https://github.com/rust-lang/cargo/pull/14836">#14836</a></li>
<li><code>edition2024</code>: 2024 에디션 / resolver=3가 해결 과정에 영향을 미치지 않음을 검증했습니다. <a href="https://github.com/rust-lang/cargo/pull/14724">#14724</a></li>
<li><code>native-completions</code>: zsh에서 설명을 포함합니다. <a href="https://github.com/rust-lang/cargo/pull/14726">#14726</a></li>
<li><code>-Zbindeps</code>: 교차 컴파일된 bindep이 있는 패키지에서 <code>cargo tree</code> 를 실행할 때 발생하는 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14593">#14593</a></li>
<li><code>-Zbindeps</code>: 아티팩트 의존성의 타겟 플랫폼과 함께 타겟팅된 전이 의존성을 다운로드합니다. <a href="https://github.com/rust-lang/cargo/pull/14723">#14723</a></li>
<li><code>-Zbuild-std</code>: <code>--target</code> 요구 사항을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/14317">#14317</a></li>
<li><code>-Zpackage-workspace</code>: <code>cargo publish</code> 에서 <code>--exclude</code> 와 같은 패키지 선택 옵션을 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/14659">#14659</a></li>
<li><code>-Zscript</code>: <code>Cargo.toml</code> 수용 지원을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/14670">#14670</a></li>
<li><code>-Zscript</code>: <code>CARGO_HOME</code> 만 확인하도록 설정 경로를 변경했습니다. <a href="https://github.com/rust-lang/cargo/pull/14749">#14749</a></li>
<li><code>-Zscript</code>: RFC 3503에 맞춰 프론트매터 파서를 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/14792">#14792</a></li>
</ul>
<h3 id="문서-11"><a class="header" href="#문서-11">문서</a></h3>
<ul>
<li><code>--tests</code> 및 <code>--benches</code> 플래그의 의미를 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/14675">#14675</a></li>
<li>도구들이 <code>{</code> 로 시작하는 줄만 JSON 메시지로 해석해야 함을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/14677">#14677</a></li>
<li><code>cargo package</code> 에 포함되는 것과 포함되지 않는 것을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/14684">#14684</a></li>
<li>공식 외부 명령어인 <code>cargo-clippy</code>, <code>cargo-fmt</code>, <code>cargo-miri</code> 를 문서화했습니다. <a href="https://github.com/rust-lang/cargo/pull/14669">#14669</a> <a href="https://github.com/rust-lang/cargo/pull/14805">#14805</a></li>
<li>환경 변수에 대한 문서를 강화했습니다. <a href="https://github.com/rust-lang/cargo/pull/14676">#14676</a></li>
<li>문서에 사용된 영어를 단순화했습니다. <a href="https://github.com/rust-lang/cargo/pull/14825">#14825</a> <a href="https://github.com/rust-lang/cargo/pull/14829">#14829</a></li>
<li>사용 중단 및 제거된 명령어에 대한 새로운 문서 페이지를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/14739">#14739</a></li>
<li>cargo-test-support: 포팅 작업에 기반하여 <code>Execs</code> 단언(assertion)을 문서화했습니다. <a href="https://github.com/rust-lang/cargo/pull/14793">#14793</a></li>
</ul>
<h3 id="내부-변경-11"><a class="header" href="#내부-변경-11">내부 변경</a></h3>
<ul>
<li>🎉 <code>build-rs</code> 크레이트를 Cargo 팀의 공식 결과물로서 <code>rust-lang/cargo</code> 저장소로 이전했습니다. <a href="https://github.com/rust-lang/cargo/pull/14786">#14786</a> <a href="https://github.com/rust-lang/cargo/pull/14817">#14817</a></li>
<li>triagebot에서 이전(transfer) 기능을 활성화했습니다. <a href="https://github.com/rust-lang/cargo/pull/14777">#14777</a></li>
<li>InternedString에 대해 필요할 때 복사(clone-on-write)를 수행하도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/14808">#14808</a></li>
<li>ci: CI를 bors에서 머지 큐(merge queue)로 전환했습니다. <a href="https://github.com/rust-lang/cargo/pull/14718">#14718</a></li>
<li>ci: <code>lint-docs</code> 작업을 필수 항목으로 만들었습니다. <a href="https://github.com/rust-lang/cargo/pull/14797">#14797</a></li>
<li>ci: 클리피(clippy)의 <code>correctness</code> 를 확인합니다. <a href="https://github.com/rust-lang/cargo/pull/14796">#14796</a></li>
<li>ci: renovate를 위해 matchPackageNames를 matchDepNames로 전환했습니다. <a href="https://github.com/rust-lang/cargo/pull/14704">#14704</a></li>
<li>fingerprint: <code>UnitHash</code> 각 사용의 의도를 추적하도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/14826">#14826</a></li>
<li>fingerprint: <code>rustc_fingerprint</code> 에 더 많은 메타데이터를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/14761">#14761</a></li>
<li>test: 남은 스냅샷 테스트들을 snapbox로 마이그레이션했습니다. <a href="https://github.com/rust-lang/cargo/pull/14642">#14642</a> <a href="https://github.com/rust-lang/cargo/pull/14760">#14760</a> <a href="https://github.com/rust-lang/cargo/pull/14781">#14781</a> <a href="https://github.com/rust-lang/cargo/pull/14785">#14785</a> <a href="https://github.com/rust-lang/cargo/pull/14790">#14790</a></li>
<li>의존성을 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/14668">#14668</a> <a href="https://github.com/rust-lang/cargo/pull/14705">#14705</a> <a href="https://github.com/rust-lang/cargo/pull/14762">#14762</a> <a href="https://github.com/rust-lang/cargo/pull/14766">#14766</a> <a href="https://github.com/rust-lang/cargo/pull/14772">#14772</a></li>
</ul>
<h2 id="cargo-183-2024-11-28"><a class="header" href="#cargo-183-2024-11-28">Cargo 1.83 (2024-11-28)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/8f40fc59...rust-1.83.0">8f40fc59…rust-1.83.0</a></p>
<h3 id="추가됨-12"><a class="header" href="#추가됨-12">추가됨</a></h3>
<ul>
<li><code>--timings</code> HTML 출력이 이제 브라우저 설정에 따라 라이트 모드와 다크 모드 사이를 자동으로 전환할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/14588">#14588</a></li>
<li><code>CARGO_MANIFEST_DIR</code> 와 비슷하지만 매니페스트 파일을 직접 가리키는 새로운 <code>CARGO_MANIFEST_PATH</code> 환경 변수를 도입했습니다. <a href="https://github.com/rust-lang/cargo/pull/14404">#14404</a></li>
<li>manifest: <code>package.autolib</code> 를 추가하여 <code>[lib]</code> 자동 감지를 비활성화할 수 있도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/14591">#14591</a></li>
</ul>
<h3 id="변경됨-12"><a class="header" href="#변경됨-12">변경됨</a></h3>
<ul>
<li>❗️ Lockfile format v4 is now the default for creating/updating a lockfile. Rust toolchains 1.78+ support lockfile v4. For compatibility with earlier MSRV, consider setting the <code>package.rust-version</code> to 1.82 or earlier. <a href="https://github.com/rust-lang/cargo/pull/14595">#14595</a></li>
<li>❗️ cargo-package: <code>--package</code> 플래그를 사용할 때 지정된 패키지만 패키징됩니다. 이전에는 현재 작업 디렉토리의 패키지가 자동으로 패키징 대상으로 선택되었습니다. <a href="https://github.com/rust-lang/cargo/pull/14488">#14488</a></li>
<li>cargo-publish: 패키지 버전이 이미 게시된 경우 이제 즉시 실패(fail-fast)합니다. <a href="https://github.com/rust-lang/cargo/pull/14448">#14448</a></li>
<li>누락된 기능에 대한 에러 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/14436">#14436</a></li>
<li>에러가 표시되지 않는 경우 <code>rustc</code> 호출 실패의 세부 정보를 로그에 기록합니다. <a href="https://github.com/rust-lang/cargo/pull/14453">#14453</a></li>
<li><code>windows-gnullvm</code> 임포트 라이브러리를 <code>windows-gnu</code> 와 일치하도록 업그레이드했습니다. <a href="https://github.com/rust-lang/cargo/pull/14451">#14451</a></li>
<li><code>cargo search</code> 결과에서 <code>cargo info</code> 명령어를 제안하도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/14537">#14537</a></li>
<li>의존성 업데이트 상태 메시지를 강화하여, 이제 호환성(호환, 비호환, 직접 의존성)에 따라 다른 색상으로 업데이트를 표시하며 메시지와 MSRV도 함께 보여줍니다. <a href="https://github.com/rust-lang/cargo/pull/14440">#14440</a> <a href="https://github.com/rust-lang/cargo/pull/14457">#14457</a> <a href="https://github.com/rust-lang/cargo/pull/14459">#14459</a> <a href="https://github.com/rust-lang/cargo/pull/14461">#14461</a> <a href="https://github.com/rust-lang/cargo/pull/14471">#14471</a> <a href="https://github.com/rust-lang/cargo/pull/14568">#14568</a></li>
<li><code>Locking</code> 상태 메시지에 더 이상 워크스페이스 멤버가 표시되지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/14445">#14445</a></li>
</ul>
<h3 id="수정됨-12"><a class="header" href="#수정됨-12">수정됨</a></h3>
<ul>
<li><code>cargo</code> 를 재귀적으로 호출할 때 라이브러리 검색 환경 변수가 중복되는 것을 방지했습니다. <a href="https://github.com/rust-lang/cargo/pull/14464">#14464</a></li>
<li><code>$CARGO_HOME/config</code> 에 <code>.toml</code> 확장자가 없다는 경고가 중복해서 표시되지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14579">#14579</a></li>
<li><code>--message-format json</code> 사용 시 진단 카운트 메시지를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14598">#14598</a></li>
<li>cargo-add: 패키지 이름을 번역할 때 퍼지(fuzzy) 검색을 수행합니다. <a href="https://github.com/rust-lang/cargo/pull/13765">#13765</a></li>
<li>cargo-new: 현재 디렉토리가 아닌 매니페스트를 기준으로 워크스페이스에 새 패키지를 자동 추가합니다. <a href="https://github.com/rust-lang/cargo/pull/14505">#14505</a></li>
<li>cargo-rustc: <code>--crate-type</code> 플래그에서 쉼표로 구분된 값의 파싱 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14499">#14499</a></li>
<li>cargo-vendor: 레지스트리에서 유래한 경우에만 크레이트 버전을 신뢰합니다. 이로 인해 git 의존성은 변경되지 않았더라도 다시 벤더링됩니다. <a href="https://github.com/rust-lang/cargo/pull/14530">#14530</a></li>
<li>cargo-publish: 드라이 런(dry-run) 시 버전 중복 에러를 경고로 등급을 낮췄습니다. <a href="https://github.com/rust-lang/cargo/pull/14742">#14742</a> <a href="https://github.com/rust-lang/cargo/pull/14744">#14744</a></li>
</ul>
<h3 id="나이틀리nightly-전용-12"><a class="header" href="#나이틀리nightly-전용-12">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>❗️ cargo-rustc: 나이틀리에서 뒤에 오는 플래그에 더 높은 우선순위를 부여합니다. 이 기능은 몇 번의 릴리스 후에 안정화될 예정입니다. 워크플로에 문제가 생기면 피드백을 주세요. 이 동작을 비활성화하기 위해 임시 환경 변수 <code>__CARGO_RUSTC_ORIG_ARGS_PRIO=1</code> 이 제공됩니다. <a href="https://github.com/rust-lang/cargo/pull/14587">#14587</a></li>
<li>🔥 cargo-install: 실제로 바이너리를 설치하지 않고 확인만 하는 새로운 <code>--dry-run</code> 플래그를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/14280">#14280</a></li>
<li>🔥 <code>native-completions</code>: 수동으로 작성된 셸 완성 스크립트를 Rust 네이티브로 옮겨, 새로운 완성을 추가, 확장 및 테스트하기 쉽게 만들었습니다. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#native-completions">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/14493">#14493</a> <a href="https://github.com/rust-lang/cargo/pull/14531">#14531</a> <a href="https://github.com/rust-lang/cargo/pull/14532">#14532</a> <a href="https://github.com/rust-lang/cargo/pull/14533">#14533</a> <a href="https://github.com/rust-lang/cargo/pull/14534">#14534</a> <a href="https://github.com/rust-lang/cargo/pull/14535">#14535</a> <a href="https://github.com/rust-lang/cargo/pull/14536">#14536</a> <a href="https://github.com/rust-lang/cargo/pull/14546">#14546</a> <a href="https://github.com/rust-lang/cargo/pull/14547">#14547</a> <a href="https://github.com/rust-lang/cargo/pull/14548">#14548</a> <a href="https://github.com/rust-lang/cargo/pull/14552">#14552</a> <a href="https://github.com/rust-lang/cargo/pull/14557">#14557</a> <a href="https://github.com/rust-lang/cargo/pull/14558">#14558</a> <a href="https://github.com/rust-lang/cargo/pull/14563">#14563</a> <a href="https://github.com/rust-lang/cargo/pull/14564">#14564</a> <a href="https://github.com/rust-lang/cargo/pull/14573">#14573</a> <a href="https://github.com/rust-lang/cargo/pull/14590">#14590</a> <a href="https://github.com/rust-lang/cargo/pull/14592">#14592</a> <a href="https://github.com/rust-lang/cargo/pull/14653">#14653</a> <a href="https://github.com/rust-lang/cargo/pull/14656">#14656</a></li>
<li>🔥 <code>-Zchecksum-freshness</code>: Cargo의 재빌드 감지에서 파일의 mtime(수정 시간) 대신 파일 체크섬 알고리즘을 사용하도록 대체합니다. 이는 mtime 구현이 부실한 시스템이나 CI/CD 환경에서 유용합니다. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#checksum-freshness">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/14137">#14137</a></li>
<li>cargo-update: <code>matches_prerelease</code> 시맨틱을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/14305">#14305</a></li>
<li><code>build-plan</code>: 사용 중단(deprecated)되었음을 문서화했습니다. <a href="https://github.com/rust-lang/cargo/pull/14657">#14657</a></li>
<li><code>edition2024</code>: 2024 에디션에서 암시적인 기능 제거를 취소했습니다. <a href="https://github.com/rust-lang/cargo/pull/14630">#14630</a></li>
<li><code>lockfile-path</code>: <code>cargo install</code> 시 <code>--locked</code> 를 함축하도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/14556">#14556</a></li>
<li><code>open-namespaces</code>: <code>PackageIdSpec</code> 에서 열린 네임스페이스를 허용합니다. <a href="https://github.com/rust-lang/cargo/pull/14467">#14467</a></li>
<li><code>path-bases</code>: <code>cargo [add|remove|update]</code> 에서 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/14427">#14427</a></li>
<li><code>-Zmsrv-policy</code>: 워크스페이스 내에서 가장 많이 사용되는 MSRV를 기준으로 워크스페이스의 MSRV를 결정합니다. <a href="https://github.com/rust-lang/cargo/pull/14569">#14569</a></li>
<li><code>-Zpackage-workspace</code>: 워크스페이스 내의 여러 크레이트가 서로 의존 관계에 있더라도 동시에 게시할 수 있도록 허용합니다. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#package-workspace">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/14433">#14433</a> <a href="https://github.com/rust-lang/cargo/pull/14496">#14496</a></li>
<li><code>-Zpublic-dependency</code>: <code>cargo metadata</code> 에 공개/비공개 의존성 상태를 포함합니다. <a href="https://github.com/rust-lang/cargo/pull/14504">#14504</a></li>
<li><code>-Zpublic-dependency</code>: MSRV 상향 조정을 요구하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/14507">#14507</a></li>
</ul>
<h3 id="문서-12"><a class="header" href="#문서-12">문서</a></h3>
<ul>
<li>🎉 <code>package.rust-version</code>(일명 MSRV)의 사용법, 지원 기대치 및 관리에 대한 새로운 장을 추가했습니다. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/rust-version.html">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/14619">#14619</a> <a href="https://github.com/rust-lang/cargo/pull/14636">#14636</a></li>
<li><code>target.'cfg(...)'</code> 이 빌드 스크립트의 cfg를 따르지 않음을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/14312">#14312</a></li>
<li><code>[[bin]]</code> 타겟 자동 감지가 <code>src/main.rs</code> 및/또는 <code>src/bin/</code> 에 있을 수 있음을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/14515">#14515</a></li>
<li>기능 해결사(feature resolver) v2 문서에서 ’target’의 사용법을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/14540">#14540</a></li>
<li><code>--config &lt;PATH&gt;</code> 를 더 눈에 띄게 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14631">#14631</a></li>
<li>페이지들의 구성을 소폭 재조정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14620">#14620</a></li>
<li>contrib: cargo 게시 방식에 대한 문서를 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/14539">#14539</a></li>
<li>contrib: Cargo 헌장 및 크레이트 문서에서 각 크레이트에 대한 지원 수준을 선언했습니다. <a href="https://github.com/rust-lang/cargo/pull/14600">#14600</a></li>
<li>contrib: 새로운 공식 결과물(Intentional Artifacts)을 ‘작은(small)’ 변경으로 선언했습니다. <a href="https://github.com/rust-lang/cargo/pull/14599">#14599</a></li>
</ul>
<h3 id="내부-변경-12"><a class="header" href="#내부-변경-12">내부 변경</a></h3>
<ul>
<li>중복된 check-cfg 린트 로직을 정리했습니다. <a href="https://github.com/rust-lang/cargo/pull/14567">#14567</a></li>
<li>나이틀리 rustc 변경으로 인한 생략된 라이프타임 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14487">#14487</a></li>
<li><code>activated_features</code> 에서 기능을 찾을 수 없을 때의 에러 보고를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/14647">#14647</a></li>
<li>cargo-info: <code>shell.note</code> 를 사용하여 노트를 프린트하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14554">#14554</a></li>
<li>ci: CI 도구 버전을 올렸습니다. <a href="https://github.com/rust-lang/cargo/pull/14503">#14503</a> <a href="https://github.com/rust-lang/cargo/pull/14628">#14628</a></li>
<li>성능: 가능한 경우 컴파일러 메시지에 대해 제로 카피(zero-copy) 역직렬화를 사용합니다. <a href="https://github.com/rust-lang/cargo/pull/14608">#14608</a></li>
<li>resolver: SAT 해결사(SAT resolver) 테스트를 더 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/14583">#14583</a> <a href="https://github.com/rust-lang/cargo/pull/14614">#14614</a></li>
<li>test: 더 많은 테스트를 snapbox로 마이그레이션했습니다. <a href="https://github.com/rust-lang/cargo/pull/14576">#14576</a> <a href="https://github.com/rust-lang/cargo/pull/14577">#14577</a></li>
<li>의존성을 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/14475">#14475</a> <a href="https://github.com/rust-lang/cargo/pull/14478">#14478</a> <a href="https://github.com/rust-lang/cargo/pull/14489">#14489</a> <a href="https://github.com/rust-lang/cargo/pull/14607">#14607</a> <a href="https://github.com/rust-lang/cargo/pull/14624">#14624</a> <a href="https://github.com/rust-lang/cargo/pull/14632">#14632</a></li>
</ul>
<h2 id="cargo-182-2024-10-17"><a class="header" href="#cargo-182-2024-10-17">Cargo 1.82 (2024-10-17)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/a2b58c3d...rust-1.82.0">a2b58c3d…rust-1.82.0</a></p>
<h3 id="추가됨-13"><a class="header" href="#추가됨-13">추가됨</a></h3>
<ul>
<li>🎉 패키지에 대한 정보를 표시하는 <code>cargo info</code> 명령어를 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/commands/cargo-info.html">문서</a> <a href="https://github.com/rust-lang/cargo/pull/14141">#14141</a> <a href="https://github.com/rust-lang/cargo/pull/14418">#14418</a> <a href="https://github.com/rust-lang/cargo/pull/14430">#14430</a></li>
</ul>
<h3 id="변경됨-13"><a class="header" href="#변경됨-13">변경됨</a></h3>
<ul>
<li>❗️ Doctest가 rustdoc 호출 시 <code>--color</code> 를 전달하여 Cargo의 색상 옵션을 따르도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14425">#14425</a></li>
<li>Cargo.toml에 <code>[package]</code> 와 <code>[workspace]</code> 가 모두 없을 때의 에러 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/14261">#14261</a></li>
<li>에러 메시지에서 <code>profile.*.debug</code> 에 사용할 수 있는 모든 값을 열거하도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/14413">#14413</a></li>
</ul>
<h3 id="수정됨-13"><a class="header" href="#수정됨-13">수정됨</a></h3>
<ul>
<li>긴 형식의(longhand) gitoxide path-spec 패턴을 사용합니다. 이전에는 짧은 형식의 path-spec을 사용하여, 예를 들어 매니페스트 파일 경로가 밑줄(<code>_</code>)로 시작하는 경우 유효하지 않은 구문이 생성될 수 있었습니다. <a href="https://github.com/rust-lang/cargo/pull/14380">#14380</a></li>
<li>cargo-package: 베어(bare) 커밋 git 저장소에서의 실패 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14359">#14359</a></li>
<li>cargo-publish: 레지스트리로 전송되는 HTTP JSON 바디에서 이름이 변경된 의존성의 비-개발용 기능을 제거하지 않도록 수정했습니다. 이 버그는 서드파티 레지스트리에만 영향을 미쳤습니다. <a href="https://github.com/rust-lang/cargo/pull/14325">#14325</a> <a href="https://github.com/rust-lang/cargo/pull/14327">#14327</a></li>
<li>cargo-vendor: 벤더링할 때 제외된 Cargo 타겟의 소스 파일을 복사하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14367">#14367</a></li>
</ul>
<h3 id="나이틀리nightly-전용-13"><a class="header" href="#나이틀리nightly-전용-13">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>🔥 <code>lockfile-path</code>: 기본 경로인 <code>&lt;workspace_root&gt;/Cargo.lock</code> 외에 다른 잠금 파일 경로를 지정할 수 있는 <code>--lockfile-path</code> 플래그를 추가했습니다. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#lockfile-path">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/14326">#14326</a> <a href="https://github.com/rust-lang/cargo/pull/14417">#14417</a> <a href="https://github.com/rust-lang/cargo/pull/14423">#14423</a> <a href="https://github.com/rust-lang/cargo/pull/14424">#14424</a></li>
<li>🔥 <code>path-bases</code>: 경로(path) 의존성 및 패치(patch) 항목의 경로 앞에 붙일 수 있는 경로 “bases” 테이블을 Cargo 설정 파일에 도입했습니다. (<a href="https://github.com/rust-lang/rfcs/blob/master/text/3529-cargo-path-bases.md">RFC 3529</a>) (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#path-bases">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/14360">#14360</a></li>
<li>🔥 <code>-Zpackage-workspace</code>: 워크스페이스 내 크레이트들 사이에 의존성이 있을 때 <code>cargo package --workspace</code> 의 경험을 개선했습니다. 이제 워크스페이스 내의 크레이트들을 실제 레지스트리에 게시할 필요가 없습니다. 이는 <code>cargo publish --workspace</code> 지원을 위한 단계입니다. <a href="https://github.com/rust-lang/cargo/pull/13947">#13947</a> <a href="https://github.com/rust-lang/cargo/pull/14408">#14408</a> <a href="https://github.com/rust-lang/cargo/pull/14340">#14340</a></li>
<li>cargo-update: 프리릴리스 매치 시맨틱을 <code>OptVersionReq::Req</code> 에서만 사용하도록 제한했습니다. <a href="https://github.com/rust-lang/cargo/pull/14412">#14412</a></li>
<li><code>edition2024</code>: “fix: Ensure dep/feature activates the dependency on 2024“를 되돌렸습니다. <a href="https://github.com/rust-lang/cargo/pull/14295">#14295</a></li>
<li><code>update-breaking</code>: <code>update --breaking</code> 에 유효하지 않은 명세(spec)가 있을 때의 에러 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/14279">#14279</a></li>
<li><code>update-breaking</code>: <code>--breaking</code> 으로 업데이트할 때 프리릴리스 <code>VersionReq</code> 에서 다운그레이드하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14250">#14250</a></li>
<li><code>-Zbuild-std</code>: 가상 std 워크스페이스를 생성할 때의 해킹성 코드를 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/14358">#14358</a> <a href="https://github.com/rust-lang/cargo/pull/14370">#14370</a></li>
<li><code>-Zmsrv-policy</code>: MSRV 해결 설정 필드 이름 및 값을 조정했습니다. 이전의 임시 필드명인 <code>resolver.something-like-precedence</code> 가 <code>resolver.incompatible-rust-versions</code>로 변경되었습니다. <a href="https://github.com/rust-lang/cargo/pull/14296">#14296</a></li>
<li><code>-Zmsrv-policy</code>: 호환되지 않는 Rust 버전의 패키지가 선택되었을 때 보고하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14401">#14401</a></li>
<li><code>-Ztarget-applies-to-host</code>: target-applies-to-host 및 암시적 타겟을 사용할 때 links-overrides 전달 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14205">#14205</a></li>
<li><code>-Ztarget-applies-to-host</code>: <code>-Cmetadata</code> 에 추가 rustflags가 호스트와 동일한지 여부를 포함했습니다. <a href="https://github.com/rust-lang/cargo/pull/14432">#14432</a></li>
<li><code>-Ztrim-paths</code>: rustdoc이 진단 메시지에 대해 trim-paths를 지원하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14389">#14389</a></li>
</ul>
<h3 id="문서-13"><a class="header" href="#문서-13">문서</a></h3>
<ul>
<li><code>Workspace</code> 의 주석들을 문서 주석으로 변환했습니다. <a href="https://github.com/rust-lang/cargo/pull/14397">#14397</a></li>
<li><code>workspace.package</code> 및 <code>workspace.dependencies</code> 에 대한 MSRV 표시기를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14400">#14400</a></li>
<li>FAQ: 오래된 Cargo 오프라인 사용 섹션을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/14336">#14336</a></li>
</ul>
<h3 id="내부-변경-13"><a class="header" href="#내부-변경-13">내부 변경</a></h3>
<ul>
<li><code>cargo-test-support</code> 의 사용성 및 문서를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/14266">#14266</a> <a href="https://github.com/rust-lang/cargo/pull/14268">#14268</a> <a href="https://github.com/rust-lang/cargo/pull/14269">#14269</a> <a href="https://github.com/rust-lang/cargo/pull/14270">#14270</a> <a href="https://github.com/rust-lang/cargo/pull/14272">#14272</a></li>
<li><code>Rc</code> 대신 <code>Arc</code> 를 사용하여 서머리(summary)를 동기화(sync) 가능하게 만들었습니다. <a href="https://github.com/rust-lang/cargo/pull/14260">#14260</a></li>
<li><code>rustflags</code> 저장에 <code>Arc</code> 대신 <code>Rc</code> 를 사용하도록 변경했습니다. <a href="https://github.com/rust-lang/cargo/pull/14273">#14273</a></li>
<li><code>--check-cfg</code> 지원을 위한 <code>rustc</code> 탐색 코드를 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/14302">#14302</a></li>
<li>매니페스트 정규화와 관련된 모든 항목의 이름을 ’resolved’에서 ’normalized’로 변경했습니다. <a href="https://github.com/rust-lang/cargo/pull/14342">#14342</a></li>
<li>cargo-util-schemas: <code>TomlPackage::new</code> 를 추가하고 <code>TomlWorkspace</code> 에 <code>Default</code> 를 구현했습니다. <a href="https://github.com/rust-lang/cargo/pull/14271">#14271</a></li>
<li>ci: macOS aarch64를 나이틀리(nightly) 채널로 전환했습니다. <a href="https://github.com/rust-lang/cargo/pull/14382">#14382</a></li>
<li>mdman: 옵션을 렌더링할 때 줄바꿈을 정규화하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14428">#14428</a></li>
<li>perf: 아무런 동작도 하지 않는 <code>source_id::with*</code> 호출 시 <code>wrap</code> 을 호출하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14318">#14318</a></li>
<li>test: 더 많은 테스트를 snapbox로 마이그레이션했습니다. <a href="https://github.com/rust-lang/cargo/pull/14242">#14242</a> <a href="https://github.com/rust-lang/cargo/pull/14244">#14244</a> <a href="https://github.com/rust-lang/cargo/pull/14293">#14293</a> <a href="https://github.com/rust-lang/cargo/pull/14297">#14297</a> <a href="https://github.com/rust-lang/cargo/pull/14319">#14319</a> <a href="https://github.com/rust-lang/cargo/pull/14402">#14402</a> <a href="https://github.com/rust-lang/cargo/pull/14410">#14410</a></li>
<li>test: <code>RUST_BACKTRACE</code> 의 부재에 의존하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14441">#14441</a></li>
<li>test: AIX에서 gmake를 사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14323">#14323</a></li>
<li><code>gix</code> 를 0.64.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/14332">#14332</a></li>
<li><code>rusqlite</code> 를 0.32.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/14334">#14334</a></li>
<li><code>windows-sys</code> 를 0.59로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/14335">#14335</a></li>
<li>의존성을 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/14299">#14299</a> <a href="https://github.com/rust-lang/cargo/pull/14303">#14303</a> <a href="https://github.com/rust-lang/cargo/pull/14324">#14324</a> <a href="https://github.com/rust-lang/cargo/pull/14329">#14329</a> <a href="https://github.com/rust-lang/cargo/pull/14331">#14331</a> <a href="https://github.com/rust-lang/cargo/pull/14391">#14391</a></li>
</ul>
<h2 id="cargo-181-2024-09-05"><a class="header" href="#cargo-181-2024-09-05">Cargo 1.81 (2024-09-05)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/34a6a87d...rust-1.81.0">34a6a87d…rust-1.81.0</a></p>
<h3 id="추가됨-14"><a class="header" href="#추가됨-14">추가됨</a></h3>
<h3 id="변경됨-14"><a class="header" href="#변경됨-14">변경됨</a></h3>
<ul>
<li>❗️ cargo-package: 패키징 중에 존재하지 않는 파일을 가리키는 <code>package.license-file</code> 및 <code>package.readme</code> 를 허용하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13921">#13921</a></li>
<li>❗️ cargo-package: 생성된 <code>.cargo_vcs_info.json</code> 은 <code>--allow-dirty</code> 가 전달되더라도 항상 포함되도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13960">#13960</a></li>
<li>❗️ <code>--profile</code> 플래그와 함께 <code>--release</code>/<code>--debug</code> 플래그를 사용하는 것을 금지했습니다. <a href="https://github.com/rust-lang/cargo/pull/13971">#13971</a></li>
<li>❗️ Cargo.toml에서 <code>lib.plugin</code> 키 지원을 제거했습니다. Rust 플러그인 지원은 4년 동안 사용이 중단된 상태였으며 1.75.0에서 제거되었습니다. <a href="https://github.com/rust-lang/cargo/pull/13902">#13902</a> <a href="https://github.com/rust-lang/cargo/pull/14038">#14038</a></li>
<li>rustc를 위한 <code>-Cmetadata</code> 계산 방식을 플랫폼 간에 일관되게 만들었습니다. <a href="https://github.com/rust-lang/cargo/pull/14107">#14107</a></li>
<li>MSRV가 설정되지 않았더라도 <code>edition</code> 이 설정되지 않은 경우 경고를 표시하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14110">#14110</a></li>
</ul>
<h3 id="수정됨-14"><a class="header" href="#수정됨-14">수정됨</a></h3>
<ul>
<li>기능 해결(feature resolution)에 영향을 미치는 의존성의 proc-macro 예제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13892">#13892</a></li>
<li>‘..’ 사용으로 인한 중복 패키지에 대해 경고하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14234">#14234</a></li>
<li>모든 git 소스 로드 시마다 <code>du</code> 를 호출하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14252">#14252</a></li>
<li>참조되지 않은 중복 패키지에 대해 경고하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14239">#14239</a></li>
<li>cargo-publish: 레지스트리로 전송되는 HTTP JSON 바디에서 이름이 변경된 의존성의 비-개발용 기능을 제거하지 않도록 수정했습니다. 이 버그는 서드파티 레지스트리에만 영향을 미쳤습니다. <a href="https://github.com/rust-lang/cargo/pull/14328">#14328</a></li>
<li>cargo-vendor: 벤더링할 때 제외된 Cargo 타겟의 소스 파일을 복사하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14368">#14368</a></li>
</ul>
<h3 id="나이틀리nightly-전용-14"><a class="header" href="#나이틀리nightly-전용-14">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>🔥 <code>update-breaking</code>: <code>cargo update</code> 에 <code>--breaking</code> 플래그를 추가하여, 의존성을 하위 호환성이 깨지는(breaking) 버전으로 업그레이드할 수 있게 했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#update-breaking">문서</a> <a href="https://github.com/rust-lang/cargo/pull/13979">#13979</a> <a href="https://github.com/rust-lang/cargo/pull/14047">#14047</a> <a href="https://github.com/rust-lang/cargo/pull/14049">#14049</a></li>
<li><code>--artifact-dir</code>: <code>--out-dir</code> 플래그의 이름을 <code>--artifact-dir</code> 로 변경했습니다. <code>--out-dir</code> 플래그는 호환성을 위해 유지되며 해당 기능이 안정화되면 제거될 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/13809">#13809</a></li>
<li><code>edition2024</code>: 가려진(shadowed) 의존성에 대해 사용되지 않는 선택적 의존성 경고가 발생하도록 보장했습니다. <a href="https://github.com/rust-lang/cargo/pull/14028">#14028</a></li>
<li><code>edition2024</code>: 암시적 기능에서 명시적 기능으로의 마이그레이션 문제를 해결했습니다. <a href="https://github.com/rust-lang/cargo/pull/14018">#14018</a></li>
<li><code>-Zcargo-lints</code>: 린트 목록에 <code>unknown_lints</code> 를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/14024">#14024</a></li>
<li><code>-Zcargo-lints</code>: 린트 문서화를 위한 도구를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/14025">#14025</a></li>
<li><code>-Zcargo-lints</code>: 린트를 최신 상태로 정렬된 상태로 유지합니다. <a href="https://github.com/rust-lang/cargo/pull/14030">#14030</a></li>
<li><code>-Zconfig-include</code>: 설정에서 <code>config-include</code> 기능을 활성화할 수 있도록 허용합니다. <a href="https://github.com/rust-lang/cargo/pull/14196">#14196</a></li>
<li><code>-Zpublic-dependency</code>: 해결사(resolver)에서 일부 오래된 공개 의존성 코드를 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/14090">#14090</a></li>
<li><code>-Ztarget-applies-to-host</code>: target-applies-to-host를 사용할 때 암시적 타겟으로 빌드된 결과물에 rustflags를 전달합니다. <a href="https://github.com/rust-lang/cargo/pull/13900">#13900</a> <a href="https://github.com/rust-lang/cargo/pull/14201">#14201</a></li>
<li>cargo-update: <code>--precise &lt;prerelease&gt;</code> 의 동작을 추적합니다. <a href="https://github.com/rust-lang/cargo/pull/14013">#14013</a></li>
</ul>
<h3 id="문서-14"><a class="header" href="#문서-14">문서</a></h3>
<ul>
<li><code>CARGO_CFG_TARGET_FAMILY</code> 가 다중 값을 가질 수 있음을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/14165">#14165</a></li>
<li><code>CARGO_CFG_TARGET_ABI</code> 를 문서화했습니다. <a href="https://github.com/rust-lang/cargo/pull/14164">#14164</a></li>
<li>각 매니페스트 필드와 빌드 스크립트 호출 방식에 대한 MSRV를 문서화했습니다. <a href="https://github.com/rust-lang/cargo/pull/14224">#14224</a></li>
<li>중복된 <code>strip</code> 섹션을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/14146">#14146</a></li>
<li>누락된 키들을 포함하도록 Cargo 설정 요약을 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/14145">#14145</a></li>
<li>Cargo 문서의 인덱스를 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/14228">#14228</a></li>
<li>존재하지 않는 <code>workspace.badges</code> 필드에 대한 언급을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/14042">#14042</a></li>
<li>contrib: 테스트 커밋을 분리한 원자적(atomic) 커밋을 권장하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14014">#14014</a></li>
<li>contrib: Cargo를 위한 RFC 작성법을 문서화했습니다. <a href="https://github.com/rust-lang/cargo/pull/14222">#14222</a></li>
<li>contrib: 트리이징(triage) 지침을 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/14052">#14052</a></li>
</ul>
<h3 id="내부-변경-14"><a class="header" href="#내부-변경-14">내부 변경</a></h3>
<ul>
<li>cargo-package: 패키징 중 검증 순서를 변경했습니다. <a href="https://github.com/rust-lang/cargo/pull/14074">#14074</a></li>
<li>ci: Cargo를 자동으로 게시하는 워크플로우를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/14202">#14202</a></li>
<li>ci: CI 도구들을 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/14062">#14062</a> <a href="https://github.com/rust-lang/cargo/pull/14257">#14257</a></li>
<li>registry: 로컬 레지스트리 오버레이를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13926">#13926</a></li>
<li>registry: <code>get_source_id</code> 를 레지스트리 밖으로 이동했습니다. <a href="https://github.com/rust-lang/cargo/pull/14218">#14218</a></li>
<li>resolver: 의존성 순환 확인 로직을 단순화했습니다. <a href="https://github.com/rust-lang/cargo/pull/14089">#14089</a></li>
<li>rustfix: <code>CodeFix::apply_solution</code> 을 추가하고 <code>Clone</code> 을 구현했습니다. <a href="https://github.com/rust-lang/cargo/pull/14092">#14092</a></li>
<li>source: <code>PathSource</code>/<code>RecursivePathSource</code> 분리 이후 코드를 정리했습니다. <a href="https://github.com/rust-lang/cargo/pull/14169">#14169</a> <a href="https://github.com/rust-lang/cargo/pull/14231">#14231</a></li>
<li>임시 환경 변수인 <code>__CARGO_GITOXIDE_DISABLE_LIST_FILES</code> 를 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/14036">#14036</a></li>
<li>기능(feature) 구문 검사를 단순화했습니다. <a href="https://github.com/rust-lang/cargo/pull/14106">#14106</a></li>
<li>빈번하게 호출되는 경로(hot path)에서 새로운 <code>InternedString</code> 상수를 생성하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14211">#14211</a></li>
<li>직접 구현하는 대신 <code>std::fs::absolute</code> 를 사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14075">#14075</a></li>
<li>Remove unnecessary feature activations from cargo. <a href="https://github.com/rust-lang/cargo/pull/14122">#14122</a> <a href="https://github.com/rust-lang/cargo/pull/14160">#14160</a></li>
<li>rustc가 MSVC에서 <code>-C strip</code> 을 무시하므로 #13630을 되돌렸습니다. <a href="https://github.com/rust-lang/cargo/pull/14061">#14061</a></li>
<li>test: <code>user_specific_cfgs</code> 테스트에서 <code>unexpected_builtin_cfgs</code> 린트를 허용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14153">#14153</a></li>
<li>test: <code>test-support</code> 프렐류드(prelude)에 <code>cargo_test</code> 를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/14243">#14243</a></li>
<li>test: Cargo 테스트 세트를 <code>snapbox</code> 로 마이그레이션했습니다. 전체 마이그레이션 풀 리퀘스트 목록은 <a href="https://github.com/rust-lang/cargo/issues/14039#issuecomment-2158974033">#14039</a>를 참조하세요.</li>
<li><code>gix</code> 를 0.64.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/14431">#14431</a></li>
<li>의존성을 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13995">#13995</a> <a href="https://github.com/rust-lang/cargo/pull/13998">#13998</a> <a href="https://github.com/rust-lang/cargo/pull/14037">#14037</a> <a href="https://github.com/rust-lang/cargo/pull/14063">#14063</a> <a href="https://github.com/rust-lang/cargo/pull/14067">#14067</a> <a href="https://github.com/rust-lang/cargo/pull/14174">#14174</a> <a href="https://github.com/rust-lang/cargo/pull/14186">#14186</a> <a href="https://github.com/rust-lang/cargo/pull/14254">#14254</a></li>
</ul>
<h2 id="cargo-180-2024-07-25"><a class="header" href="#cargo-180-2024-07-25">Cargo 1.80 (2024-07-25)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/b60a1555...rust-1.80.0">b60a1555…rust-1.80.0</a></p>
<h3 id="추가됨-15"><a class="header" href="#추가됨-15">추가됨</a></h3>
<ul>
<li>
<p>🎉 <code>-Zcheck-cfg</code> 를 안정화했습니다! 이는 기본적으로 컴파일 시점에 rustc의 조건부 컴파일 검사를 활성화하여, 크레이트가 다양한 타겟 플랫폼이나 기능에 대해 조건부 컴파일을 올바르게 처리하는지 확인합니다. 내부적으로 Cargo는 모든 rustc 및 rustdoc 호출 시 새로운 명령줄 옵션인 <code>--check-cfg</code> 를 전달하게 됩니다.</p>
<p>이번 안정화와 함께 새로운 빌드 스크립트 호출 방식인 <a href="https://doc.rust-lang.org/nightly/cargo/reference/build-scripts.html#rustc-check-cfg"><code>cargo::rustc-check-cfg=CHECK_CFG</code></a>가 추가되었습니다. 이는 기대되는 cfg 이름 및 값 목록에 사용자 정의 cfg를 추가하는 방법입니다.</p>
<p>패키지에서 빌드 스크립트를 사용할 수 없는 경우, Cargo는 알려진 사용자 정의 cfg를 정적으로 추가할 수 있는 설정인 <a href="https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html#check-cfg-in-lintsrust-table"><code>[lints.rust.unexpected_cfgs.check-cfg]</code></a>를 제공합니다.</p>
<p>(<a href="https://github.com/rust-lang/rfcs/blob/master/text/3013-conditional-compilation-checking.md">RFC 3013</a>) (<a href="https://doc.rust-lang.org/nightly/rustc/check-cfg/cargo-specifics.html">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/13571">#13571</a> <a href="https://github.com/rust-lang/cargo/pull/13865">#13865</a> <a href="https://github.com/rust-lang/cargo/pull/13869">#13869</a> <a href="https://github.com/rust-lang/cargo/pull/13884">#13884</a> <a href="https://github.com/rust-lang/cargo/pull/13913">#13913</a> <a href="https://github.com/rust-lang/cargo/pull/13937">#13937</a> <a href="https://github.com/rust-lang/cargo/pull/13958">#13958</a></p>
</li>
<li>
<p>🎉 cargo-update: <code>--precise</code> 옵션으로 패키지의 yank(제거된) 버전을 지정할 수 있도록 허용하고, 이에 따라 잠금 파일을 업데이트합니다. <a href="https://github.com/rust-lang/cargo/pull/13974">#13974</a></p>
</li>
</ul>
<h3 id="변경됨-15"><a class="header" href="#변경됨-15">변경됨</a></h3>
<ul>
<li>❗️ manifest: <code>[badges]</code> 가 <code>[workspace.package.badges]</code> 로부터 상속받는 것을 금지했습니다. 이는 버그로 간주되었습니다. <code>[badges]</code> 는 사실상 사용이 중단(deprecated)된 상태라는 점을 유의하세요. <a href="https://github.com/rust-lang/cargo/pull/13788">#13788</a></li>
<li>build-script: MSRV를 기반으로 구형 구문을 사용하도록 권장합니다. <a href="https://github.com/rust-lang/cargo/pull/13874">#13874</a></li>
<li>cargo-add: 문자열 리터럴을 사용하여 큰따옴표 이스케이프를 방지합니다. <a href="https://github.com/rust-lang/cargo/pull/14006">#14006</a></li>
<li>cargo-clean: <code>-p</code> 플래그를 통한 특정 패키지 정리의 성능을 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/13818">#13818</a></li>
<li>cargo-new: 라이브러리 템플릿에서 “기본 정수형“으로 <code>usize</code> 대신 <code>i32</code> 를 사용합니다. <a href="https://github.com/rust-lang/cargo/pull/13939">#13939</a></li>
<li>cargo-package: 패키징 중에 Cargo 타겟이 제외되는 경우 실패 처리하는 대신 경고를 표시하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13713">#13713</a></li>
<li>manifest: <code>[lints]</code> 테이블에서 지원되지 않는 린트 도구에 대해 에러가 아닌 경고를 표시하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13833">#13833</a></li>
<li>perf: Cargo 타겟이 알려진 경우 추론을 피하도록 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/13849">#13849</a></li>
<li>Rust 소스 타르볼로부터 Cargo를 빌드할 때 git 정보를 채워 넣습니다. <a href="https://github.com/rust-lang/cargo/pull/13832">#13832</a></li>
<li>일부 환경 변수로부터 Cargo 설정을 역직렬화할 때의 에러 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/13956">#13956</a></li>
</ul>
<h3 id="수정됨-15"><a class="header" href="#수정됨-15">수정됨</a></h3>
<ul>
<li>resolver: 동일한 이름을 가진 경로(path) 의존성이 잠긴 상태를 유지하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13572">#13572</a></li>
<li>cargo-add: Unix에서 <code>write_atomic</code> 수행 시 파일 권한을 보존하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13898">#13898</a></li>
<li>cargo-clean: Windows에서 심볼릭 링크 디렉토리를 제거하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13910">#13910</a></li>
<li>cargo-fix: 표준 라이브러리 내부를 수정하지 않도록 변경했습니다. <a href="https://github.com/rust-lang/cargo/pull/13792">#13792</a></li>
<li>cargo-fix: IPv6 전용 네트워크를 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/13907">#13907</a></li>
<li>cargo-new: 루트에 일반 패키지가 있는 경우 워크스페이스에 추가한다고 표시하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13987">#13987</a></li>
<li>cargo-vendor: 벤더링을 잊었다는 경고를 표시하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13886">#13886</a></li>
<li>cargo-publish/cargo-vendor: 생성된 Cargo.toml의 타겟들이 결정론적인(deterministic) 순서로 배치되도록 보장했습니다. <a href="https://github.com/rust-lang/cargo/pull/13989">#13989</a> <a href="https://github.com/rust-lang/cargo/pull/14004">#14004</a></li>
<li>cargo-credential-libsecret: <code>libsecret</code> 을 <code>SONAME</code> 인 <code>libsecret-1.so.0</code> 으로 로드하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13927">#13927</a></li>
<li>별칭(alias)에 하위 명령어가 포함되지 않은 경우 패닉이 발생하는 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13819">#13819</a></li>
<li>macOS의 ZFS에서 파일 복사 시 EAGAIN을 반환하는 문제에 대한 임시 해결책을 적용했습니다. <a href="https://github.com/rust-lang/cargo/pull/13845">#13845</a></li>
<li>GitHub 패스트 패스가 실패하더라도 특정 커밋을 가져오도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13946">#13946</a> <a href="https://github.com/rust-lang/cargo/pull/13969">#13969</a></li>
<li>동일한 접두사를 공유하는 서로 다른 환경 변수들로부터 Cargo 설정을 구분하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/14000">#14000</a></li>
</ul>
<h3 id="나이틀리nightly-전용-15"><a class="header" href="#나이틀리nightly-전용-15">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><code>-Zcargo-lints</code>: 워크스페이스 린트를 항상 상속하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13812">#13812</a></li>
<li><code>-Zcargo-lints</code>: cap-lints가 작동하는지 확인하기 위한 테스트를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13829">#13829</a></li>
<li><code>-Zcargo-lints</code>: 불안정한 린트가 지정되었으나 활성화되지 않은 경우 에러를 발생시킵니다. <a href="https://github.com/rust-lang/cargo/pull/13805">#13805</a></li>
<li><code>-Zcargo-lints</code>: 불안정한 기능 문서에 cargo-lints를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13881">#13881</a></li>
<li><code>-Zcargo-lints</code>: cargo 린트 테스트들을 리팩토링했습니다. <a href="https://github.com/rust-lang/cargo/pull/13880">#13880</a></li>
<li><code>-Zcargo-lints</code>: 린트 이름에 <code>-</code> 를 지정할 수 없도록 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/13837">#13837</a></li>
<li><code>-Zscript</code>: cargo 스크립트에서 사용되지 않기로 한 프론트매터(frontmatter) 구문을 제거했습니다. 이제 허용되는 프론트매터 구문은 <code>---</code> 뿐입니다. <a href="https://github.com/rust-lang/cargo/pull/13861">#13861</a> <a href="https://github.com/rust-lang/cargo/pull/13893">#13893</a></li>
<li><code>-Zbindeps</code>: 여러 유형이 사용 가능한 경우 지정된 아티팩트 라이브러리만 빌드하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13842">#13842</a></li>
<li><code>-Zmsrv-policy</code>: 설정되지 않은 MSRV를 호환되는 것으로 취급합니다. <a href="https://github.com/rust-lang/cargo/pull/13791">#13791</a></li>
<li><code>-Zgit</code>/<code>-Zgitoxide</code>: 환경 변수와 Cargo 설정 모두에서 기본 설정을 가져오도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13687">#13687</a></li>
<li><code>-Zpublic-dependency</code>: 의존성을 상속할 때 ‘public’ 상태를 잃지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13836">#13836</a></li>
<li><code>edition2024</code>: 상속 시 무시된 <code>default-features</code> 를 허용하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13839">#13839</a></li>
<li><code>edition2024</code>: 다른 Cargo 타겟과 마찬가지로 바이너리에 대해서도 crate-types/proc-macro 검증을 수행합니다. <a href="https://github.com/rust-lang/cargo/pull/13841">#13841</a></li>
</ul>
<h3 id="문서-15"><a class="header" href="#문서-15">문서</a></h3>
<ul>
<li>cargo-package: VCS 출처가 보장되지 않음을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/13984">#13984</a></li>
<li>cargo-metadata: Cargo 타겟 이름에서의 대시(<code>-</code>) 교체 규칙을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/13887">#13887</a></li>
<li>config: 빌드 스크립트 재정의에서 <code>rustc-flags</code> 의 잘못된 타입을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13957">#13957</a></li>
<li>resolver: <code>resolver-tests</code> 를 위한 README를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13977">#13977</a></li>
<li>contrib: 기여자 가이드의 UI 예제 코드를 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13864">#13864</a></li>
<li>libcurl 프록시 문서 링크를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13990">#13990</a></li>
<li>플러그인을 위해 누락된 <code>CARGO_MAKEFLAGS</code> 환경 변수를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13872">#13872</a></li>
<li>지속적 통합(CI) 장에 CircleCI 레퍼런스를 포함했습니다. <a href="https://github.com/rust-lang/cargo/pull/13850">#13850</a></li>
</ul>
<h3 id="내부-변경-15"><a class="header" href="#내부-변경-15">내부 변경</a></h3>
<ul>
<li>ci: 베타 채널에 대해 <code>cargo</code> 를 확인하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13827">#13827</a></li>
<li>test: apache 컨테이너의 git 저장소에 대해 safe.directory를 설정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13920">#13920</a></li>
<li>test: 내장된 단위 테스트 실행 시 발생하는 경고를 숨겼습니다. <a href="https://github.com/rust-lang/cargo/pull/13929">#13929</a></li>
<li>test: 나이틀리 rustc의 변경 사항에 맞춰 테스트 포맷팅을 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13890">#13890</a> <a href="https://github.com/rust-lang/cargo/pull/13901">#13901</a> <a href="https://github.com/rust-lang/cargo/pull/13964">#13964</a></li>
<li>test: <code>git::use_the_cli</code> 테스트를 로케일에 완전히 독립적으로 만들었습니다. <a href="https://github.com/rust-lang/cargo/pull/13935">#13935</a></li>
<li>cargo-test-support: cargo-test-support의 직접 단언(direct assertions)들을 snapbox로 전환했습니다. <a href="https://github.com/rust-lang/cargo/pull/13980">#13980</a></li>
<li>cargo-test-support: 소요 시간을 자동으로 편집(redact)하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13973">#13973</a></li>
<li>cargo-test-support: 불필요한 <code>match_exact</code> 사용을 정리했습니다. <a href="https://github.com/rust-lang/cargo/pull/13879">#13879</a></li>
<li><code>PathSource</code> 로부터 <code>RecursivePathSource</code> 를 분리했습니다. <a href="https://github.com/rust-lang/cargo/pull/13993">#13993</a></li>
<li>libgit2 1.8 변경 사항에 맞춰 cert-check의 커스텀 에러를 조정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13970">#13970</a></li>
<li>진단 메시지 출력을 Shell로 이동했습니다. <a href="https://github.com/rust-lang/cargo/pull/13813">#13813</a></li>
<li>의존성을 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13834">#13834</a> <a href="https://github.com/rust-lang/cargo/pull/13840">#13840</a> <a href="https://github.com/rust-lang/cargo/pull/13948">#13948</a> <a href="https://github.com/rust-lang/cargo/pull/13963">#13963</a> <a href="https://github.com/rust-lang/cargo/pull/13976">#13976</a></li>
</ul>
<h2 id="cargo-179-2024-06-13"><a class="header" href="#cargo-179-2024-06-13">Cargo 1.79 (2024-06-13)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/2fe739fc...rust-1.79.0">2fe739fc…rust-1.79.0</a></p>
<h3 id="추가됨-16"><a class="header" href="#추가됨-16">추가됨</a></h3>
<ul>
<li>🎉 <code>cargo add</code> 가 새로운 의존성을 추가할 때 <code>package.rust-version</code>(일명 MSRV)을 따릅니다. 이 동작은 버전 요구사항을 지정하거나 <code>--ignore-rust-version</code> 플래그를 전달하여 재정의할 수 있습니다. (<a href="https://github.com/rust-lang/rfcs/blob/master/text/3537-msrv-resolver.md">RFC 3537</a>) <a href="https://github.com/rust-lang/cargo/pull/13608">#13608</a></li>
<li>모든 명령어에서 의존성 변경 사항을 보여주는 새로운 <code>Locking</code> 상태 메시지가 추가되었습니다. <code>cargo update</code> 의 경우, 의존성 버전이 오래되었는지도 알려줍니다. <a href="https://github.com/rust-lang/cargo/pull/13561">#13561</a> <a href="https://github.com/rust-lang/cargo/pull/13647">#13647</a> <a href="https://github.com/rust-lang/cargo/pull/13651">#13651</a> <a href="https://github.com/rust-lang/cargo/pull/13657">#13657</a> <a href="https://github.com/rust-lang/cargo/pull/13759">#13759</a> <a href="https://github.com/rust-lang/cargo/pull/13764">#13764</a></li>
</ul>
<h3 id="변경됨-16"><a class="header" href="#변경됨-16">변경됨</a></h3>
<ul>
<li>❗️ <code>RUSTC_WRAPPER</code>, <code>RUSTC_WORKSPACE_WRAPPER</code> 및 <code>[env]</code> 테이블의 변수들이 이제 Cargo가 rustc 정보를 탐색하기 위해 사용하는 초기 <code>rustc -vV</code> 호출 시에도 적용됩니다. <a href="https://github.com/rust-lang/cargo/pull/13659">#13659</a></li>
<li>❗️ 경고와 함께 <code>version="*"</code> 의존성으로 취급되던 <code>foo = { optional = true }</code> 와 같은 의존성을 에러로 처리합니다. 이 동작은 처음부터 버그로 간주되어 왔습니다. <a href="https://github.com/rust-lang/cargo/pull/13775">#13775</a></li>
<li>❗️ <code>lib.name</code> 이 <code>package.name</code> 으로부터 추론되는 경우에도 대시(<code>-</code>)를 밑줄(<code>_</code>)로 교체합니다. 이 변경은 문서화된 동작과 일치하도록 하기 위함입니다. 한 가지 주의할 점은 <code>cargo metadata</code> 나 <code>--message-format=json</code> 을 통해 Cargo가 내보내는 JSON 메시지에서 라이브러리 이름이 밑줄로 보고되기 시작한다는 것입니다. <a href="https://github.com/rust-lang/cargo/pull/12783">#12783</a></li>
<li>파일 목록 생성 시 <code>gitoxide</code> 를 사용하도록 전환했습니다. 이를 통해 빌드 스크립트와 <code>cargo doc</code> 의 캐시 최신 상태 계산 성능이 향상되었으며, <code>cargo publish</code> 와 관련된 미묘한 버그들이 수정되었습니다. <a href="https://github.com/rust-lang/cargo/pull/13592">#13592</a> <a href="https://github.com/rust-lang/cargo/pull/13696">#13696</a> <a href="https://github.com/rust-lang/cargo/pull/13704">#13704</a> <a href="https://github.com/rust-lang/cargo/pull/13777">#13777</a></li>
<li>더 이상 필요하지 않은 <code>-Zlints</code> 가 전달될 때 경고를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/13632">#13632</a></li>
<li>가상(virtual) 워크스페이스에서 사용되지 않는 <code>workspace.dependencies</code> 키에 대해 경고를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/13664">#13664</a></li>
<li>MSRV가 호환되지 않는 경우에만 1.77 빌드 스크립트 구문 에러를 출력합니다. <a href="https://github.com/rust-lang/cargo/pull/13808">#13808</a></li>
<li><code>lints.rust.unexpected_cfgs.check-cfg</code> 에 대해 경고하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13925">#13925</a></li>
<li>cargo-init: 값을 추론할 수 있는 경우 <code>Cargo.toml</code> 에 <code>target.name</code> 을 할당하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13606">#13606</a></li>
<li>cargo-package: <code>Cargo.toml</code> 의 경로를 정규화하며, <code>\</code> 를 <code>/</code> 로 교체하는 로직을 포함했습니다. <a href="https://github.com/rust-lang/cargo/pull/13729">#13729</a></li>
<li>cargo-test: <code>cargo test</code> 의 <code>--doc</code> 플래그를 “Target Selection” 하위로 재분류했습니다. <a href="https://github.com/rust-lang/cargo/pull/13756">#13756</a></li>
</ul>
<h3 id="수정됨-16"><a class="header" href="#수정됨-16">수정됨</a></h3>
<ul>
<li><code>--config net.git-fetch-with-cli=true</code> 가 올바르게 적용되도록 보장했습니다. <a href="https://github.com/rust-lang/cargo/pull/13992">#13992</a> <a href="https://github.com/rust-lang/cargo/pull/13997">#13997</a></li>
<li>비어 있는 별칭(alias)을 해결할 때 패닉이 발생하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13613">#13613</a></li>
<li><code>--target</code> 을 사용할 때도 기본 디버그 정보 제거(debuginfo strip) 규칙이 적용됩니다. Windows MSVC에서 Cargo는 더 이상 기본적으로 제거하지 않음을 유의하세요. <a href="https://github.com/rust-lang/cargo/pull/13618">#13618</a></li>
<li>다중 바이트 문자를 가리키는 Cargo.toml 파싱 에러로 인해 크래시가 발생하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13780">#13780</a></li>
<li><code>.cargo/{config,config.toml}</code> 중 하나가 다른 하나의 심볼릭 링크인 경우 사용 중단 경고를 출력하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13793">#13793</a></li>
<li>GitHub 저장소의 최신 여부를 확인할 때 HTTP 리다이렉션을 따르도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13718">#13718</a></li>
<li>Bash의 <code>nounset</code> 모드에서 완화된 자동 완성을 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/13686">#13686</a></li>
<li>rustflags가 변경되고 <code>--target</code> 이 전달된 경우 빌드 스크립트를 재실행하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13560">#13560</a></li>
<li>추론된 이름에 대시가 포함된 lib/bin의 문서 충돌 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13640">#13640</a></li>
<li>cargo-add: 의존성 기능(feature)들의 정렬 상태를 유지하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13682">#13682</a></li>
<li>cargo-add: 간단한 의존성을 업데이트할 때 주석을 보존하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13655">#13655</a></li>
<li>cargo-fix: 동일한 제안을 두 번 적용하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13728">#13728</a></li>
<li>cargo-package: <code>--package</code> 로 지정된 패키지를 찾을 수 없는 경우 에러를 발생시킵니다. <a href="https://github.com/rust-lang/cargo/pull/13735">#13735</a></li>
<li>credential-provider: 표준 입력(stdin)에서 토큰을 읽을 때 줄바꿈 문자를 제거합니다. <a href="https://github.com/rust-lang/cargo/pull/13770">#13770</a></li>
</ul>
<h3 id="나이틀리nightly-전용-16"><a class="header" href="#나이틀리nightly-전용-16">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>🔥 cargo-update: <code>--precise</code> 옵션으로 패키지의 프리릴리스 버전을 지정할 수 있도록 허용합니다 (<a href="https://github.com/rust-lang/rfcs/blob/master/text/3493-precise-pre-release-cargo-update.md">RFC 3493</a>) (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#precise-pre-release">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/13626">#13626</a></li>
<li>RFC 3491: 사용되지 않는 의존성 정리 <a href="https://github.com/rust-lang/cargo/pull/13778">#13778</a></li>
<li><code>-Zcargo-lints</code>: Cargo를 위한 기본적인 린트 시스템을 추가했습니다. 이 기능은 아직 개발 중이며 일반적인 용도로는 사용할 수 없습니다. <a href="https://github.com/rust-lang/cargo/pull/13621">#13621</a> <a href="https://github.com/rust-lang/cargo/pull/13635">#13635</a> <a href="https://github.com/rust-lang/cargo/pull/13797">#13797</a> <a href="https://github.com/rust-lang/cargo/pull/13740">#13740</a> <a href="https://github.com/rust-lang/cargo/pull/13801">#13801</a> <a href="https://github.com/rust-lang/cargo/pull/13852">#13852</a> <a href="https://github.com/rust-lang/cargo/pull/13853">#13853</a></li>
<li>🔥 <code>edition2024</code>: resolver v3(MSRV 인식 해결사)에 기본 Edition2024를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13785">#13785</a></li>
<li><code>edition2024</code>: 2024 에디션에서 밑줄(<code>_</code>) 필드 지원을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/13783">#13783</a> <a href="https://github.com/rust-lang/cargo/pull/13798">#13798</a> <a href="https://github.com/rust-lang/cargo/pull/13800">#13800</a> <a href="https://github.com/rust-lang/cargo/pull/13804">#13804</a></li>
<li><code>edition2024</code>: 2024 에디션에서 <code>[project]</code> 사용 시 에러를 발생시킵니다. <a href="https://github.com/rust-lang/cargo/pull/13747">#13747</a></li>
<li><code>-Zmsrv-policy</code>: ‘–ignore-rust-version’ 옵션을 준수하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13738">#13738</a></li>
<li><code>-Zmsrv-policy</code>: update/generate-lockfile 명령어에 <code>--ignore-rust-version</code> 플래그를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13741">#13741</a> <a href="https://github.com/rust-lang/cargo/pull/13742">#13742</a></li>
<li><code>-Zmsrv-policy</code>: MSRV 인식 해결사를 설정 옵션 뒤로 배치했습니다. <a href="https://github.com/rust-lang/cargo/pull/13769">#13769</a></li>
<li><code>-Zmsrv-policy</code>: rust-version이 ’x’인 경우 패닉 대신 에러를 발생시킵니다. <a href="https://github.com/rust-lang/cargo/pull/13771">#13771</a></li>
<li><code>-Zmsrv-policy</code>: MSRV 해결 시 ’rustc -V’를 폴백(fallback)으로 사용합니다. <a href="https://github.com/rust-lang/cargo/pull/13743">#13743</a></li>
<li><code>-Zmsrv-policy</code>: MSRV 인식을 위해 v3 resolver를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13776">#13776</a></li>
<li><code>-Zmsrv-policy</code>: 로컬 설치가 아닌 경우 MSRV를 따르지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13790">#13790</a></li>
<li><code>-Zmsrv-policy</code>: MSRV가 명시적으로 설정된 경우(어느 쪽이든) 이를 추적하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13732">#13732</a></li>
<li>test: 테스트 레지스트리 크레이트를 압축하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13744">#13744</a></li>
</ul>
<h3 id="문서-16"><a class="header" href="#문서-16">문서</a></h3>
<ul>
<li><code>--locked</code> 옵션이 Cargo가 잠금 파일에 있는 의존성 버전을 사용하도록 보장한다는 점을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/13665">#13665</a></li>
<li><code>RUSTC_WORKSPACE_WRAPPER</code> 와 <code>RUSTC_WRAPPER</code> 의 우선순위를 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/13648">#13648</a></li>
<li><code>[workspace]</code> 섹션은 루트 Cargo.toml에서만 허용됨을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/13753">#13753</a></li>
<li>가상(virtual) 매니페스트와 실제 매니페스트의 차이점을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/13794">#13794</a></li>
</ul>
<h3 id="내부-변경-16"><a class="header" href="#내부-변경-16">내부 변경</a></h3>
<ul>
<li>🎉 새로운 멤버 크레이트 <a href="https://crates.io/crates/cargo-test-support"><code>cargo-test-support</code></a> 및 <a href="https://crates.io/crates/cargo-test-macro"><code>cargo-test-macro</code></a>가 추가되었습니다! 이들은 Cargo 자체를 테스트하기 위해 설계되었으므로 버전 간의 안정성이 보장되지 않습니다. 이 크레이트들의 crates.io 게시는 다른 멤버 크레이트들과 동일하게 Rust의 <a href="https://doc.crates.io/contrib/process/release.html#cratesio-publishing">6주 릴리스 프로세스</a>를 따릅니다. <a href="https://github.com/rust-lang/cargo/pull/13418">#13418</a></li>
<li>crates.io CDN 변경으로 인한 게시 스크립트 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13614">#13614</a></li>
<li>진단 복잡성을 annotate-snippets로 옮겼습니다. <a href="https://github.com/rust-lang/cargo/pull/13619">#13619</a></li>
<li>cargo-package: 게시된 매니페스트를 가져오는 방식을 단순화했습니다. <a href="https://github.com/rust-lang/cargo/pull/13666">#13666</a></li>
<li>ci: macOS 이미지를 macos-13으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13685">#13685</a></li>
<li>manifest: <code>Cargo.toml</code> 을 해결(resolve)하기 위한 명시적 단계를 분리했습니다. <a href="https://github.com/rust-lang/cargo/pull/13693">#13693</a></li>
<li>manifest: 타겟 생성 로직에서 타겟 감지 로직을 분리했습니다. <a href="https://github.com/rust-lang/cargo/pull/13701">#13701</a></li>
<li>manifest: <code>VirtualManifests</code> 에 대해 소스 및 스팬(spans) 정보를 노출했습니다. <a href="https://github.com/rust-lang/cargo/pull/13603">#13603</a></li>
<li>의존성을 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13609">#13609</a> <a href="https://github.com/rust-lang/cargo/pull/13674">#13674</a> <a href="https://github.com/rust-lang/cargo/pull/13675">#13675</a> <a href="https://github.com/rust-lang/cargo/pull/13679">#13679</a> <a href="https://github.com/rust-lang/cargo/pull/13680">#13680</a> <a href="https://github.com/rust-lang/cargo/pull/13692">#13692</a> <a href="https://github.com/rust-lang/cargo/pull/13731">#13731</a> <a href="https://github.com/rust-lang/cargo/pull/13760">#13760</a> <a href="https://github.com/rust-lang/cargo/pull/13950">#13950</a></li>
</ul>
<h2 id="cargo-178-2024-05-02"><a class="header" href="#cargo-178-2024-05-02">Cargo 1.78 (2024-05-02)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/7bb7b539...rust-1.78.0">7bb7b539…rust-1.78.0</a></p>
<h3 id="추가됨-17"><a class="header" href="#추가됨-17">추가됨</a></h3>
<ul>
<li>전역 캐시 데이터 추적 기능을 안정화했습니다. <code>-Zgc</code> 플래그는 여전히 불안정한 상태입니다. 이는 Cargo가 데이터를 수집하기 시작하도록 하여, 자동 GC 기능이 안정화되었을 때 캐시 미스가 발생할 가능성을 줄이기 위함입니다. <a href="https://github.com/rust-lang/cargo/pull/13492">#13492</a> <a href="https://github.com/rust-lang/cargo/pull/13467">#13467</a></li>
<li>잠금 파일 형식 v4를 안정화했습니다. 잠금 파일 v3가 여전히 기본 버전입니다. <a href="https://github.com/rust-lang/cargo/pull/12852">#12852</a></li>
<li>비-ASCII 유니코드 문자를 사용하여 출력을 렌더링할 수 있는지 여부를 자동으로 감지합니다. 이 동작을 수동으로 제어하기 위해 <code>term.unicode</code> 설정값이 추가되었습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/config.html#termunicode">문서</a> <a href="https://github.com/rust-lang/cargo/pull/13337">#13337</a></li>
<li>Cargo 설정에서 <code>target.&lt;triple&gt;.rustdocflags</code> 를 지원합니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/config.html#targettriplerustdocflags">문서</a> <a href="https://github.com/rust-lang/cargo/pull/13197">#13197</a></li>
</ul>
<h3 id="변경됨-17"><a class="header" href="#변경됨-17">변경됨</a></h3>
<ul>
<li>cargo-add: 의존성 기능(feature)이 생성될 때 상태를 출력합니다. <a href="https://github.com/rust-lang/cargo/pull/13434">#13434</a></li>
<li>cargo-add: 교체된 소스로부터 패키지를 추가할 때의 에러 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/13281">#13281</a></li>
<li>cargo-doc: <code>--verbose</code> 가 아닌 경우 <code>Generated</code> 상태 메시지들을 하나로 접어 출력합니다. <a href="https://github.com/rust-lang/cargo/pull/13557">#13557</a></li>
<li>cargo-new: ‘Created’ 대신 ‘Creating’ 상태 메시지를 출력하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13367">#13367</a></li>
<li>cargo-new: 더 많은 정보를 제공할 때 주석 대신 ‘참고(note)’ 형식을 사용합니다. <a href="https://github.com/rust-lang/cargo/pull/13371">#13371</a></li>
<li>cargo-new: 워크스페이스에 멤버를 추가할 때 힌트를 출력합니다. <a href="https://github.com/rust-lang/cargo/pull/13411">#13411</a></li>
<li>cargo-test: libtest 인수를 위해 <code>--</code> 사용을 권장합니다. <a href="https://github.com/rust-lang/cargo/pull/13448">#13448</a></li>
<li>cargo-update: 일부 의존성이 여전히 최신 버전보다 뒤처져 있을 때 사용자에게 알립니다. <a href="https://github.com/rust-lang/cargo/pull/13372">#13372</a></li>
<li>확장자가 없는 <code>.cargo/config</code> 파일의 사용을 중단(deprecate)했습니다. <a href="https://github.com/rust-lang/cargo/pull/13349">#13349</a></li>
<li>기본적으로 실패 시 rustdoc 명령줄을 인쇄하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13387">#13387</a></li>
<li>새로운 잠금 파일을 생성할 때 <code>package.rust-version</code> 을 준수합니다. <a href="https://github.com/rust-lang/cargo/pull/12861">#12861</a></li>
<li>원격 레지스트리와 통신할 때 <code>User-Agent: cargo/1.2.3</code> 헤더를 보냅니다. 이전에는 HTTP 사양을 따르지 않는 <code>cargo 1.2.3</code> 이었습니다. <a href="https://github.com/rust-lang/cargo/pull/13548">#13548</a></li>
<li>Cargo.toml에 <code>package.edition</code> 필드가 없는 경우 경고를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/13499">#13499</a> <a href="https://github.com/rust-lang/cargo/pull/13504">#13504</a> <a href="https://github.com/rust-lang/cargo/pull/13505">#13505</a> <a href="https://github.com/rust-lang/cargo/pull/13533">#13533</a></li>
<li>가상 매니페스트를 파싱할 때 경고를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/13589">#13589</a></li>
<li>워크스페이스 멤버를 수집할 때의 에러 메시지에 워크스페이스 루트 위치를 명시하도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/13480">#13480</a></li>
<li><code>Finished</code> 상태 메시지에서 사용 중인 프로파일을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/13422">#13422</a></li>
<li>더 많은 참고/경고 메시지를 소문자로 전환했습니다. <a href="https://github.com/rust-lang/cargo/pull/13410">#13410</a></li>
<li><code>package.rust-version</code> 과 호환되지 않는 모든 패키지를 보고하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13514">#13514</a></li>
</ul>
<h3 id="수정됨-17"><a class="header" href="#수정됨-17">수정됨</a></h3>
<ul>
<li>cargo-add: Cargo.toml에 기존 워크스페이스가 없는 경우 새 패키지를 <code>workspace.members</code>에 추가하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13391">#13391</a></li>
<li>cargo-add: 마크다운 줄바꿈 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13400">#13400</a></li>
<li>cargo-run: 패키지를 매칭할 때 패키지 ID 명세를 사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13335">#13335</a></li>
<li>cargo-doc: doctest가 빌드 스크립트 출력에서 네이티브 라이브러리를 검색하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13490">#13490</a></li>
<li>cargo-publish: 게시용 Cargo.toml에서 개발 의존성(dev-dependencies)의 기능(feature)들도 제거하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13518">#13518</a></li>
<li><code>cargo add/rm/init/new</code> 를 통해 TOML을 편집할 때 주석이 중복되지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13402">#13402</a></li>
<li>희소(sparse) 인덱스로 교체된 소스에 대한 혼란스러운 에러 메시지를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13433">#13433</a></li>
<li>‘–list’ 및 ’-Zhelp’에서 <code>CARGO_TERM_COLOR</code> 를 준수하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13479">#13479</a></li>
<li>clap의 에러 및 도움말 텍스트 색상을 <code>CARGO_TERM_COLOR</code> 를 통해 제어하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13463">#13463</a></li>
<li>Cargo.toml의 빈 스팬(span)으로 인해 패닉이 발생하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13375">#13375</a> <a href="https://github.com/rust-lang/cargo/pull/13376">#13376</a></li>
</ul>
<h3 id="나이틀리nightly-전용-17"><a class="header" href="#나이틀리nightly-전용-17">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>🔥 cargo-update: <code>--precise</code> 옵션으로 패키지의 yank(제거된) 버전을 지정할 수 있도록 허용합니다. <a href="https://github.com/rust-lang/cargo/pull/13333">#13333</a></li>
<li><code>-Zcheck-cfg</code>: <code>docsrs</code> cfg를 잘 알려진(well known) <code>--check-cfg</code> 로 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13383">#13383</a></li>
<li><code>-Zcheck-cfg</code>: <code>-Zcheck-cfg</code> 안정화 시 MSRV 문제를 피하기 위해 <code>cargo::rustc-check-cfg</code>를 조용히 무시하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13438">#13438</a></li>
<li><code>-Zmsrv-policy</code>: MSRV가 설정되지 않은 경우 <code>rustc -v</code> 를 폴백으로 사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13516">#13516</a></li>
<li><code>-Zscript</code>: cargo 스크립트와 관련된 에러 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/13346">#13346</a></li>
<li><code>-Zpanic-abort-tests</code>: doctest에도 적용되도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13388">#13388</a></li>
<li><code>-Zpublic-dependency</code>: <code>-Zpublic-dependency</code> 플래그를 통한 활성화를 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/13340">#13340</a> <a href="https://github.com/rust-lang/cargo/pull/13556">#13556</a> <a href="https://github.com/rust-lang/cargo/pull/13547">#13547</a></li>
<li><code>-Zpublic-dependency</code>: 공개 의존성 패키징에 대한 테스트를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13536">#13536</a></li>
<li><code>-Zrustdoc-map</code>: <code>doc.extern-map</code> 옵션을 위해 모든 유닛의 자식들을 재귀적으로 추가합니다. <a href="https://github.com/rust-lang/cargo/pull/13481">#13481</a> <a href="https://github.com/rust-lang/cargo/pull/13544">#13544</a></li>
<li><code>edition2024</code>: 2024 에디션 마이그레이션을 활성화했습니다. <a href="https://github.com/rust-lang/cargo/pull/13429">#13429</a></li>
<li><code>open-namespaces</code>: 열린 네임스페이스(open namespaces)에 대한 기본적인 지원을 추가했습니다 (<a href="https://github.com/rust-lang/rfcs/blob/master/text/3243-packages-as-optional-namespaces.md">RFC 3243</a>) (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#open-namespaces">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/13591">#13591</a></li>
</ul>
<h3 id="문서-17"><a class="header" href="#문서-17">문서</a></h3>
<ul>
<li>cargo-fetch: <code>--offline</code> 맨 페이지에서 <code>cargo-fetch</code> 재귀 링크를 숨겼습니다. <a href="https://github.com/rust-lang/cargo/pull/13364">#13364</a></li>
<li>cargo-install: <code>--list</code> 옵션 설명이 대문자로 시작하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13344">#13344</a></li>
<li>cargo-vendor: 벤더링된 소스가 읽기 전용이라는 점과 이를 수정하는 방법을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/13512">#13512</a></li>
<li>build-script: <code>cargo::metadata=KEY=VALUE</code> 를 통해 설정되는 빌드 스크립트 메타데이터에 대해 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/13436">#13436</a></li>
<li>Cargo.toml의 <code>[package]</code> 섹션에서 <code>version</code> 필드가 선택 사항임을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/13390">#13390</a></li>
<li>“Registry Authentication” 문서를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/13351">#13351</a></li>
<li>“Specifying Dependencies” 문서를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/13341">#13341</a></li>
<li>“게시 전 확인 사항” 목록에서 <code>package.documentation</code> 을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/13398">#13398</a></li>
</ul>
<h3 id="내부-변경-17"><a class="header" href="#내부-변경-17">내부 변경</a></h3>
<ul>
<li>🎉 Cargo 자체를 위한 기본적인 프로파일러로 tracing-chrome을 통합했습니다. <a href="https://doc.crates.io/contrib/tests/profiling.html">문서</a> <a href="https://github.com/rust-lang/cargo/pull/13399">#13399</a> <a href="https://github.com/rust-lang/cargo/pull/13551">#13551</a></li>
<li><code>gix</code> 를 0.58.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13380">#13380</a></li>
<li><code>git2</code> 를 0.18.2로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13412">#13412</a></li>
<li><code>jobserver</code> 를 0.1.28로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13419">#13419</a></li>
<li><code>supports-hyperlinks</code> 를 3.0.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13511">#13511</a></li>
<li><code>rusqlite</code> 를 0.31.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13510">#13510</a></li>
<li>bump-check: 소스 코드 비교 시 대칭 차집합(symmetric difference)을 사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13581">#13581</a></li>
<li>bump-check: rustfix 및 cargo-util-schemas를 포함하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13421">#13421</a></li>
<li>ci: M1 러너를 활성화했습니다. <a href="https://github.com/rust-lang/cargo/pull/13377">#13377</a></li>
<li>ci: <code>cargo-hack</code> 을 통한 MSRV 테스트 중에 잠금 파일을 준수하도록 보장했습니다. <a href="https://github.com/rust-lang/cargo/pull/13523">#13523</a></li>
<li>cargo-util-schemas: <code>RustVersion::is_compatible_with</code> 를 통해 일관되게 MSRV를 비교하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13537">#13537</a></li>
<li>console: 새로운 <code>anstyle</code> API를 사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13368">#13368</a> <a href="https://github.com/rust-lang/cargo/pull/13562">#13562</a></li>
<li>fingerprint: <code>Freshness::Dirty</code> 에서 불필요한 <code>Option</code> 을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/13361">#13361</a></li>
<li>fingerprint: 디스크 인덱스 캐시로부터 <code>std::fs</code> 를 추상화했습니다. <a href="https://github.com/rust-lang/cargo/pull/13515">#13515</a></li>
<li>mdman: <code>pulldown-cmark</code> 를 0.10.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13517">#13517</a></li>
<li>refactor: <code>Config</code> 의 이름을 <code>GlobalContext</code> 로 변경했습니다. <a href="https://github.com/rust-lang/cargo/pull/13409">#13409</a> <a href="https://github.com/rust-lang/cargo/pull/13486">#13486</a> <a href="https://github.com/rust-lang/cargo/pull/13506">#13506</a></li>
<li>refactor: 사용되지 않는 <code>sysroot_host_libdir</code> 를 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/13468">#13468</a></li>
<li>refactor: 린트 출력을 위해 매니페스트에 소스/스팬 정보를 노출했습니다. <a href="https://github.com/rust-lang/cargo/pull/13593">#13593</a></li>
<li>refactor: 매니페스트 파싱 로직을 평탄화(flatten)했습니다. <a href="https://github.com/rust-lang/cargo/pull/13589">#13589</a></li>
<li>refactor: 잠금 파일 비교 및 인쇄 기능을 재사용 가능하게 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13564">#13564</a></li>
<li>test: <code>snapbox</code> 를 0.5.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13441">#13441</a></li>
<li>test: snapbox의 <code>term-svg</code> 기능을 통해 터미널 스타일링을 검증합니다. <a href="https://github.com/rust-lang/cargo/pull/13461">#13461</a> <a href="https://github.com/rust-lang/cargo/pull/13465">#13465</a> <a href="https://github.com/rust-lang/cargo/pull/13520">#13520</a></li>
<li>test: <code>nonzero_exit_code</code> 테스트가 개발자의 <code>RUST_BACKTRACE</code> 설정에 영향을 받지 않도록 보장했습니다. <a href="https://github.com/rust-lang/cargo/pull/13385">#13385</a></li>
<li>test: 워크트리(worktrees) 사용에 대한 테스트를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13567">#13567</a></li>
<li>test: old_cargos 테스트를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13435">#13435</a></li>
<li>test: rust-lang/rust의 변경 사항에 맞춰 테스트를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13362">#13362</a> <a href="https://github.com/rust-lang/cargo/pull/13382">#13382</a> <a href="https://github.com/rust-lang/cargo/pull/13415">#13415</a> <a href="https://github.com/rust-lang/cargo/pull/13424">#13424</a> <a href="https://github.com/rust-lang/cargo/pull/13444">#13444</a> <a href="https://github.com/rust-lang/cargo/pull/13455">#13455</a> <a href="https://github.com/rust-lang/cargo/pull/13464">#13464</a> <a href="https://github.com/rust-lang/cargo/pull/13466">#13466</a> <a href="https://github.com/rust-lang/cargo/pull/13469">#13469</a></li>
<li>test: macOS에서 실행 시 권한이 필요한 lldb 테스트를 비활성화했습니다. <a href="https://github.com/rust-lang/cargo/pull/13416">#13416</a></li>
</ul>
<h2 id="cargo-1771-2024-03-28"><a class="header" href="#cargo-1771-2024-03-28">Cargo 1.77.1 (2024-03-28)</a></h2>
<h3 id="수정됨-18"><a class="header" href="#수정됨-18">수정됨</a></h3>
<ul>
<li>Windows MSVC 타겟에서 더 이상 기본적으로 디버그 정보를 제거하지 않습니다. 1.77.0에서 발생하여 백트레이스를 망가뜨렸던 예상치 못한 회귀 문제를 해결했습니다. <a href="https://github.com/rust-lang/cargo/pull/13654">#13654</a></li>
</ul>
<h2 id="cargo-177-2024-03-21"><a class="header" href="#cargo-177-2024-03-21">Cargo 1.77 (2024-03-21)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/1a2666dd...rust-1.77.0">1a2666dd…rust-1.77.0</a></p>
<h3 id="추가됨-18"><a class="header" href="#추가됨-18">추가됨</a></h3>
<ul>
<li>🎉 패키지 식별자 형식을 <a href="https://doc.rust-lang.org/nightly/cargo/reference/pkgid-spec.html">Package ID Spec</a>으로 안정화했습니다. 이 형식은 <code>--package</code>/<code>-p</code> 플래그, <code>cargo pkgid</code>, <code>cargo metadata</code> 및 <code>--message-format=json</code> 의 JSON 메시지를 포함하여 Cargo의 대부분의 명령어에서 사용할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/12914">#12914</a> <a href="https://github.com/rust-lang/cargo/pull/13202">#13202</a> <a href="https://github.com/rust-lang/cargo/pull/13311">#13311</a> <a href="https://github.com/rust-lang/cargo/pull/13298">#13298</a> <a href="https://github.com/rust-lang/cargo/pull/13322">#13322</a></li>
<li><code>-Zhelp</code> 콘솔 출력에 색상을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13269">#13269</a></li>
<li>빌드 스크립트: 빌드 지시어 구문에 <code>cargo::</code> 접두사를 추가로 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/12201">#12201</a> <a href="https://github.com/rust-lang/cargo/pull/13212">#13212</a></li>
</ul>
<h3 id="변경됨-18"><a class="header" href="#변경됨-18">변경됨</a></h3>
<ul>
<li>🎉 디버그 정보(debuginfo)를 비활성화하면 이제 <code>strip = "debuginfo"</code> 가 설정된 것으로 간주하여(따로 <code>strip</code> 이 설정되지 않은 경우), 표준 라이브러리에서 제공되는 기존 디버그 정보를 제거합니다. 이를 통해 릴리스 바이너리의 기본 크기가 상당히 줄어듭니다(Linux x64의 helloworld 예제 기준 약 4.5 MiB에서 약 450 KiB로 감소). <a href="https://github.com/rust-lang/cargo/pull/13257">#13257</a></li>
<li>매니페스트 파싱 시 <code>rustc</code> 스타일의 에러 표시를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13172">#13172</a></li>
<li>Cargo에서 rustc 플러그인 지원을 중단(deprecate)했습니다. <a href="https://github.com/rust-lang/cargo/pull/13248">#13248</a></li>
<li>cargo-vendor: 벤더링할 때 수정 배타적 잠금(mutate exclusive lock)을 유지하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12509">#12509</a></li>
<li>crates-io: 바디 페이로드가 있는 요청에 대해서만 <code>Content-Type: application/json</code>을 설정하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13264">#13264</a></li>
</ul>
<h3 id="수정됨-19"><a class="header" href="#수정됨-19">수정됨</a></h3>
<ul>
<li>jobserver: 모든 종류의 러너에 대해 환경 변수로부터 jobserver를 상속하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12776">#12776</a></li>
<li>빌드 스크립트: 빌드 스크립트가 있는 모든 유닛에 대해 <code>OUT_DIR</code> 을 설정하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13204">#13204</a></li>
<li>cargo-add: 여러 패키지가 포함된 Git 저장소에서 지정된 기능(feature)을 가진 올바른 패키지를 찾도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13213">#13213</a></li>
<li>cargo-fix: 항상 jobserver를 상속하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13225">#13225</a></li>
<li>cargo-fix: 성능 향상을 위해 rustc 호출 횟수를 줄였습니다. <a href="https://github.com/rust-lang/cargo/pull/13243">#13243</a></li>
<li>cargo-new: 새 패키지가 워크스페이스 멤버인 경우에만 워크스페이스 패키지 테이블을 상속하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13261">#13261</a></li>
<li>cargo-update: <code>--precise</code> 옵션이 임의의 git 리비전을 수용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13250">#13250</a></li>
<li>manifest: lints 테이블에서 사용되지 않는 키에 대한 경고를 제공합니다. <a href="https://github.com/rust-lang/cargo/pull/13262">#13262</a></li>
<li>rustfix: 새 줄(new lines) 삽입을 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/13226">#13226</a></li>
</ul>
<h3 id="나이틀리nightly-전용-18"><a class="header" href="#나이틀리nightly-전용-18">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>🔥 <code>-Zgit</code>: 불안정한 플래그 뒤에 얕은(shallow) libgit2 페치 구현을 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#git">문서</a> <a href="https://github.com/rust-lang/cargo/pull/13252">#13252</a></li>
<li>🔥 <code>cargo rustdoc</code> 에 불안정한 <code>--output-format</code> 옵션을 추가하여, rustdoc의 실험적인 JSON 형식을 활용할 수 있는 방법을 도구들에 제공합니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#output-format-for-rustdoc">문서</a> <a href="https://github.com/rust-lang/cargo/pull/12252">#12252</a> <a href="https://github.com/rust-lang/cargo/pull/13284">#13284</a> <a href="https://github.com/rust-lang/cargo/pull/13325">#13325</a></li>
<li><code>-Zcheck-cfg</code>: <code>--check-cfg</code> 생성 주석을 재작성했습니다. <a href="https://github.com/rust-lang/cargo/pull/13195">#13195</a></li>
<li><code>-Zcheck-cfg</code>: 선언된 기능이 없을 때 빈 <code>values()</code> 를 전달하는 방식으로 되돌렸습니다. <a href="https://github.com/rust-lang/cargo/pull/13316">#13316</a></li>
<li><code>-Zprecise-pre-release</code>: 플래그는 추가되었으나 아직 구현되지는 않았습니다. <a href="https://github.com/rust-lang/cargo/pull/13296">#13296</a> <a href="https://github.com/rust-lang/cargo/pull/13320">#13320</a></li>
<li><code>-Zpublic-dependency</code>: <code>public</code> 필드가 있는 패키지의 게시를 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/13245">#13245</a></li>
<li><code>-Zpublic-dependency</code>: <code>cargo add</code> 의 <code>--public</code>/<code>--no-public</code> 플래그 도움말 텍스트를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13272">#13272</a></li>
<li><code>-Zscript</code>: prefix-char 프론트매터 구문 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13247">#13247</a></li>
<li><code>-Zscript</code>: 여러 실험적인 매니페스트 구문을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13241">#13241</a></li>
<li><code>-Ztrim-paths</code>: 공통 접두사만 리맵(remap)하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13210">#13210</a></li>
</ul>
<h3 id="문서-18"><a class="header" href="#문서-18">문서</a></h3>
<ul>
<li>매니페스트에 홈페이지를 설정하는 방법에 대한 안내를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13293">#13293</a></li>
<li>커스텀 하위 명령어를 찾는 방식을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/13203">#13203</a></li>
<li><code>du</code> 함수가 뮤텍스(mutex)를 사용하는 이유를 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/13273">#13273</a></li>
<li>“의존성에 활성화된 기능을 찾는 방법” 섹션을 강조 표시했습니다. <a href="https://github.com/rust-lang/cargo/pull/13305">#13305</a></li>
<li>라이선스에서 괄호가 지원되지 않는다는 문장을 삭제했습니다. <a href="https://github.com/rust-lang/cargo/pull/13292">#13292</a></li>
<li>resolver: 의존성 해결 시 프리릴리스 버전이 처리되는 방식을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/13286">#13286</a></li>
<li>cargo-test: 테스트 옵션들의 타겟 선택 방식을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/13236">#13236</a></li>
<li>cargo-install: <code>--path</code> 가 설치 대상이 아니라 설치 소스임을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/13205">#13205</a></li>
<li>contrib: 팀 HackMD 링크를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13237">#13237</a></li>
<li>contrib: 비차단적(non-blocking) 기능 게이팅 기법을 강조 표시했습니다. <a href="https://github.com/rust-lang/cargo/pull/13307">#13307</a></li>
</ul>
<h3 id="내부-변경-18"><a class="header" href="#내부-변경-18">내부 변경</a></h3>
<ul>
<li>🎉 새로운 멤버 크레이트 <a href="https://crates.io/crates/cargo-util-schemas"><code>cargo-util-schemas</code></a>가 추가되었습니다! 이 크레이트는 파일을 읽고 명령줄을 파싱할 때 사용하는 <code>serde</code> 및 <code>FromStr</code> 위주의 저수준 Cargo 스키마 타입들을 포함합니다. 이들로부터 최종적인 시맨틱을 얻기 위한 로직은 <code>cargo metadata</code> 와 같은 다른 도구들의 처리가 필요할 것입니다. 이 크레이트의 crates.io 게시는 다른 멤버 크레이트들과 동일하게 Rust의 <a href="https://doc.crates.io/contrib/process/release.html#cratesio-publishing">6주 릴리스 프로세스</a>를 따릅니다. <a href="https://github.com/rust-lang/cargo/pull/13178">#13178</a> <a href="https://github.com/rust-lang/cargo/pull/13185">#13185</a> <a href="https://github.com/rust-lang/cargo/pull/13186">#13186</a> <a href="https://github.com/rust-lang/cargo/pull/13209">#13209</a> <a href="https://github.com/rust-lang/cargo/pull/13267">#13267</a></li>
<li><code>gix</code> 를 0.57.1로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13230">#13230</a></li>
<li>cargo-fix: <code>cargo fix</code> 에서 error-format 특수 처리 로직을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/13224">#13224</a></li>
<li>cargo-credential: 0.4.3으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13221">#13221</a></li>
<li>mdman: <code>handlebars</code> 를 5.0.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13168">#13168</a> <a href="https://github.com/rust-lang/cargo/pull/13249">#13249</a></li>
<li>rustfix: 불필요한 clippy 규칙을 제거하고 오타를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13182">#13182</a></li>
<li>ci: Dependabot의 MSRV 자동 업데이트 기능을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13265">#13265</a> <a href="https://github.com/rust-lang/cargo/pull/13324">#13324</a> <a href="https://github.com/rust-lang/cargo/pull/13268">#13268</a></li>
<li>ci: <a href="https://github.com/rust-lang/cargo/issues/13256">의존성 대시보드</a> 를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13255">#13255</a></li>
<li>ci: alpine docker 태그를 v3.19로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13228">#13228</a></li>
<li>ci: GitHub Actions CI 설정을 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/13317">#13317</a></li>
<li>resolver: 빈 서머리를 정렬할 때 패닉이 발생하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13287">#13287</a></li>
</ul>
<h2 id="cargo-176-2024-02-08"><a class="header" href="#cargo-176-2024-02-08">Cargo 1.76 (2024-02-08)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/6790a512...rust-1.76.0">6790a512…rust-1.76.0</a></p>
<h3 id="추가됨-19"><a class="header" href="#추가됨-19">추가됨</a></h3>
<ul>
<li>Windows MSVC용으로 빌드된 <code>cargo.exe</code> 에 Windows 애플리케이션 매니페스트 파일을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13131">#13131</a><br />
주요 변경 사항:
<ul>
<li>Windows 버전 7, 8, 8.1, 10 및 11과의 호환성을 명시합니다.</li>
<li>코드 페이지를 UTF-8로 설정합니다.</li>
<li>긴 경로(long path) 인식을 활성화합니다.</li>
</ul>
</li>
<li><code>cargo --list</code> 에 색상 출력을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12992">#12992</a></li>
<li>cargo-add: <code>--optional &lt;dep&gt;</code> 사용 시 <code>&lt;dep&gt; = "dep:&lt;dep&gt;"</code> 기능을 생성하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13071">#13071</a></li>
<li>모호하지 않은 명세를 위해 패키지 ID 명세를 확장했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/pkgid-spec.html">문서</a> <a href="https://github.com/rust-lang/cargo/pull/12933">#12933</a><br />
구체적으로,
<ul>
<li><code>git+</code> 및 <code>path+</code> 스킴을 지원합니다.</li>
<li><code>?branch=dev</code> 또는 <code>?tag=1.69.0</code> 과 같은 Git 참조 쿼리 문자열을 지원합니다.</li>
</ul>
</li>
</ul>
<h3 id="변경됨-19"><a class="header" href="#변경됨-19">변경됨</a></h3>
<ul>
<li>❗️ 가상(virtual) 워크스페이스에서 <code>[lints]</code> 사용을 금지했습니다. 이는 무시되므로 사용자가 <code>[workspace.lints]</code> 를 의도했을 가능성이 높습니다. 이는 초기 구현에서의 실수였습니다(예: <code>[dependencies]</code> 도 동일한 에러를 발생시킴). <a href="https://github.com/rust-lang/cargo/pull/13155">#13155</a></li>
<li>패키지 ID 명세 및 <code>cargo new</code> 등 여러 곳에서 빈 이름을 사용하는 것을 금지했습니다. <a href="https://github.com/rust-lang/cargo/pull/13152">#13152</a></li>
<li><code>rust-lang/rust</code> 의 <code>omit-git-hash</code> 옵션을 준수하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12968">#12968</a></li>
<li>에러가 하나만 있는 경우에도 에러 개수를 숫자로 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/12484">#12484</a></li>
<li><code>all-static</code> 기능에 이제 <code>vendored-libgit2</code> 가 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/13134">#13134</a></li>
<li>crates-io: 레지스트리와 통신할 때 다른 2xx HTTP 상태 코드도 지원하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13158">#13158</a> <a href="https://github.com/rust-lang/cargo/pull/13160">#13160</a></li>
<li>home: SHGetFolderPathW를 SHGetKnownFolderPath로 교체했습니다. <a href="https://github.com/rust-lang/cargo/pull/13173">#13173</a></li>
</ul>
<h3 id="수정됨-20"><a class="header" href="#수정됨-20">수정됨</a></h3>
<ul>
<li>wincon에서 rustc 메시지를 색상과 함께 인쇄합니다. <a href="https://github.com/rust-lang/cargo/pull/13140">#13140</a></li>
<li>공백이 포함된 디렉토리에서의 Bash 자동 완성을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13126">#13126</a></li>
<li>Windows에서 실행 중인 바이너리의 삭제가 실패하는 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13053">#13053</a> <a href="https://github.com/rust-lang/cargo/pull/13099">#13099</a></li>
<li>중복된 링크에 대한 에러 메시지를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12973">#12973</a></li>
<li>중첩된 하위 명령어와 함께 <code>--quiet</code> 가 사용되는 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12959">#12959</a></li>
<li>개발 의존성(dev-dependencies)에 순환이 있을 때 발생하는 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12977">#12977</a></li>
<li>rustc 커밋 해시 파싱 실패 시 패닉이 발생하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12963">#12963</a> <a href="https://github.com/rust-lang/cargo/pull/12965">#12965</a></li>
<li>워크스페이스 멤버를 업데이트할 때 git 페치를 수행하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12975">#12975</a></li>
<li>CACHEDIR.TAG가 이미 존재하는 경우 다시 쓰지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13132">#13132</a></li>
<li>유효한 pkgid 명세인 경우 <code>--package</code> 플래그에서 <code>?</code> 를 허용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13315">#13315</a> <a href="https://github.com/rust-lang/cargo/pull/13318">#13318</a></li>
<li>cargo-package: <code>target</code> 디렉토리가 패키지 루트에 있는 경우에만 필터링하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12944">#12944</a></li>
<li>cargo-package: 빌드 스크립트가 존재하지 않거나 패키지 루트 밖에 있는 경우 에러를 발생시킵니다. <a href="https://github.com/rust-lang/cargo/pull/12995">#12995</a></li>
<li>cargo-credential-1password: <code>op signin</code> 명령어에 누락된 <code>--account</code> 인수를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12985">#12985</a> <a href="https://github.com/rust-lang/cargo/pull/12986">#12986</a></li>
</ul>
<h3 id="나이틀리nightly-전용-19"><a class="header" href="#나이틀리nightly-전용-19">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>🔥 <code>-Zgc</code> 플래그는 Cargo 캐시에서 오래되고 사용되지 않는 파일들을 삭제하는 가비지 컬렉션 기능을 활성화합니다. 즉, <code>CARGO_HOME</code> 디렉토리 하위의 다운로드된 소스 파일들과 레지스트리 인덱스가 대상입니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#gc">문서</a> <a href="https://github.com/rust-lang/cargo/pull/12634">#12634</a> <a href="https://github.com/rust-lang/cargo/pull/12958">#12958</a> <a href="https://github.com/rust-lang/cargo/pull/12981">#12981</a> <a href="https://github.com/rust-lang/cargo/pull/13055">#13055</a></li>
<li>🔥 새로운 환경 변수인 <code>CARGO_RUSTC_CURRENT_DIR</code> 을 추가했습니다. 이는 rustc가 호출되는 경로입니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/environment-variables.html?highlight=CARGO_RUSTC_CURRENT_DIR#environment-variables-cargo-sets-for-crates">문서</a> <a href="https://github.com/rust-lang/cargo/pull/12996">#12996</a></li>
<li><code>-Zcheck-cfg</code>: <code>-Zcheck-cfg</code> 를 위한 핑거프린트(fingerprint)에 선언된 기능 목록을 포함하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13012">#13012</a></li>
<li><code>-Zcheck-cfg</code>: 기능이 하나도 없을 때의 <code>--check-cfg</code> 호출을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13011">#13011</a></li>
<li><code>-Ztrim-paths</code>: <code>-Zbuild-std</code> 를 위해 <code>--remap-path-prefix</code> 플래그들의 순서를 재조정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13065">#13065</a></li>
<li><code>-Ztrim-paths</code>: <code>.</code> 을 사용하여 현재 디렉토리를 명시적으로 리맵하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13114">#13114</a></li>
<li><code>-Ztrim-paths</code>: 실제 디버거를 통한 검증을 수행했습니다. <a href="https://github.com/rust-lang/cargo/pull/13091">#13091</a> <a href="https://github.com/rust-lang/cargo/pull/13118">#13118</a></li>
<li><code>-Zpublic-dependency</code>: <code>exported-private-dependencies</code> 린트를 라이브러리로 제한했습니다. <a href="https://github.com/rust-lang/cargo/pull/13135">#13135</a></li>
<li><code>-Zpublic-dependency</code>: 의존성의 공개 여부 상태를 워크스페이스로부터 상속받는 것을 금지했습니다. <a href="https://github.com/rust-lang/cargo/pull/13125">#13125</a></li>
<li><code>-Zpublic-dependency</code>: <code>cargo add</code> 에 <code>--public</code> 옵션을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13046">#13046</a></li>
<li><code>-Zpublic-dependency</code>: 사용되지 않는 public-deps 에러 처리 로직을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/13036">#13036</a></li>
<li><code>-Zmsrv-policy</code>: 호환되지 않는 버전을 무시하는 대신 MSRV를 우선시하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12950">#12950</a></li>
<li><code>-Zmsrv-policy</code>: MSRV 해결 시 rust-version 정보가 없는 경우의 우선순위를 낮췄습니다. <a href="https://github.com/rust-lang/cargo/pull/13066">#13066</a></li>
<li><code>-Zrustdoc-scrape-examples</code>: 문서 예제 추출 시 워크스페이스 멤버만으로 필터링하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13077">#13077</a></li>
</ul>
<h3 id="문서-19"><a class="header" href="#문서-19">문서</a></h3>
<ul>
<li>더 다양한 libsecret 호환 패스워드 매니저들을 추천하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12993">#12993</a></li>
<li>타겟마다 서로 다른 <code>CARGO_CFG_*</code> 값 집합을 가진다는 점을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/13069">#13069</a></li>
<li><code>[lints]</code> 테이블은 현재 패키지의 로컬 개발에만 영향을 미친다는 점을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/12976">#12976</a></li>
<li><code>cargo search</code> 가 대체 레지스트리에서도 검색할 수 있음을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/12962">#12962</a></li>
<li><code>rust-version</code> (MSRV) 필드 검증을 위한 일반적인 CI 관행들을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13056">#13056</a></li>
<li>rustc 린트 레벨 문서에 대한 링크를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12990">#12990</a></li>
<li>관련 워크스페이스 테이블로부터 패키지 린트 테이블로의 링크를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13057">#13057</a></li>
<li>contrib: 기여 문서에 더 많은 리소스들을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13008">#13008</a></li>
<li>contrib: 자격 증명(credential) 크레이트 게시 방식을 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13006">#13006</a></li>
<li>contrib: 리뷰 용량(review capacity) 공지를 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/13070">#13070</a></li>
</ul>
<h3 id="내부-변경-19"><a class="header" href="#내부-변경-19">내부 변경</a></h3>
<ul>
<li>🎉 <code>rustfix</code> 크레이트를 <code>rust-lang/cargo</code> 저장소로 마이그레이션했습니다. <a href="https://github.com/rust-lang/cargo/pull/13005">#13005</a> <a href="https://github.com/rust-lang/cargo/pull/13042">#13042</a> <a href="https://github.com/rust-lang/cargo/pull/13047">#13047</a> <a href="https://github.com/rust-lang/cargo/pull/13048">#13048</a> <a href="https://github.com/rust-lang/cargo/pull/13050">#13050</a></li>
<li>curl 8.4.0에 해당하는 <code>curl-sys</code> 0.4.70으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13147">#13147</a></li>
<li><code>gix-index</code> 를 0.27.1로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13148">#13148</a></li>
<li><code>itertools</code> 를 0.12.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13086">#13086</a></li>
<li><code>rusqlite</code> 를 0.30.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13087">#13087</a></li>
<li><code>toml_edit</code> 를 0.21.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13088">#13088</a></li>
<li><code>windows-sys</code> 를 0.52.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13089">#13089</a></li>
<li>rustc_log와의 호환성을 위해 <code>tracing</code> 을 0.1.37로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/13239">#13239</a> <a href="https://github.com/rust-lang/cargo/pull/13242">#13242</a></li>
<li><code>gix-config</code> 업데이트 덕분에 간헐적으로 실패하던 gitoxide 인증 테스트를 다시 활성화했습니다. <a href="https://github.com/rust-lang/cargo/pull/13117">#13117</a> <a href="https://github.com/rust-lang/cargo/pull/13129">#13129</a> <a href="https://github.com/rust-lang/cargo/pull/13130">#13130</a></li>
<li>Cargo의 <code>-Zlints</code> 테이블 기능을 자체적으로 적용(Dogfooding)했습니다. <a href="https://github.com/rust-lang/cargo/pull/12178">#12178</a></li>
<li>공식 스키마 API 추출을 준비하기 위해 <code>Cargo.toml</code> 파싱 코드를 리팩토링했습니다. <a href="https://github.com/rust-lang/cargo/pull/12954">#12954</a> <a href="https://github.com/rust-lang/cargo/pull/12960">#12960</a> <a href="https://github.com/rust-lang/cargo/pull/12961">#12961</a> <a href="https://github.com/rust-lang/cargo/pull/12971">#12971</a> <a href="https://github.com/rust-lang/cargo/pull/13000">#13000</a> <a href="https://github.com/rust-lang/cargo/pull/13021">#13021</a> <a href="https://github.com/rust-lang/cargo/pull/13080">#13080</a> <a href="https://github.com/rust-lang/cargo/pull/13097">#13097</a> <a href="https://github.com/rust-lang/cargo/pull/13123">#13123</a> <a href="https://github.com/rust-lang/cargo/pull/13128">#13128</a> <a href="https://github.com/rust-lang/cargo/pull/13154">#13154</a> <a href="https://github.com/rust-lang/cargo/pull/13166">#13166</a></li>
<li><code>query{_vec}</code> 함수에서 <code>IndexSummary</code> 를 사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12970">#12970</a></li>
<li>ci: renovate 설정을 마이그레이션했습니다. <a href="https://github.com/rust-lang/cargo/pull/13106">#13106</a></li>
<li>ci: gix 패키지들은 항상 함께 업데이트하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13093">#13093</a></li>
<li>ci: AtomicU64의 미숙한 사용을 조기에 잡아내도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12988">#12988</a></li>
<li>xtask-bump-check: <code>home</code> 크레이트를 베타/스테이블 브랜치에 대해 확인하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13167">#13167</a></li>
<li>cargo-test-support: JSON 진단 메시지에서 $message_type을 처리하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13016">#13016</a></li>
<li>cargo-test-support: 레지스트리 테스트 지원에 더 많은 옵션을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/13085">#13085</a></li>
<li>cargo-test-support: 기본 Cargo.toml 파일에 기능(feature)들을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12997">#12997</a></li>
<li>cargo-test-support: clippy-wrapper 테스트의 레이스 컨디션(race condition)을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12999">#12999</a></li>
<li>test: 변경 사항 테스트 시 mtime에 의존하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/13143">#13143</a></li>
<li>test: <code>optionals</code> 테스트에서 불필요한 패키지와 버전들을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/13108">#13108</a></li>
<li>test: 삭제된 기능인 <code>test_2018_feature</code> 를 테스트에서 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/13156">#13156</a></li>
<li>test: 일부 테스트에서 jobserver 환경 변수를 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/13072">#13072</a></li>
<li>test: 잘못된 빌드 파일 이름을 사용하던 rustflags 테스트를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12987">#12987</a></li>
<li>test: 일부 테스트 출력 검증 로직을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12982">#12982</a></li>
<li>test: windows-gnu 환경에서 changing_spec_relearns_crate_types 테스트를 무시하도록 설정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12972">#12972</a></li>
</ul>
<h2 id="cargo-175-2023-12-28"><a class="header" href="#cargo-175-2023-12-28">Cargo 1.75 (2023-12-28)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/59596f0f...rust-1.75.0">59596f0f…rust-1.75.0</a></p>
<h3 id="추가됨-20"><a class="header" href="#추가됨-20">추가됨</a></h3>
<ul>
<li><code>Cargo.toml</code> 의 <code>package.version</code> 필드가 이제 선택 사항이며 기본값은 <code>0.0.0</code> 입니다. <code>package.version</code> 필드가 없는 패키지는 게시할 수 없습니다. <a href="https://github.com/rust-lang/cargo/pull/12786">#12786</a></li>
<li><code>--timings</code> 및 <code>cargo doc</code> 출력의 링크가 지원되는 터미널에서 클릭 가능하도록 개선되었으며, <code>term.hyperlinks</code> 설정값으로 제어할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/12889">#12889</a></li>
<li><code>-vv</code> 사용 시 빌드 스크립트 실행을 위한 환경 변수들을 인쇄합니다. <a href="https://github.com/rust-lang/cargo/pull/12829">#12829</a></li>
<li>cargo-new: 새 패키지를 [workspace.members] 에 자동으로 추가합니다. <a href="https://github.com/rust-lang/cargo/pull/12779">#12779</a></li>
<li>cargo-doc: 전체 경로를 표시하는 새로운 <code>Generated</code> 상태 메시지를 인쇄합니다. <a href="https://github.com/rust-lang/cargo/pull/12859">#12859</a></li>
</ul>
<h3 id="변경됨-20"><a class="header" href="#변경됨-20">변경됨</a></h3>
<ul>
<li>cargo-new: 크레이트 이름이 snake_case 또는 kebab-case를 따르지 않는 경우 경고를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/12766">#12766</a></li>
<li>cargo-install: 설치할 크레이트 인수(<code>&lt;crate&gt;</code>)가 위치 인수(positional)임을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/12841">#12841</a></li>
<li>cargo-install: MSRV 실패 시 대안 버전을 제안합니다. <a href="https://github.com/rust-lang/cargo/pull/12798">#12798</a></li>
<li>cargo-install: 더 자세한 SemVer 에러를 보고합니다. <a href="https://github.com/rust-lang/cargo/pull/12924">#12924</a></li>
<li>cargo-install: 중복된 크레이트가 있는 경우 한 번만 설치합니다. <a href="https://github.com/rust-lang/cargo/pull/12868">#12868</a></li>
<li>cargo-remove: 서로 다른 의존성 종류에 대한 플래그 동작을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/12823">#12823</a></li>
<li>cargo-remove: 제거하려는 의존성이 다른 섹션에만 존재하는 경우 이를 제안합니다. <a href="https://github.com/rust-lang/cargo/pull/12865">#12865</a></li>
<li>cargo-update: 빌드 메타데이터만 차이 나는 경우 “Downgrading“으로 부르지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12796">#12796</a></li>
<li><code>--test</code> 플래그가 테스트 함수가 아닌 Cargo 타겟을 위한 것임을 명확히 하기 위해 도움말 텍스트를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/12915">#12915</a></li>
<li>빌드 스크립트 경고에 패키지 이름/버전을 포함했습니다. <a href="https://github.com/rust-lang/cargo/pull/12799">#12799</a></li>
<li>잘못된 -Z 플래그 사용 시 다음 단계를 안내합니다. <a href="https://github.com/rust-lang/cargo/pull/12857">#12857</a></li>
<li><code>cargo-&lt;command&gt;</code> 를 찾을 수 없는 경우 <code>cargo search</code> 를 제안합니다. <a href="https://github.com/rust-lang/cargo/pull/12840">#12840</a></li>
<li>비어 있는 기능(feature) 이름을 허용하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12928">#12928</a></li>
<li><code>--target</code> 및 <code>--exclude</code> 플래그에 대해 지원되지 않는 짧은 플래그 제안 기능을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12805">#12805</a></li>
<li><code>--out-dir</code> 플래그에 대해 지원되지 않는 짧은 플래그 제안 기능을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12755">#12755</a></li>
<li><code>-Z</code> 플래그에 대해 지원되지 않는 소문자 <code>-z</code> 플래그 제안 기능을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12788">#12788</a></li>
<li>지원되지 않는 <code>--path</code> 플래그에 대해 더 나은 제안 기능을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12811">#12811</a></li>
<li>타겟 디렉토리 경로가 유효하지 않을 때의 상세한 메시지를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12820">#12820</a></li>
</ul>
<h3 id="수정됨-21"><a class="header" href="#수정됨-21">수정됨</a></h3>
<ul>
<li>파일 쓰기 중에 Cargo 프로세스가 종료되었을 때 발생하는 파일 손상 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12744">#12744</a></li>
<li>cargo-add: 더 많은 주석을 보존하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12838">#12838</a></li>
<li>cargo-fix: rustc 호출 시 jobserver 파일 기술자(file descriptors)를 유지하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12951">#12951</a></li>
<li>cargo-remove: 기능(feature) 관련 주석을 보존하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12837">#12837</a></li>
<li>에러 발생 시 timings HTML 보고서에서 불필요한 백슬래시를 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/12934">#12934</a></li>
<li>유효하지 않은 기능 이름이 <code>-</code> 를 포함할 수 있다는 내용의 에러 메시지를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12939">#12939</a></li>
<li>잠금 파일에 의존성 버전이 있는 경우, Cargo는 빌드 메타데이터를 포함한 해당 “정확한” 버전을 사용하게 됩니다. <a href="https://github.com/rust-lang/cargo/pull/12772">#12772</a></li>
</ul>
<h3 id="나이틀리nightly-전용-20"><a class="header" href="#나이틀리nightly-전용-20">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><code>Edition2024</code> 불안정한 기능을 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#edition-2024">문서</a> <a href="https://github.com/rust-lang/cargo/pull/12771">#12771</a></li>
<li>🔥 <code>-Ztrim-paths</code> 기능은 생성된 바이너리에서 경로가 정규화되는 방식을 제어하는 새로운 프로파일 설정을 추가합니다. (<a href="https://github.com/rust-lang/rfcs/blob/master/text/3127-trim-paths.md">RFC 3127</a>) (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#profile-trim-paths-option">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/12625">#12625</a> <a href="https://github.com/rust-lang/cargo/pull/12900">#12900</a> <a href="https://github.com/rust-lang/cargo/pull/12908">#12908</a></li>
<li><code>-Zcheck-cfg</code>: 새로운 rustc 구문 및 동작에 맞춰 조정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12845">#12845</a></li>
<li><code>-Zcheck-cfg</code>: 오래된 <code>-Zcheck-cfg</code> 경고 옵션을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/12884">#12884</a></li>
<li><code>public-dependency</code>: 워크스페이스 의존성과의 <code>public</code> 의존성 설정을 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/12817">#12817</a></li>
</ul>
<h3 id="문서-20"><a class="header" href="#문서-20">문서</a></h3>
<ul>
<li>profile: 누락된 <code>strip</code> 정보를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12754">#12754</a></li>
<li>features: 기능(feature) 개수 제한에 대한 참고 사항을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12913">#12913</a></li>
<li>crates-io: <code>NewCrate</code> 구조체에 대한 문서 주석을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12782">#12782</a></li>
<li>resolver: 의존성 해결 관련 질문에 답하기 위한 명령어들을 강조 표시했습니다. <a href="https://github.com/rust-lang/cargo/pull/12903">#12903</a></li>
<li>cargo-bench: 벤치 하네스에 <code>--bench</code> 인수가 무조건적으로 전달되도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12850">#12850</a></li>
<li>cargo-login: 맨 페이지에서 <code>--</code> 뒤의 인수에 대해 언급했습니다. <a href="https://github.com/rust-lang/cargo/pull/12832">#12832</a></li>
<li>cargo-vendor: 벤더링된 소스를 사용하기 위한 설정이 표준 출력(stdout)으로 인쇄된다는 점을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/12893">#12893</a></li>
<li>manifest: SPDX 2.3 라이선스 표현식 및 3.20 라이선스 목록으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12827">#12827</a></li>
<li>contrib: 매니페스트 편집에 대한 정책을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12836">#12836</a></li>
<li>contrib: use <code>AND</code> search terms in mdbook search and fixed broken links. <a href="https://github.com/rust-lang/cargo/pull/12812">#12812</a> <a href="https://github.com/rust-lang/cargo/pull/12813">#12813</a> <a href="https://github.com/rust-lang/cargo/pull/12814">#12814</a></li>
<li>contrib: 새로운 패키지를 추가하는 방법을 설명했습니다. <a href="https://github.com/rust-lang/cargo/pull/12878">#12878</a></li>
<li>contrib: 리뷰 용량 공지를 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/12842">#12842</a></li>
</ul>
<h3 id="내부-변경-20"><a class="header" href="#내부-변경-20">내부 변경</a></h3>
<ul>
<li><code>itertools</code> 를 0.11.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12759">#12759</a></li>
<li><code>cargo_metadata</code> 를 0.18.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12758">#12758</a></li>
<li>curl 8.4.0에 해당하는 <code>curl-sys</code> 0.4.68로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12808">#12808</a></li>
<li><code>toml</code> 을 0.8.2로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12760">#12760</a></li>
<li><code>toml_edit</code> 를 0.20.2로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12761">#12761</a></li>
<li><code>gix</code> 를 0.55.2로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12906">#12906</a></li>
<li>windows-gnu 환경에서 <code>custom_target::custom_bin_target</code> 테스트를 비활성화했습니다. <a href="https://github.com/rust-lang/cargo/pull/12763">#12763</a></li>
<li>공식 스키마 API 추출을 준비하기 위해 <code>Cargo.toml</code> 파싱 코드를 리팩토링했습니다. <a href="https://github.com/rust-lang/cargo/pull/12768">#12768</a> <a href="https://github.com/rust-lang/cargo/pull/12881">#12881</a> <a href="https://github.com/rust-lang/cargo/pull/12902">#12902</a> <a href="https://github.com/rust-lang/cargo/pull/12911">#12911</a> <a href="https://github.com/rust-lang/cargo/pull/12948">#12948</a></li>
<li>SemVer 로직을 별도의 모듈로 분리했습니다. <a href="https://github.com/rust-lang/cargo/pull/12926">#12926</a> <a href="https://github.com/rust-lang/cargo/pull/12940">#12940</a></li>
<li>source: 새로운 <code>PackageIDSpec</code> 구문을 준비했습니다. <a href="https://github.com/rust-lang/cargo/pull/12938">#12938</a></li>
<li>resolver: <code>VersionPreferences</code> 에 로직을 통합했습니다. <a href="https://github.com/rust-lang/cargo/pull/12930">#12930</a></li>
<li><code>SourceId::precise</code> 필드를 Enum으로 변경했습니다. <a href="https://github.com/rust-lang/cargo/pull/12849">#12849</a></li>
<li>shell: 파편화된 출력이 아닌 한 번에 출력하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12880">#12880</a></li>
<li>인덱스 서머리(index summary) 열거형 조회를 상단으로 이동했습니다. <a href="https://github.com/rust-lang/cargo/pull/12749">#12749</a> <a href="https://github.com/rust-lang/cargo/pull/12923">#12923</a></li>
<li>CI에서 Cargo 기여자 가이드를 위한 리다이렉션 HTML 페이지를 생성하도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/12846">#12846</a></li>
<li>새로운 패키지 캐시 잠금 모드를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12706">#12706</a></li>
<li>6915 이슈(기능 및 전이적 개발 의존성)에 대한 회귀 테스트를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12907">#12907</a></li>
<li>PR 리뷰 상태가 변경될 때 자동 레이블링 기능을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12856">#12856</a></li>
<li>credential: 게시되는 모든 크레이트에 라이선스 파일을 포함했습니다. <a href="https://github.com/rust-lang/cargo/pull/12953">#12953</a></li>
<li>credential: OS별로 <code>cargo-credential-*</code> 의존성을 필터링하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12949">#12949</a></li>
<li>ci: cargo-semver-checks를 0.24.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12795">#12795</a></li>
<li>ci: Cargo 크레이트들의 모든 MSRV를 자동으로 설정하고 검증하도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/12767">#12767</a> <a href="https://github.com/rust-lang/cargo/pull/12654">#12654</a></li>
<li>ci: Cargo 기여자 도서 게시를 위해 별도의 동시성 그룹을 사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12834">#12834</a> <a href="https://github.com/rust-lang/cargo/pull/12835">#12835</a></li>
<li>ci: <code>actions/checkout</code> 액션을 v4로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12762">#12762</a></li>
<li>cargo-search: 출력 여백 계산 로직을 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/12890">#12890</a></li>
</ul>
<h2 id="cargo-174-2023-11-16"><a class="header" href="#cargo-174-2023-11-16">Cargo 1.74 (2023-11-16)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/80eca0e5...rust-1.74.0">80eca0e5…rust-1.74.0</a></p>
<h3 id="추가됨-21"><a class="header" href="#추가됨-21">추가됨</a></h3>
<ul>
<li>🎉 <code>[lints]</code> 테이블을 안정화하여, <code>Cargo.toml</code> 에서 rustc 및 다른 도구의 린트 보고 레벨을 설정할 수 있게 했습니다. (<a href="https://github.com/rust-lang/rfcs/blob/master/text/3389-manifest-lint.md">RFC 3389</a>) (<a href="https://doc.rust-lang.org/nightly/cargo/reference/manifest.html#the-lints-section">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/12584">#12584</a> <a href="https://github.com/rust-lang/cargo/pull/12648">#12648</a></li>
<li>🎉 불안정한 기능이었던 <code>credential-process</code> 와 <code>registry-auth</code> 가 안정화되었습니다. 이 기능들은 프라이빗 레지스트리 인증 방식을 통합합니다. (<a href="https://github.com/rust-lang/rfcs/blob/master/text/2730-cargo-token-from-process.md">RFC 2730</a>) (<a href="https://github.com/rust-lang/rfcs/blob/master/text/3139-cargo-alternative-registry-auth.md">RFC 3139</a>) (<a href="https://doc.rust-lang.org/nightly/cargo/reference/registry-authentication.html">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/12590">#12590</a> <a href="https://github.com/rust-lang/cargo/pull/12622">#12622</a> <a href="https://github.com/rust-lang/cargo/pull/12623">#12623</a> <a href="https://github.com/rust-lang/cargo/pull/12626">#12626</a> <a href="https://github.com/rust-lang/cargo/pull/12641">#12641</a> <a href="https://github.com/rust-lang/cargo/pull/12644">#12644</a> <a href="https://github.com/rust-lang/cargo/pull/12649">#12649</a> <a href="https://github.com/rust-lang/cargo/pull/12671">#12671</a> <a href="https://github.com/rust-lang/cargo/pull/12709">#12709</a><br />
주요 변경 사항:
<ul>
<li>레지스트리 인증을 위한 자격 증명을 저장하고 검색하기 위해 외부 및 내장 제공자 모두를 위한 새로운 프로토콜을 도입했습니다.</li>
<li>레지스트리 인덱스의 <code>config.json</code> 에 <code>auth-required</code> 필드를 추가하여, 인증이 필요한 희소(sparse) 인덱스, 크레이트 다운로드 및 검색 API를 활성화했습니다.</li>
<li>인증이 필요한 대체 레지스트리를 사용하려면, 암호화되지 않은 자격 증명이 디스크에 저장되는 것을 방지하기 위해 자격 증명 제공자를 설정해야 합니다.</li>
<li>이 설정들은 <code>[registry]</code> 및 <code>[registries]</code> 테이블에서 구성할 수 있습니다.</li>
</ul>
</li>
<li>🎉 <code>--keep-going</code> flag has been stabilized and is now available in each build command (except <code>bench</code> and <code>test</code>, which have <code>--no-fail-fast</code> instead). (<a href="commands/cargo-build.html#option-cargo-build---keep-going">docs</a>) <a href="https://github.com/rust-lang/cargo/pull/12568">#12568</a></li>
<li><code>cargo clean</code> 명령어에 <code>--dry-run</code> 플래그와 마지막 요약 줄을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12638">#12638</a></li>
<li>명령줄 옵션 <code>--dry-run</code> 에 대한 짧은 별칭인 <code>-n</code> 을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12660">#12660</a></li>
<li><code>target.'cfg(..)'.linker</code> 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12535">#12535</a></li>
<li><code>--package</code> 와 같은 플래그에서 모호하지 않은 경우 불완전한 버전 번호 사용을 허용했습니다. <a href="https://github.com/rust-lang/cargo/pull/12591">#12591</a> <a href="https://github.com/rust-lang/cargo/pull/12614">#12614</a> <a href="https://github.com/rust-lang/cargo/pull/12806">#12806</a></li>
</ul>
<h3 id="변경됨-21"><a class="header" href="#변경됨-21">변경됨</a></h3>
<ul>
<li>❗️ 설정에서 배열이 병합되는 방식을 변경했습니다. 기존에는 순서가 명시되지 않았으나, 이제 일관성을 위해 다른 설정 타입들과 동일한 방식을 따릅니다. <a href="https://blog.rust-lang.org/inside-rust/2023/08/24/cargo-config-merging.html">요약</a> <a href="https://github.com/rust-lang/cargo/pull/12515">#12515</a></li>
<li>❗️ cargo-clean: <code>--doc</code> 와 <code>-p</code> 를 함께 사용할 때 에러를 발생시킵니다. <a href="https://github.com/rust-lang/cargo/pull/12637">#12637</a></li>
<li>❗ cargo-new / cargo-init: 더 이상 라이브러리의 VCS 무시 파일에서 <code>Cargo.lock</code> 을 제외하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/12382">#12382</a></li>
<li>cargo-update: 새로운 <code>--recursive</code> 를 위해 <code>--aggressive</code> 를 조용히 사용 중단(deprecate)했습니다. <a href="https://github.com/rust-lang/cargo/pull/12544">#12544</a></li>
<li>cargo-update: <code>-p/--package</code> 를 위치 인수로 사용할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/12545">#12545</a> <a href="https://github.com/rust-lang/cargo/pull/12586">#12586</a></li>
<li>cargo-install: 패키지 이름이 URL처럼 보일 때 <code>--git</code> 사용을 제안합니다. <a href="https://github.com/rust-lang/cargo/pull/12575">#12575</a></li>
<li>cargo-add: 기능 목록이 너무 길면 요약해서 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/12662">#12662</a> <a href="https://github.com/rust-lang/cargo/pull/12702">#12702</a></li>
<li><code>--target</code> 에 대한 쉘 자동 완성은 rustup을 사용하며, 실패 시 rustc로 폴백합니다. <a href="https://github.com/rust-lang/cargo/pull/12606">#12606</a></li>
<li>사용자가 가능한 <code>--target</code> 값들을 알 수 있도록 도움말을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12607">#12607</a></li>
<li>“registry index not found” 에러 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/12732">#12732</a></li>
<li><code>--explain</code> 의 CLI 도움말 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/12592">#12592</a></li>
<li><code>serde-untagged</code> 를 사용하여 태그가 없는(untagged) 열거형의 역직렬화 에러를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/12574">#12574</a> <a href="https://github.com/rust-lang/cargo/pull/12581">#12581</a></li>
<li>프리릴리스 버전 후보가 일치하지 않을 때의 에러를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/12659">#12659</a></li>
<li>모호한 패키지 ID 명세에 대한 제안 기능을 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/12685">#12685</a></li>
<li>문맥을 보여주도록 TOML 파싱 에러를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/12556">#12556</a></li>
<li><code>std::fs::metadata</code> 주변에 래퍼를 추가하여 파일시스템 에러를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/12636">#12636</a></li>
<li>해결사(resolver) 버전 불일치 경고를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/12573">#12573</a></li>
<li>지원되지 않는 인수에 대해 clap을 사용하여 대안 인수를 제안하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12529">#12529</a> <a href="https://github.com/rust-lang/cargo/pull/12693">#12693</a> <a href="https://github.com/rust-lang/cargo/pull/12723">#12723</a></li>
<li>cargo new/init <code>--help</code> 출력에서 불필요한 정보를 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/12594">#12594</a></li>
<li>콘솔 출력 및 스타일을 조정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12578">#12578</a> <a href="https://github.com/rust-lang/cargo/pull/12655">#12655</a> <a href="https://github.com/rust-lang/cargo/pull/12593">#12593</a></li>
</ul>
<h3 id="수정됨-22"><a class="header" href="#수정됨-22">수정됨</a></h3>
<ul>
<li><code>cargo rustc --print --target</code> 에 대해 전체 타겟 명세를 사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12743">#12743</a></li>
<li>EFI 타겟에 대해서도 PDB 파일을 복사하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12688">#12688</a></li>
<li>해결사(resolver) 동작이 패키지 순서에 의존하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12602">#12602</a></li>
<li><code>cargo remove</code> 실행 시 <code>profile.release.package."*"</code> 가 불필요하게 정리되던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12624">#12624</a></li>
</ul>
<h3 id="나이틀리nightly-전용-21"><a class="header" href="#나이틀리nightly-전용-21">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><code>-Zasymmetric-token</code>: 비대칭 토큰 지원을 위한 전용 불안정 플래그를 생성했습니다. <a href="https://github.com/rust-lang/cargo/pull/12551">#12551</a></li>
<li><code>-Zasymmetric-token</code>: 비대칭 토큰에 대한 로그아웃 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/12587">#12587</a></li>
<li><code>-Zmsrv-policy</code>: <strong>매우</strong> 기초적인 수준의 MSRV 해결사 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12560">#12560</a></li>
<li><code>-Zscript</code>: 코드 펜스(code fence) 지원을 임시로 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12681">#12681</a></li>
<li><code>-Zbindeps</code>: 레지스트리로부터의 의존성 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12421">#12421</a></li>
</ul>
<h3 id="문서-21"><a class="header" href="#문서-21">문서</a></h3>
<ul>
<li>❗ 정책 변경: 이제 라이브러리를 포함하여 <code>Cargo.lock</code> 을 버전 관리 시스템에 체크인하는 것이 기본 권장 사항입니다. 잠금 파일 및 CI 연동 문서도 확장되었습니다. <a href="https://doc.rust-lang.org/nightly/cargo/faq.html#why-have-cargolock-in-version-control">정책 문서</a>, <a href="https://doc.rust-lang.org/nightly/cargo/guide/cargo-toml-vs-cargo-lock.html">잠금 파일 문서</a>, <a href="https://doc.rust-lang.org/nightly/cargo/guide/continuous-integration.html">CI 문서</a>, <a href="https://github.com/rust-lang/cargo/pull/12382">#12382</a> <a href="https://github.com/rust-lang/cargo/pull/12630">#12630</a></li>
<li>SemVer: 선택적 의존성 제거에 관한 문서를 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12687">#12687</a></li>
<li>Contrib: 보안 응답 프로세스를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12487">#12487</a></li>
<li>cargo-publish: 업로드 타임아웃에 대한 경고를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12733">#12733</a></li>
<li>mdbook: 여러 검색어를 사용할 때 <em>AND</em> 검색을 사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12548">#12548</a></li>
<li>게시(publish) 권장 사례를 확립했습니다. <a href="https://github.com/rust-lang/cargo/pull/12745">#12745</a></li>
<li>캐럿(caret) 요구사항을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/12679">#12679</a></li>
<li><code>git</code> 의존성에서 <code>version</code> 이 작동하는 방식을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/12270">#12270</a></li>
<li>split-debuginfo의 기본값들을 명확히 하고 구분했습니다. <a href="https://github.com/rust-lang/cargo/pull/12680">#12680</a></li>
<li><code>dev</code> 및 <code>release</code> 프로파일에서 누락된 <code>strip</code> 항목들을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12748">#12748</a></li>
</ul>
<h3 id="내부-변경-21"><a class="header" href="#내부-변경-21">내부 변경</a></h3>
<ul>
<li>curl 8.3.0에 해당하는 <code>curl-sys</code> 0.4.66으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12718">#12718</a></li>
<li><code>gitoxide</code> 를 0.54.1로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12731">#12731</a></li>
<li>libgit2 1.7.1에 해당하는 <code>git2</code> 0.18.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12580">#12580</a></li>
<li><code>cargo_metadata</code> 를 0.17.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12610">#12758</a></li>
<li>타겟 아키텍처 인식 크레이트들을 mips r6 타겟을 지원하도록 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12720">#12720</a></li>
<li>publish.py: 더 이상 사용되지 않는 <code>sleep()</code> 호출들을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/12686">#12686</a></li>
<li>src/doc/man/includes에서 사용할 <code>{{command}}</code> 를 정의했습니다. <a href="https://github.com/rust-lang/cargo/pull/12570">#12570</a></li>
<li>네트워크 관련 메시지를 위해 트레이싱(tracing) 타겟 <code>network</code> 를 설정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12582">#12582</a></li>
<li>cargo-test-support: <code>with_stdout_unordered</code> 를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12635">#12635</a></li>
<li>dep: <code>termcolor</code> 에서 <code>anstream</code> 으로 전환했습니다. <a href="https://github.com/rust-lang/cargo/pull/12751">#12751</a></li>
<li><code>Source</code> 트레이트를 <code>cargo::sources</code> 아래로 이동했습니다. <a href="https://github.com/rust-lang/cargo/pull/12527">#12527</a></li>
<li>SourceId: <code>name</code> 과 <code>alt_registry_key</code> 를 하나의 enum으로 병합했습니다. <a href="https://github.com/rust-lang/cargo/pull/12675">#12675</a></li>
<li>TomlManifest: package_root가 디렉토리가 아닌 경우 실패 처리하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12722">#12722</a></li>
<li>util: <code>network::retry</code> 문서를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/12583">#12583</a></li>
<li>refactor: 재사용을 위해 cargo-add의 MSRV 관련 코드를 분리했습니다. <a href="https://github.com/rust-lang/cargo/pull/12553">#12553</a></li>
<li>refactor(install): 값 파싱 로직을 clap으로 이동했습니다. <a href="https://github.com/rust-lang/cargo/pull/12547">#12547</a></li>
<li>네트워크 테스트에서 발생하는 가짜 에러들을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12726">#12726</a></li>
<li><code>CARGO_LOG</code> 내부 로깅을 위해 더 간결한 상대 시간 포맷을 사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12542">#12542</a></li>
<li>코드 정리를 위해 더 새로운 표준 라이브러리 API를 사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12559">#12559</a> <a href="https://github.com/rust-lang/cargo/pull/12604">#12604</a> <a href="https://github.com/rust-lang/cargo/pull/12615">#12615</a> <a href="https://github.com/rust-lang/cargo/pull/12631">#12631</a></li>
<li>콘솔 상태 메시지를 버퍼링하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12727">#12727</a></li>
<li>해결(resolution)을 위해 서머리(summary)를 사용할 수 없는 경우 더 풍부한 정보를 제공하도록 인덱스 서머리를 enum으로 표현했습니다. <a href="https://github.com/rust-lang/cargo/pull/12643">#12643</a></li>
<li>지정된 의존성으로부터 루트까지의 경로를 해결할 때 최단 경로를 사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12678">#12678</a></li>
<li>인코딩된 <code>cargo update --precise</code> 를 같은 위치에서 읽고 쓰도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12629">#12629</a></li>
<li>내부 패키지들에 대해 MSRV를 설정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12381">#12381</a></li>
<li>ci: Renovate 스키마를 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12741">#12741</a></li>
<li>ci: MSRV에서 패치 버전을 무시하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12716">#12716</a></li>
</ul>
<h2 id="cargo-173-2023-10-05"><a class="header" href="#cargo-173-2023-10-05">Cargo 1.73 (2023-10-05)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/45782b6b...rust-1.73.0">45782b6b…rust-1.73.0</a></p>
<h3 id="추가됨-22"><a class="header" href="#추가됨-22">추가됨</a></h3>
<ul>
<li>추가 상세 모드인 <code>-vv</code> 사용 시 <code>cargo run/bench/test</code> 를 위한 환경 변수들을 인쇄합니다. <a href="https://github.com/rust-lang/cargo/pull/12498">#12498</a></li>
<li>Cargo timings 그래프에 패키지 버전을 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/12420">#12420</a></li>
</ul>
<h3 id="변경됨-22"><a class="header" href="#변경됨-22">변경됨</a></h3>
<ul>
<li>❗️ 커스텀 빌드 스크립트에서 <code>cargo::</code> 를 사용하는 경우 Cargo가 종료됩니다. 이는 향후 빌드 스크립트 호출 방식의 변경을 준비하기 위함입니다. <a href="https://github.com/rust-lang/cargo/pull/12332">#12332</a></li>
<li>❗️ <code>cargo login</code> 이 더 이상 <code>--</code> 구문 뒤의 토큰을 수락하지 않습니다. <code>--</code> 뒤의 인수들은 이제 새로운 자격 증명 제공자 기능을 위해 예약됩니다. 이로 인해 이전 버전에서의 <code>cargo login -- &lt;token&gt;</code> 지원이 누락되는 회귀 문제가 발생했습니다. <a href="https://github.com/rust-lang/cargo/pull/12499">#12499</a></li>
<li>Cargo <code>--help</code> 를 더 읽기 쉽게 만들었습니다. <a href="https://github.com/rust-lang/cargo/pull/11905">#11905</a></li>
<li><code>cargo test</code> 프로세스가 시그널에 의해 종료된 경우 <code>--nocapture</code> 플래그 사용을 권장합니다. <a href="https://github.com/rust-lang/cargo/pull/12463">#12463</a></li>
<li>타겟 정보를 얻기 위한 rustc 호출 시 jobserver 파일 기술자(file descriptors)를 유지하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12447">#12447</a></li>
<li><code>cargo test --all-targets</code> 가 doctest를 제외한다는 점을 <code>--help</code> 에서 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/12422">#12422</a></li>
<li>게시 시 <code>cargo.toml</code> 을 <code>Cargo.toml</code> 로 정규화하며, <code>Cargo.toml</code> 의 다른 대소문자 표기에 대해 경고를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/12399">#12399</a></li>
</ul>
<h3 id="수정됨-23"><a class="header" href="#수정됨-23">수정됨</a></h3>
<ul>
<li><code>~/.cargo/{git,registry}</code> 에서만 mtime 확인을 건너뛰도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12369">#12369</a></li>
<li>WSL2에서 <code>cargo doc --open</code> 실행 시 발생하는 크래시 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12373">#12373</a></li>
<li>특정 문자열에 대해 <code>http.debug</code> 를 활성화할 때 발생하는 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12468">#12468</a></li>
<li><code>cargo remove</code> 가 사용 중인 패치를 잘못 제거하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12454">#12454</a></li>
<li>크레이트 체크섬 조회 쿼리가 SemVer 빌드 메타데이터와 일치하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11447">#11447</a></li>
<li><code>[registries]</code> 테이블의 사용되지 않는 필드에 대해 여러 개의 경고 메시지가 출력되던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12439">#12439</a></li>
</ul>
<h3 id="나이틀리nightly-전용-22"><a class="header" href="#나이틀리nightly-전용-22">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>🔥 <code>-Zcredential-process</code> 가 다양한 자격 증명 제공자와 통신하기 위한 더 명확한 방식으로 재구현되었습니다. 여러 내장 제공자들도 Cargo에 추가되었습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#credential-process">문서</a> <a href="https://github.com/rust-lang/cargo/pull/12334">#12334</a> <a href="https://github.com/rust-lang/cargo/pull/12396">#12396</a> <a href="https://github.com/rust-lang/cargo/pull/12424">#12424</a> <a href="https://github.com/rust-lang/cargo/pull/12440">#12440</a> <a href="https://github.com/rust-lang/cargo/pull/12461">#12461</a> <a href="https://github.com/rust-lang/cargo/pull/12469">#12469</a> <a href="https://github.com/rust-lang/cargo/pull/12483">#12483</a> <a href="https://github.com/rust-lang/cargo/pull/12499">#12499</a> <a href="https://github.com/rust-lang/cargo/pull/12507">#12507</a> <a href="https://github.com/rust-lang/cargo/pull/12512">#12512</a> <a href="https://github.com/rust-lang/cargo/pull/12518">#12518</a> <a href="https://github.com/rust-lang/cargo/pull/12521">#12521</a> <a href="https://github.com/rust-lang/cargo/pull/12526">#12526</a><br />
주요 변경 사항:
<ul>
<li>Cargo 설정에서 <code>credential-process</code> 를 <code>credential-provider</code> 로 이름을 변경했습니다.</li>
<li>표준 입력/출력을 통해 외부 자격 증명 제공자와 통신하기 위한 새로운 JSON 프로토콜을 도입했습니다.</li>
<li>The GNOME Secret provider now dynamically loads <code>libsecert</code>.</li>
<li>1password 제공자가 더 이상 내장되어 제공되지 않습니다.</li>
<li>비대칭 토큰을 위한 불안정 키를 <code>registry-auth</code> 에서 <code>credential-process</code> 로 변경했습니다.</li>
</ul>
</li>
<li>❗️ <code>cargo test</code> 와 <code>cargo bench</code> 에서 <code>--keep-going</code> 플래그 지원을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/12478">#12478</a> <a href="https://github.com/rust-lang/cargo/pull/12492">#12492</a></li>
<li><code>-Zscript</code> 에 의해 생성되던 잘못된 패키지 이름들을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12349">#12349</a></li>
<li><code>-Zscript</code> 가 이제 지원되지 않는 명령어인 <code>publish</code> 및 <code>package</code> 에 대해 에러를 발생시킵니다. <a href="https://github.com/rust-lang/cargo/pull/12350">#12350</a></li>
<li><code>Cargo.lock</code> 의 소스 ID를 위해 URL 매개변수를 올바르게 인코딩하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12280">#12280</a></li>
<li>유효하지 않은 <code>panic_unwind</code> 표준 라이브러리 기능을 <code>panic-unwind</code> 로 교체했습니다. <a href="https://github.com/rust-lang/cargo/pull/12364">#12364</a></li>
<li><code>-Zlints</code>: doctest 추출 시 <code>[lints]</code> 설정을 준수하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12501">#12501</a></li>
</ul>
<h3 id="문서-22"><a class="header" href="#문서-22">문서</a></h3>
<ul>
<li>SemVer: 잘 정의된 타입의 정렬(alignment), 레이아웃 또는 크기 변경에 관한 섹션을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12169">#12169</a></li>
<li>프래그먼트 제어를 위해 헤딩 속성(heading attributes)을 사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12339">#12339</a></li>
<li>Cargo의 SemVer 사용 방식을 설명할 때 “digit” 대신 “number“를 사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12340">#12340</a></li>
<li>contrib: 게시(publishing) 작동 방식에 대한 상세 설명을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12344">#12344</a></li>
<li><code>cargo metadata</code> 의 “Package ID“와 “Source ID“가 불투명한(opaque) 문자열임을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/12313">#12313</a></li>
<li><code>rerun-if-env-changed</code> 가 크레이트 및 빌드 스크립트를 위해 설정한 환경 변수들을 모니터링하지 않는다는 점을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/12482">#12482</a></li>
<li>메타데이터 태그만 다른 여러 버전들은 crates.io에서 허용되지 않는다는 점을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/12335">#12335</a></li>
<li><code>lto</code> 설정이 <code>-Clinker-plugin-lto</code> 를 전달한다는 점을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/12407">#12407</a></li>
<li>설정 및 환경 변수 문서에 <code>profile.strip</code> 을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12337">#12337</a> <a href="https://github.com/rust-lang/cargo/pull/12408">#12408</a></li>
<li>아티팩트 JSON 디버그 정보 레벨에 대한 문서를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12376">#12376</a></li>
<li>하위 호환성을 위해 존재하는 <code>.cargo/credential</code> 파일에 대한 안내를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12479">#12479</a></li>
<li>워크스페이스 내부에서 사용되는 <code>resolver = 2</code> 에 대한 주의를 환기시켰습니다. <a href="https://github.com/rust-lang/cargo/pull/12388">#12388</a></li>
<li>문서에서 <code>master</code> 브랜치라는 표현을 기본 브랜치(default branch)로 교체했습니다. <a href="https://github.com/rust-lang/cargo/pull/12435">#12435</a></li>
</ul>
<h3 id="내부-변경-22"><a class="header" href="#내부-변경-22">내부 변경</a></h3>
<ul>
<li><code>criterion</code> 을 0.5.1로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12338">#12338</a></li>
<li>curl 8.2.1에 해당하는 <code>curl-sys</code> 0.4.65로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12406">#12406</a></li>
<li><code>indexmap</code> 을 v2로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12368">#12368</a></li>
<li><code>miow</code> 를 0.6.0으로 업데이트하고 구형 버전의 <code>windows-sys</code> 사용을 중단했습니다. <a href="https://github.com/rust-lang/cargo/pull/12453">#12453</a></li>
<li>ci: <code>--workspace</code> 를 사용하여 새로운 패키지를 자동으로 테스트하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12342">#12342</a></li>
<li>ci: Renovate를 사용하여 매달 자동으로 의존성을 업데이트합니다. <a href="https://github.com/rust-lang/cargo/pull/12341">#12341</a> <a href="https://github.com/rust-lang/cargo/pull/12466">#12466</a></li>
<li>ci: <code>cargo-semver-checks</code> 를 도입하여 SemVer를 준수하도록 <code>xtask-bump-check</code> 를 재작성했습니다. <a href="https://github.com/rust-lang/cargo/pull/12395">#12395</a> <a href="https://github.com/rust-lang/cargo/pull/12513">#12513</a> <a href="https://github.com/rust-lang/cargo/pull/12508">#12508</a></li>
<li>테스트 디렉토리의 구조를 변경하고 이름을 바꿨습니다. <a href="https://github.com/rust-lang/cargo/pull/12397">#12397</a> <a href="https://github.com/rust-lang/cargo/pull/12398">#12398</a></li>
<li><code>log</code> 에서 <code>tracing</code> 으로 마이그레이션했습니다. <a href="https://github.com/rust-lang/cargo/pull/12458">#12458</a> <a href="https://github.com/rust-lang/cargo/pull/12488">#12488</a></li>
<li>테스트에서 <code>--help</code> 출력을 추적하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11912">#11912</a></li>
<li>워크스페이스 내에서 패키지 메타데이터를 정리하고 공유하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12352">#12352</a></li>
<li><code>crates-io</code>: HTTP 헤더와 <code>Error</code> 타입을 노출했습니다. <a href="https://github.com/rust-lang/cargo/pull/12310">#12310</a></li>
<li><code>cargo update</code> 실행 시 <code>--aggressive</code> 와 <code>--precise</code> 플래그 간의 충돌을 clap에서 감지하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12428">#12428</a></li>
<li>나이틀리 채널 또는 <code>rust-lang/rust</code> 에서 Cargo 테스트 세트가 통과되도록 여러 사항을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12413">#12413</a> <a href="https://github.com/rust-lang/cargo/pull/12416">#12416</a> <a href="https://github.com/rust-lang/cargo/pull/12429">#12429</a> <a href="https://github.com/rust-lang/cargo/pull/12450">#12450</a> <a href="https://github.com/rust-lang/cargo/pull/12491">#12491</a> <a href="https://github.com/rust-lang/cargo/pull/12500">#12500</a></li>
</ul>
<h2 id="cargo-172-2023-08-24"><a class="header" href="#cargo-172-2023-08-24">Cargo 1.72 (2023-08-24)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/64fb38c9...rust-1.72.0">64fb38c9…rust-1.72.0</a></p>
<h3 id="추가됨-23"><a class="header" href="#추가됨-23">추가됨</a></h3>
<ul>
<li>❗ <code>-Zdoctest-in-workspace</code> 기능을 기본으로 활성화했습니다. 이제 각 문서 테스트를 실행할 때 작업 디렉토리가 해당 테스트가 속한 패키지의 루트 디렉토리로 설정됩니다. <a href="https://doc.rust-lang.org/nightly/cargo/commands/cargo-test.html#working-directory-of-tests">문서</a> <a href="https://github.com/rust-lang/cargo/pull/12221">#12221</a> <a href="https://github.com/rust-lang/cargo/pull/12288">#12288</a></li>
<li>이전에 설정된 <code>build.jobs</code> 병렬 처리 값을 다시 기본값으로 되돌리기 위한 “default” 키워드 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12222">#12222</a></li>
</ul>
<h3 id="변경됨-23"><a class="header" href="#변경됨-23">변경됨</a></h3>
<ul>
<li>🚨 <a href="https://github.com/rust-lang/cargo/security/advisories/GHSA-wrrj-h57r-vx9p">CVE-2023-40030</a>: 악의적인 의존성이 Cargo가 생성하는 타이밍 보고서에 임의의 JavaScript를 삽입할 수 있는 취약점을 발견했습니다. 이를 완화하기 위해 기능 이름 유효성 검사를 하드 에러(hard error)로 전환했습니다. 관련 경고는 Rust 1.49에서 추가되었습니다. 이러한 확장 문자들은 crates.io에서 허용되지 않으므로, 이 변경 사항은 다른 레지스트리 사용자나 레지스트리에 게시하지 않는 사람들에게만 영향을 미칠 것입니다. <a href="https://github.com/rust-lang/cargo/pull/12291">#12291</a></li>
<li>이제 에디션 2021 패키지가 가상 워크스페이스에 있고 <code>workspace.resolver</code> 가 설정되지 않은 경우 Cargo가 경고를 표시합니다. 워크스페이스의 해결사 버전을 명시적으로 설정하는 것이 권장됩니다. <a href="https://github.com/rust-lang/cargo/pull/10910">#10910</a></li>
<li>IBM AIX 공유 라이브러리 검색 경로를 <code>LIBPATH</code> 로 설정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11968">#11968</a></li>
<li>기본값이므로 rustc에 <code>-C debuginfo=0</code> 을 전달하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12022">#12022</a> <a href="https://github.com/rust-lang/cargo/pull/12205">#12205</a></li>
<li><code>cargo install</code> 실패 시 이전 임시 경로를 재사용한다는 메시지를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12231">#12231</a></li>
<li><code>rustup</code> 재정의(override) 축약형이 잘못된 위치에 있을 때 메시지를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12226">#12226</a></li>
<li>중첩된 서브모듈을 가져올 때 가능한 한 scp 스타일의 URL을 준수하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12359">#12359</a> <a href="https://github.com/rust-lang/cargo/pull/12411">#12411</a></li>
</ul>
<h3 id="수정됨-24"><a class="header" href="#수정됨-24">수정됨</a></h3>
<ul>
<li><code>cargo clean</code> 실행 시 레이스 컨디션 해결을 위한 폴백으로 <code>remove_dir_all</code> 을 사용합니다. <a href="https://github.com/rust-lang/cargo/pull/11442">#11442</a></li>
<li>Cargo가 사용자의 <code>[features]</code> 테이블 형식을 다시 맞출 가능성을 줄였습니다. <a href="https://github.com/rust-lang/cargo/pull/12191">#12191</a></li>
<li>중첩된 Git 서브모듈을 페치할 수 없던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12244">#12244</a></li>
</ul>
<h3 id="나이틀리nightly-전용-23"><a class="header" href="#나이틀리nightly-전용-23">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>의존성을 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12245">#12245</a> <a href="https://github.com/rust-lang/cargo/pull/12255">#12255</a> <a href="https://github.com/rust-lang/cargo/pull/12258">#12258</a> <a href="https://github.com/rust-lang/cargo/pull/12262">#12262</a> <a href="https://github.com/rust-lang/cargo/pull/12268">#12268</a> <a href="https://github.com/rust-lang/cargo/pull/12269">#12269</a> <a href="https://github.com/rust-lang/cargo/pull/12281">#12281</a> <a href="https://github.com/rust-lang/cargo/pull/12282">#12282</a> <a href="https://github.com/rust-lang/cargo/pull/12283">#12283</a> <a href="https://github.com/rust-lang/cargo/pull/12284">#12284</a> <a href="https://github.com/rust-lang/cargo/pull/12287">#12287</a> <a href="https://github.com/rust-lang/cargo/pull/12289">#12289</a> <a href="https://github.com/rust-lang/cargo/pull/12303">#12303</a> <a href="https://github.com/rust-lang/cargo/pull/12305">#12305</a> <a href="https://github.com/rust-lang/cargo/pull/12308">#12308</a></li>
<li><code>cargo new</code>/<code>cargo init</code> 실행 시 워크스페이스 린트를 자동으로 상속하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12174">#12174</a></li>
<li><code>-Zjobserver-per-rustc</code> 를 다시 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/12285">#12285</a></li>
<li><code>-Zconfig-include</code> 에 대한 <code>.toml</code> 파일 확장자 제한을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12298">#12298</a></li>
<li>다음 잠금 파일 버전 상향을 준비하기 위해 <code>-Znext-lockfile-bump</code> 를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12279">#12279</a> <a href="https://github.com/rust-lang/cargo/pull/12302">#12302</a></li>
</ul>
<h3 id="문서-23"><a class="header" href="#문서-23">문서</a></h3>
<ul>
<li>Cargo FAQ에 <code>Cargo.lock</code> 충돌에 대한 설명을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12185">#12185</a></li>
<li>인덱스가 SemVer 빌드 메타데이터를 무시한다는 점에 대한 짧은 메모를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12206">#12206</a></li>
<li><code>cargo::sources</code> 모듈의 타입들에 대해 문서 주석을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12192">#12192</a> <a href="https://github.com/rust-lang/cargo/pull/12239">#12239</a> <a href="https://github.com/rust-lang/cargo/pull/12247">#12247</a></li>
<li><code>Source</code> 다운로드 함수들에 대한 더 많은 문서를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12319">#12319</a></li>
<li>자격 증명 헬퍼들을 위한 README를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12322">#12322</a></li>
<li>의존성 해결(Dependency Resolution) 섹션의 버전 요구사항 예제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12267">#12267</a></li>
<li>cargo-install의 기본 동작을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/12276">#12276</a></li>
<li>기본적으로 <code>main</code> 대신 “default” 브랜치를 사용한다는 점을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/12251">#12251</a></li>
<li>버전 요구사항에 대한 지침을 제공합니다. <a href="https://github.com/rust-lang/cargo/pull/12323">#12323</a></li>
</ul>
<h3 id="내부-변경-23"><a class="header" href="#내부-변경-23">내부 변경</a></h3>
<ul>
<li>다중 라운드 팩 협상(multi-round pack negotiations)을 위해 <code>gix</code> 를 0.45로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12236">#12236</a></li>
<li>curl 8.1.2에 해당하는 <code>curl-sys</code> 0.4.63으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12218">#12218</a></li>
<li><code>openssl</code> 을 0.10.55로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12300">#12300</a></li>
<li>여러 의존성들을 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12261">#12261</a></li>
<li><code>windows-sys</code> 의존성에서 사용되지 않는 기능들을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/12176">#12176</a></li>
<li>컴파일러 호출 방식을 리팩토링했습니다. <a href="https://github.com/rust-lang/cargo/pull/12211">#12211</a></li>
<li>git 및 레지스트리 소스, 그리고 레지스트리 데이터를 리팩토링했습니다. <a href="https://github.com/rust-lang/cargo/pull/12203">#12203</a> <a href="https://github.com/rust-lang/cargo/pull/12197">#12197</a> <a href="https://github.com/rust-lang/cargo/pull/12240">#12240</a> <a href="https://github.com/rust-lang/cargo/pull/12248">#12248</a></li>
<li><code>-Z</code> 플래그들을 사전 순으로 정렬했습니다. <a href="https://github.com/rust-lang/cargo/pull/12182">#12182</a> <a href="https://github.com/rust-lang/cargo/pull/12223">#12223</a> <a href="https://github.com/rust-lang/cargo/pull/12224">#12224</a></li>
<li>Cargo의 테스트 인프라를 여러 방면으로 개선하고 속도를 향상했습니다. <a href="https://github.com/rust-lang/cargo/pull/12184">#12184</a> <a href="https://github.com/rust-lang/cargo/pull/12188">#12188</a> <a href="https://github.com/rust-lang/cargo/pull/12189">#12189</a> <a href="https://github.com/rust-lang/cargo/pull/12194">#12194</a> <a href="https://github.com/rust-lang/cargo/pull/12199">#12199</a></li>
<li>print-ban을 테스트에서 clippy로 마이그레이션했습니다. <a href="https://github.com/rust-lang/cargo/pull/12246">#12246</a></li>
<li>Interning 용도로 <code>OnceLock</code> 을 사용하도록 전환했습니다. <a href="https://github.com/rust-lang/cargo/pull/12217">#12217</a></li>
<li>불필요한 <code>.clone</code> 호출을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/12213">#12213</a></li>
<li>리눅스가 아닌 플랫폼에서 <code>cargo-credential-gnome-secret</code> 을 컴파일하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12321">#12321</a></li>
<li>매크로를 사용하여 워크스페이스 상속 가능 필드들의 getter 중복을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/12317">#12317</a></li>
<li>레지스트리 API 항목들을 별도의 모듈로 추출하고 재배치했습니다. <a href="https://github.com/rust-lang/cargo/pull/12290">#12290</a></li>
<li>컨테이너 테스트 실패 시 더 나은 에러를 표시하도록 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/12264">#12264</a></li>
</ul>
<h2 id="cargo-1711-2023-08-03"><a class="header" href="#cargo-1711-2023-08-03">Cargo 1.71.1 (2023-08-03)</a></h2>
<h3 id="수정됨-25"><a class="header" href="#수정됨-25">수정됨</a></h3>
<ul>
<li>🚨 <a href="https://github.com/rust-lang/cargo/security/advisories/GHSA-j3xp-wfr4-hx87">CVE-2023-38497</a>: Cargo 1.71.1 이상 버전에서는 크레이트 아카이브를 추출할 때 umask를 준수합니다. 또한 이전 Cargo 버전에서 생성된 캐시에 접근하려고 할 때 해당 캐시를 삭제합니다.</li>
</ul>
<h2 id="cargo-171-2023-07-13"><a class="header" href="#cargo-171-2023-07-13">Cargo 1.71 (2023-07-13)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/84b7041f...rust-1.71.0">84b7041f…rust-1.71.0</a></p>
<h3 id="추가됨-24"><a class="header" href="#추가됨-24">추가됨</a></h3>
<ul>
<li>Cargo.toml에서 이름이 지정된(named) 디버그 정보 옵션을 허용합니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/profiles.html#debug">문서</a> <a href="https://github.com/rust-lang/cargo/pull/11958">#11958</a></li>
<li><code>cargo metadata</code> 출력에 <code>workspace_default_members</code> 를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/11978">#11978</a></li>
<li><code>cargo new</code>/<code>cargo init</code> 실행 시 워크스페이스 필드들을 자동으로 상속하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12069">#12069</a></li>
</ul>
<h3 id="변경됨-24"><a class="header" href="#변경됨-24">변경됨</a></h3>
<ul>
<li>❗ <code>rustup</code> 환경에서의 사용을 최적화했습니다. Cargo가 rustup 프록시를 가리키는 <code>rustc</code> 를 실행할 것임을 감지하면, 프록시를 우회하고 실제 바이너리를 직접 사용하려고 시도합니다. rustup 및 <code>RUSTUP_TOOLCHAIN</code> 과의 상호작용에 관한 몇 가지 가정이 있으나, 일반 사용자에게는 영향을 미치지 않을 것으로 예상됩니다. <a href="https://github.com/rust-lang/cargo/pull/11917">#11917</a></li>
<li>❗ 패키지 조회 시, 오타 처리를 위해 원래 이름, 전체 하이픈(<code>-</code>), 전체 밑줄(<code>_</code>) 케이스만 시도합니다. 이전에는 하이픈과 밑줄의 모든 조합을 시도하여 crates.io에 과도한 요청을 보냈습니다. <a href="https://github.com/rust-lang/cargo/pull/12083">#12083</a></li>
<li>❗ <code>[env]</code> 설정 테이블에서 <code>RUSTUP_HOME</code> 및 <code>RUSTUP_TOOLCHAIN</code> 설정을 금지했습니다. 이는 문제가 발생하거나 혼란을 야기할 가능성이 높기 때문에 Cargo가 지원하고자 하는 사용 사례가 아닌 것으로 간주됩니다. <a href="https://github.com/rust-lang/cargo/pull/12101">#12101</a> <a href="https://github.com/rust-lang/cargo/pull/12107">#12107</a></li>
<li>Cargo.toml에서 의존성 테이블이 비어 있을 때의 에러 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/11997">#11997</a></li>
<li>Cargo.toml에서 비어 있는 의존성이 지정되었을 때의 에러 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/12001">#12001</a></li>
<li>좁은 화면에서도 읽기 쉽도록 <code>--help</code> 텍스트를 줄바꿈 처리했습니다. <a href="https://github.com/rust-lang/cargo/pull/12013">#12013</a></li>
<li><code>--bin</code> 의 역할을 명확히 하기 위해 <code>--help</code> 텍스트의 인수 순서를 조정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12157">#12157</a></li>
<li>레지스트리에 대한 <code>cargo publish</code> 요청에 <code>rust-version</code> 정보가 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/12041">#12041</a></li>
</ul>
<h3 id="수정됨-26"><a class="header" href="#수정됨-26">수정됨</a></h3>
<ul>
<li><code>cargo clippy --fix</code> 의 버그 보고 URL을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11882">#11882</a></li>
<li>이제 Cargo가 타겟 정보 탐색을 위한 rust 호출 시 <code>[env]</code> 설정을 적용합니다. <a href="https://github.com/rust-lang/cargo/pull/12029">#12029</a></li>
<li>HTTP/2 사용 시 http 디버그 출력에서 토큰이 편집(redact)되지 않던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12095">#12095</a></li>
<li>일부 상황에서 <code>-C debuginfo</code> 가 전달되지 않아 빌드 캐시 미스가 발생하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12165">#12165</a></li>
<li><code>cargo install</code> 시 동일한 이름을 가진 패키지들이 발견될 때의 모호성 문제를 수정했습니다. 이 문제는 패키지가 자신의 이전 버전에 의존하는 것과 같은 상황에서 발생했습니다. <a href="https://github.com/rust-lang/cargo/pull/12015">#12015</a></li>
<li><code>cargo package</code> 가 충돌 파일을 확인할 때 발생하는 오탐(false positive) 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12135">#12135</a></li>
<li>선택적 의존성의 기능을 활성화할 때 <code>dep/feat</code> 구문이 <code>dep:</code> 구문과 공존할 경우 작동하지 않던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12130">#12130</a></li>
<li><code>cargo tree</code> 가 <code>-e no-proc-macro</code> 옵션 사용 시 출력을 올바르게 처리하지 못하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12044">#12044</a></li>
<li>Cargo.toml의 <code>readme</code> 또는 <code>license-file</code> 이 비어 있는 경우 <code>cargo package</code> 에서 에러 대신 경고를 출력하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12036">#12036</a></li>
<li>HTTP 프록시를 사용 중이고 Cargo 실행 파일이 특정 버전의 시스템 libcurl과 링크된 경우 CURL 연결이 실패할 수 있던 문제를 수정했습니다. 영향을 받는 libcurl 버전: 7.87.0, 7.88.0, 7.88.1. <a href="https://github.com/rust-lang/cargo/pull/12234">#12234</a> <a href="https://github.com/rust-lang/cargo/pull/12242">#12242</a></li>
</ul>
<h3 id="나이틀리nightly-전용-24"><a class="header" href="#나이틀리nightly-전용-24">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>🔥 <code>-Zgitoxide</code> 기능이 이제 의존성 및 레지스트리 인덱스에 대해 얕은 클론(shallow clones) 및 페치를 지원합니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#gitoxide">문서</a> <a href="https://github.com/rust-lang/cargo/pull/11840">#11840</a></li>
<li>🔥 <code>-Zlints</code> 기능은 Cargo.toml에서 린트 규칙을 설정할 수 있게 해줍니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#lints">문서</a> <a href="https://github.com/rust-lang/cargo/pull/12148">#12148</a> <a href="https://github.com/rust-lang/cargo/pull/12168">#12168</a></li>
<li><code>nightly-2023-05-04</code> 에서 <code>-Zbuild-std</code> 사용 시 기능이 누락되던 문제가 <code>nightly-2023-05-05</code>에서 수정되었습니다. <a href="https://github.com/rust-lang/cargo/pull/12088">#12088</a></li>
<li>프로파일의 rustflags가 변경되었을 때 재컴파일하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11981">#11981</a></li>
<li><code>-Zmsrv-policy</code> 기능 플래그를 위한 플레이스홀더(placeholder)를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12043">#12043</a></li>
<li><code>cargo add</code> 사용 시 <code>-Zmsrv-policy</code> 가 켜져 있으면 패키지 선택 시 <code>rust-version</code> 을 고려하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12078">#12078</a></li>
</ul>
<h3 id="문서-24"><a class="header" href="#문서-24">문서</a></h3>
<ul>
<li>Cargo 팀 헌장을 추가했습니다. <a href="https://doc.crates.io/contrib/team.html">문서</a> <a href="https://github.com/rust-lang/cargo/pull/12010">#12010</a></li>
<li>SemVer: 기존 항목에 <code>#[non_exhaustive]</code> 를 추가하는 것은 하위 호환성이 깨지는 변경(breaking change)입니다. <a href="https://github.com/rust-lang/cargo/pull/10877">#10877</a></li>
<li>SemVer: <code>unsafe</code> 함수를 <code>safe</code> 하게 만드는 것은 하위 호환성이 깨지는 변경이 아닙니다. <a href="https://github.com/rust-lang/cargo/pull/12116">#12116</a></li>
<li>SemVer: MSRV를 변경하는 것은 일반적으로 마이너 변경(minor change)입니다. <a href="https://github.com/rust-lang/cargo/pull/12122">#12122</a></li>
<li><code>cargo yank</code> 를 언제 어떻게 수행해야 하는지 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/11862">#11862</a></li>
<li>crates.io가 docs.rs에 즉시 링크되지 않는다는 점을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/12146">#12146</a></li>
<li>테스트 타겟 설정 관련 문서를 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/12032">#12032</a></li>
<li>인덱스 포맷에 <code>rust_version</code> 을 명시했습니다. <a href="https://github.com/rust-lang/cargo/pull/12040">#12040</a></li>
<li>레지스트리 소유자 제거 API 응답에 <code>msg</code> 를 명시했습니다. <a href="https://github.com/rust-lang/cargo/pull/12068">#12068</a></li>
<li>아티팩트 의존성(artifact-dependencies)에 대한 더 많은 문서를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12110">#12110</a></li>
<li>라이브러리로서의 Cargo를 위해 <code>Source</code> 및 빌드 스크립트에 대한 문서 주석을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12133">#12133</a> <a href="https://github.com/rust-lang/cargo/pull/12153">#12153</a> <a href="https://github.com/rust-lang/cargo/pull/12159">#12159</a></li>
<li>여러 오타 및 깨진 링크들을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12018">#12018</a> <a href="https://github.com/rust-lang/cargo/pull/12020">#12020</a> <a href="https://github.com/rust-lang/cargo/pull/12049">#12049</a> <a href="https://github.com/rust-lang/cargo/pull/12067">#12067</a> <a href="https://github.com/rust-lang/cargo/pull/12073">#12073</a> <a href="https://github.com/rust-lang/cargo/pull/12143">#12143</a></li>
<li>home: 플랫폼별 동작 방식을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/12047">#12047</a></li>
</ul>
<h3 id="내부-변경-24"><a class="header" href="#내부-변경-24">내부 변경</a></h3>
<ul>
<li><code>linux-raw-sys</code> 를 0.3.2로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/11998">#11998</a></li>
<li>libgit2 1.6.4에 해당하는 <code>git2</code> 0.17.1로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12096">#12096</a></li>
<li><code>windows-sys</code> 를 0.48.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12021">#12021</a></li>
<li><code>libc</code> 를 0.2.144로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12014">#12014</a> <a href="https://github.com/rust-lang/cargo/pull/12098">#12098</a></li>
<li><code>openssl-src</code> 를 111.25.3+1.1.1t로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12005">#12005</a></li>
<li><code>home</code> 을 0.5.5로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/12037">#12037</a></li>
<li>사용 중인 <code>Win32_System_Console</code> 기능을 활성화했습니다. <a href="https://github.com/rust-lang/cargo/pull/12016">#12016</a></li>
<li>Cargo가 이제 Cargo 워크스페이스가 되었습니다. 드디어 자체 적용(dogfooding)을 시작합니다! <a href="https://github.com/rust-lang/cargo/pull/11851">#11851</a> <a href="https://github.com/rust-lang/cargo/pull/11994">#11994</a> <a href="https://github.com/rust-lang/cargo/pull/11996">#11996</a> <a href="https://github.com/rust-lang/cargo/pull/12024">#12024</a> <a href="https://github.com/rust-lang/cargo/pull/12025">#12025</a> <a href="https://github.com/rust-lang/cargo/pull/12057">#12057</a></li>
<li>🔥 Cargo 기여자를 위한 새롭고 명확한 이슈 레이블 시스템을 도입했습니다. <a href="https://doc.crates.io/contrib/issues.html">문서</a> <a href="https://github.com/rust-lang/cargo/pull/11995">#11995</a> <a href="https://github.com/rust-lang/cargo/pull/12002">#12002</a> <a href="https://github.com/rust-lang/cargo/pull/12003">#12003</a></li>
<li>Windows/Mac 자격 증명 관리자가 모든 플랫폼에서 빌드될 수 있도록 허용했습니다. <a href="https://github.com/rust-lang/cargo/pull/11993">#11993</a> <a href="https://github.com/rust-lang/cargo/pull/12027">#12027</a></li>
<li>Windows가 아닌 플랫폼에서만 <code>openssl</code> 을 사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11979">#11979</a></li>
<li>오타 제안을 제공하기 위해 제한된 Damerau-Levenshtein 알고리즘을 사용합니다. <a href="https://github.com/rust-lang/cargo/pull/11963">#11963</a></li>
<li>새로운 xtask인 <code>cargo build-man</code> 을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12048">#12048</a></li>
<li>새로운 xtask인 <code>cargo stale-label</code> 을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12051">#12051</a></li>
<li>새로운 xtask인 <code>cargo unpublished</code> 를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/12039">#12039</a> <a href="https://github.com/rust-lang/cargo/pull/12045">#12045</a> <a href="https://github.com/rust-lang/cargo/pull/12085">#12085</a></li>
<li>CI: 멤버 크레이트들에 대해 버전 상향(version bump)이 필요한지 확인하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/12126">#12126</a></li>
<li>일부 테스트 인프라 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11976">#11976</a> <a href="https://github.com/rust-lang/cargo/pull/12026">#12026</a> <a href="https://github.com/rust-lang/cargo/pull/12055">#12055</a> <a href="https://github.com/rust-lang/cargo/pull/12117">#12117</a></li>
</ul>
<h2 id="cargo-170-2023-06-01"><a class="header" href="#cargo-170-2023-06-01">Cargo 1.70 (2023-06-01)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/9880b408...rust-1.70.0">9880b408…rust-1.70.0</a></p>
<h3 id="추가됨-25"><a class="header" href="#추가됨-25">추가됨</a></h3>
<ul>
<li>🎉 로컬 레지스트리에서 API 토큰을 제거하는 <code>cargo logout</code> 명령어를 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/commands/cargo-logout.html">문서</a> <a href="https://github.com/rust-lang/cargo/pull/11919">#11919</a> <a href="https://github.com/rust-lang/cargo/pull/11950">#11950</a></li>
<li><code>cargo install</code> 에 <code>--ignore-rust-version</code> 플래그를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/11859">#11859</a></li>
<li>크레이트 컴파일 시 <code>CARGO_PKG_README</code> 환경 변수가 README 파일 경로로 설정됩니다. <a href="https://github.com/rust-lang/cargo/pull/11645">#11645</a></li>
<li>컴파일에 실패한 Cargo 타겟에 대해 더 풍부한 정보를 표시하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11636">#11636</a></li>
</ul>
<h3 id="변경됨-25"><a class="header" href="#변경됨-25">변경됨</a></h3>
<ul>
<li>🎉 이제 crates.io의 기본 프로토콜로 <code>sparse</code> 프로토콜을 사용합니다! (<a href="https://github.com/rust-lang/rfcs/blob/master/text/2789-sparse-index.md">RFC 2789</a>) (<a href="https://doc.rust-lang.org/nightly/cargo/reference/registries.html#registry-protocols">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/11791">#11791</a> <a href="https://github.com/rust-lang/cargo/pull/11783">#11783</a></li>
<li>❗ <code>cargo login</code> 및 <code>cargo logout</code> 이 이제 <code>registry.default</code> 에 지정된 레지스트리를 사용합니다. 이는 의도치 않은 회귀(regression) 문제였습니다. <a href="https://github.com/rust-lang/cargo/pull/11949">#11949</a></li>
<li><code>cargo update</code> 가 의존성을 다운그레이드할 때 <code>Downgrading</code> 상태를 정확하게 표시하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11839">#11839</a></li>
<li>디버깅을 돕기 위해 HTTP 에러에 더 많은 정보를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/11878">#11878</a></li>
<li>네트워크 재시도 시 지연 시간을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/11881">#11881</a></li>
<li>게시 완료를 기다릴 때의 <code>cargo publish</code> 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/11713">#11713</a></li>
<li>Git 저장소에서 <code>cargo install</code> 실행 시 여러 패키지가 발견될 경우의 에러 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/11835">#11835</a></li>
</ul>
<h3 id="수정됨-27"><a class="header" href="#수정됨-27">수정됨</a></h3>
<ul>
<li><code>cargo tree</code> 의 <code>--charset</code> 옵션에서 가능한 값들의 중복을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/11785">#11785</a></li>
<li>값의 유무에 관계없이 정의된 설정에 대해 <code>CARGO_CFG_</code> 변수들을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11790">#11790</a></li>
<li><code>cargo add</code> 시 추가된 의존성의 순환 기능(feature)으로 인한 무한 루프 문제를 해결했습니다. <a href="https://github.com/rust-lang/cargo/pull/11805">#11805</a></li>
<li>의존성 해결 과정에 포함된 <code>[patch]</code> 가 충돌을 일으킬 때 패닉이 발생하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11770">#11770</a></li>
<li>자격 증명 토큰 형식 검증 로직을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11951">#11951</a></li>
<li>게시(publish) 시 누락되었던 토큰 형식 검증을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/11952">#11952</a></li>
<li>Config 스냅샷에서 환경 변수 조회 시 대소문자 불일치 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11824">#11824</a></li>
<li><code>cargo new</code> 실행 시 다른 VCS 무시 파일들과 시맨틱을 맞춘 올바른 <code>.hgignore</code> 를 생성하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11855">#11855</a></li>
<li>불필요한 퍼지(fuzzy) 레지스트리 인덱스 조회를 중단했습니다. 이를 통해 이름에 <code>-</code> 또는 <code>_</code> 가 포함된 크레이트에 대해 원격 레지스트리로 보내는 HTTP 요청 횟수를 크게 줄였습니다. <a href="https://github.com/rust-lang/cargo/pull/11936">#11936</a> <a href="https://github.com/rust-lang/cargo/pull/11937">#11937</a></li>
</ul>
<h3 id="나이틀리nightly-전용-25"><a class="header" href="#나이틀리nightly-전용-25">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><code>-Zdirect-minimal-versions</code> 를 추가했습니다. 이는 <code>-Zminimal-versions</code> 처럼 동작하지만 직접적인 의존성에 대해서만 적용됩니다. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#direct-minimal-versions">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/11688">#11688</a></li>
<li>Added <code>-Zgitoxide</code> which switches all <code>git fetch</code> operation in Cargo to use <code>gitoxide</code> crate. This is still an MVP but could improve the performance up to 2 times. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html##gitoxide">docs</a>) <a href="https://github.com/rust-lang/cargo/pull/11448">#11448</a> <a href="https://github.com/rust-lang/cargo/pull/11800">#11800</a> <a href="https://github.com/rust-lang/cargo/pull/11822">#11822</a> <a href="https://github.com/rust-lang/cargo/pull/11830">#11830</a></li>
<li>rustc 측의 변경 사항이 반영되지 않아 <code>-Zjobserver-per-rustc</code> 를 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/11764">#11764</a></li>
</ul>
<h3 id="문서-25"><a class="header" href="#문서-25">문서</a></h3>
<ul>
<li>불안정한 기능 문서를 정리했습니다. <a href="https://github.com/rust-lang/cargo/pull/11793">#11793</a></li>
<li>그래프를 포함한 타이밍 보고서 문서를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/11798">#11798</a></li>
<li>게시 후 레지스트리 인덱스 상태에 관한 요구 사항을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/11926">#11926</a></li>
<li><code>-C</code> 옵션이 명령어 앞에 나타나야 한다는 점을 명확히 문서화했습니다. <a href="https://github.com/rust-lang/cargo/pull/11947">#11947</a></li>
<li><code>cargo test</code>, <code>cargo bench</code>, <code>cargo run</code> 의 작업 디렉토리 동작을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/11901">#11901</a></li>
<li><code>registries.name.index</code> 설정 관련 문서를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11880">#11880</a></li>
<li><code>cargo-add</code> 도움말 텍스트에 잠재적인 쉘 확장(shell expansions) 관련 주의 사항을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/11826">#11826</a></li>
<li>외부 도구용 JSON 문서를 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/11918">#11918</a></li>
<li>인덱스 JSON과 API 또는 메타데이터 간의 차이점을 명시했습니다. <a href="https://github.com/rust-lang/cargo/pull/11927">#11927</a></li>
<li>pkgid 형식을 언급할 때 <code>@</code> 를 일관되게 사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11956">#11956</a></li>
<li>Cargo 기여자 가이드를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/11825">#11825</a> <a href="https://github.com/rust-lang/cargo/pull/11842">#11842</a> <a href="https://github.com/rust-lang/cargo/pull/11869">#11869</a> <a href="https://github.com/rust-lang/cargo/pull/11876">#11876</a></li>
<li>Cargo 기여자 가이드의 일부를 Cargo API 문서로 옮겼습니다. <a href="https://doc.rust-lang.org/nightly/nightly-rustc/cargo">문서</a> <a href="https://github.com/rust-lang/cargo/pull/11809">#11809</a> <a href="https://github.com/rust-lang/cargo/pull/11841">#11841</a> <a href="https://github.com/rust-lang/cargo/pull/11850">#11850</a> <a href="https://github.com/rust-lang/cargo/pull/11870">#11870</a></li>
<li>Cargo 팀이 이제 <a href="https://github.com/rust-lang/cargo/wiki/Office-Hours">오피스 아워(office hours)</a>를 운영합니다! <a href="https://github.com/rust-lang/cargo/pull/11903">#11903</a></li>
</ul>
<h3 id="내부-변경-25"><a class="header" href="#내부-변경-25">내부 변경</a></h3>
<ul>
<li>SHA256 계산을 위해 <code>sha2</code> 크레이트를 사용하도록 전환했습니다. <a href="https://github.com/rust-lang/cargo/pull/11795">#11795</a> <a href="https://github.com/rust-lang/cargo/pull/11807">#11807</a></li>
<li>벤치 세트를 인덱스 아카이브로 전환했습니다. <a href="https://github.com/rust-lang/cargo/pull/11933">#11933</a></li>
<li><code>base64</code> 를 0.21.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/11796">#11796</a></li>
<li>curl 8.0.1에 해당하는 <code>curl-sys</code> 0.4.61로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/11871">#11871</a></li>
<li><code>proptest</code> 를 1.1.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/11886">#11886</a></li>
<li>libgit2 1.6.3에 해당하는 <code>git2</code> 0.17.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/11928">#11928</a></li>
<li><code>clap</code> 을 4.2로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/11904">#11904</a></li>
<li>Cargo 자체 CI 파이프라인에 <code>cargo-deny</code> 를 통합했습니다. <a href="https://github.com/rust-lang/cargo/pull/11761">#11761</a></li>
<li>비차단(non-blocking) IO 호출을 더 견고하게 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/11624">#11624</a></li>
<li><code>cargo-platform</code> 에서 <code>serde</code> 의 <code>derive</code> 기능을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/11915">#11915</a></li>
<li><code>std::fs::canonicalize</code> 를 더 견고한 <code>try_canonicalize</code> 로 교체했습니다. <a href="https://github.com/rust-lang/cargo/pull/11866">#11866</a></li>
<li><code>std::env::var</code> 등에 대해 <code>disallowed_methods</code> clippy 경고를 활성화했습니다. <a href="https://github.com/rust-lang/cargo/pull/11828">#11828</a></li>
</ul>
<h2 id="cargo-169-2023-04-20"><a class="header" href="#cargo-169-2023-04-20">Cargo 1.69 (2023-04-20)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/985d561f...rust-1.69.0">985d561f…rust-1.69.0</a></p>
<h3 id="추가됨-26"><a class="header" href="#추가됨-26">추가됨</a></h3>
<ul>
<li>컴파일 경고가 자동으로 수정 가능한 경우, Cargo가 <code>cargo fix</code> 또는 <code>cargo clippy --fix</code>를 제안합니다. <a href="https://github.com/rust-lang/cargo/pull/11558">#11558</a></li>
<li>라이브러리 크레이트를 설치하려고 시도하면 Cargo가 <code>cargo add</code> 를 제안합니다. <a href="https://github.com/rust-lang/cargo/pull/11410">#11410</a></li>
<li>바이너리 예제에 대해서도 <code>CARGO_BIN_NAME</code> 환경 변수를 설정하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11705">#11705</a></li>
</ul>
<h3 id="변경됨-26"><a class="header" href="#변경됨-26">변경됨</a></h3>
<ul>
<li>❗ 워크스페이스 의존성의 <code>default-features</code> 가 false로 설정되어 있고, 멤버의 상속된 의존성이 <code>default-features = true</code> 인 경우, Cargo는 해당 의존성의 기본 기능을 활성화합니다. <a href="https://github.com/rust-lang/cargo/pull/11409">#11409</a></li>
<li>❗ <code>[env]</code> 설정 테이블에서 <code>CARGO_HOME</code> 사용을 금지했습니다. Cargo 자체는 이 값을 사용하지 않지만, 의도치 않게 Cargo를 재귀적으로 호출할 때 이 값이 사용될 수 있기 때문입니다. <a href="https://github.com/rust-lang/cargo/pull/11644">#11644</a></li>
<li>❗ 명시적으로 설정하지 않은 경우, 빌드 의존성에 대한 디버그 정보가 이제 기본적으로 꺼집니다. 이를 통해 전체 빌드 시간이 단축될 것으로 기대됩니다. <a href="https://github.com/rust-lang/cargo/pull/11252">#11252</a></li>
<li>레지스트리 토큰에 유효하지 않은 영숫자 문자가 포함된 경우 에러를 발생시킵니다. <a href="https://github.com/rust-lang/cargo/pull/11600">#11600</a></li>
<li><code>cargo add</code> 가 이제 <code>[dependencies.*]</code> 는 고려하지 않고 <code>[dependencies]</code> 의 순서만 확인합니다. <a href="https://github.com/rust-lang/cargo/pull/11612">#11612</a></li>
<li>의존성 라이브러리인 <code>jobserver</code> 를 업데이트하여 GNU Make 4.4의 새로운 jobserver IPC 방식을 준수하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11767">#11767</a></li>
<li><code>cargo install</code> 실행 시 요구사항을 충족하는 바이너리가 없는 경우 필요한 기능(feature)들을 보고하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11647">#11647</a></li>
</ul>
<h3 id="수정됨-28"><a class="header" href="#수정됨-28">수정됨</a></h3>
<ul>
<li>디버거가 위치를 찾을 수 있도록 실행 파일 옆에 <code>.dwp</code> DWARF 패키지 파일을 생성하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11572">#11572</a></li>
<li><code>rerun-if-changed</code> 가 파일시스템에 의해 mtime이 보존되지 않는 디렉토리를 가리킬 때 빌드 스크립트가 재컴파일을 트리거하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11613">#11613</a></li>
<li><code>[patch]</code> 에 <code>[workspace.dependencies]</code> 의 의존성을 사용할 때 발생하는 패닉을 수정했습니다. 이러한 사용 방식은 지원되지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/11565">#11565</a> <a href="https://github.com/rust-lang/cargo/pull/11630">#11630</a></li>
<li><code>cargo report</code> 가 동일한 미래 비호환성(future-incompat) 보고서를 여러 번 저장하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11648">#11648</a></li>
<li><code>.rs</code> 로 끝나는 디렉토리를 파일로 잘못 추론하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11678">#11678</a></li>
<li><code>.cargo-ok</code> 파일이 잘못 절단되어(truncated) 의존성 사용을 방해하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11665">#11665</a> <a href="https://github.com/rust-lang/cargo/pull/11724">#11724</a></li>
</ul>
<h3 id="나이틀리nightly-전용-26"><a class="header" href="#나이틀리nightly-전용-26">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>잘못된 빌드 스크립트가 있는 경우 <code>-Zrustdoc-scrape-example</code> 이 반드시 실패하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11694">#11694</a></li>
<li>1password 자격 증명 관리자 연동을 버전 2 CLI로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/11692">#11692</a></li>
<li>패키지가 직접적으로 상호작용하지 않는 타겟을 가진 전이적 아티팩트 의존성에 대해 에러 메시지를 출력하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11643">#11643</a></li>
<li>빌드 시작 전에 현재 디렉토리를 변경하기 위한 <code>-C</code> 플래그를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/10952">#10952</a></li>
</ul>
<h3 id="문서-26"><a class="header" href="#문서-26">문서</a></h3>
<ul>
<li><code>CARGO_CRATE_NAME</code> 과 <code>CARGO_PKG_NAME</code> 의 차이점을 명확히 했습니다. <a href="https://github.com/rust-lang/cargo/pull/11576">#11576</a></li>
<li>타겟 트리플(target triple)이 나타나는 곳에 용어집의 Target 섹션으로의 링크를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/11603">#11603</a></li>
<li>현재 해결사(resolver)가 때때로 의존성을 중복시키는 방식에 대해 설명했습니다. <a href="https://github.com/rust-lang/cargo/pull/11604">#11604</a></li>
<li>crates.io에서 이메일 주소를 인증하는 것에 관한 참고 사항을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/11620">#11620</a></li>
<li><code>publish.timeout</code> 문서에 현재 기본값을 언급했습니다. <a href="https://github.com/rust-lang/cargo/pull/11652">#11652</a></li>
<li><code>cargo::core::compiler</code> 모듈들에 대해 더 많은 문서 주석을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/11669">#11669</a> <a href="https://github.com/rust-lang/cargo/pull/11703">#11703</a> <a href="https://github.com/rust-lang/cargo/pull/11711">#11711</a> <a href="https://github.com/rust-lang/cargo/pull/11758">#11758</a></li>
<li>불안정한 기능을 구현하는 방법에 대한 더 많은 지침을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/11675">#11675</a></li>
<li><code>codegen-backend</code> 에 대한 불안정 장(unstable chapter) 레이아웃을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11676">#11676</a></li>
<li>LTO 문서로의 링크를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/11701">#11701</a></li>
<li>맨 페이지에 <code>cargo install</code> 의 설정 탐색(configuration discovery)에 관한 문서를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/11763">#11763</a></li>
<li><code>cargo add</code> 에서 <code>-F</code> 플래그가 <code>--features</code> 의 별칭임을 문서화했습니다. <a href="https://github.com/rust-lang/cargo/pull/11774">#11774</a></li>
</ul>
<h3 id="내부-변경-26"><a class="header" href="#내부-변경-26">내부 변경</a></h3>
<ul>
<li>Windows에서 네트워크 SSH 테스트를 비활성화했습니다. <a href="https://github.com/rust-lang/cargo/pull/11610">#11610</a></li>
<li>일부 블로킹(blocking) 테스트들을 비블로킹(non-blocking)으로 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11650">#11650</a></li>
<li>로컬이 아닌 CI 환경에서만 경고를 에러로 처리(deny warnings)하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11699">#11699</a></li>
<li><code>cargo_new::NewProjectKind</code> 를 공개(public)로 다시 내보냈습니다. <a href="https://github.com/rust-lang/cargo/pull/11700">#11700</a></li>
<li>의존성들을 알파벳 순으로 정렬했습니다. <a href="https://github.com/rust-lang/cargo/pull/11719">#11719</a></li>
<li>일부 테스트들을 <code>build</code> 에서 <code>check</code> 로 전환했습니다. <a href="https://github.com/rust-lang/cargo/pull/11725">#11725</a></li>
<li>Cargo 내부에서 환경 변수를 읽는 방식을 통합했습니다. <a href="https://github.com/rust-lang/cargo/pull/11727">#11727</a> <a href="https://github.com/rust-lang/cargo/pull/11754">#11754</a></li>
<li>비결정론적인(nondeterministic) 순서를 가진 테스트들을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11766">#11766</a></li>
<li>임시 디렉토리에 중간 아티팩트들이 유지되는지 확인하는 테스트를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/11771">#11771</a></li>
<li>aarch64-apple-darwin을 위한 교차 테스트(cross test) 지침을 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/11663">#11663</a></li>
<li>TOML 조작을 위해 <code>toml</code> v0.6 및 <code>toml_edit</code> v0.18로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/11618">#11618</a></li>
<li><code>clap</code> v4.1.3으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/11619">#11619</a></li>
<li>Windows 바인딩을 위해 <code>winapi</code> 를 <code>windows-sys</code> 크레이트로 교체했습니다. <a href="https://github.com/rust-lang/cargo/pull/11656">#11656</a></li>
<li>퍼센트 인코딩을 위해 <code>percent-encoding</code> 대신 <code>url</code> 크레이트를 재사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11750">#11750</a></li>
<li>Cargo 기여자들이 문서를 작성할 때 스마트 구두점(smart punctuations) 기능을 사용할 수 있게 되었습니다. 예: <code>---</code> 는 자동으로 em 대시로 변환됩니다. (<a href="https://rust-lang.github.io/mdBook/format/markdown.html#smart-punctuation">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/11646">#11646</a> <a href="https://github.com/rust-lang/cargo/pull/11715">#11715</a></li>
<li>Cargo의 CI 파이프라인이 이제 나이틀리 채널의 macOS를 포함합니다. <a href="https://github.com/rust-lang/cargo/pull/11712">#11712</a></li>
<li>Cargo 자체적으로 일부 clippy 린트들을 다시 활성화했습니다. <a href="https://github.com/rust-lang/cargo/pull/11722">#11722</a></li>
<li>Cargo의 CI에서 sparse 프로토콜을 활성화했습니다. <a href="https://github.com/rust-lang/cargo/pull/11632">#11632</a></li>
<li>Cargo의 풀 리퀘스트들에 대해 <code>A-*</code> 및 <code>Command-*</code> 레이블이 자동으로 지정되도록 설정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11664">#11664</a> <a href="https://github.com/rust-lang/cargo/pull/11679">#11679</a></li>
</ul>
<h2 id="cargo-1682-2023-03-28"><a class="header" href="#cargo-1682-2023-03-28">Cargo 1.68.2 (2023-03-28)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/115f3455...rust-1.68.0">115f3455…rust-1.68.0</a></p>
<ul>
<li>Cargo에 번들된 GitHub RSA SSH 호스트 키를 업데이트했습니다. 해당 키는 이전 키가 유출된 후 2023년 3월 24일에 <a href="https://github.blog/2023-03-23-we-updated-our-rsa-ssh-host-key/">GitHub에 의해 교체(rotated)</a>되었습니다. <a href="https://github.com/rust-lang/cargo/pull/11883">#11883</a></li>
<li>SSH known hosts 마커인 <code>@revoked</code> 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/11635">#11635</a></li>
<li>이전 GitHub RSA 호스트 키를 폐기된(revoked) 것으로 표시했습니다. 이를 통해 시스템에서 신뢰하더라도 유출된 키를 Cargo가 수락하지 않도록 방지합니다. <a href="https://github.com/rust-lang/cargo/pull/11889">#11889</a></li>
</ul>
<h2 id="cargo-168-2023-03-09"><a class="header" href="#cargo-168-2023-03-09">Cargo 1.68 (2023-03-09)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/f6e737b1...rust-1.68.0">f6e737b1…rust-1.68.0</a></p>
<h3 id="추가됨-27"><a class="header" href="#추가됨-27">추가됨</a></h3>
<ul>
<li>🎉 새로운 “sparse” 프로토콜이 안정화되었습니다. 이는 crates.io에 접근할 때 상당한 성능 향상을 제공할 것입니다. (<a href="https://github.com/rust-lang/rfcs/blob/master/text/2789-sparse-index.md">RFC 2789</a>) (<a href="https://doc.rust-lang.org/nightly/cargo/reference/registries.html#registry-protocols">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/11224">#11224</a> <a href="https://github.com/rust-lang/cargo/pull/11480">#11480</a> <a href="https://github.com/rust-lang/cargo/pull/11733">#11733</a> <a href="https://github.com/rust-lang/cargo/pull/11756">#11756</a></li>
<li>🎉 <code>home</code> 크레이트가 이제 <code>rust-lang/cargo</code> 저장소의 하위 크레이트가 되었습니다. 환영합니다! <a href="https://github.com/rust-lang/cargo/pull/11359">#11359</a> <a href="https://github.com/rust-lang/cargo/pull/11481">#11481</a></li>
<li>긴 진단 메시지가 가독성을 위해 생략(truncate)될 수 있도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11494">#11494</a></li>
<li><code>net.git-fetch-with-cli</code> 가 활성화된 경우에도 crates.io 인덱스 업데이트 진행 상황을 표시하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11579">#11579</a></li>
<li><code>cargo build --verbose</code> 가 재컴파일 이유에 대해 더 자세히 알려주도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11407">#11407</a></li>
<li>Cargo의 파일 잠금 메커니즘이 이제 <code>fcntl</code> 을 사용하여 Solaris를 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/11439">#11439</a> <a href="https://github.com/rust-lang/cargo/pull/11474">#11474</a></li>
<li>진단용 린트(diagnostic lints)에 대한 기대 사항을 설명하는 새로운 SemVer 호환성 규칙을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/11596">#11596</a></li>
<li><code>cargo vendor</code> 가 동일한 git 저장소의 각 리비전에 대해 서로 다른 소스 교체 항목을 생성하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/1090">#10690</a></li>
<li>Cargo 기여자들이 triagebot을 통해 이슈 레이블을 다시 지정할 수 있게 되었습니다. <a href="https://forge.rust-lang.org/triagebot/labeling.html">문서</a> <a href="https://github.com/rust-lang/cargo/pull/11498">#11498</a></li>
<li>Cargo 기여자들이 컨테이너 환경에서 테스트를 작성할 수 있게 되었습니다. <a href="https://github.com/rust-lang/cargo/pull/11583">#11583</a></li>
</ul>
<h3 id="변경됨-27"><a class="header" href="#변경됨-27">변경됨</a></h3>
<ul>
<li>Cargo가 이제 기본적으로 <code>.cargo/credentials.toml</code> 에 자격 증명을 저장합니다. <code>.cargo/credentials</code> 파일이 존재하는 경우 하위 호환성을 위해 해당 파일에 씁니다. <a href="https://github.com/rust-lang/cargo/pull/11533">#11533</a></li>
<li>민감한 데이터가 로그에 기록되는 것을 방지하기 위해 Cargo 내부에 새로운 래퍼(wrapper) 타입을 도입했습니다. <a href="https://github.com/rust-lang/cargo/pull/11545">#11545</a></li>
<li>여러 문서 개선 사항들을 반영했습니다. <a href="https://github.com/rust-lang/cargo/pull/11475">#11475</a> <a href="https://github.com/rust-lang/cargo/pull/11504">#11504</a> <a href="https://github.com/rust-lang/cargo/pull/11516">#11516</a> <a href="https://github.com/rust-lang/cargo/pull/11517">#11517</a> <a href="https://github.com/rust-lang/cargo/pull/11568">#11568</a> <a href="https://github.com/rust-lang/cargo/pull/11586">#11586</a> <a href="https://github.com/rust-lang/cargo/pull/11592">#11592</a></li>
</ul>
<h3 id="수정됨-29"><a class="header" href="#수정됨-29">수정됨</a></h3>
<ul>
<li>❗ <code>cargo package</code> 및 <code>cargo publish</code> 가 이제 워크스페이스의 <code>Cargo.lock</code> 을 준수합니다. 이는 의도된 동작이었으나 이전에는 간과되었습니다. <a href="https://github.com/rust-lang/cargo/pull/11477">#11477</a></li>
<li><code>cargo vendor</code> 가 워크스페이스로부터 상속된 git 의존성을 해결하지 못해 실패하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11414">#11414</a></li>
<li><code>workspace.default-members</code> 가 지정된 경우에도 <code>cargo install</code> 이 루트 패키지를 올바르게 설치할 수 있도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11067">#11067</a></li>
<li>타겟별 의존성 에러 시 발생하는 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11541">#11541</a></li>
<li>하위 명령어에 대한 맨 페이지가 없는 경우 <code>--help</code> 를 표시하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11473">#11473</a></li>
<li><code>target.cfg(…).rustflags</code> 설정이 <code>build.rustdocflags</code> 를 지우지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11323">#11323</a></li>
<li>지원되지 않는 <code>profile.split-debuginfo</code> 옵션들은 이제 무시됩니다. 이전에는 특정 플랫폼에서 Cargo의 컴파일을 실패하게 만들었습니다. <a href="https://github.com/rust-lang/cargo/pull/11347">#11347</a> <a href="https://github.com/rust-lang/cargo/pull/11633">#11633</a></li>
<li>Windows 헤드리스 세션에서 매우 긴 파일 이름으로 인해 패닉이 발생하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11759">#11759</a></li>
</ul>
<h3 id="나이틀리nightly-전용-27"><a class="header" href="#나이틀리nightly-전용-27">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>Implemented initial support of asymmetric token authentication for registries. (<a href="https://github.com/rust-lang/rfcs/blob/master/text/3231-cargo-asymmetric-tokens.md">RFC 3231</a>) (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#registry-auth">docs</a>) <a href="https://github.com/rust-lang/cargo/pull/10771">#10771</a></li>
<li><code>-Z sparse-registry</code> 없이 <code>auth-required: true</code> 인 경우에도 에러를 발생시키지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11661">#11661</a></li>
<li>설정 파일의 프로파일에서 <code>codegen-backend</code> 및 <code>rustflags</code> 설정을 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/11562">#11562</a></li>
<li>경고/에러가 clippy를 통해 수정 가능한 경우 <code>cargo clippy --fix</code> 를 제안합니다. <a href="https://github.com/rust-lang/cargo/pull/11399">#11399</a></li>
<li>타겟 필드가 지정된 아티팩트 의존성이 <code>optional = true</code> 와 공존할 때 작동하지 않던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11434">#11434</a></li>
<li>Cargo가 아티팩트 타겟이 있는 <code>Unit</code> 과 없는 <code>Unit</code> 을 구분하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11478">#11478</a></li>
<li><code>cargo metadata</code> 가 아티팩트 의존성을 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/11550">#11550</a></li>
<li>선택적인 문서 예제 추출(doc-scraping) 중에 일부 크레이트의 빌드가 실패하는 것을 허용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11450">#11450</a></li>
<li>개발 의존성(dev-dependencies)으로 인해 추출 가능한 예제들을 건너뛰는 경우 경고를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/11503">#11503</a></li>
<li>기본적으로 라이브러리 타겟으로부터는 예제를 추출하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11499">#11499</a></li>
<li>proc-macro 크레이트의 예제들이 예제 추출 대상이 되던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11497">#11497</a></li>
</ul>
<h2 id="cargo-167-2023-01-26"><a class="header" href="#cargo-167-2023-01-26">Cargo 1.67 (2023-01-26)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/7e484fc1...rust-1.67.0">7e484fc1…rust-1.67.0</a></p>
<h3 id="추가됨-28"><a class="header" href="#추가됨-28">추가됨</a></h3>
<ul>
<li><code>cargo remove</code> 가 의존성 제거에 성공한 후, 루트 워크스페이스 매니페스트, <code>profile</code>, <code>patch</code>, <code>replace</code> 섹션에서 참조된 의존성들을 정리하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11194">#11194</a> <a href="https://github.com/rust-lang/cargo/pull/11242">#11242</a> <a href="https://github.com/rust-lang/cargo/pull/11351">#11351</a></li>
<li><code>cargo package</code> 및 <code>cargo publish</code> 가 패키징 후 크레이트의 전체 크기와 압축된 크기를 보고하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11270">#11270</a></li>
</ul>
<h3 id="변경됨-28"><a class="header" href="#변경됨-28">변경됨</a></h3>
<ul>
<li>❗ Cargo가 이제 환경 변수에 <code>$CARGO</code> 가 이미 설정되어 있는 경우 해당 값을 재사용하며, 외부 하위 명령어 및 빌드 스크립트 실행 시 해당 값을 전달합니다. <a href="https://github.com/rust-lang/cargo/pull/11285">#11285</a></li>
<li>❗ Cargo가 이제 <code>-p</code> 플래그 없이 <code>cargo update --precise</code> 를 실행하는 경우 에러를 발생시킵니다. <a href="https://github.com/rust-lang/cargo/pull/11349">#11349</a></li>
<li>❗ 설정 파일에 동일한 인덱스 URL을 가진 여러 레지스트리가 정의되어 있는 경우 에러를 발생시킵니다. <a href="https://github.com/rust-lang/cargo/pull/10592">#10592</a></li>
<li>크레이트 파일 추출 시 압축률을 인식하도록 수정했습니다. 이는 zip bomb 공격 완화를 위해 1.64.0에서 도입되었던 엄격한 크기 제한을 완화합니다. <a href="https://github.com/rust-lang/cargo/pull/11337">#11337</a></li>
<li>커밋되지 않은 변경 사항이 있는 git 저장소에서 <code>cargo fix</code> 를 실행하는 경우 에러를 발생시킵니다. <a href="https://github.com/rust-lang/cargo/pull/11400">#11400</a></li>
<li><code>cargo tree -i &lt;spec&gt;</code> 이 어떠한 패키지도 찾지 못할 경우 경고를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/11377">#11377</a></li>
<li><code>cargo new/init</code> 실행 시 프로젝트 경로에 <code>PATH</code> 환경 변수의 구분자가 포함된 경우 경고를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/11318">#11318</a></li>
<li>여러 패키지가 발견되어 <code>cargo add/remove</code> 가 혼동을 일으킬 때의 에러 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/11186">#11186</a> <a href="https://github.com/rust-lang/cargo/pull/11375">#11375</a></li>
<li><code>cargo init</code> 실행 시 기존의 ignore 파일들이 UTF-8이 아닌 경우의 에러 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/11321">#11321</a></li>
<li><code>cargo install .</code> 에 대한 에러 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/11401">#11401</a></li>
<li>동일한 파일 경로가 여러 빌드 타겟에서 발견될 때의 경고 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/11299">#11299</a></li>
<li>내부 HTTP 라이브러리인 libcurl을 다양한 수정 및 업데이트가 포함된 버전으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/11307">#11307</a> <a href="https://github.com/rust-lang/cargo/pull/11326">#11326</a></li>
</ul>
<h3 id="수정됨-30"><a class="header" href="#수정됨-30">수정됨</a></h3>
<ul>
<li>요청된 패키지의 핑거프린트와 빌드 스크립트 아티팩트만 제거하도록 <code>cargo clean</code> 을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10621">#10621</a></li>
<li><code>registry.default</code> 가 설정되어 있을 때 <code>cargo install --index</code> 가 작동하지 않던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11302">#11302</a></li>
<li>네트워크 설정을 찾을 수 없을 때 git2 safe-directory 기능이 의도치 않게 비활성화되던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11366">#11366</a></li>
<li>잠재적인 건전성(soundness) 문제를 해결하기 위해 <code>atty</code> 크레이트에서 마이그레이션했습니다. <a href="https://github.com/rust-lang/cargo/pull/11420">#11420</a></li>
<li>libgit2 인덱싱이 중단될 때 남겨진 오래된 git 임시 파일들을 정리하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11308">#11308</a></li>
</ul>
<h3 id="나이틀리nightly-전용-28"><a class="header" href="#나이틀리nightly-전용-28">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>컴파일 경고/에러가 자동으로 수정 가능한 경우 <code>cargo fix</code> 를 제안합니다. <a href="https://github.com/rust-lang/cargo/pull/10989">#10989</a> <a href="https://github.com/rust-lang/cargo/pull/11368">#11368</a></li>
<li><code>rustdoc-scrape-examples</code> 설정을 타겟 레벨 설정으로 변경했습니다. <a href="https://github.com/rust-lang/cargo/pull/10343">#10343</a> <a href="https://github.com/rust-lang/cargo/pull/11425">#11425</a> <a href="https://github.com/rust-lang/cargo/pull/11430">#11430</a> <a href="https://github.com/rust-lang/cargo/pull/11445">#11445</a></li>
<li>아티팩트 바이너리 의존성의 변경 사항을 부모 핑거프린트로 전파하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11353">#11353</a></li>
<li><code>wait-for-publish</code> 가 sparse 레지스트리와 함께 작동하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11356">#11356</a> <a href="https://github.com/rust-lang/cargo/pull/11327">#11327</a> <a href="https://github.com/rust-lang/cargo/pull/11388">#11388</a></li>
<li>sparse 레지스트리를 위해 <code>SourceId</code> 에 <code>sparse+</code> 접두사를 저장하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11387">#11387</a> <a href="https://github.com/rust-lang/cargo/pull/11403">#11403</a></li>
<li>대체 레지스트리 인증 지원을 구현했습니다. (<a href="https://github.com/rust-lang/rfcs/blob/master/text/3139-cargo-alternative-registry-auth.md">RFC 3139</a>) (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#registry-auth">문서</a>) <a href="https://github.com/rust-lang/cargo/pull/10592">#10592</a></li>
<li>설정 옵션인 <code>registries.crates-io.protocol</code> 에 대한 문서를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/11350">#11350</a></li>
</ul>
<h2 id="cargo-1661-2023-01-10"><a class="header" href="#cargo-1661-2023-01-10">Cargo 1.66.1 (2023-01-10)</a></h2>
<h3 id="수정됨-31"><a class="header" href="#수정됨-31">수정됨</a></h3>
<ul>
<li>🚨 <a href="https://github.com/rust-lang/cargo/security/advisories/GHSA-r5w3-xm58-jv6j">CVE-2022-46176</a>: Added validation of SSH host keys for git URLs. See <a href="appendix/git-authentication.html#ssh-known-hosts">the docs</a> for more information on how to configure the known host keys.</li>
</ul>
<h2 id="cargo-166-2022-12-15"><a class="header" href="#cargo-166-2022-12-15">Cargo 1.66 (2022-12-15)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/08250398...rust-1.66.0">08250398…rust-1.66.0</a></p>
<h3 id="추가됨-29"><a class="header" href="#추가됨-29">추가됨</a></h3>
<ul>
<li>🎉 <code>Cargo.toml</code> 에서 의존성을 제거하는 <code>cargo remove</code> 명령어를 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/commands/cargo-remove.html">문서</a> <a href="https://github.com/rust-lang/cargo/pull/11059">#11059</a> <a href="https://github.com/rust-lang/cargo/pull/11099">#11099</a> <a href="https://github.com/rust-lang/cargo/pull/11193">#11193</a> <a href="https://github.com/rust-lang/cargo/pull/11204">#11204</a> <a href="https://github.com/rust-lang/cargo/pull/11227">#11227</a></li>
<li>상대 경로를 가진 git 서브모듈을 포함하는 git 의존성에 대한 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/11106">#11106</a></li>
<li>Cargo now sends requests with an <code>Accept-Encoding</code> header to registries. <a href="https://github.com/rust-lang/cargo/pull/11292">#11292</a></li>
<li>Cargo가 외부 하위 명령어로 non-UTF8 인수를 전달하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11118">#11118</a></li>
</ul>
<h3 id="변경됨-29"><a class="header" href="#변경됨-29">변경됨</a></h3>
<ul>
<li>❗ 여러 측면에서 소스 교체(source replacement)의 모호성을 제거했습니다. <a href="https://github.com/rust-lang/rfcs/blob/master/text/3289-source_replacement_ambiguity.md">RFC-3289</a> <a href="https://github.com/rust-lang/cargo/pull/10907">#10907</a>
<ul>
<li>crates-io 소스가 교체된 경우, 사용자는 API 작업을 수행할 때 <code>--registry &lt;NAME&gt;</code> 을 사용하여 어떤 레지스트리를 사용할지 지정해야 합니다.</li>
<li>소스가 교체된 crates.io에 대한 게시는 더 이상 crates.io 토큰(<code>registry.token</code>)을 사용하여 허용되지 않습니다.</li>
<li>소스 교체 시, <code>replace-with</code> 키는 <code>[registries]</code> 테이블에 있는 대체 레지스트리의 이름을 참조할 수 있습니다.</li>
</ul>
</li>
<li>❗ <code>cargo publish</code> 가 이제 게시된 패키지가 인덱스에 나타날 때까지 차단(block)됩니다. <a href="https://github.com/rust-lang/cargo/pull/11062">#11062</a> <a href="https://github.com/rust-lang/cargo/pull/11210">#11210</a> <a href="https://github.com/rust-lang/cargo/pull/11216">#11216</a> <a href="https://github.com/rust-lang/cargo/pull/11255">#11255</a></li>
<li>Cargo가 이제 명령줄 인수 파싱을 위해 clap v4 라이브러리를 사용합니다. <a href="https://github.com/rust-lang/cargo/pull/11116">#11116</a> <a href="https://github.com/rust-lang/cargo/pull/11119">#11119</a> <a href="https://github.com/rust-lang/cargo/pull/11159">#11159</a> <a href="https://github.com/rust-lang/cargo/pull/11190">#11190</a> <a href="https://github.com/rust-lang/cargo/pull/11239">#11239</a> <a href="https://github.com/rust-lang/cargo/pull/11280">#11280</a></li>
<li>Cargo가 이제 사용자 정의 별칭이 외부 명령어를 가리는(shadowing) 경우에만 경고를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/11170">#11170</a></li>
<li>여러 문서 개선 사항들을 반영했습니다. <a href="https://github.com/rust-lang/cargo/pull/10770">#10770</a> <a href="https://github.com/rust-lang/cargo/pull/10938">#10938</a> <a href="https://github.com/rust-lang/cargo/pull/11082">#11082</a> <a href="https://github.com/rust-lang/cargo/pull/11093">#11093</a> <a href="https://github.com/rust-lang/cargo/pull/11157">#11157</a> <a href="https://github.com/rust-lang/cargo/pull/11185">#11185</a> <a href="https://github.com/rust-lang/cargo/pull/11207">#11207</a> <a href="https://github.com/rust-lang/cargo/pull/11219">#11219</a> <a href="https://github.com/rust-lang/cargo/pull/11240">#11240</a> <a href="https://github.com/rust-lang/cargo/pull/11241">#11241</a> <a href="https://github.com/rust-lang/cargo/pull/11282">#11282</a></li>
</ul>
<h3 id="수정됨-32"><a class="header" href="#수정됨-32">수정됨</a></h3>
<ul>
<li>❗ <code>cargo --config &lt;file&gt;</code> 을 통해 로드된 설정 파일이 이제 환경 변수보다 우선순위를 가집니다. 이는 문서화된 동작이었으나 이전 구현에서는 실수로 잘못 처리되었습니다. <a href="https://github.com/rust-lang/cargo/pull/11077">#11077</a></li>
<li>❗ Cargo가 <code>target.cfg(…).rustflags</code> 에서 rustflags를 더 정확하게 수집하며, 수렴(convergence)에 충분하지 않은 경우 경고를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/11114">#11114</a></li>
<li>링커에 의해 제거되지 않은 최종 아티팩트들은 컴파일이 시작되기 전에 제거되어야 합니다. <a href="https://github.com/rust-lang/cargo/pull/11122">#11122</a></li>
<li><code>cargo add</code> 가 이제 알 수 없는 기능(feature)을 더 찾기 쉬운 방식으로 보고합니다. <a href="https://github.com/rust-lang/cargo/pull/11098">#11098</a></li>
<li>명령어 별칭(aliasing) 실패 시 더 많은 에러 문맥을 포함하여 보고하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11087">#11087</a></li>
<li><code>cargo login</code> 프롬프트에서 빈 입력을 받았을 때의 에러 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/11145">#11145</a></li>
<li>워크스페이스 상속이 지원되는 필드들에서 잘못된 타입이 사용되었을 때의 에러 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/11113">#11113</a></li>
<li>기능 구문인 <code>dep:</code> 와 <code>/</code> 를 섞어서 사용할 때의 에러 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/11172">#11172</a></li>
<li>매니페스트의 <code>package.publish</code> 가 <code>false</code> 인데 게시를 시도할 때의 에러 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/11280">#11280</a></li>
</ul>
<h3 id="나이틀리nightly-전용-29"><a class="header" href="#나이틀리nightly-전용-29">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><code>-Zpublish-timeout</code> 플래그 뒤에 새로운 설정 옵션인 <code>publish.timeout</code> 을 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#publish-timeout">문서</a> <a href="https://github.com/rust-lang/cargo/pull/11230">#11230</a></li>
<li>sparse 레지스트리에 재시도 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/11069">#11069</a></li>
<li><code>registry+sparse+</code> 가 포함되던 sparse 레지스트리 잠금 파일 URL을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11177">#11177</a></li>
<li>crates.io 프로토콜을 제어하기 위한 새로운 설정 옵션인 <code>registries.crates-io.protocol</code>을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/11215">#11215</a></li>
<li>index.crates.io에 대한 <code>sparse+</code> 접두사를 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/11247">#11247</a></li>
<li>sparse 레지스트리 의존성이 있는 경우의 게시 기능을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11268">#11268</a></li>
<li><code>-Zsparse-registry</code> 사용 시의 혼란스러운 에러 메시지들을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11283">#11283</a></li>
<li>sparse 레지스트리에 대한 410 gone 응답 처리를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11286">#11286</a></li>
</ul>
<h2 id="cargo-165-2022-11-03"><a class="header" href="#cargo-165-2022-11-03">Cargo 1.65 (2022-11-03)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/4fd148c4...rust-1.65.0">4fd148c4…rust-1.65.0</a></p>
<h3 id="추가됨-30"><a class="header" href="#추가됨-30">추가됨</a></h3>
<ul>
<li>외부 하위 명령어가 이제 Cargo로부터 jobserver 파일 기술자(file descriptors)를 상속받을 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/10511">#10511</a></li>
<li>라이브러리로서의 Cargo의 프라이빗 항목들에 대한 API 문서를 추가했습니다. <a href="https://doc.rust-lang.org/nightly/nightly-rustc/cargo">https://doc.rust-lang.org/nightly/nightly-rustc/cargo</a>를 참조하세요. <a href="https://github.com/rust-lang/cargo/pull/11019">#11019</a></li>
</ul>
<h3 id="변경됨-30"><a class="header" href="#변경됨-30">변경됨</a></h3>
<ul>
<li>이미 <code>PATH</code> 에 존재하는 경우, Cargo가 더 이상 자신의 bin 경로를 <code>PATH</code> 에 추가하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/11023">#11023</a></li>
<li>대기 중인 작업 큐를 정렬하여 Cargo 빌드 스케줄링 성능을 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/11032">#11032</a></li>
<li><code>rev</code> 필드에 부분 해시를 사용하는 경우에도 GitHub로부터 git 의존성을 가져오는 성능을 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/10807">#10807</a></li>
<li>git의 새로운 동작들에 대한 여러 호환성 수정을 포함하는 git2 v0.15 및 libgit2-sys v0.14를 사용하도록 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/11004">#11004</a></li>
<li>레지스트리 인덱스 파일들이 콘텐츠 해시를 기반으로 더 세밀하게 캐싱됩니다. <a href="https://github.com/rust-lang/cargo/pull/11044">#11044</a></li>
<li>범위가 지정된 스레드(scoped threads) 생성을 위해 <code>crossbeam</code> 크레이트 대신 표준 라이브러리의 <code>std::thread::scope</code> 를 사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10977">#10977</a></li>
<li>기본 병렬 처리 수준 결정을 위해 <code>num_cpus</code> 크레이트 대신 표준 라이브러리의 <code>available_parallelism</code> 을 사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10969">#10969</a></li>
<li><code>rust-version</code> 요구사항이 충족되지 않았을 때 해결 방법을 안내하도록 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/10891">#10891</a></li>
<li>하위 명령어를 찾을 수 없을 때 가능한 원인과 해결 방법에 대해 더 자세히 알려주도록 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/10924">#10924</a></li>
<li>지정된 Cargo 타겟을 찾을 수 없을 때 사용 가능한 타겟 이름 목록을 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/10999">#10999</a></li>
<li><code>cargo update</code> 실행 시 <code>--package</code> 플래그 없이 <code>--precise</code> 를 사용하는 경우 이제 경고를 표시합니다. 일정 기간의 유예를 거친 후에는 하드 에러로 처리될 예정입니다. <a href="https://github.com/rust-lang/cargo/pull/10988">#10988</a> <a href="https://github.com/rust-lang/cargo/pull/11011">#11011</a></li>
<li><code>cargo bench</code> 및 <code>cargo test</code> 실행 시 테스트 실패 직후에 더 정확한 테스트 실행 에러를 보고하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11028">#11028</a></li>
<li><code>cargo add</code> 가 이제 어떤 버전에 기능(feature)들이 추가되었는지 알려줍니다. <a href="https://github.com/rust-lang/cargo/pull/11075">#11075</a></li>
<li>비-ASCII 크레이트 이름이 이제 Rust에서 더 이상 지원되지 않음을 명시했습니다. <a href="https://github.com/rust-lang/cargo/pull/11017">#11017</a></li>
<li>매니페스트에서 배열(array)이 기대되는 필드에 문자열(string)이 사용된 경우의 에러 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/10944">#10944</a></li>
</ul>
<h3 id="수정됨-33"><a class="header" href="#수정됨-33">수정됨</a></h3>
<ul>
<li>리눅스 이외의 플랫폼에서도 파일 잠금 지원에 대한 제한을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/10975">#10975</a></li>
<li>os_info를 3.5.0으로 업데이트하여 잘못된 OS 감지 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10943">#10943</a></li>
<li>패키지 디렉토리를 스캔할 때 깨져있지만 제외된(excluded) 심볼릭 링크 파일로부터 발생하는 에러를 무시하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11008">#11008</a></li>
<li>빌드 스크립트가 표준 입력(stdin)에서 입력을 기다릴 때 발생하는 데드락 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/11257">#11257</a></li>
</ul>
<h3 id="nightly"><a class="header" href="#nightly">Nightly</a></h3>
<ul>
<li>sparse 레지스트리의 진행 상황 표시기가 더 직관적으로 개선되었습니다. <a href="https://github.com/rust-lang/cargo/pull/11068">#11068</a></li>
</ul>
<h2 id="cargo-164-2022-09-22"><a class="header" href="#cargo-164-2022-09-22">Cargo 1.64 (2022-09-22)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/a5e08c47...rust-1.64.0">a5e08c47…rust-1.64.0</a></p>
<h3 id="추가됨-31"><a class="header" href="#추가됨-31">추가됨</a></h3>
<ul>
<li>🎉 이제 패키지가 워크스페이스로부터 설정을 상속받을 수 있어 한곳에서 집중 관리할 수 있습니다. 이러한 공통 설정 정의 방법에 대한 자세한 내용은 <a href="https://doc.rust-lang.org/nightly/cargo/reference/workspaces.html#the-package-table"><code>workspace.package</code></a> 및 <a href="https://doc.rust-lang.org/nightly/cargo/reference/workspaces.html#the-dependencies-table"><code>workspace.dependencies</code></a>를 참조하세요. <a href="https://github.com/rust-lang/cargo/pull/10859">#10859</a></li>
<li>크레이트 타입을 재정의할 수 있도록 <code>cargo rustc</code> 에 <a href="https://doc.rust-lang.org/nightly/cargo/commands/cargo-rustc.html#option-cargo-rustc---crate-type"><code>--crate-type</code></a> 플래그를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/10838">#10838</a></li>
<li>이제 Cargo 명령어에서 여러 개의 <code>--target</code> 플래그를 사용하여 한 번에 여러 타겟을 빌드할 수 있으며, <a href="https://doc.rust-lang.org/nightly/cargo/reference/config.html#buildtarget"><code>build.target</code></a> 설정 옵션에 타겟 배열을 지정할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/10766">#10766</a></li>
<li><code>--jobs</code> 인수에 음수를 사용하여 최대 CPU 코어 수로부터 역으로 계산할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/10844">#10844</a></li>
</ul>
<h3 id="변경됨-31"><a class="header" href="#변경됨-31">변경됨</a></h3>
<ul>
<li><code>cargo install --path</code> 의 Bash 자동 완성이 이제 경로 자동 완성을 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/10798">#10798</a></li>
<li><code>rev</code> 필드에 해시(hash)를 사용하는 경우 GitHub로부터 git 의존성을 가져오는 성능이 크게 향상되었습니다. <a href="https://github.com/rust-lang/cargo/pull/10079">#10079</a></li>
<li>게시된 패키지들이 이제 워크스페이스의 해결사(resolver) 설정을 포함하게 되어, 개별적으로 사용될 때도 동일한 해결사를 사용하도록 보장합니다. <a href="https://github.com/rust-lang/cargo/pull/10911">#10911</a> <a href="https://github.com/rust-lang/cargo/pull/10961">#10961</a> <a href="https://github.com/rust-lang/cargo/pull/10970">#10970</a></li>
<li><code>cargo add</code> 가 이제 <code>Cargo.lock</code> 을 업데이트합니다. <a href="https://github.com/rust-lang/cargo/pull/10902">#10902</a></li>
<li><code>cargo vendor</code> 의 설정 출력에 포함된 경로에서 백슬래시(<code>\</code>)를 슬래시(<code>/</code>)로 변환하여 플랫폼 간에 설정이 호환되도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10668">#10668</a></li>
<li><a href="https://doc.rust-lang.org/nightly/cargo/reference/workspaces.html#package-selection"><code>workspace.default-members</code></a> 설정에서 가상이 아닌(non-virtual) 워크스페이스의 루트 패키지를 참조하기 위해 <code>"."</code> 값을 사용할 수 있도록 허용했습니다. <a href="https://github.com/rust-lang/cargo/pull/10784">#10784</a></li>
</ul>
<h3 id="수정됨-34"><a class="header" href="#수정됨-34">수정됨</a></h3>
<ul>
<li>🚨 <a href="https://github.com/rust-lang/cargo/security/advisories/GHSA-rfj2-q3h3-hm5j">CVE-2022-36113</a>: 악의적인 크레이트를 추출할 때 임의의 파일을 손상시킬 수 있는 취약점을 해결했습니다. <a href="https://github.com/rust-lang/cargo/pull/11089">#11089</a> <a href="https://github.com/rust-lang/cargo/pull/11088">#11088</a></li>
<li>🚨 <a href="https://github.com/rust-lang/cargo/security/advisories/GHSA-2hvr-h6gw-qrxp">CVE-2022-36114</a>: 악의적인 크레이트를 추출할 때 파일 시스템을 가득 채울 수 있는 취약점을 해결했습니다. <a href="https://github.com/rust-lang/cargo/pull/11089">#11089</a> <a href="https://github.com/rust-lang/cargo/pull/11088">#11088</a></li>
<li><code>cargo --version --verbose</code> 의 <code>os</code> 출력이 이제 더 많은 플랫폼을 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/10802">#10802</a></li>
<li>캐싱된 git 체크아웃 파일이 손상된 경우 이제 다시 빌드합니다. 이는 <code>net.git-fetch-with-cli</code>를 사용하면서 클론 과정이 중단된 경우 등에 발생할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/10829">#10829</a></li>
<li><code>cargo add --offline</code> 실행 시 발생하는 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10817">#10817</a></li>
</ul>
<h3 id="나이틀리nightly-전용-30"><a class="header" href="#나이틀리nightly-전용-30">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><code>config.toml</code> 에서 불안정한 <code>check-cfg</code> 의 역직렬화 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10799">#10799</a></li>
</ul>
<h2 id="cargo-163-2022-08-11"><a class="header" href="#cargo-163-2022-08-11">Cargo 1.63 (2022-08-11)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/3f052d8e...rust-1.63.0">3f052d8e…rust-1.63.0</a></p>
<h3 id="추가됨-32"><a class="header" href="#추가됨-32">추가됨</a></h3>
<ul>
<li>🎉 명령줄에서 직접 설정 옵션을 전달할 수 있는 <code>--config</code> 옵션을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/10755">#10755</a></li>
<li>매니페스트에 <code>rust-version</code> 필드가 설정되어 있는 경우, 크레이트 컴파일 시 <code>CARGO_PKG_RUST_VERSION</code> 환경 변수가 설정됩니다. <a href="https://github.com/rust-lang/cargo/pull/10713">#10713</a></li>
</ul>
<h3 id="변경됨-32"><a class="header" href="#변경됨-32">변경됨</a></h3>
<ul>
<li>git 의존성에서 동일한 이름을 가진 패키지가 여러 개 발견될 경우 경고를 표시합니다. <code>publish=false</code> 인 패키지는 무시됩니다. <a href="https://github.com/rust-lang/cargo/pull/10701">#10701</a> <a href="https://github.com/rust-lang/cargo/pull/10767">#10767</a></li>
<li>변경 사항 추적 시 <code>.json</code> 타겟 명세 파일의 경로 대신 그 내용을 사용하도록 수정했습니다. 이를 통해 경로가 변경되더라도 재빌드를 방지할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/10746">#10746</a></li>
<li><code>.gitmodules</code> 에 <code>update=none</code> 전략이 설정된 서브모듈을 포함하는 git 의존성을 준수하여, 해당 서브모듈을 페치하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10717">#10717</a></li>
<li>결정론적인 동작을 위해 크레이트 파일들이 이제 더 최근의 날짜(1973년 11월 29일 대신 2006년 7월 23일)를 사용합니다. <a href="https://github.com/rust-lang/cargo/pull/10720">#10720</a></li>
<li><code>cargo new</code> 로 생성되는 초기 템플릿에 테스트 모듈 내의 <code>use super::*;</code> 를 포함하는 등 좀 더 실용적인 테스트 구조를 적용했습니다. <a href="https://github.com/rust-lang/cargo/pull/10706">#10706</a></li>
<li>내부 HTTP 라이브러리인 libcurl을 다양한 소규모 수정 및 업데이트가 포함된 버전으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/10696">#10696</a></li>
</ul>
<h3 id="수정됨-35"><a class="header" href="#수정됨-35">수정됨</a></h3>
<ul>
<li><code>cargo add</code> 및 <code>cargo locate-project</code> 에 대한 zsh 자동 완성을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10810">#10810</a> <a href="https://github.com/rust-lang/cargo/pull/10811">#10811</a></li>
<li>가상 워크스페이스의 루트에서 <code>cargo publish</code> 실행 시 <code>-p</code> 옵션이 무시되던 문제를 수정했습니다. 또한 여러 패키지가 선택된 경우 에러를 발생시키는 추가 검사 로직을 추가했습니다(이전에는 첫 번째 패키지를 선택했음). <a href="https://github.com/rust-lang/cargo/pull/10677">#10677</a></li>
<li>JSON 출력을 사용하는 경우 <code>cargo test</code> 에서 사람이 읽을 수 있는 실행 파일 이름이 더 이상 표시되지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/10691">#10691</a></li>
</ul>
<h3 id="나이틀리nightly-전용-31"><a class="header" href="#나이틀리nightly-전용-31">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>빌드 스크립트가 <code>cargo:rustc-check-cfg</code> 를 사용하여 지원하는 <code>cfg</code> 값 세트를 선언할 수 있도록 하는 <code>-Zcheck-cfg=output</code> 옵션을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/10539">#10539</a></li>
<li><code>-Z sparse-registry</code> 가 이제 crates-io에 접근할 때 https://index.crates.io/ 를 사용합니다. <a href="https://github.com/rust-lang/cargo/pull/10725">#10725</a></li>
<li>워크스페이스 상속 시 <code>cargo add</code> 에서 <code>.workspace</code> 키의 포맷팅 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10705">#10705</a></li>
<li>희소(sparse) HTTP 레지스트리 URL은 이제 반드시 <code>/</code> 로 끝나야 합니다. <a href="https://github.com/rust-lang/cargo/pull/10698">#10698</a></li>
<li><code>cargo add</code> 와 <code>default-features</code> 키의 워크스페이스 상속과 관련된 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10685">#10685</a></li>
</ul>
<h2 id="cargo-162-2022-06-30"><a class="header" href="#cargo-162-2022-06-30">Cargo 1.62 (2022-06-30)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/1ef1e0a1...rust-1.62.0">1ef1e0a1…rust-1.62.0</a></p>
<h3 id="추가됨-33"><a class="header" href="#추가됨-33">추가됨</a></h3>
<ul>
<li>🎉 명령줄에서 의존성을 추가할 수 있는 <code>cargo add</code> 명령어를 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/commands/cargo-add.html">문서</a> <a href="https://github.com/rust-lang/cargo/pull/10472">#10472</a> <a href="https://github.com/rust-lang/cargo/pull/10577">#10577</a> <a href="https://github.com/rust-lang/cargo/pull/10578">#10578</a></li>
<li>패키지 ID 명세가 이제 <code>cargo add</code> 및 다른 도구들의 동작과 일치하도록 기존의 <code>name:version</code> 구문 외에 <code>name@version</code> 구문을 지원합니다. <code>cargo install</code> 및 <code>cargo yank</code> 도 이제 이 구문을 지원하므로 버전을 별도의 플래그로 전달할 필요가 없습니다. <a href="https://github.com/rust-lang/cargo/pull/10582">#10582</a> <a href="https://github.com/rust-lang/cargo/pull/10650">#10650</a> <a href="https://github.com/rust-lang/cargo/pull/10597">#10597</a></li>
<li><code>--features</code> 의 별칭으로 CLI 옵션 <code>-F</code> 를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/10576">#10576</a></li>
<li>Cargo의 홈 디렉토리(보통 <code>~/.cargo</code>) 내의 <code>git</code> 및 <code>registry</code> 디렉토리가 캐시 디렉토리로 표시되어 백업이나 콘텐츠 인덱싱(Windows)에서 제외되도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10553">#10553</a></li>
<li><code>cargo install</code> 과 일관성을 유지하기 위해 <code>cargo yank</code> 에서 <code>--vers</code> 플래그를 대체하는 <code>--version</code> 플래그를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/10575">#10575</a></li>
<li>자동 <code>@</code> 인자 파일(argfile) 지원이 추가되었습니다. <code>rustc</code> 에 대한 명령줄이 운영 체제의 제한을 초과하는 경우 “응답 파일(response files)“을 사용합니다. <a href="https://github.com/rust-lang/cargo/pull/10546">#10546</a></li>
<li><code>cargo clean</code> 에 진행 표시줄이 추가되었습니다 (0.5초 이상 걸리는 경우). <a href="https://github.com/rust-lang/cargo/pull/10236">#10236</a></li>
</ul>
<h3 id="변경됨-33"><a class="header" href="#변경됨-33">변경됨</a></h3>
<ul>
<li>설치할 바이너리를 찾지 못한 경우(예: 필수 기능 누락 등) <code>cargo install</code> 이 더 이상 오류를 생성하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/10508">#10508</a></li>
<li>지정된 타겟이 호스트 타겟과 동일한 경우, <code>cargo test</code> 가 이제 <code>rustdoc</code> 에 <code>--target</code> 을 전달합니다. <a href="https://github.com/rust-lang/cargo/pull/10594">#10594</a></li>
<li>바이너리를 문서화할 때 <code>cargo doc</code> 이 이제 자동으로 <code>-Arustdoc::private-intra-doc-links</code> 를 전달합니다 (이는 자동으로 <code>--document-private-items</code> 를 포함합니다). <a href="https://doc.rust-lang.org/rustdoc/lints.html#private_intra_doc_links"><code>private-intra-doc-links</code></a> 린트는 비공개 항목을 문서화하지 <em>않을</em> 때만 관련이 있으며, 바이너리에는 적용되지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/10142">#10142</a></li>
<li><code>cargo --version</code> 출력의 짧은 git 해시 길이가 이제 9자로 고정되었습니다. 이전에는 플랫폼마다 길이가 달랐습니다. <a href="https://github.com/rust-lang/cargo/pull/10579">#10579</a></li>
<li><code>Cargo.toml.orig</code> 파일이 포함된 패키지를 게시하려고 시도하면 이제 오류가 발생합니다. 그렇지 않으면 파일 이름이 자동으로 생성된 파일과 충돌할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/10551">#10551</a></li>
</ul>
<h3 id="수정됨-36"><a class="header" href="#수정됨-36">수정됨</a></h3>
<ul>
<li><code>build.dep-info-basedir</code> 설정이 이제 상위 디렉토리를 참조하기 위한 경로의 <code>..</code> 사용을 올바르게 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/10281">#10281</a></li>
<li>cgroups v1을 사용하는 시스템에서 사용할 기본 CPU 수의 자동 감지 회귀 버그를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10737">#10737</a> <a href="https://github.com/rust-lang/cargo/pull/10739">#10739</a></li>
</ul>
<h3 id="나이틀리nightly-전용-32"><a class="header" href="#나이틀리nightly-전용-32">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><code>cargo fetch</code> 가 이제 <code>-Zbuild-std</code> 와 함께 작동하여 표준 라이브러리의 의존성을 가져옵니다. <a href="https://github.com/rust-lang/cargo/pull/10129">#10129</a></li>
<li>워크스페이스 상속(workspace inheritance) 지원을 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#workspace-inheritance">docs</a> <a href="https://github.com/rust-lang/cargo/pull/10584">#10584</a> <a href="https://github.com/rust-lang/cargo/pull/10568">#10568</a> <a href="https://github.com/rust-lang/cargo/pull/10565">#10565</a> <a href="https://github.com/rust-lang/cargo/pull/10564">#10564</a> <a href="https://github.com/rust-lang/cargo/pull/10563">#10563</a> <a href="https://github.com/rust-lang/cargo/pull/10606">#10606</a> <a href="https://github.com/rust-lang/cargo/pull/10548">#10548</a> <a href="https://github.com/rust-lang/cargo/pull/10538">#10538</a></li>
<li>알 수 없는 이름과 값에 대해 <code>cfg</code> 표현식을 검증하는 다양한 형태를 추가하는 <code>-Zcheck-cfg</code> 가 추가되었습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#check-cfg">docs</a> <a href="https://github.com/rust-lang/cargo/pull/10486">#10486</a> <a href="https://github.com/rust-lang/cargo/pull/10566">#10566</a></li>
<li><code>--config</code> CLI 옵션에서 더 이상 레지스트리 토큰 설정을 허용하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/10580">#10580</a></li>
<li>proc-macro 및 <code>-Z rustdoc-scrape-examples</code> 와 관련된 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10549">#10549</a> <a href="https://github.com/rust-lang/cargo/pull/10533">#10533</a></li>
</ul>
<h2 id="cargo-161-2022-05-19"><a class="header" href="#cargo-161-2022-05-19">Cargo 1.61 (2022-05-19)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/ea2a21c9...rust-1.61.0">ea2a21c9…rust-1.61.0</a></p>
<h3 id="추가됨-34"><a class="header" href="#추가됨-34">추가됨</a></h3>
<h3 id="변경됨-34"><a class="header" href="#변경됨-34">변경됨</a></h3>
<ul>
<li><code>cargo test --no-run</code> 이 이제 테스트 실행 파일의 경로를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/10346">#10346</a></li>
<li><code>cargo tree --duplicates</code> 가 이제 호스트와 타겟 간에 공유되는 의존성을 중복으로 보고하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/10466">#10466</a></li>
<li>여러 수정 사항이 포함된 libgit2 1.4.2 릴리스로 업데이트되었습니다. <a href="https://github.com/rust-lang/cargo/pull/10442">#10442</a> <a href="https://github.com/rust-lang/cargo/pull/10479">#10479</a></li>
<li><code>cargo vendor</code> 가 더 이상 <code>--sync</code> 에 대해 여러 값을 허용하지 않습니다. 대신 여러 개의 <code>--sync</code> 플래그를 전달해야 합니다. <a href="https://github.com/rust-lang/cargo/pull/10448">#10448</a></li>
<li>밑줄(<code>_</code>)과 대시(<code>-</code>) 변형이 혼용된 매니페스트 키(예: <code>proc_macro</code> 와 <code>proc-macro</code> 를 모두 지정하는 경우)에 대해 이제 경고가 발생합니다. <a href="https://github.com/rust-lang/cargo/pull/10316">#10316</a></li>
<li>Cargo가 이제 기본 병렬 처리 수준을 결정하기 위해 <code>num_cpus</code> 크레이트 대신 표준 라이브러리의 <code>available_parallelism</code> 을 사용합니다. <a href="https://github.com/rust-lang/cargo/pull/10427">#10427</a></li>
<li><code>cargo search</code> 검색어가 이제 하이라이트되어 표시됩니다. <a href="https://github.com/rust-lang/cargo/pull/10425">#10425</a></li>
</ul>
<h3 id="수정됨-37"><a class="header" href="#수정됨-37">수정됨</a></h3>
<ul>
<li><code>hg</code> 와 같은 VCS 도구에 전달되는 경로가 이제 VCS 플래그와의 충돌을 피하기 위해 <code>--</code> 뒤에 추가됩니다. <a href="https://github.com/rust-lang/cargo/pull/10483">#10483</a></li>
<li><code>http.timeout</code> 설정 값이 실제로 작동하도록 수정되었습니다. <a href="https://github.com/rust-lang/cargo/pull/10456">#10456</a></li>
<li>일부 상황에서 <code>cargo rustc --crate-type</code> 이 작동하지 않던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10388">#10388</a></li>
</ul>
<h3 id="나이틀리nightly-전용-33"><a class="header" href="#나이틀리nightly-전용-33">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>기능(features)의 컴파일 시점 검사를 활성화하기 위한 <code>-Z check-cfg-features</code> 가 추가되었습니다. <a href="https://github.com/rust-lang/cargo/pull/10408">#10408</a></li>
<li>바이너리 산출물 의존성(RFC-3028)을 지원하기 위한 <code>-Z bindeps</code> 가 추가되었습니다. <a href="https://github.com/rust-lang/cargo/pull/9992">#9992</a></li>
<li><code>build.target</code> 설정 값에서 배열을 통한 <code>-Z multitarget</code> 이 이제 지원됩니다. <a href="https://github.com/rust-lang/cargo/pull/10473">#10473</a></li>
<li>하나의 크레이트가 컴파일에 실패하더라도 컴파일을 계속 진행하는 <code>--keep-going</code> 플래그가 추가되었습니다. <a href="https://github.com/rust-lang/cargo/pull/10383">#10383</a></li>
<li>워크스페이스에서 매니페스트 값을 상속받는 작업이 시작되었습니다. <a href="https://github.com/rust-lang/cargo/pull/10497">#10497</a> <a href="https://github.com/rust-lang/cargo/pull/10517">#10517</a></li>
<li>스파스(sparse) HTTP 레지스트리 지원이 추가되었습니다. <a href="https://github.com/rust-lang/cargo/pull/10470">#10470</a> <a href="https://github.com/rust-lang/cargo/pull/10064">#10064</a></li>
<li><code>[target.'cfg(&lt;target&gt;)'.dependencies]</code> 에 산출물 타겟(artifact target)이 사용될 때 발생하는 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10433">#10433</a></li>
<li>빌드 스크립트에 전달할 호스트 플래그(<code>-Z target-applies-to-host</code>)를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10395">#10395</a></li>
<li>rustdoc에 대한 <code>-Z check-cfg-features</code> 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/10428">#10428</a></li>
</ul>
<h2 id="cargo-160-2022-04-07"><a class="header" href="#cargo-160-2022-04-07">Cargo 1.60 (2022-04-07)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/358e79fe...rust-1.60.0">358e79fe…rust-1.60.0</a></p>
<h3 id="추가됨-35"><a class="header" href="#추가됨-35">추가됨</a></h3>
<ul>
<li>🎉 선택적 의존성을 참조하기 위해 <code>[features]</code> 테이블에 <code>dep:</code> 접두사를 추가했습니다. 이를 통해 의존성과 동일한 이름을 가진 기능 이름을 생성할 수 있으며, 선택적 의존성을 “숨겨서” 기능 이름이 암시적으로 노출되지 않도록 할 수 있습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/features.html#optional-dependencies">docs</a> <a href="https://github.com/rust-lang/cargo/pull/10269">#10269</a></li>
<li>🎉 선택적 의존성 <code>dep-name</code> 이 이미 다른 기능에 의해 활성화된 경우에만 <code>feature-name</code> 기능을 활성화하는 <code>dep-name?/feature-name</code> 구문을 <code>[features]</code> 테이블에 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/features.html#dependency-features">docs</a> <a href="https://github.com/rust-lang/cargo/pull/10269">#10269</a></li>
<li>🎉 빌드 시간, 동시성 및 CPU 사용량에 대한 HTML 보고서를 생성하는 <code>--timings</code> 옵션을 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/timings.html">docs</a> <a href="https://github.com/rust-lang/cargo/pull/10245">#10245</a></li>
<li>레지스트리 인덱스에 <code>"v"</code> 및 <code>"features2"</code> 필드를 추가했습니다. <code>"v"</code> 필드는 인덱스의 향후 변경 사항과의 호환성을 위한 방법을 제공합니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/registries.html#index-format">docs</a> <a href="https://github.com/rust-lang/cargo/pull/10269">#10269</a></li>
<li><code>cargo clippy</code> 에 대한 bash 자동 완성이 추가되었습니다. <a href="https://github.com/rust-lang/cargo/pull/10347">#10347</a></li>
<li><code>cargo report</code> 에 대한 bash 자동 완성이 추가되었습니다. <a href="https://github.com/rust-lang/cargo/pull/10295">#10295</a></li>
<li><code>rustc-link-arg-tests</code>, <code>rustc-link-arg-examples</code>, 및 <code>rustc-link-arg-benches</code> 에 대한 빌드 스크립트 지원이 추가되었습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/build-scripts.html#outputs-of-the-build-script">docs</a> <a href="https://github.com/rust-lang/cargo/pull/10274">#10274</a></li>
</ul>
<h3 id="변경됨-35"><a class="header" href="#변경됨-35">변경됨</a></h3>
<ul>
<li>Cargo가 이제 명령줄 인자 파싱을 위해 clap 3 라이브러리를 사용합니다. <a href="https://github.com/rust-lang/cargo/pull/10265">#10265</a></li>
<li><code>build.pipelining</code> 설정 옵션은 이제 더 이상 사용되지 않으며(deprecated), 파이프라이닝은 항상 활성화됩니다. <a href="https://github.com/rust-lang/cargo/pull/10258">#10258</a></li>
<li><code>cargo new</code> 가 이제 모든 디렉토리가 아닌 저장소의 루트에 있는 <code>Cargo.lock</code> 만 무시하는 <code>.gitignore</code> 를 생성합니다. <a href="https://github.com/rust-lang/cargo/pull/10379">#10379</a></li>
<li>bash 자동 완성의 시작 시간이 개선되었습니다. <a href="https://github.com/rust-lang/cargo/pull/10365">#10365</a></li>
<li><code>--features</code> 플래그가 <code>--all-features</code> 플래그와 함께 사용될 때도 존중되며, 이를 통해 다른 패키지의 기능을 활성화할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/10337">#10337</a></li>
<li>Cargo가 이제 다른 TOML 파서를 사용합니다. 이는 사용자에게 보이는 어떠한 변경도 도입하지 않을 것입니다. 이는 <code>cargo add</code> 및 기타 향후 개선 사항을 지원하기 위해 TOML 파일의 형식을 보존하는 프로그래밍 방식의 수정을 지원할 수 있는 기반을 마련합니다. <a href="https://github.com/rust-lang/cargo/pull/10086">#10086</a></li>
<li>라이브러리가 <code>dylib</code> 와 <code>cdylib</code> 를 모두 생성하도록 설정하는 것은 지원되지 않는 조합이므로 이제 오류가 발생합니다. <a href="https://github.com/rust-lang/cargo/pull/10243">#10243</a></li>
<li><code>cargo --list</code> 에 이제 <code>help</code> 명령어가 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/10300">#10300</a></li>
</ul>
<h3 id="수정됨-38"><a class="header" href="#수정됨-38">수정됨</a></h3>
<ul>
<li>개발 의존성(dev-dependencies)이 있는 예제에서 <code>cargo doc</code> 을 실행할 때의 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10341">#10341</a></li>
<li>현재 디렉토리의 워크스페이스 외부에 있는 디렉토리에 대한 상대 경로로 <code>cargo install --path</code>를 사용할 때의 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10335">#10335</a></li>
<li><code>cargo test TEST_FILTER</code> 가 이제 <code>test = false</code> 로 명시적으로 비활성화된 바이너리를 더 이상 빌드하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/10305">#10305</a></li>
<li><code>term.quiet</code> 없이 <code>term.verbose</code> 를 사용하거나 그 반대의 경우에 발생하던 회귀 버그를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10429">#10429</a> <a href="https://github.com/rust-lang/cargo/pull/10436">#10436</a></li>
</ul>
<h3 id="나이틀리nightly-전용-34"><a class="header" href="#나이틀리nightly-전용-34">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>프로파일 정의에 <code>rustflags</code> 옵션을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/10217">#10217</a></li>
<li><code>--config</code> 가 점으로 구분된 키(dotted keys)만 지원하도록 변경되었습니다. <a href="https://github.com/rust-lang/cargo/pull/10176">#10176</a></li>
<li>프로파일 재정의(overrides)에서 프로파일 <code>rustflags</code> 가 제대로 제어되지 않던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10411">#10411</a> <a href="https://github.com/rust-lang/cargo/pull/10413">#10413</a></li>
</ul>
<h2 id="cargo-159-2022-02-24"><a class="header" href="#cargo-159-2022-02-24">Cargo 1.59 (2022-02-24)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/7f08ace4...rust-1.59.0">7f08ace4…rust-1.59.0</a></p>
<h3 id="추가됨-36"><a class="header" href="#추가됨-36">추가됨</a></h3>
<ul>
<li>🎉 바이너리에서 심볼과 디버그 정보를 제거하는 동작을 지정하기 위해 이제 프로파일에 <code>strip</code> 옵션을 지정할 수 있습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/profiles.html#strip">docs</a> <a href="https://github.com/rust-lang/cargo/pull/10088">#10088</a> <a href="https://github.com/rust-lang/cargo/pull/10376">#10376</a></li>
<li>🎉 미래 비호환성 보고(future incompatible reporting) 기능이 추가되었습니다. 이는 <code>rustc</code> 의 향후 변경으로 인해 패키지나 그 의존성 중 하나가 빌드되지 않을 수 있는 경우 보고를 제공합니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/future-incompat-report.html">docs</a> <a href="https://github.com/rust-lang/cargo/pull/10165">#10165</a></li>
<li>윈도우에서의 SSH 인증이 이제 ssh-agent를 지원합니다. <a href="https://doc.rust-lang.org/nightly/cargo/appendix/git-authentication.html#ssh-authentication">docs</a> <a href="https://github.com/rust-lang/cargo/pull/10248">#10248</a></li>
<li>설정 파일에서 <code>--quiet</code> 동작을 활성화할 수 있는 <code>term.quiet</code> 설정 옵션이 추가되었습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/config.html#termquiet">docs</a> <a href="https://github.com/rust-lang/cargo/pull/10152">#10152</a></li>
<li><code>--release</code> 의 별칭으로 <code>-r</code> CLI 옵션이 추가되었습니다. <a href="https://github.com/rust-lang/cargo/pull/10133">#10133</a></li>
</ul>
<h3 id="변경됨-36"><a class="header" href="#변경됨-36">변경됨</a></h3>
<ul>
<li>패키지 디렉토리 스캔이 이제 파일 시스템 루프나 접근 권한 문제와 같은 오류에 대해 탄력적으로 대응합니다. <a href="https://github.com/rust-lang/cargo/pull/10188">#10188</a> <a href="https://github.com/rust-lang/cargo/pull/10214">#10214</a> <a href="https://github.com/rust-lang/cargo/pull/10286">#10286</a></li>
<li><code>cargo help &lt;alias&gt;</code> 가 이제 별칭(alias)의 타겟을 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/10193">#10193</a></li>
<li>사용 중단된(deprecated) <code>--host</code> CLI 옵션이 제거되었습니다. <a href="https://github.com/rust-lang/cargo/pull/10145">#10145</a> <a href="https://github.com/rust-lang/cargo/pull/10327">#10327</a></li>
<li>Cargo가 이제 항상 <code>rustc</code> 와 동기화된 버전을 보고합니다. <a href="https://github.com/rust-lang/cargo/pull/10178">#10178</a></li>
<li>무시되는 파일 잠금 오류에 EOPNOTSUPP를 추가했습니다. 이는 BSD 운영 체제와 관련이 있습니다. <a href="https://github.com/rust-lang/cargo/pull/10157">#10157</a></li>
</ul>
<h3 id="수정됨-39"><a class="header" href="#수정됨-39">수정됨</a></h3>
<ul>
<li>macOS: 실행 파일을 실행할 때 커널에 의해 산발적으로 종료되던 문제를 수정했습니다 (macOS 12부터 발생한 것으로 추정). <a href="https://github.com/rust-lang/cargo/pull/10196">#10196</a></li>
<li>의존성의 <code>[lib]</code> 정의에서 <code>doc=false</code> 설정이 존중되도록 수정되었습니다. <a href="https://github.com/rust-lang/cargo/pull/10201">#10201</a> <a href="https://github.com/rust-lang/cargo/pull/10324">#10324</a></li>
<li>바이너리를 문서화할 때 JSON 옵션의 <code>"executable"</code> 필드에 <code>index.html</code> 경로가 잘못 포함되던 문제를 수정했습니다. 이제 null로 표시됩니다. <a href="https://github.com/rust-lang/cargo/pull/10171">#10171</a></li>
<li>바이너리를 문서화할 때 이제 패키지 라이브러리의 문서화가 끝날 때까지 기다린 후 시작합니다. 이를 통해 바이너리에 라이브러리로 향하는 내부 문서 링크(intra-doc links)가 있을 때 발생하던 경쟁 상태를 해결했습니다. <a href="https://github.com/rust-lang/cargo/pull/10172">#10172</a></li>
<li>닫힌 파이프에 도움말 텍스트를 표시할 때 발생하던 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10164">#10164</a></li>
</ul>
<h3 id="나이틀리nightly-전용-35"><a class="header" href="#나이틀리nightly-전용-35">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><code>cargo rustc</code> 에 <code>--crate-type</code> 플래그를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/10093">#10093</a></li>
</ul>
<h2 id="cargo-158-2022-01-13"><a class="header" href="#cargo-158-2022-01-13">Cargo 1.58 (2022-01-13)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/b2e52d7c...rust-1.58.0">b2e52d7c…rust-1.58.0</a></p>
<h3 id="추가됨-37"><a class="header" href="#추가됨-37">추가됨</a></h3>
<ul>
<li><code>cargo metadata</code> 의 패키지 데이터에 <code>rust_version</code> 필드를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9967">#9967</a></li>
<li><code>cargo install</code> 에 <code>--message-format</code> 옵션을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/10107">#10107</a></li>
</ul>
<h3 id="변경됨-37"><a class="header" href="#변경됨-37">변경됨</a></h3>
<ul>
<li>별칭(alias)이 외부 명령어를 가릴(shadow) 때 이제 경고가 표시됩니다. <a href="https://github.com/rust-lang/cargo/pull/10082">#10082</a></li>
<li>curl을 7.80.0으로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/10040">#10040</a> <a href="https://github.com/rust-lang/cargo/pull/10106">#10106</a></li>
</ul>
<h3 id="수정됨-40"><a class="header" href="#수정됨-40">수정됨</a></h3>
<ul>
<li>문서 테스트(doctests)에 이제 빌드 스크립트의 rustc-link-args가 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/9916">#9916</a></li>
<li>순환 개발 의존성이 있을 때 <code>cargo tree</code> 가 무한 루프에 빠지던 문제를 수정했습니다. 리졸버(resolver)가 기능(feature)이 포함된 순환 개발 의존성을 처리하지 못하던 엣지 케이스를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10103">#10103</a></li>
<li>디렉토리 경로에 글로브(glob) 문자가 포함되어 있을 때 <code>cargo clean -p</code> 가 작동하지 않던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10072">#10072</a></li>
<li>서버가 비어 있지 않은 본문(body)과 함께 리다이렉트할 때 크레이트를 다운로드하는 도중 <code>cargo</code> 의 디버그 빌드가 패닉을 일으킬 수 있던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10048">#10048</a></li>
</ul>
<h3 id="나이틀리nightly-전용-36"><a class="header" href="#나이틀리nightly-전용-36">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>미래 비호환성 보고서(future-incompat-report) 출력을 더 사용자 친화적으로 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/9953">#9953</a></li>
<li><code>examples</code> 디렉토리에서 코드 예제를 수집(scrape)하여 문서에 포함하는 기능을 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#scrape-examples">docs</a> <a href="https://github.com/rust-lang/cargo/pull/9525">#9525</a> <a href="https://github.com/rust-lang/cargo/pull/10037">#10037</a> <a href="https://github.com/rust-lang/cargo/pull/10017">#10017</a></li>
<li>표준 출력(stdout)이 색상을 지원하는지 확인하도록 <code>cargo report future-incompatibilities</code>를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/10024">#10024</a></li>
</ul>
<h2 id="cargo-157-2021-12-02"><a class="header" href="#cargo-157-2021-12-02">Cargo 1.57 (2021-12-02)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/18751dd3...rust-1.57.0">18751dd3…rust-1.57.0</a></p>
<h3 id="추가됨-38"><a class="header" href="#추가됨-38">추가됨</a></h3>
<ul>
<li>🎉 사용자 정의 이름의 프로파일 기능이 추가되었습니다. 또한 <code>test</code> 및 <code>bench</code> 프로파일이 <code>dev</code> 및 <code>release</code> 에서 설정을 상속받도록 변경되었으며, Cargo는 이제 주어진 명령을 수행하는 동안 의존성 및 Cargo 타겟에 대해 서로 다른 프로파일을 사용하는 대신 단일 프로파일만 사용합니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/profiles.html#custom-profiles">docs</a> <a href="https://github.com/rust-lang/cargo/pull/9943">#9943</a></li>
<li>git 의존성의 <code>rev</code> 옵션이 이제 <code>refs/</code> 로 시작하는 git 참조(git references)를 지원합니다. 이를 통해 병합되기 전의 GitHub와 같은 서비스의 풀 리퀘스트에 의존하도록 설정할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/9859">#9859</a></li>
<li><code>.cargo_vcs_info.json</code> 파일에 <code>path_in_vcs</code> 필드를 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/commands/cargo-package.html#cargo_vcs_infojson-format">docs</a> <a href="https://github.com/rust-lang/cargo/pull/9866">#9866</a></li>
</ul>
<h3 id="변경됨-38"><a class="header" href="#변경됨-38">변경됨</a></h3>
<ul>
<li>❗ 빌드 스크립트에 대해 <code>RUSTFLAGS</code> 가 더 이상 설정되지 않습니다. 이 변경은 1.55에서 이루어졌으나 릴리스 노트에서 강조되지 않았습니다. 빌드 스크립트는 대신 <code>CARGO_ENCODED_RUSTFLAGS</code> 를 사용해야 합니다. 자세한 내용은 <a href="https://doc.rust-lang.org/nightly/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">문서</a>를 참조하세요.</li>
<li><code>cargo version</code> 명령어가 이제 몇 가지 추가 정보를 포함합니다. <a href="https://github.com/rust-lang/cargo/pull/9968">#9968</a></li>
<li>git 처리에 관한 여러 수정 사항과 변경 사항이 포함된 libgit2 1.3으로 업데이트되었습니다. <a href="https://github.com/rust-lang/cargo/pull/9963">#9963</a> <a href="https://github.com/rust-lang/cargo/pull/9988">#9988</a></li>
<li>쉘 자동 완성에 이제 b/r/c/d 단축 서브 명령어가 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/9951">#9951</a></li>
<li><code>cargo update --precise</code> 에서 이제 semver 메타데이터(버전 번호의 <code>+</code> 뒤에 오는 내용) 없이 버전을 지정할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/9945">#9945</a></li>
<li>zsh 자동 완성에서 이제 <code>--example</code> 이름을 자동 완성합니다. <a href="https://github.com/rust-lang/cargo/pull/9939">#9939</a></li>
<li>단위 테스트를 빌드할 때 진행 표시줄이 이제 이를 구분하여 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/9934">#9934</a></li>
<li>유효하지 않은 TOML 구문에 대한 일부 하위 호환성 지원이 제거되었습니다. <a href="https://github.com/rust-lang/cargo/pull/9932">#9932</a></li>
<li>필드가 포함되지 않은 의존성 명세에 대해 오류를 발생시키던 1.55의 변경 사항을 되돌렸습니다. <a href="https://github.com/rust-lang/cargo/pull/9911">#9911</a></li>
</ul>
<h3 id="수정됨-41"><a class="header" href="#수정됨-41">수정됨</a></h3>
<ul>
<li>토큰이 유출될 수 있는 로그 메시지(<code>CARGO_LOG</code> 에서 발생)를 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/9873">#9873</a></li>
<li><code>cargo fix</code> 가 이제 글로벌 레지스트리 캐시에 수정을 기록하는 것을 피합니다. <a href="https://github.com/rust-lang/cargo/pull/9938">#9938</a></li>
<li>단축 별칭(b/c/r/d)과 함께 사용할 때의 <code>-Z help</code> CLI 옵션을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9933">#9933</a></li>
</ul>
<h3 id="나이틀리nightly-전용-37"><a class="header" href="#나이틀리nightly-전용-37">나이틀리(Nightly) 전용</a></h3>
<h2 id="cargo-156-2021-10-21"><a class="header" href="#cargo-156-2021-10-21">Cargo 1.56 (2021-10-21)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/cebef295...rust-1.56.0">cebef295…rust-1.56.0</a></p>
<h3 id="추가됨-39"><a class="header" href="#추가됨-39">추가됨</a></h3>
<ul>
<li>🎉 Cargo가 이제 2021 에디션을 지원합니다. 더 자세한 정보는 <a href="https://doc.rust-lang.org/nightly/edition-guide/rust-2021/index.html">에디션 가이드</a>에서 확인할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/9800">#9800</a></li>
<li>🎉 최소 지원 Rust 버전을 지정하기 위해 <code>Cargo.toml</code> 에 <a href="https://doc.rust-lang.org/nightly/cargo/reference/manifest.html#the-rust-version-field"><code>rust-version</code></a> 필드를 추가했으며, 이를 무시하기 위한 <code>--ignore-rust-version</code> 명령줄 옵션을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9732">#9732</a></li>
<li>설정할 환경 변수를 지정하기 위해 설정 파일에 <code>[env]</code> 테이블을 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/config.html#env">docs</a> <a href="https://github.com/rust-lang/cargo/pull/9411">#9411</a></li>
<li>설정 파일에서 <code>[patch]</code> 테이블을 지정할 수 있게 되었습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/config.html#patch">docs</a> <a href="https://github.com/rust-lang/cargo/pull/9839">#9839</a></li>
<li><code>cargo doc</code> 이 이제 <code>--example</code> 및 <code>--examples</code> 플래그를 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/9808">#9808</a></li>
<li>🎉 빌드 스크립트가 이제 바이너리 또는 모든 링크 가능한 타겟에 대해 추가적인 링커 인자를 전달할 수 있습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/build-scripts.html#outputs-of-the-build-script">docs</a> <a href="https://github.com/rust-lang/cargo/pull/9557">#9557</a></li>
<li>워크스페이스에서 특정 패키지를 게시하기 위해 <code>cargo publish</code> 에 <code>-p</code> 플래그 지원을 추가했습니다. <code>cargo package</code> 도 이제 <code>-p</code> 및 <code>--workspace</code> 를 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/9559">#9559</a></li>
<li>서드파티 레지스트리에 대한 문서를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9830">#9830</a></li>
<li>레지스트리 <code>config.json</code> 의 URL에 대해 <code>{sha256-checksum}</code> 자리표시자(placeholder)를 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/registries.html#index-format">docs</a> <a href="https://github.com/rust-lang/cargo/pull/9801">#9801</a></li>
<li>의존성에 라이브러리가 없을 때 경고를 표시하도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/9771">#9771</a></li>
</ul>
<h3 id="변경됨-39"><a class="header" href="#변경됨-39">변경됨</a></h3>
<ul>
<li>문서 테스트(doc tests)에서 간결한 테스트 출력을 보여주는 <code>-q</code> 플래그를 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/9730">#9730</a></li>
<li><code>[replace]</code> 테이블에서 사용된 <code>features</code> 는 무시되므로 이제 경고를 발생시킵니다. <a href="https://github.com/rust-lang/cargo/pull/9681">#9681</a></li>
<li><code>wasm32-unknown-emscripten</code> 실행 파일만 파일 이름에 해시 없이 빌드되도록 변경되었습니다. 이전에는 모든 <code>wasm32</code> 타겟이 그러했습니다. 또한 모든 <code>apple</code> 바이너리는 이제 파일 이름에 해시가 포함되어 빌드됩니다. 이를 통해 여러 복사본을 동시에 캐시할 수 있으며, 다른 플랫폼(<code>msvc</code> 제외)의 동작과 일치하게 됩니다. <a href="https://github.com/rust-lang/cargo/pull/9653">#9653</a></li>
<li><code>cargo new</code> 가 이제 clippy에서 경고를 생성하지 않는 예제를 생성합니다. <a href="https://github.com/rust-lang/cargo/pull/9796">#9796</a></li>
<li><code>cargo fix --edition</code> 이 이제 에디션 관련 린트(lints)만 적용합니다. <a href="https://github.com/rust-lang/cargo/pull/9846">#9846</a></li>
<li>의존성 요구 사항을 포함하도록 리졸버 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/9827">#9827</a></li>
<li><code>cargo fix</code> 에서 이제 <code>CARGO_LOG</code> 환경 변수를 통해 더 많은 디버그 로그를 볼 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/9831">#9831</a></li>
<li>안정(stable) 채널에서 실행 중일 때 이미 최신 안정 에디션을 사용하고 있다면 <code>cargo fix --edition</code>이 오류 대신 경고를 발생시키도록 변경되었습니다. <a href="https://github.com/rust-lang/cargo/pull/9792">#9792</a></li>
<li><code>cargo install</code> 가 이제 설치를 시작하기 전에 설치할 모든 패키지를 결정합니다. 이를 통해 일부만 설치된 상태에서 오류가 발생하는 대신 미리 오류를 보고하는 데 도움이 됩니다. <a href="https://github.com/rust-lang/cargo/pull/9793">#9793</a></li>
<li><code>cargo fix --edition</code> 에 대한 리졸버 보고서에 이제 개발 의존성(dev-dependencies)의 차이점이 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/9803">#9803</a></li>
<li><code>cargo fix</code> 가 이제 <code>rustc</code> 에서 발생하는 비정상적인 오류에 대해 더 나은 진단을 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/9799">#9799</a></li>
<li><code>cargo --list</code> 의 항목들이 이제 중복 제거되어 표시됩니다. <a href="https://github.com/rust-lang/cargo/pull/9773">#9773</a></li>
<li><code>cargo --list</code> 에 이제 별칭(aliases)이 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/9764">#9764</a></li>
</ul>
<h3 id="수정됨-42"><a class="header" href="#수정됨-42">수정됨</a></h3>
<ul>
<li>proc-macro의 build-std 과정에서 발생하던 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9834">#9834</a></li>
<li><code>cargo fix</code> 를 실행하는 동안 proc-macro에서 <code>cargo</code> 를 재귀적으로 실행하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9818">#9818</a></li>
<li>명령어 별칭 루프가 발생할 경우 스택 오버플로 대신 오류를 반환하도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/9791">#9791</a></li>
<li>간헐적인 http2 오류를 해결하기 위해 curl 7.79.1로 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/9937">#9937</a></li>
</ul>
<h3 id="나이틀리nightly-전용-38"><a class="header" href="#나이틀리nightly-전용-38">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><code>[future-incompat-report]</code> 설정 섹션을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9774">#9774</a></li>
<li>사용자 정의 이름의 프로파일에서 발생하던 value-after-table 오류를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9789">#9789</a></li>
<li>바이너리 이름에 Rust 식별자가 아닌 이름을 지정할 수 있도록 <code>different-binary-name</code> 기능을 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#different-binary-name">docs</a> <a href="https://github.com/rust-lang/cargo/pull/9627">#9627</a></li>
<li>코드 생성(codegen) 백엔드를 선택할 수 있는 프로파일 옵션을 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#codegen-backend">docs</a> <a href="https://github.com/rust-lang/cargo/pull/9118">#9118</a></li>
</ul>
<h2 id="cargo-155-2021-09-09"><a class="header" href="#cargo-155-2021-09-09">Cargo 1.55 (2021-09-09)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/aa8b0929...rust-1.55.0">aa8b0929…rust-1.55.0</a></p>
<h3 id="추가됨-40"><a class="header" href="#추가됨-40">추가됨</a></h3>
<ul>
<li><code>cargo metadata</code> 의 패키지 정의에 매니페스트의 <code>"default_run"</code> 필드가 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/9550">#9550</a></li>
<li>❗ 빌드 스크립트가 이제 다음 환경 변수에 접근할 수 있습니다: <code>RUSTC_WRAPPER</code>, <code>RUSTC_WORKSPACE_WRAPPER</code>, <code>CARGO_ENCODED_RUSTFLAGS</code>. 빌드 스크립트에 대해 <code>RUSTFLAGS</code> 는 더 이상 설정되지 않으며, 대신 <code>CARGO_ENCODED_RUSTFLAGS</code> 를 사용해야 합니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-build-scripts">docs</a> <a href="https://github.com/rust-lang/cargo/pull/9601">#9601</a></li>
<li><code>cargo doc</code> 의 별칭으로 <code>cargo d</code> 를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9680">#9680</a></li>
<li>패키지의 라이브러리 이름을 표시하기 위해 <code>cargo tree --format</code> 옵션에 <code>{lib}</code> 를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9663">#9663</a></li>
<li><code>Workspace</code> API에 <code>members_mut</code> 메서드를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9547">#9547</a></li>
</ul>
<h3 id="변경됨-40"><a class="header" href="#변경됨-40">변경됨</a></h3>
<ul>
<li><code>--all-targets</code>, <code>--bins</code>, <code>--tests</code>, <code>--examples</code>, 또는 <code>--benches</code> 플래그를 사용할 때 빌드 명령이 어떤 타겟과도 일치하지 않으면, 일치하는 타겟이 없음을 알리는 경고가 표시됩니다. <a href="https://github.com/rust-lang/cargo/pull/9549">#9549</a></li>
<li>기존 소스 파일이 바이너리인지 라이브러리인지 <code>cargo init</code> 이 감지하는 방식이 변경되어, 타입을 추측하는 대신 명령줄 플래그를 존중하도록 수정되었습니다. <a href="https://github.com/rust-lang/cargo/pull/9522">#9522</a></li>
<li>가능한 경우 레지스트리 URL 대신 레지스트리 이름이 표시됩니다. <a href="https://github.com/rust-lang/cargo/pull/9632">#9632</a></li>
<li>중복된 컴파일러 진단 결과가 더 이상 표시되지 않습니다. 이는 동일한 코드의 여러 복사본을 병렬로 빌드하는 <code>cargo test</code> 에서 자주 발생할 수 있는 일입니다. 또한 경고 요약이 더 많은 문맥을 제공하도록 업데이트되었습니다. <a href="https://github.com/rust-lang/cargo/pull/9675">#9675</a></li>
<li>경고 또는 오류 출력이 더 간결하고 깔끔해졌으며, 더 많은 문맥을 보여주도록 개선되었습니다. <a href="https://github.com/rust-lang/cargo/pull/9655">#9655</a></li>
<li>네트워크 전송 오류가 이제 “일시적인(spurious)” 오류로 취급되어 재시도됩니다. <a href="https://github.com/rust-lang/cargo/pull/9695">#9695</a></li>
<li>git 의존성이 아닌 곳에 git 키(<code>branch</code>, <code>tag</code>, <code>rev</code>)를 사용하는 것이 이제 오류로 처리됩니다. 또한 <code>git</code> 과 <code>path</code> 를 동시에 지정하는 것도 이제 오류입니다. <a href="https://github.com/rust-lang/cargo/pull/9689">#9689</a></li>
<li>키를 하나도 지정하지 않고 의존성을 명시하는 것은 이제 오류입니다. <a href="https://github.com/rust-lang/cargo/pull/9686">#9686</a></li>
<li>리졸버가 가능할 경우 의존성의 <code>[patch]</code> 테이블 항목을 사용하는 것을 선호하도록 변경되었습니다. <a href="https://github.com/rust-lang/cargo/pull/9639">#9639</a></li>
<li>의존성의 패키지 이름 오타 오류가 원본과 나란히 표시되어 차이점을 더 쉽게 확인할 수 있도록 개선되었습니다. <a href="https://github.com/rust-lang/cargo/pull/9665">#9665</a></li>
<li>윈도우 플랫폼에서 대소문자가 잘못된 환경 변수에 대해 이제 경고를 표시할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/9654">#9654</a></li>
<li><code>[patch]</code> 테이블에서 사용된 <code>features</code> 는 무시되므로 이제 경고를 발생시킵니다. <a href="https://github.com/rust-lang/cargo/pull/9666">#9666</a></li>
<li>윈도우에서 <code>target</code> 디렉토리가 이제 콘텐츠 인덱싱 대상에서 제외됩니다. <a href="https://github.com/rust-lang/cargo/pull/9635">#9635</a></li>
<li><code>Cargo.toml</code> 을 찾을 수 없을 때, 소문자 <code>c</code> 로 잘못 이름 지어진 것인지 감지하여 올바른 형식을 제안하도록 오류 메시지가 개선되었습니다. <a href="https://github.com/rust-lang/cargo/pull/9607">#9607</a></li>
<li>새로운 리졸버를 사용하여 <code>diesel</code> 을 빌드할 때 호환성 알림이 표시됩니다. <a href="https://github.com/rust-lang/cargo/pull/9602">#9602</a></li>
<li>웹 브라우저를 여는 기능을 담당하는 <code>opener</code> 의존성을 업데이트했습니다. 여기에는 WSL에서 실행될 때의 새로운 동작과 리눅스에서 시스템 <code>xdg-open</code> 을 사용하는 등 여러 변경 사항이 포함되어 있습니다. <a href="https://github.com/rust-lang/cargo/pull/9583">#9583</a></li>
<li>libcurl 7.78로 업데이트되었습니다. <a href="https://github.com/rust-lang/cargo/pull/9809">#9809</a> <a href="https://github.com/rust-lang/cargo/pull/9810">#9810</a></li>
</ul>
<h3 id="수정됨-43"><a class="header" href="#수정됨-43">수정됨</a></h3>
<ul>
<li>비로컬(non-local) 빌드 스크립트 경로를 포함하던 dep-info 파일 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9596">#9596</a></li>
<li>Cargo 설정 파일에서 “jobs = 0“인 경우를 처리하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9584">#9584</a></li>
<li><code>--</code> 뒤에 오는 무시된 후속 인자들에 대해 경고를 표시하도록 구현했습니다. <a href="https://github.com/rust-lang/cargo/pull/9561">#9561</a></li>
<li>rustc/rustdoc 설정 값이 설정 파일 위치에 상대적으로(config-relative) 처리되도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9566">#9566</a></li>
<li><code>cargo fix</code> 가 이제 여러 범위(multiple spans)를 가진 rustc의 제안을 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/9567">#9567</a></li>
<li><code>cargo fix</code> 가 이제 동일한 파일을 동시에 수정할 때 발생하는 문제를 피하기 위해 각 타겟을 병렬이 아닌 순차적으로 수정합니다. <a href="https://github.com/rust-lang/cargo/pull/9677">#9677</a></li>
<li>타겟 <code>linker</code> 설정 값의 변경이 이제 재빌드를 유발합니다. <a href="https://github.com/rust-lang/cargo/pull/9647">#9647</a></li>
<li><code>cargo publish</code> 또는 <code>cargo package</code> 에서 <code>--allow-dirty</code> 플래그를 사용할 때, 스테이징되지 않은 git 삭제 파일들이 이제 무시됩니다. <a href="https://github.com/rust-lang/cargo/pull/9645">#9645</a></li>
</ul>
<h3 id="나이틀리nightly-전용-39"><a class="header" href="#나이틀리nightly-전용-39">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>2021 에디션에 대해 <code>cargo fix --edition</code> 지원을 활성화했습니다. <a href="https://github.com/rust-lang/cargo/pull/9588">#9588</a></li>
<li>이름이 지정된 프로파일(named profiles)과 관련된 몇 가지 변경 사항이 있습니다. <a href="https://github.com/rust-lang/cargo/pull/9685">#9685</a></li>
<li>2021 에디션에서 <code>cargo fix --edition</code> 을 실행할 때 수행할 작업에 대한 지침을 확장했습니다. <a href="https://github.com/rust-lang/cargo/pull/9694">#9694</a></li>
<li>상황을 더 잘 설명할 수 있도록 나이틀리(nightly) 기능을 사용할 때의 오류 메시지를 여러 차례 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/9657">#9657</a></li>
<li>2021 에디션 리졸버의 차이점 보고서(diff report)를 조정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9649">#9649</a></li>
<li><code>doc.extern-map</code> 과 함께 <code>cargo doc --open</code> 을 사용할 때 발생하던 오류를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9531">#9531</a></li>
<li>약한 기능(weak features)과 네임스페이스가 지정된 기능(namespaced features)을 통합했습니다. <a href="https://github.com/rust-lang/cargo/pull/9574">#9574</a></li>
<li>미래 비호환성 보고(future-incompatible reporting)와 관련된 여러 업데이트가 있었습니다. <a href="https://github.com/rust-lang/cargo/pull/9606">#9606</a></li>
<li><code>[env]</code> 환경 변수가 Cargo에 의해 설정된 변수를 덮어쓰는 것을 허용하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/9579">#9579</a></li>
</ul>
<h2 id="cargo-154-2021-07-29"><a class="header" href="#cargo-154-2021-07-29">Cargo 1.54 (2021-07-29)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/4369396c...rust-1.54.0">4369396c…rust-1.54.0</a></p>
<h3 id="추가됨-41"><a class="header" href="#추가됨-41">추가됨</a></h3>
<ul>
<li>(crates.io 인덱스와 같은) git 저장소에서 데이터를 가져올 때 이제 네트워크 전송 속도가 표시됩니다. <a href="https://github.com/rust-lang/cargo/pull/9395">#9395</a></li>
<li>표시되는 내용을 제한하기 위해 <code>cargo tree</code> 에 <code>--prune</code> 옵션을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9520">#9520</a></li>
<li>표시되는 깊이를 제한하기 위해 <code>cargo tree</code> 에 <code>--depth</code> 옵션을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9499">#9499</a></li>
<li>절차적 매크로(procedural macro) 의존성을 숨기기 위해 <code>cargo tree -e no-proc-macro</code> 옵션을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9488">#9488</a></li>
<li><code>cargo doc --open</code> 으로 열 브라우저를 설정할 수 있는 <code>doc.browser</code> 설정 옵션을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9473">#9473</a></li>
<li>통합 테스트 및 벤치마크를 위해 <code>CARGO_TARGET_TMPDIR</code> 환경 변수를 추가했습니다. 이는 테스트와 벤치마크에서 사용할 수 있도록 <code>target</code> 디렉토리 내에 임시 또는 “스크래치(scratch)” 디렉토리를 제공합니다. <a href="https://github.com/rust-lang/cargo/pull/9375">#9375</a></li>
</ul>
<h3 id="변경됨-41"><a class="header" href="#변경됨-41">변경됨</a></h3>
<ul>
<li>새로운 기능 리졸버(feature resolver) 사용 시 <code>--features</code> CLI 플래그가 이제 오타 수정을 제안합니다. <a href="https://github.com/rust-lang/cargo/pull/9420">#9420</a></li>
<li>Cargo가 이제 SemVer 버전에 대해 새로운 파서를 사용합니다. 이는 이전과 거의 동일하게 동작하지만, 유효하지 않은 버전 요구 사항 구문이 거부되는 등의 사소한 예외가 있을 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/9508">#9508</a></li>
<li>게시된 <code>.crate</code> 패키지의 수정 시간(mtime) 처리가 0이 되지 않도록 약간 변경되었습니다. 수정 시간이 0인 경우 lldb가 해당 파일을 읽지 못하는 문제가 발생했었습니다. <a href="https://github.com/rust-lang/cargo/pull/9517">#9517</a></li>
<li><code>cargo package</code> 에서 git 상태 확인 성능을 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/9478">#9478</a></li>
<li>fossil을 사용하는 <code>cargo new</code> 가 이제 무시 설정을 전역적으로 설정하는 <code>fossil settings</code> 대신 새 저장소에 직접 배치합니다. 또한 다른 VCS 설정과의 일관성을 높이기 위해 여러 가지 정리를 수행했습니다. <a href="https://github.com/rust-lang/cargo/pull/9469">#9469</a></li>
<li><code>rustc-cdylib-link-arg</code> 가 전이적으로 적용될 때 이것이 의도되지 않았음을 알리는 경고를 표시하며, 향후 오류로 처리될 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/9563">#9563</a></li>
</ul>
<h3 id="수정됨-44"><a class="header" href="#수정됨-44">수정됨</a></h3>
<ul>
<li>git 저장소가 아니거나 의존성을 벤더링할 때 <code>Cargo.toml</code> 의 <code>package.exclude</code> 에서 반전된 제외 규칙(<code>!somefile</code>)이 제대로 작동하지 않던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9186">#9186</a></li>
<li>Dep-info 파일이 이제 빌드 스크립트의 <code>rerun-if-changed</code> 경로를 절대 경로로 조정합니다. <a href="https://github.com/rust-lang/cargo/pull/9421">#9421</a></li>
<li><code>resolver = "1"</code> 에서 비가상(non-virtual) 패키지가 알 수 없는 기능을 허용하던 버그를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9437">#9437</a></li>
<li>빌드 메타데이터만 다른 버전(예: <code>110.0.0</code> 과 <code>110.0.0+1.1.0f</code>)을 인덱스 캐시가 잘못 처리하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9476">#9476</a></li>
<li>semver 메타데이터가 포함된 버전에 대한 <code>cargo install</code> 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9467">#9467</a></li>
</ul>
<h3 id="나이틀리nightly-전용-40"><a class="header" href="#나이틀리nightly-전용-40">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><code>report</code> 서브 명령어를 추가하고, <code>cargo describe-future-incompatibilitie</code> 를 <code>cargo report future-incompatibilities</code> 로 변경했습니다. <a href="https://github.com/rust-lang/cargo/pull/9438">#9438</a></li>
<li>호스트 타겟에 대한 빌드 플래그를 설정할 수 있도록 설정 파일에 <code>[host]</code> 테이블을 추가했습니다. 또한 <code>[target]</code> 테이블의 동작 방식을 제어하기 위해 <code>target-applies-to-host</code>를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9322">#9322</a></li>
<li>타겟이 존재하지 않을 경우 오류를 반환하도록 빌드 스크립트의 <code>rustc-link-arg-*</code> 지시문에 대한 몇 가지 검증을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9523">#9523</a></li>
<li>빌드 스크립트를 위한 <code>cargo:rustc-link-arg-bin</code> 지시문을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9486">#9486</a></li>
</ul>
<h2 id="cargo-153-2021-06-17"><a class="header" href="#cargo-153-2021-06-17">Cargo 1.53 (2021-06-17)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/90691f2b...rust-1.53.0">90691f2b…rust-1.53.0</a></p>
<h3 id="추가됨-42"><a class="header" href="#추가됨-42">추가됨</a></h3>
<h3 id="변경됨-42"><a class="header" href="#변경됨-42">변경됨</a></h3>
<ul>
<li>🔥 Cargo가 이제 기본 <code>HEAD</code> 브랜치가 “master“가 아닌 git 저장소를 지원합니다. 여기에는 기본 브랜치를 올바르게 처리할 수 있는 버전 3 <code>Cargo.lock</code> 형식으로의 전환도 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/9133">#9133</a> <a href="https://github.com/rust-lang/cargo/pull/9397">#9397</a> <a href="https://github.com/rust-lang/cargo/pull/9384">#9384</a> <a href="https://github.com/rust-lang/cargo/pull/9392">#9392</a></li>
<li>🔥 macOS 타겟의 기본값이 이제 <code>unpacked</code> split-debuginfo로 설정됩니다. <a href="https://github.com/rust-lang/cargo/pull/9298">#9298</a></li>
<li>❗ 새로운 프로젝트의 <code>Cargo.toml</code> 에 <code>authors</code> 필드가 더 이상 포함되지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/9282">#9282</a></li>
<li><code>cargo update</code> 가 이제 <code>--offline</code> 플래그와 함께 작동할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/9279">#9279</a></li>
<li><code>cargo doc</code> 이 이제 다른 툴체인 버전 간에 전환할 때 <code>doc</code> 디렉토리를 삭제합니다. 검색 인덱스와 같이 공유되고 버전이 지정되지 않은 파일들이 서로 다른 버전을 사용할 때 깨질 수 있기 때문입니다. <a href="https://github.com/rust-lang/cargo/pull/8640">#8640</a> <a href="https://github.com/rust-lang/cargo/pull/9404">#9404</a></li>
<li>경로 의존성(path dependency)이나 워크스페이스 구성원이 누락되었을 때의 오류 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/9368">#9368</a></li>
</ul>
<h3 id="수정됨-45"><a class="header" href="#수정됨-45">수정됨</a></h3>
<ul>
<li>기능(features)과 같은 일부 설정을 변경할 때 <code>cargo doc</code> 이 문서 재빌드 필요 여부를 감지하지 못하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9419">#9419</a></li>
<li><code>cargo doc</code> 이 이제 오래된 파일을 정리하기 위해 rustdoc을 실행하기 전 패키지의 출력 디렉토리를 삭제합니다. <a href="https://github.com/rust-lang/cargo/pull/9419">#9419</a></li>
<li>모든 빌드에 대해 <code>-C metadata</code> 값이 항상 모든 정보를 포함하도록 수정했습니다. 이전에는 일부 상황에서 해시에 패키지 이름과 버전만 포함되었습니다. 이를 통해 macOS에서 split-debuginfo를 사용한 점진적 빌드(incremental builds) 시 점진적 캐시가 손상되던 문제 등을 해결했습니다. <a href="https://github.com/rust-lang/cargo/pull/9418">#9418</a></li>
<li><code>man</code> 이 <code>PATH</code> 에 있을 때 윈도우에서 매뉴얼 페이지(man pages)가 작동하지 않던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9378">#9378</a></li>
<li><code>rustc</code> 캐시가 이제 <code>RUSTC_WRAPPER</code> 및 <code>RUSTC_WORKSPACE_WRAPPER</code> 를 인식합니다. <a href="https://github.com/rust-lang/cargo/pull/9348">#9348</a></li>
<li>코드에서 <code>env!("CARGO")</code> 를 사용하는 경우, 재빌드 핑거프린트에서 <code>CARGO</code> 환경 변수를 추적하도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/9363">#9363</a></li>
</ul>
<h3 id="나이틀리nightly-전용-41"><a class="header" href="#나이틀리nightly-전용-41">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>설정 포함(config includes) 기능이 작동하지 않던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9299">#9299</a></li>
<li><code>--future-incompat-report</code> 에서 보고할 내용이 없을 때 알림(note)을 출력하도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/9263">#9263</a></li>
<li>나이틀리 기능 플래그(<code>-Z</code> 및 <code>cargo-features</code> 등)에 대한 오류 메시지가 이제 더 많은 정보를 제공합니다. <a href="https://github.com/rust-lang/cargo/pull/9290">#9290</a></li>
<li><code>Cargo.toml</code> 에서 개별 패키지에 대해 타겟을 설정할 수 있는 기능을 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#per-package-target">docs</a> <a href="https://github.com/rust-lang/cargo/pull/9030">#9030</a></li>
<li>빌드할 때마다 build-std가 인덱스를 업데이트하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9393">#9393</a></li>
<li><code>-Z help</code> 가 이제 모든 <code>-Z</code> 옵션을 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/9369">#9369</a></li>
<li>사용 가능한 나이틀리 기능을 지정하기 위한 <code>-Zallow-features</code> 를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9283">#9283</a></li>
<li><code>cargo config</code> 서브 명령어를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9302">#9302</a></li>
</ul>
<h2 id="cargo-152-2021-05-06"><a class="header" href="#cargo-152-2021-05-06">Cargo 1.52 (2021-05-06)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/34170fcd...rust-1.52.0">34170fcd…rust-1.52.0</a></p>
<h3 id="추가됨-43"><a class="header" href="#추가됨-43">추가됨</a></h3>
<ul>
<li>패키지에 대한 JSON 메시지에 <code>"manifest_path"</code> 필드를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9022">#9022</a> <a href="https://github.com/rust-lang/cargo/pull/9247">#9247</a></li>
</ul>
<h3 id="변경됨-43"><a class="header" href="#변경됨-43">변경됨</a></h3>
<ul>
<li>안정(stable) 채널에서 빌드 스크립트가 <code>RUSTC_BOOTSTRAP</code> 을 설정하는 것이 이제 금지됩니다. <a href="https://github.com/rust-lang/cargo/pull/9181">#9181</a> <a href="https://github.com/rust-lang/cargo/pull/9385">#9385</a></li>
<li>crates.io가 이제 SPDX 3.11 라이선스를 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/9209">#9209</a></li>
<li><code>CARGO_TARGET_DIR</code> 이 빈 문자열인 경우 이제 오류가 보고됩니다. <a href="https://github.com/rust-lang/cargo/pull/8939">#8939</a></li>
<li>문서 테스트(doc tests)에서 이제 <code>--message-format</code> 플래그를 전달하여 “short” 형식을 사용할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/9128">#9128</a></li>
<li><code>cargo test</code> 가 이제 현재 어떤 타겟이 실행 중인지 더 명확한 표시기를 출력합니다. <a href="https://github.com/rust-lang/cargo/pull/9195">#9195</a></li>
<li><code>CARGO_TARGET_&lt;TRIPLE&gt;</code> 환경 변수가 소문자를 사용하고 있을 경우 이제 경고가 발생합니다. <a href="https://github.com/rust-lang/cargo/pull/9169">#9169</a></li>
</ul>
<h3 id="수정됨-46"><a class="header" href="#수정됨-46">수정됨</a></h3>
<ul>
<li><code>Cargo.toml</code> 에 메타데이터(metadata) 및 리졸버(resolver) 필드가 있는 패키지의 게시(publication) 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9300">#9300</a> <a href="https://github.com/rust-lang/cargo/pull/9304">#9304</a></li>
<li>워크스페이스와 단일 패키지에서 다르게 작동하던 dylib의 prefer-dynamic 결정 로직을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9252">#9252</a></li>
<li>의존성 종류(일반 및 빌드 의존성 등) 간에 겹치는 배타적 타겟별 의존성이 양쪽 모두에 잘못 포함되던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9255">#9255</a></li>
<li><code>-p</code> 플래그에 특정 형식의 패키지 ID가 전달될 때 발생하던 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9188">#9188</a></li>
<li>출력이 TTY가 아닌 상태에서 진행 표시줄과 색상을 강제로 활성화하고 Cargo를 실행할 때, 이제 진행 상황 표시줄이 올바르게 지워집니다. <a href="https://github.com/rust-lang/cargo/pull/9231">#9231</a></li>
<li>JSON에 비 UTF-8 경로가 포함되어 있을 때 패닉 대신 오류를 발생시키도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/9226">#9226</a></li>
<li>손상된 표준 에러(stderr)에서 발생할 수 있는 멈춤(hang) 현상을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9201">#9201</a></li>
<li><code>lto=off</code> 설정 시 thin-local LTO가 올바르게 비활성화되지 않던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9182">#9182</a></li>
</ul>
<h3 id="나이틀리nightly-전용-42"><a class="header" href="#나이틀리nightly-전용-42">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><code>strip</code> 프로파일 옵션이 이제 <code>true</code> 및 <code>false</code> 값을 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/9153">#9153</a></li>
<li>2021 에디션으로 전환할 때 새로운 리졸버가 기능을 변경하는 경우, <code>cargo fix --edition</code> 이 이제 보고서를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/9268">#9268</a></li>
<li><code>.cargo/config</code> 파일에서 <code>[patch]</code> 테이블 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9204">#9204</a></li>
<li>미래 비호환 경고가 포함된 의존성에 대한 보고서를 생성하는 <code>cargo describe-future-incompatibilities</code>를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8825">#8825</a></li>
<li>2021 에디션을 더 쉽게 테스트할 수 있도록 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9184">#9184</a></li>
<li>2021 에디션에서 기본 리졸버를 “2“로 변경했습니다. <a href="https://github.com/rust-lang/cargo/pull/9184">#9184</a></li>
<li><code>cargo fix --edition</code> 이 이제 2021 에디션을 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/9184">#9184</a></li>
<li>rustc의 정보를 표시하기 위해 <code>rustc</code> 로 전달할 <code>--print</code> 플래그를 <code>cargo rustc</code> 에 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9002">#9002</a></li>
<li>문서 테스트가 <em>컴파일</em> 되는 위치와 <em>실행</em> 되는 디렉토리를 변경할 수 있는 <code>-Zdoctest-in-workspace</code>를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9105">#9105</a></li>
<li>Cargo를 실행할 때 환경 변수를 설정할 수 있도록 <code>.cargo/config.toml</code> 에 <code>[env]</code> 섹션 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9175">#9175</a></li>
<li>인덱스에 스키마(schema) 필드와 <code>features2</code> 필드를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9161">#9161</a></li>
<li>JSON 명세 타겟(JSON spec targets)의 변경이 이제 재빌드를 유발합니다. <a href="https://github.com/rust-lang/cargo/pull/9223">#9223</a></li>
</ul>
<h2 id="cargo-151-2021-03-25"><a class="header" href="#cargo-151-2021-03-25">Cargo 1.51 (2021-03-25)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/75d5d8cf...rust-1.51.0">75d5d8cf…rust-1.51.0</a></p>
<h3 id="추가됨-44"><a class="header" href="#추가됨-44">추가됨</a></h3>
<ul>
<li>🔥 <code>split-debuginfo</code> 프로파일 옵션을 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/profiles.html#split-debuginfo">docs</a> <a href="https://github.com/rust-lang/cargo/pull/9112">#9112</a></li>
<li>“path” 의존성의 경로를 표시하기 위해 <code>cargo metadata</code> 의 패키지 의존성 목록에 <code>path</code> 필드를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8994">#8994</a></li>
<li>🔥 새로운 기능 리졸버(feature resolver)와 새로운 CLI 기능 플래그 동작을 추가했습니다. <code>resolver = "2"</code> 옵션에 대한 자세한 내용은 새로운 <a href="https://doc.rust-lang.org/nightly/cargo/reference/features.html#feature-resolver-version-2">기능(features)</a> 및 <a href="https://doc.rust-lang.org/nightly/cargo/reference/resolver.html#feature-resolver-version-2">리졸버(resolver)</a> 문서를 참조하세요. 새로운 CLI 동작에 대해서는 <a href="https://doc.rust-lang.org/nightly/cargo/reference/features.html#command-line-feature-options">CLI</a> 및 <a href="https://doc.rust-lang.org/nightly/cargo/reference/features.html#resolver-version-2-command-line-flags">리졸버 2 CLI</a> 옵션을 참조하세요. 마지막으로, 변경 사항에 대한 자세한 내용은 <a href="https://github.com/rust-lang/rfcs/blob/master/text/2957-cargo-features2.md">RFC 2957</a>을 참조하세요. <a href="https://github.com/rust-lang/cargo/pull/8997">#8997</a></li>
</ul>
<h3 id="변경됨-44"><a class="header" href="#변경됨-44">변경됨</a></h3>
<ul>
<li><code>cargo install --locked</code> 실행 시 <code>Cargo.lock</code> 파일을 찾을 수 없으면 이제 경고를 발생시킵니다. <a href="https://github.com/rust-lang/cargo/pull/9108">#9108</a></li>
<li>명령줄에 알 수 없거나 모호한 패키지 ID가 전달되면 이제 올바른 패키지 ID에 대한 제안을 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/9095">#9095</a></li>
<li><code>cargo vendor</code> 의 성능을 약간 최적화했습니다. <a href="https://github.com/rust-lang/cargo/pull/8937">#8937</a> <a href="https://github.com/rust-lang/cargo/pull/9131">#9131</a> <a href="https://github.com/rust-lang/cargo/pull/9132">#9132</a></li>
</ul>
<h3 id="수정됨-47"><a class="header" href="#수정됨-47">수정됨</a></h3>
<ul>
<li>동일한 빌드 세션 동안 빌드 스크립트가 여러 번 실행될 때, <code>cargo test</code> 및 <code>cargo run</code>에 대해 설정되는 빌드 스크립트 기반 환경 변수 및 cfg 설정 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9122">#9122</a></li>
<li><code>cargo doc</code> 과 새로운 기능 리졸버 사용 시 발생하던 패닉을 수정했습니다. 또한 여러 버전이 있거나 호스트 및 타겟 플랫폼에 대해 동일한 패키지가 공유되는 경우와 같이 패키지의 변형이 여러 개인 경우, 하나만 문서화하여 <code>rustdoc</code> 과의 경로 충돌을 피하기 위한 몇 가지 휴리스틱을 도입했습니다. <a href="https://github.com/rust-lang/cargo/pull/9077">#9077</a></li>
<li>스택 오버플로를 유발하던 Cargo의 순환 의존성 그래프 감지 버그를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9075">#9075</a></li>
<li>일부 경우에 패키지 테스트 시 빌드 스크립트의 <code>links</code> 환경 변수(<code>DEP_*</code>)가 나타나지 않던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9065">#9065</a></li>
<li><code>resolver="2"</code> 를 사용하는 워크스페이스에 proc-macro가 포함되어 있고 전체 워크스페이스의 모든 타겟을 빌드할 때, 특정 시나리오에서 기능(feature)이 비결정적인 방식으로 선택되던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9059">#9059</a></li>
<li><code>~/.gitconfig</code> 의 <code>http.proxy</code> 설정을 사용하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8986">#8986</a></li>
<li>V1 리졸버에서 비구성원(non-member)에 대한 <code>--feature pkg/feat</code> 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9275">#9275</a> <a href="https://github.com/rust-lang/cargo/pull/9277">#9277</a></li>
<li>워크스페이스에서 출력 파일 이름이 충돌할 때 <code>cargo doc</code> 에서 발생하던 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9276">#9276</a> <a href="https://github.com/rust-lang/cargo/pull/9277">#9277</a></li>
<li>여러 패키지 중 하나가 성공적으로 설치되지 않았음에도 <code>cargo install</code> 이 성공적으로 종료되던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9185">#9185</a> <a href="https://github.com/rust-lang/cargo/pull/9196">#9196</a></li>
<li>문서 충돌 고아(orphan)와 관련된 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/9142">#9142</a> <a href="https://github.com/rust-lang/cargo/pull/9196">#9196</a></li>
</ul>
<h3 id="나이틀리nightly-전용-43"><a class="header" href="#나이틀리nightly-전용-43">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><code>publish-lockfile</code> 불안정한 기능을 제거했습니다. 이 기능은 1.5년 전에 명시적인 플래그 없이 안정화되었습니다. <a href="https://github.com/rust-lang/cargo/pull/9092">#9092</a></li>
<li>나이틀리 기능(예: <code>-Z</code> 플래그로 전달되거나 <code>Cargo.toml</code> 의 <code>cargo-features</code> 에 지정된 기능)에 대해 더 나은 진단, 도움말 메시지 및 문서를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9092">#9092</a></li>
<li>Rust 2021 에디션 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8922">#8922</a></li>
<li>프로젝트 메타데이터에서 <code>rust-version</code> 필드 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8037">#8037</a></li>
<li>인덱스에 스키마(schema) 필드를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/9161">#9161</a> <a href="https://github.com/rust-lang/cargo/pull/9196">#9196</a></li>
</ul>
<h2 id="cargo-150-2021-02-11"><a class="header" href="#cargo-150-2021-02-11">Cargo 1.50 (2021-02-11)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/8662ab42...rust-1.50.0">8662ab42…rust-1.50.0</a></p>
<h3 id="추가됨-45"><a class="header" href="#추가됨-45">추가됨</a></h3>
<ul>
<li><code>cargo metadata</code> 에 타겟이 문서화되었는지 여부를 나타내는 <code>doc</code> 필드를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8869">#8869</a></li>
<li>로컬 워크스페이스 패키지에 대해서만 실행되고 래핑되지 않은 빌드와 독립적으로 산출물을 캐시하는 대체 RUSTC 래퍼인 <code>RUSTC_WORKSPACE_WRAPPER</code> 를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8976">#8976</a></li>
<li>워크스페이스 구성원만 업데이트하고 의존성은 업데이트하지 않도록 <code>cargo update</code> 에 <code>--workspace</code> 를 추가했습니다. 이는 <code>Cargo.toml</code> 의 버전을 업데이트하고 다른 명령을 실행하지 않고 <code>Cargo.lock</code> 을 업데이트하고 싶을 때 특히 유용합니다. <a href="https://github.com/rust-lang/cargo/pull/8725">#8725</a></li>
</ul>
<h3 id="변경됨-45"><a class="header" href="#변경됨-45">변경됨</a></h3>
<ul>
<li>레지스트리에 업로드된 <code>.crate</code> 파일이 이제 재현 가능한 설정으로 빌드되어, 서로 다른 머신에서 생성된 동일한 <code>.crate</code> 파일이 동일해야 합니다. <a href="https://github.com/rust-lang/cargo/pull/8864">#8864</a></li>
<li><code>branch</code>, <code>tag</code>, <code>rev</code> 중 하나 이상을 지정하는 Git 의존성은 이제 거부됩니다. <a href="https://github.com/rust-lang/cargo/pull/8984">#8984</a></li>
<li><code>rerun-if-changed</code> 빌드 스크립트 지시문이 이제 디렉토리를 가리킬 수 있으며, 이 경우 Cargo는 해당 디렉토리의 파일이 변경되었는지 확인합니다. <a href="https://github.com/rust-lang/cargo/pull/8973">#8973</a></li>
<li>Cargo가 사용자 이름이나 이메일 주소를 결정할 수 없는 경우, <code>cargo new</code> 는 더 이상 실패하지 않고 대신 빈 작성자 목록을 만듭니다. <a href="https://github.com/rust-lang/cargo/pull/8912">#8912</a></li>
<li>현재 빌드 중인 크레이트를 표시할 공간을 더 확보하기 위해 진행률 표시줄 너비가 줄어들었습니다. <a href="https://github.com/rust-lang/cargo/pull/8892">#8892</a></li>
<li><code>cargo new</code> 는 이제 사용자 이름과 이메일 주소를 결정할 때 올바른 디렉토리와 일치하도록 <code>.gitconfig</code> 의 <code>includeIf</code> 지시문을 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/8886">#8886</a></li>
</ul>
<h3 id="수정됨-48"><a class="header" href="#수정됨-48">수정됨</a></h3>
<ul>
<li>요청된 타겟에 대해서만 패키지를 다운로드하도록 <code>cargo metadata</code> 및 <code>cargo tree</code> 를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8987">#8987</a></li>
<li>많은 수정 사항이 포함된 libgit2를 업데이트했으며, 특히 32비트 시스템에서 가끔 발생하는 zlib 오류를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8998">#8998</a></li>
<li><code>links</code> 필드를 사용하는 순환 개발 의존성으로 인한 스택 오버플로를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8969">#8969</a></li>
<li>일부 파일 시스템, 특히 WSL2의 9p에서 <code>cargo publish</code> 가 실패하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8950">#8950</a></li>
</ul>
<h3 id="나이틀리nightly-전용-44"><a class="header" href="#나이틀리nightly-전용-44">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>원래의 기능 해결 동작을 지정할 수 있도록 <code>resolver="1"</code> 을 허용했습니다. <a href="https://github.com/rust-lang/cargo/pull/8857">#8857</a></li>
<li><code>cargo:rustc-link-arg-bins</code> 및 <code>cargo:rustc-link-arg</code> 빌드 스크립트 옵션을 추가하는 <code>-Z extra-link-arg</code> 를 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#extra-link-arg">docs</a> <a href="https://github.com/rust-lang/cargo/pull/8441">#8441</a></li>
<li>외부 자격 증명 프로세스 지원을 구현하고 <code>cargo logout</code> 을 추가했습니다. (<a href="https://github.com/rust-lang/rfcs/blob/master/text/2730-cargo-token-from-process.md">RFC 2730</a>) (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#credential-process">docs</a>) <a href="https://github.com/rust-lang/cargo/pull/8934">#8934</a></li>
<li>루트가 없을 때 <code>-Zbuild-std</code> 와 관련된 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8942">#8942</a></li>
<li>crates.io에 대해 docs.rs를 기본 extern-map으로 설정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8877">#8877</a></li>
</ul>
<h2 id="cargo-149-2020-12-31"><a class="header" href="#cargo-149-2020-12-31">Cargo 1.49 (2020-12-31)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/75615f8e...rust-1.49.0">75615f8e…rust-1.49.0</a></p>
<h3 id="추가됨-46"><a class="header" href="#추가됨-46">추가됨</a></h3>
<ul>
<li><code>cargo metadata</code> 에 <code>homepage</code> 및 <code>documentation</code> 필드를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8744">#8744</a></li>
<li>패키지가 명령줄에서 선택된 “루트” 패키지 중 하나인 경우 <code>rustc</code> 를 실행할 때 설정되는 <code>CARGO_PRIMARY_PACKAGE</code> 환경 변수를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8758">#8758</a></li>
<li>명령줄에서 패키지 및 타겟 선택 플래그(예: <code>-p 'serde*'</code> 또는 <code>--test '*'</code>)에 대해 유닉스 스타일의 글로브(glob) 패턴 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8752">#8752</a></li>
</ul>
<h3 id="변경됨-46"><a class="header" href="#변경됨-46">변경됨</a></h3>
<ul>
<li>계산된 LTO 플래그가 이제 파일 이름 메타데이터 해시에 포함되어 LTO 설정의 변경 사항이 이전 빌드 산출물을 덮어쓰는 대신 독립적으로 캐시됩니다. 이는 일부 상황에서 <code>cargo build</code> 와 <code>cargo test</code> 사이를 전환할 때와 같은 재빌드를 방지합니다. <a href="https://github.com/rust-lang/cargo/pull/8755">#8755</a></li>
<li><code>cargo tree</code> 가 이제 proc-macro 패키지 옆에 <code>(proc-macro)</code> 를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/8765">#8765</a></li>
<li>향후 구문 변경에 대비하여 기능(feature) 이름에 허용되는 문자가 문자, 숫자, <code>_</code>, <code>-</code>, <code>+</code> 로 제한되었다는 경고를 추가했습니다. 이는 여전히 ASCII를 요구하는 crates.io에서 허용되는 구문의 슈퍼셋입니다. 이는 향후 오류로 변경될 예정입니다. <a href="https://github.com/rust-lang/cargo/pull/8814">#8814</a></li>
<li>값 없이 <code>-p</code> 를 사용하면 이제 워크스페이스 패키지 이름 목록이 출력됩니다. <a href="https://github.com/rust-lang/cargo/pull/8808">#8808</a></li>
<li>허용되는 기능(feature) 이름 문자에 마침표(.)를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8932">#8932</a> <a href="https://github.com/rust-lang/cargo/pull/8943">#8943</a></li>
</ul>
<h3 id="수정됨-49"><a class="header" href="#수정됨-49">수정됨</a></h3>
<ul>
<li>LTO가 활성화된 상태에서 “dylib” 및 “rlib” 크레이트 타입을 모두 가진 라이브러리를 빌드하는 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8754">#8754</a></li>
<li>Cargo의 dep-info 파일의 경로를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8819">#8819</a></li>
<li><code>branch="master"</code> 를 명시적으로 지정한 Git 의존성에 대해 <code>cargo metadata</code> 에서 소스 ID가 일관되지 않던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8824">#8824</a></li>
<li><code>.cargo-ok</code> 파일을 포함한 의존성을 다시 추출할 때의 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8835">#8835</a></li>
</ul>
<h3 id="나이틀리nightly-전용-45"><a class="header" href="#나이틀리nightly-전용-45">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>일부 상황에서 <code>cargo doc -Zfeatures=itarget</code> 사용 시 발생하던 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8777">#8777</a></li>
<li><code>dep:serde</code> 구문을 사용하는 네임스페이스가 지정된 기능(namespaced features)의 새로운 구현이 추가되었습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#namespaced-features">docs</a> <a href="https://github.com/rust-lang/cargo/pull/8799">#8799</a></li>
<li>의존성을 활성화하지 않고도 의존성의 기능을 활성화할 수 있는 <code>dep_name?/feat_name</code> 구문을 사용하는 “약한(weak)” 의존성 기능 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8818">#8818</a></li>
<li>새로운 기능 리졸버가 엄격하게 필요하지 않은 추가 의존성을 다운로드하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8823">#8823</a></li>
</ul>
<h2 id="cargo-148-2020-11-19"><a class="header" href="#cargo-148-2020-11-19">Cargo 1.48 (2020-11-19)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/51b66125...rust-1.48.0">51b66125…rust-1.48.0</a></p>
<h3 id="추가됨-47"><a class="header" href="#추가됨-47">추가됨</a></h3>
<ul>
<li>진행률 표시줄이 표시되는 시기와 방법을 제어하기 위해 <code>term.progress</code> 설정 옵션을 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/config.html#termprogresswhen">docs</a> <a href="https://github.com/rust-lang/cargo/pull/8165">#8165</a></li>
<li>스크립트에서 더 쉽게 사용할 수 있도록 JSON 없이 프로젝트 위치를 표시하는 <code>--message-format plain</code> 옵션을 <code>cargo locate-project</code> 에 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8707">#8707</a></li>
<li>워크스페이스 매니페스트의 경로를 표시하기 위해 <code>cargo locate-project</code> 에 <code>--workspace</code> 옵션을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8712">#8712</a></li>
<li>Cargo 자체에 기여하기 위한 새로운 기여자 가이드가 추가되었습니다. 이는 <a href="https://rust-lang.github.io/cargo/contrib/">https://rust-lang.github.io/cargo/contrib/</a>에 게시되어 있습니다. <a href="https://github.com/rust-lang/cargo/pull/8715">#8715</a></li>
<li>Zsh의 <code>--target</code> 자동 완성이 이제 내장된 rustc 타겟으로 자동 완성됩니다. <a href="https://github.com/rust-lang/cargo/pull/8740">#8740</a></li>
</ul>
<h3 id="변경됨-47"><a class="header" href="#변경됨-47">변경됨</a></h3>
<h3 id="수정됨-50"><a class="header" href="#수정됨-50">수정됨</a></h3>
<ul>
<li>fossil 저장소를 생성할 때 <code>target</code> 디렉토리를 올바르게 무시하도록 <code>cargo new</code> 를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8671">#8671</a></li>
<li>원격 패키지의 <code>cargo install</code> 을 사용할 때 현재 디렉토리의 워크스페이스에 대한 경고를 표시하지 않도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/8681">#8681</a></li>
<li>git 저장소에서 “Object not found” 오류가 발생할 때 자동으로 인덱스를 재초기화합니다. <a href="https://github.com/rust-lang/cargo/pull/8735">#8735</a></li>
<li>git 저장소 처리에 대한 여러 수정 사항이 포함된 libgit2를 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/8778">#8778</a> <a href="https://github.com/rust-lang/cargo/pull/8780">#8780</a></li>
</ul>
<h3 id="나이틀리nightly-전용-46"><a class="header" href="#나이틀리nightly-전용-46">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>로컬 설정 파일의 <code>[unstable]</code> 테이블을 무시하도록 <code>cargo install</code> 을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8656">#8656</a></li>
<li>새로운 기능 리졸버의 비결정적인 동작을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8701">#8701</a></li>
<li>특정한 상황의 조합에서 새로운 기능 리졸버를 사용하여 proc-macro에 대해 <code>cargo test</code> 를 실행할 때 발생하는 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8742">#8742</a></li>
</ul>
<h2 id="cargo-147-2020-10-08"><a class="header" href="#cargo-147-2020-10-08">Cargo 1.47 (2020-10-08)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/4f74d9b2...rust-1.47.0">4f74d9b2…rust-1.47.0</a></p>
<h3 id="추가됨-48"><a class="header" href="#추가됨-48">추가됨</a></h3>
<ul>
<li><code>cargo doc</code> 이 이제 왼쪽 사이드바에 패키지 버전을 포함합니다. <a href="https://github.com/rust-lang/cargo/pull/8509">#8509</a></li>
<li><code>cargo metadata</code> 타겟에 <code>test</code> 필드를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8478">#8478</a></li>
<li>Cargo의 매뉴얼 페이지가 이제 <code>cargo help</code> 명령(예: <code>cargo help build</code>)을 통해 표시됩니다. <a href="https://github.com/rust-lang/cargo/pull/8456">#8456</a> <a href="https://github.com/rust-lang/cargo/pull/8577">#8577</a></li>
<li>프로젝트 버전을 지정하고 의존성을 다루는 방법에 대한 제안과 함께 <a href="https://doc.rust-lang.org/nightly/cargo/reference/resolver.html">의존성 해결 방식</a> 및 <a href="https://doc.rust-lang.org/nightly/cargo/reference/semver.html">SemVer 호환성</a> 에 대한 새로운 문서 장을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8609">#8609</a></li>
</ul>
<h3 id="변경됨-48"><a class="header" href="#변경됨-48">변경됨</a></h3>
<ul>
<li><code>.gitignore</code> 가 수정될 때 추가되는 주석에 공백을 추가하여 약간 조정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8476">#8476</a></li>
<li><code>cargo metadata</code> 출력이 이제 결정론적으로 정렬됩니다. <a href="https://github.com/rust-lang/cargo/pull/8489">#8489</a></li>
<li>기본적으로 빌드 스크립트와 proc-macro는 이제 릴리스 모드에서도 <code>opt-level=0</code> 과 기본 codegen unit으로 빌드됩니다. <a href="https://github.com/rust-lang/cargo/pull/8500">#8500</a></li>
<li><code>workspace.default-members</code> 가 이제 <code>workspace.exclude</code> 에 의해 필터링됩니다. <a href="https://github.com/rust-lang/cargo/pull/8485">#8485</a></li>
<li><code>workspace.members</code> 글로브가 이제 디렉토리가 아닌 경로는 무시합니다. <a href="https://github.com/rust-lang/cargo/pull/8511">#8511</a></li>
<li>git zlib 오류 발생 시 이제 재시도를 수행합니다. <a href="https://github.com/rust-lang/cargo/pull/8520">#8520</a></li>
<li>“http” 클래스 git 오류 발생 시 이제 재시도를 수행합니다. <a href="https://github.com/rust-lang/cargo/pull/8553">#8553</a></li>
<li>Git 의존성이 이제 <code>core.autocrlf</code> Git 설정 값을 재정의하여 플랫폼 간에 일관되게 동작하도록 보장합니다. 특히 윈도우에서 Git 의존성을 벤더링할 때 유용합니다. <a href="https://github.com/rust-lang/cargo/pull/8523">#8523</a></li>
<li><code>Cargo.lock</code> 을 업데이트해야 하는 경우 자동으로 새로운 V2 형식으로 전환됩니다. 이 형식은 <code>[metadata]</code> 테이블을 제거하며, 소스 제어 시스템에서 변경 사항을 병합하기 더 쉬워야 합니다. 이 형식은 1.38에서 도입되었으며 1.41에서 새 프로젝트의 기본값이 되었습니다. <a href="https://github.com/rust-lang/cargo/pull/8554">#8554</a></li>
<li>기본 브랜치가 “master“가 아닌 Git 저장소 지원을 위한 준비를 추가했습니다. 실제 지원은 향후 버전에 추가될 예정입니다. 이에 따라 몇 가지 경고가 도입됩니다:
<ul>
<li>Git 의존성이 브랜치를 지정하지 않고 저장소의 기본 브랜치가 “master“가 아닌 경우 경고합니다. 향후 Cargo는 기본 브랜치를 가져올 것입니다. 이 시나리오에서는 브랜치를 명시적으로 지정해야 합니다.</li>
<li>워크스페이스에 동일한 Git 저장소에 대한 여러 의존성이 있고, 하나는 <code>branch</code> 가 없고 다른 하나는 <code>branch="master"</code> 인 경우 경고합니다. 의존성은 모두 한 가지 형식을 사용해야 합니다. <a href="https://github.com/rust-lang/cargo/pull/8522">#8522</a></li>
</ul>
</li>
<li><code>required-features</code> 항목에 존재하지 않는 기능이 나열된 경우 이제 경고가 발생합니다. <a href="https://github.com/rust-lang/cargo/pull/7950">#7950</a></li>
<li>내장 별칭이 이제 <code>cargo --list</code> 에 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/8542">#8542</a></li>
<li>삭제(yank)된 특정 버전을 <code>cargo install</code> 하려고 하면 이제 “찾을 수 없음” 대신 삭제되었다는 오류 메시지가 표시됩니다. <a href="https://github.com/rust-lang/cargo/pull/8565">#8565</a></li>
<li><code>publish</code> 필드가 단일 레지스트리로 설정된 패키지에 대해 <code>--registry</code> 플래그 없이 <code>cargo publish</code> 를 실행하면 이제 오류를 발생시키는 대신 해당 레지스트리에 게시합니다. <a href="https://github.com/rust-lang/cargo/pull/8571">#8571</a></li>
</ul>
<h3 id="수정됨-51"><a class="header" href="#수정됨-51">수정됨</a></h3>
<ul>
<li>프로젝트 디렉토리가 이동되고 빌드 스크립트 중 하나가 <code>rerun-if-changed</code> 지시문을 사용하지 않은 경우, 해당 빌드 스크립트가 재빌드되지 않아야 함에도 불구하고 재빌드되던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8497">#8497</a></li>
<li>콘솔 색상이 이제 윈도우 7 및 8에서 작동합니다. <a href="https://github.com/rust-lang/cargo/pull/8540">#8540</a></li>
<li><code>CARGO_TARGET_{triplet}_RUNNER</code> 환경 변수가 이제 명령을 병합하려 하는 대신 설정 파일을 올바르게 재정의합니다. <a href="https://github.com/rust-lang/cargo/pull/8629">#8629</a></li>
<li>문서 테스트에서의 LTO 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8657">#8657</a> <a href="https://github.com/rust-lang/cargo/pull/8658">#8658</a></li>
</ul>
<h3 id="나이틀리nightly-전용-47"><a class="header" href="#나이틀리nightly-전용-47">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><code>rustc</code> 에 터미널 너비를 알려주어 진단 메시지 형식을 더 잘 맞출 수 있게 하는 <code>-Z terminal-width</code> 지원을 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#terminal-width">docs</a> <a href="https://github.com/rust-lang/cargo/pull/8427">#8427</a></li>
<li><code>[unstable]</code> 테이블을 통해 설정 파일에서 <code>-Z</code> 불안정한 플래그를 구성할 수 있는 기능을 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html">docs</a> <a href="https://github.com/rust-lang/cargo/pull/8393">#8393</a></li>
<li>표준 라이브러리에 대한 기능을 설정하기 위해 <code>-Z build-std-features</code> 플래그를 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std-features">docs</a> <a href="https://github.com/rust-lang/cargo/pull/8490">#8490</a></li>
</ul>
<h2 id="cargo-146-2020-08-27"><a class="header" href="#cargo-146-2020-08-27">Cargo 1.46 (2020-08-27)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/9fcb8c1d...rust-1.46.0">9fcb8c1d…rust-1.46.0</a></p>
<h3 id="추가됨-49"><a class="header" href="#추가됨-49">추가됨</a></h3>
<ul>
<li>레지스트리 인덱스의 <code>config.json</code> 에 있는 <code>dl</code> 키가 이제 <code>{prefix}</code> 및 <code>{lowerprefix}</code> 교체 마커를 지원하여, 인덱스 자체의 구조와 유사하게 디렉토리에 크레이트를 분산시킬 수 있습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/registries.html#index-format">docs</a> <a href="https://github.com/rust-lang/cargo/pull/8267">#8267</a></li>
<li>컴파일 중에 설정되는 새로운 환경 변수를 추가했습니다:
<ul>
<li><code>CARGO_CRATE_NAME</code>: 빌드 중인 크레이트의 이름입니다.</li>
<li><code>CARGO_BIN_NAME</code>: 실행 바이너리의 이름입니다(바이너리 크레이트인 경우).</li>
<li><code>CARGO_PKG_LICENSE</code>: 매니페스트의 <code>license</code> 필드 값입니다.</li>
<li><code>CARGO_PKG_LICENSE_FILE</code>: 매니페스트의 <code>license-file</code> 필드 값입니다. <a href="https://github.com/rust-lang/cargo/pull/8270">#8270</a> <a href="https://github.com/rust-lang/cargo/pull/8325">#8325</a> <a href="https://github.com/rust-lang/cargo/pull/8387">#8387</a></li>
</ul>
</li>
<li><code>Cargo.toml</code> 에 <code>readme</code> 값이 지정되지 않은 경우, 이제 <code>README</code>, <code>README.md</code> 또는 <code>README.txt</code> 라는 파일이 있는지 확인하여 자동으로 유추합니다. <code>readme = false</code> 로 설정하여 이 기능을 끌 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/8277">#8277</a></li>
<li><code>cargo install</code> 이 이제 인덱스에서 직접 설치하기 위해 <code>--index</code> 플래그를 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/8344">#8344</a></li>
<li><code>Cargo.toml</code> 의 <code>workspace</code> 정의에 <code>metadata</code> 테이블을 추가했습니다. 이는 <code>package.metadata</code> 테이블과 유사하게 임의의 데이터에 사용될 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/8323">#8323</a></li>
<li>타겟 디렉토리를 설정하기 위해 <code>cargo install</code> 에 <code>--target-dir</code> 플래그를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8391">#8391</a></li>
<li><a href="https://doc.rust-lang.org/std/macro.env.html"><code>env!</code></a> 또는 <a href="https://doc.rust-lang.org/std/macro.option_env.html"><code>option_env!</code></a> 매크로에서 사용하는 환경 변수의 변경 사항을 이제 자동으로 감지하여 재빌드를 트리거합니다. <a href="https://github.com/rust-lang/cargo/pull/8421">#8421</a></li>
<li><code>target</code> 디렉토리에 이제 일부 도구에서 백업 대상에서 디렉토리를 제외하는 데 사용되는 <code>CACHEDIR.TAG</code> 파일이 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/8378">#8378</a></li>
<li>rustup의 <code>+toolchain</code> 구문에 대한 문서를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8455">#8455</a></li>
</ul>
<h3 id="변경됨-49"><a class="header" href="#변경됨-49">변경됨</a></h3>
<ul>
<li>Git 의존성의 URL에 <code>#</code> 프래그먼트가 포함된 경우 이제 경고가 표시됩니다. 이는 Cargo 자체가 이 구문을 사용하여 Git URL을 표시하기 때문에 혼란을 줄 수 있지만, <code>Cargo.lock</code> 파일 외부에서는 아무런 의미가 없으며 제대로 작동하지 않기 때문입니다. <a href="https://github.com/rust-lang/cargo/pull/8297">#8297</a></li>
<li>비트코드 임베딩 및 LTO에 대한 다양한 최적화 및 수정을 수행했습니다. <a href="https://github.com/rust-lang/cargo/pull/8349">#8349</a></li>
<li>Git 의존성을 위해 가져오는 데이터의 양을 줄였습니다. Cargo가 가져올 브랜치나 태그를 알고 있는 경우, 이제 모든 브랜치와 태그 대신 해당 브랜치나 태그만 가져옵니다. <a href="https://github.com/rust-lang/cargo/pull/8363">#8363</a></li>
<li>Git fetch 오류 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/8409">#8409</a></li>
<li><code>.crate</code> 파일이 이제 더 긴 파일 이름을 지원하는 UStar 대신 GNU tar 형식으로 생성됩니다. <a href="https://github.com/rust-lang/cargo/pull/8453">#8453</a></li>
</ul>
<h3 id="수정됨-52"><a class="header" href="#수정됨-52">수정됨</a></h3>
<ul>
<li><code>Cargo.lock</code> 업데이트가 한 번 실패한 후 후속 실행에서 진행되던 드문 상황을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8274">#8274</a></li>
<li>윈도우 dylib가 반드시 <code>.dll</code> 확장자를 가져야 한다는 어설션을 제거했습니다. 일부 사용자 정의 JSON 명세 타겟은 확장자를 변경할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/8310">#8310</a></li>
<li>libgit2를 업데이트하여 googlesource.com과 같은 일부 원격 Git 서버의 zlib 오류에 대한 수정을 포함했습니다. <a href="https://github.com/rust-lang/cargo/pull/8320">#8320</a></li>
<li>마스터가 아닌 브랜치에서 최신 Git 의존성에 대한 GitHub fast-path 확인을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8363">#8363</a></li>
<li><code>pkg/feature</code> 구문으로 기능을 활성화할 때, <code>pkg</code> 가 선택적 의존성이면서 동시에 개발 의존성이고, 레지스트리 요약에서 개발 의존성이 선택적 일반 의존성보다 먼저 나타나는 경우 선택적 의존성이 활성화되지 않던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8395">#8395</a></li>
<li><code>build</code> 라는 이름의 테스트가 있을 때 <code>clean -p</code> 가 빌드 디렉토리를 삭제하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8398">#8398</a></li>
<li>멀티라인 Cargo 오류 메시지의 들여쓰기를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8409">#8409</a></li>
<li>rustdoc에 대해 <code>--document-private-items</code> 플래그가 자동으로 포함되어 <code>cargo rustdoc</code> 명령어에 전달된 다른 플래그를 덮어쓰던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8449">#8449</a></li>
<li>지문(fingerprint) 구조의 하위 호환되지 않는 변경을 지원하기 위해, 이제 Cargo가 지문 디렉토리의 해시에 버전을 포함합니다. <a href="https://github.com/rust-lang/cargo/pull/8473">#8473</a> <a href="https://github.com/rust-lang/cargo/pull/8488">#8488</a></li>
</ul>
<h3 id="나이틀리nightly-전용-48"><a class="header" href="#나이틀리nightly-전용-48">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>rustdoc에 대한 외부 매핑(예: https://docs.rs/ 링크)을 제공하는 <code>-Zrustdoc-map</code> 기능을 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#rustdoc-map">docs</a> <a href="https://github.com/rust-lang/cargo/pull/8287">#8287</a></li>
<li>proc-macro가 <code>Cargo.toml</code> 에서 밑줄(<code>proc_macro = true</code>)과 함께 선언되었을 때의 기능 계산 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8319">#8319</a></li>
<li>-Zdoctest-xcompile과 함께 <code>-Clinker</code> 를 설정하는 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8359">#8359</a></li>
<li>설정 파일에서 <code>strip</code> 프로파일 필드를 설정하는 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8454">#8454</a></li>
</ul>
<h2 id="cargo-145-2020-07-16"><a class="header" href="#cargo-145-2020-07-16">Cargo 1.45 (2020-07-16)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/ebda5065...rust-1.45.0">ebda5065e…rust-1.45.0</a></p>
<h3 id="추가됨-50"><a class="header" href="#추가됨-50">추가됨</a></h3>
<h3 id="변경됨-50"><a class="header" href="#변경됨-50">변경됨</a></h3>
<ul>
<li>
<p>공식 문서에서 <code>.cargo/config.toml</code> 파일 이름(<code>.toml</code> 확장자 포함)을 권장하도록 변경했습니다. <code>.toml</code> 확장자 지원은 1.39에서 추가되었습니다. <a href="https://github.com/rust-lang/cargo/pull/8121">#8121</a></p>
</li>
<li>
<p><code>registry.index</code> 설정 값은 이제 허용되지 않습니다(4년 동안 사용이 중단된 상태였습니다). <a href="https://github.com/rust-lang/cargo/pull/7973">#7973</a></p>
</li>
<li>
<p><code>--index</code> 와 <code>--registry</code> 가 모두 전달되면 이제 오류가 발생합니다(이전에는 <code>--index</code> 가 무시되었습니다). <a href="https://github.com/rust-lang/cargo/pull/7973">#7973</a></p>
</li>
<li>
<p><code>registry.token</code> 설정 값은 이제 <code>--index</code> 플래그와 함께 사용되지 않습니다. 이는 crates.io 토큰이 다른 레지스트리로 유출될 가능성을 방지하기 위한 것입니다. <a href="https://github.com/rust-lang/cargo/pull/7973">#7973</a></p>
</li>
<li>
<p>소스 교체와 함께 <code>registry.token</code> 이 사용될 경우 경고를 추가했습니다. 향후 버전에서는 오류로 처리될 예정입니다. <a href="https://github.com/rust-lang/cargo/pull/7973">#7973</a></p>
</li>
<li>
<p>Windows GNU 타겟은 이제 DLL 크레이트 타입에 대해 <code>.dll.a</code> 임포트 라이브러리 파일을 출력 디렉토리에 복사합니다. <a href="https://github.com/rust-lang/cargo/pull/8141">#8141</a></p>
</li>
<li>
<p>모든 의존성에 대한 dylib가 이제 무조건적으로 출력 디렉토리에 복사됩니다. 일부 드문 시나리오에서 빌드 사이에 이전 dylib가 참조될 수 있는데, 이 변경으로 모든 최신 복사본이 사용되도록 보장합니다. <a href="https://github.com/rust-lang/cargo/pull/8139">#8139</a></p>
</li>
<li>
<p><code>package.exclude</code> 가 이제 디렉토리 이름과 일치할 수 있습니다. 디렉토리가 지정되면 전체 디렉토리가 제외되며 Cargo는 더 이상 검사하지 않습니다. 이전에는 Cargo가 디렉토리의 모든 파일을 확인하려고 시도하여 디렉토리에 읽을 수 없는 파일이 포함된 경우 문제를 일으킬 수 있었습니다. <a href="https://github.com/rust-lang/cargo/pull/8095">#8095</a></p>
</li>
<li>
<p><code>cargo publish</code> 또는 <code>cargo package</code> 로 패키징할 때, Cargo는 어떤 파일을 포함할지 결정하기 위해 Git을 사용할 수 있습니다. 이전에는 이 Git 기반 로직이 저장소 루트에 <code>Cargo.toml</code> 파일이 있어야만 작동했습니다. 이제는 더 이상 필수 사항이 아니므로, 저장소 루트에 <code>Cargo.toml</code> 이 없더라도 Cargo는 Git 기반 안내를 사용합니다. <a href="https://github.com/rust-lang/cargo/pull/8095">#8095</a></p>
</li>
<li>
<p>윈도우에서 크레이트 압축을 풀 때, 예약된 윈도우 파일 이름(예: “aux.rs”) 때문에 파일 쓰기에 실패하면 Cargo는 실패 이유를 설명하는 추가 메시지를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/8136">#8136</a></p>
</li>
<li>
<p>파일의 mtime 설정 실패를 이제 무시합니다. 일부 파일 시스템은 이를 지원하지 않았습니다. <a href="https://github.com/rust-lang/cargo/pull/8185">#8185</a></p>
</li>
<li>
<p>특정 유형의 Git 오류가 발생할 때 이제 <code>net.git-fetch-with-cli</code> 활성화를 권장합니다. <a href="https://github.com/rust-lang/cargo/pull/8166">#8166</a></p>
</li>
<li>
<p>LTO 빌드를 수행할 때, Cargo는 가능하면 rustc가 코드 생성을 수행하지 않도록 지시합니다. 이는 빌드 속도를 높이고 디스크 공간을 덜 사용하는 결과로 이어질 수 있습니다. 또한 LTO가 아닌 빌드의 경우, Cargo는 라이브러리에 LLVM 비트코드를 임베딩하지 않도록 rustc에 지시하여 라이브러리 크기를 줄입니다. <a href="https://github.com/rust-lang/cargo/pull/8192">#8192</a> <a href="https://github.com/rust-lang/cargo/pull/8226">#8226</a> <a href="https://github.com/rust-lang/cargo/pull/8254">#8254</a></p>
</li>
<li>
<p>특정 패키지의 파일을 더 정확하게 제거할 수 있도록 <code>cargo clean -p</code> 구현을 다시 작성했습니다. <a href="https://github.com/rust-lang/cargo/pull/8210">#8210</a></p>
</li>
<li>
<p>Cargo가 빌드 출력물을 계산하는 방식이 더 완벽하고 정확하게 다시 작성되었습니다. 새로 추적되는 파일은 JSON 메시지에 표시되며, 일부 경우에는 출력 디렉토리로 이동(uplift)될 수 있습니다. 이에 따른 주요 변경 사항은 다음과 같습니다:</p>
<ul>
<li>
<p>Windows MSVC 동적 라이브러리의 <code>.exp</code> 내보내기 파일이 이제 추적됩니다.</p>
</li>
<li>
<p>Windows의 Proc-macro가 임포트/내보내기 파일을 추적합니다.</p>
</li>
<li>
<p>별도의 디버그 파일(pdb/dSYM)을 생성하는 모든 타겟(테스트 등)이 추적됩니다.</p>
</li>
<li>
<p>wasm32-unknown-emscripten을 위한 .map 파일을 추가했습니다.</p>
</li>
<li>
<p>모든 동적 라이브러리(dylib/cdylib/proc-macro) 및 빌드 스크립트에 대해 macOS dSYM 디렉토리가 추적됩니다.
이로 인해 다음과 같은 다양한 다른 변경 사항이 있습니다:</p>
</li>
<li>
<p>하이픈이 포함된 Windows MSVC 바이너리 예제는 이제 예제 디렉토리에 두 번 표시됩니다(<code>foo_bar.exe</code> 및 <code>foo-bar.exe</code>). 이전에는 Cargo가 파일을 하드 링크하는 대신 이름을 변경하기만 했습니다.</p>
</li>
<li>
<p>예제 라이브러리가 이제 일반 라이브러리와 동일하게 하이픈/밑줄 변환 규칙을 따릅니다(이제 밑줄을 사용함).
<a href="https://github.com/rust-lang/cargo/pull/8210">#8210</a></p>
</li>
</ul>
</li>
<li>
<p>Cargo는 HTTP 디버깅을 위한 디버그 로그에서 비밀 정보를 제거하려고 시도합니다. <a href="https://github.com/rust-lang/cargo/pull/8222">#8222</a></p>
</li>
<li>
<p>Cargo의 많은 파일 시스템 작업에 컨텍스트가 추가되어, 오류 메시지가 이제 문제를 일으킨 경로와 같은 더 많은 정보를 제공합니다. <a href="https://github.com/rust-lang/cargo/pull/8232">#8232</a></p>
</li>
<li>
<p>몇몇 명령어들은 이제 실행 중에 표준 출력(stdout)이나 표준 에러(stderr)가 닫히더라도 오류를 무시합니다. 예를 들어 <code>cargo install --list | grep -q cargo-fuzz</code> 는 이전에는 <code>grep -q</code> 가 명령어가 끝나기 전에 표준 출력을 닫을 수 있어 가끔 패닉이 발생했습니다. 일반 빌드는 표준 출력이나 표준 에러가 닫히면 여전히 실패하며, 이는 다른 많은 빌드 시스템의 동작과 일치합니다. <a href="https://github.com/rust-lang/cargo/pull/8236">#8236</a></p>
</li>
<li>
<p><code>cargo install</code> 에 <code>--version=1.2.3</code> 과 같이 정확한 버전이 주어지면, 해당 버전이 이미 설치된 경우 인덱스 업데이트를 피하고 이미 설치되었음을 알리며 빠르게 종료합니다. <a href="https://github.com/rust-lang/cargo/pull/8022">#8022</a></p>
</li>
<li>
<p><code>[patch]</code> 섹션의 변경 사항이 이제 <code>Cargo.lock</code> 을 새 버전으로 자동으로 업데이트하려고 시도합니다. 또한 자동으로 업데이트할 수 없는 드문 경우에 대해 더 나은 오류 메시지를 제공합니다. <a href="https://github.com/rust-lang/cargo/pull/8248">#8248</a></p>
</li>
</ul>
<h3 id="수정됨-53"><a class="header" href="#수정됨-53">수정됨</a></h3>
<ul>
<li>파일 이름에 대시가 포함된 경우 Windows <code>.pdb</code> 파일을 출력 디렉토리에 복사하는 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8123">#8123</a></li>
<li>패키지의 상위 경로 중 하나가 심볼릭 링크인 경우, 패키지가 Git 저장소 내부에 있는지 스캔할 때 Cargo가 실패하던 오류를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8186">#8186</a></li>
<li>사용되지 않는 <code>[patch]</code> 가 있을 때 <code>cargo update</code> 가 멈추고 업데이트를 거부하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8243">#8243</a></li>
<li>표준 에러(stderr)가 닫혀 있고 컴파일러가 많은 수의 메시지를 생성할 때 Cargo가 멈추던 상황을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8247">#8247</a></li>
<li>macOS에서 백트레이스(backtraces)가 파일 이름이나 줄 번호를 표시하지 않던 문제를 수정했습니다. 이에 따라 Apple 타겟의 실행 바이너리는 Cargo 캐시의 파일 이름에 해시를 포함하지 않습니다. 이는 Cargo가 하나의 복사본만 추적할 수 있음을 의미하므로, 기능(feature)이나 rustc 버전을 변경하면 Cargo가 실행 파일을 다시 빌드해야 합니다. <a href="https://github.com/rust-lang/cargo/pull/8329">#8329</a> <a href="https://github.com/rust-lang/cargo/pull/8335">#8335</a></li>
<li>윈도우에서 dylib와 함께 lld를 사용할 때 핑거프린팅 문제를 수정했습니다. Cargo는 dylib가 최신 상태가 아니라고 잘못 판단하고 있었습니다. <a href="https://github.com/rust-lang/cargo/pull/8290">#8290</a> <a href="https://github.com/rust-lang/cargo/pull/8335">#8335</a></li>
</ul>
<h3 id="나이틀리nightly-전용-49"><a class="header" href="#나이틀리nightly-전용-49">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>JSON 명세 타겟을 사용할 때 <code>rustdoc</code> 에 <code>--target</code> 의 전체 경로를 전달하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8094">#8094</a></li>
<li><code>-Cembed-bitcode=no</code> 가 <code>-Cbitcode-in-rlib=no</code> 로 이름이 변경되었습니다. <a href="https://github.com/rust-lang/cargo/pull/8134">#8134</a></li>
<li>새로운 기능 리졸버를 선택하여 사용할 수 있도록 <code>Cargo.toml</code> 에 새로운 <code>resolver</code> 필드를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8129">#8129</a></li>
<li><code>-Zbuild-std</code> 가 더 이상 표준 라이브러리 의존성을 “local“로 취급하지 않습니다. 이는 해당 의존성에 대해 점진적 컴파일을 사용하지 않고, dep-info 파일에서 제거하며, 린트 수준을 “allow“로 제한함을 의미합니다. <a href="https://github.com/rust-lang/cargo/pull/8177">#8177</a></li>
<li>여러 개의 <code>--target</code> 플래그를 사용하여 여러 타겟에 대해 동시에 빌드할 수 있는 <code>-Zmultitarget</code> 을 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#multitarget">docs</a> <a href="https://github.com/rust-lang/cargo/pull/8167">#8167</a></li>
<li>심볼과 디버그 정보를 제거하기 위해 프로파일에 <code>strip</code> 옵션을 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#profile-strip-option">docs</a> <a href="https://github.com/rust-lang/cargo/pull/8246">#8246</a></li>
<li><code>cargo tree --target=all -Zfeatures=all</code> 사용 시 발생하던 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8269">#8269</a></li>
</ul>
<h2 id="cargo-144-2020-06-04"><a class="header" href="#cargo-144-2020-06-04">Cargo 1.44 (2020-06-04)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/bda50510...rust-1.44.0">bda50510…rust-1.44.0</a></p>
<h3 id="추가됨-51"><a class="header" href="#추가됨-51">추가됨</a></h3>
<ul>
<li>🔥 <code>cargo tree</code> 명령어를 추가했습니다. <a href="https://doc.rust-lang.org/nightly/cargo/commands/cargo-tree.html">docs</a> <a href="https://github.com/rust-lang/cargo/pull/8062">#8062</a></li>
<li>패키지에 윈도우에서 제한된 파일 이름(<code>nul</code>, <code>con</code>, <code>aux</code>, <code>prn</code> 등)이 포함된 경우 경고를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/7959">#7959</a></li>
<li>컴파일이 완료되었을 때 <code>"build-finished"</code> JSON 메시지를 추가하여, 도구들이 <code>cargo run</code> 이나 <code>cargo test</code> 와 같은 명령에서 JSON 메시지 수신을 언제 중단할지 감지할 수 있도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/8069">#8069</a></li>
</ul>
<h3 id="변경됨-51"><a class="header" href="#변경됨-51">변경됨</a></h3>
<ul>
<li>유효한 패키지 이름이 이제 유니코드 XID 식별자로 제한됩니다. 이는 이전과 거의 동일하지만, 패키지 이름이 숫자나 <code>-</code> 로 시작할 수 없다는 점이 다릅니다. <a href="https://github.com/rust-lang/cargo/pull/7959">#7959</a></li>
<li><code>cargo new</code> 및 <code>init</code> 은 이제 추가적인 패키지 이름(예약된 윈도우 이름, 예약된 Cargo 디렉토리, 비 ASCII 이름, <code>core</code> 와 같이 표준 라이브러리와 충돌하는 이름 등)에 대해 경고하거나 거부합니다. <a href="https://github.com/rust-lang/cargo/pull/7959">#7959</a></li>
<li>테스트가 더 이상 출력 디렉토리(<code>target/debug/</code>)에 하드 링크되지 않습니다. 이는 도구들이 디버그 심볼에 접근하고 Cargo와 동일한 방식으로 테스트를 실행할 수 있도록 보장합니다. 도구들은 실행 파일의 경로를 찾기 위해 JSON 메시지를 사용해야 합니다. <a href="https://github.com/rust-lang/cargo/pull/7965">#7965</a></li>
<li>Git 서브모듈을 업데이트할 때 이제 각 서브모듈에 대해 “Updating” 메시지를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/7989">#7989</a></li>
<li><code>.crate</code> 파일을 추출할 때 파일 수정 시간(mtime)이 이제 보존됩니다. 이는 mtime이 보존되지 않았던 1.40의 변경 사항을 되돌린 것입니다. <a href="https://github.com/rust-lang/cargo/pull/7935">#7935</a></li>
<li>빌드 스크립트가 실패할 때 빌드 스크립트 경고가 이제 별도로 표시됩니다. <a href="https://github.com/rust-lang/cargo/pull/8017">#8017</a></li>
<li><code>git-checkout</code> 서브 명령어를 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/8040">#8040</a></li>
<li>진행률 표시줄이 이제 모든 유닉스 플랫폼에서 활성화됩니다. 이전에는 리눅스, macOS, FreeBSD에서만 활성화되었습니다. <a href="https://github.com/rust-lang/cargo/pull/8054">#8054</a></li>
<li><code>rustc</code> 프리릴리스 버전에서 생성된 산출물들이 이제 동일한 파일 이름을 공유합니다. 이는 나이틀리 버전을 변경해도 빌드 디렉토리에 오래된 파일이 남지 않음을 의미합니다. <a href="https://github.com/rust-lang/cargo/pull/8073">#8073</a></li>
<li>이름이 변경된 의존성을 사용할 때 유효하지 않은 패키지 이름은 거부됩니다. <a href="https://github.com/rust-lang/cargo/pull/8090">#8090</a></li>
<li>특정 클래스의 HTTP2 오류를 “일시적인(spurious)” 오류로 추가하여 재시도되도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/8102">#8102</a></li>
<li>다른 검증 오류(<code>Cargo.lock</code> 생성 문제 또는 누락된 의존성 등)가 있더라도 <code>cargo package --list</code> 가 성공할 수 있도록 허용합니다. <a href="https://github.com/rust-lang/cargo/pull/8175">#8175</a> <a href="https://github.com/rust-lang/cargo/pull/8215">#8215</a></li>
</ul>
<h3 id="수정됨-54"><a class="header" href="#수정됨-54">수정됨</a></h3>
<ul>
<li>Cargo가 이제 메모리에 과도한 양의 컴파일러 출력을 버퍼링하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/7838">#7838</a></li>
<li>Git 저장소의 심볼릭 링크가 이제 윈도우에서 작동합니다. <a href="https://github.com/rust-lang/cargo/pull/7996">#7996</a></li>
<li><code>Cargo.toml</code> 에 <code>dev</code> 프로파일이 정의되지 않았을 때, <code>cargo test</code> 실행 시 설정 파일에서 <code>profile.dev</code> 가 로드되지 않던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8012">#8012</a></li>
<li>바이너리가 통합 테스트의 암시적 의존성으로 빌드될 때, 이제 <code>required-features</code> 에서 <code>dep_name/feature_name</code> 구문을 올바르게 확인합니다. <a href="https://github.com/rust-lang/cargo/pull/8020">#8020</a></li>
<li>이전 빌드가 Ctrl-C로 중단되었을 때, Cargo가 실행 파일(예: 통합 테스트)을 재빌드해야 함을 감지하지 못하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8087">#8087</a></li>
<li>시스템 단조 시계(monotonic clock)가 단조적이지 않은 것처럼 보이는 일부 (알 수 없는) 상황에서 Cargo가 패닉을 일으키지 않도록 보호 조치를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8114">#8114</a></li>
<li>패키지에 빌드 스크립트가 있을 때 <code>cargo clean -p</code> 실행 시 발생하던 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8216">#8216</a></li>
</ul>
<h3 id="나이틀리nightly-전용-50"><a class="header" href="#나이틀리nightly-전용-50">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>새로운 기능 리졸버 및 <code>required-features</code> 와 관련된 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7962">#7962</a></li>
<li>워크스페이스 구성원에 대해서만 <code>rustc</code> 를 래핑하는 방법을 제공하는 <code>RUSTC_WORKSPACE_WRAPPER</code> 환경 변수를 추가했습니다. 이는 파일 이름 해시에 영향을 주어 래퍼에 의해 생성된 산출물이 별도로 캐시되도록 합니다. 이 사용 사례는 나이틀리 클리피(clippy)에서 <code>cargo clippy -Zunstable-options</code> 를 통해 확인할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/7533">#7533</a></li>
<li>Cargo의 내부 의존성 그래프를 JSON으로 표시하기 위해 <code>--unit-graph</code> CLI 옵션을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/7977">#7977</a></li>
<li><code>-Zbuild_dep</code> 을 <code>-Zhost_dep</code> 으로 변경하고, 기능 분리(feature decoupling) 로직에 proc-macro를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8003">#8003</a> <a href="https://github.com/rust-lang/cargo/pull/8028">#8028</a></li>
<li><code>RUSTDOCFLAGS</code> 에 해당 플래그가 있을 때 <code>--crate-version</code> 이 자동으로 전달되지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8014">#8014</a></li>
<li><code>-Zfeatures=dev_dep</code> 및 <code>check --profile=test</code> 사용 시 발생하던 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8027">#8027</a></li>
<li>특정 호스트 의존성과 함께 <code>-Zfeatures=itarget</code> 사용 시 발생하던 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/8048">#8048</a></li>
<li>LTO가 아닌 빌드에서 성능 향상과 디스크 공간 사용량 절감을 제공하는 <code>-Cembed-bitcode=no</code> 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/8066">#8066</a></li>
<li>워크스페이스의 명령줄에서 기능을 더 쉽게 선택할 수 있도록 여러 변경 사항과 함께 <code>-Zpackage-features</code> 가 확장되었습니다. <a href="https://github.com/rust-lang/cargo/pull/8074">#8074</a></li>
</ul>
<h2 id="cargo-143-2020-04-23"><a class="header" href="#cargo-143-2020-04-23">Cargo 1.43 (2020-04-23)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/9d32b7b0...rust-1.43.0">9d32b7b0…rust-1.43.0</a></p>
<h3 id="추가됨-52"><a class="header" href="#추가됨-52">추가됨</a></h3>
<ul>
<li>🔥 프로파일을 이제 설정 파일(및 환경 변수)에서 지정할 수 있습니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/config.html#profile">docs</a> <a href="https://github.com/rust-lang/cargo/pull/7823">#7823</a></li>
<li>❗ 통합 테스트를 빌드할 때 <code>CARGO_BIN_EXE_&lt;name&gt;</code> 환경 변수를 추가했습니다. 이 변수는 패키지의 모든 <code>[[bin]]</code> 타겟에 대한 경로를 포함합니다. 통합 테스트는 실행할 바이너리의 경로를 결정하기 위해 <code>env!</code> 매크로를 사용해야 합니다. <a href="https://doc.rust-lang.org/nightly/cargo/reference/environment-variables.html#environment-variables-cargo-sets-for-crates">docs</a> <a href="https://github.com/rust-lang/cargo/pull/7697">#7697</a></li>
</ul>
<h3 id="변경됨-52"><a class="header" href="#변경됨-52">변경됨</a></h3>
<ul>
<li><code>cargo install --git</code> 가 이제 Git 저장소의 워크스페이스를 존중합니다. 이를 통해 <code>[patch]</code>, <code>[replace]</code> 또는 <code>[profile]</code> 과 같은 워크스페이스 설정을 사용할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/7768">#7768</a></li>
<li><code>cargo new</code> 는 이제 새 파일이 사용자가 선호하는 들여쓰기 설정과 일치하도록 <code>tab_spaces</code> 와 같은 rustfmt 설정을 반영하기 위해 새 파일에 대해 <code>rustfmt</code> 를 실행합니다. <a href="https://github.com/rust-lang/cargo/pull/7827">#7827</a></li>
<li>“매우 상세한(very verbose)” 출력(<code>-vv</code>)으로 출력되는 환경 변수들이 이제 일관되게 정렬됩니다. <a href="https://github.com/rust-lang/cargo/pull/7877">#7877</a></li>
<li>핑거프린트 재빌드 감지를 위한 디버그 로깅에 이제 더 많은 정보가 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/7888">#7888</a> <a href="https://github.com/rust-lang/cargo/pull/7890">#7890</a> <a href="https://github.com/rust-lang/cargo/pull/7952">#7952</a></li>
<li>게시(publish) 중에 <code>license-file</code> 이 존재하지 않는 경우 경고를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/7905">#7905</a></li>
<li><code>license-file</code> 파일은 <code>include</code> 목록에 명시적으로 나열되지 않았거나 패키지 루트 외부의 위치에 있더라도 게시 중에 자동으로 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/7905">#7905</a></li>
<li>빌드 스크립트를 실행할 때 <code>CARGO_CFG_DEBUG_ASSERTIONS</code> 및 <code>CARGO_CFG_PROC_MACRO</code> 가 더 이상 설정되지 않습니다. 이들은 과거에 실수로 설정되었으나 항상 참이었기 때문에 아무런 의미가 없었습니다. 또한 <code>target</code> 표현식에서 <code>cfg(proc-macro)</code> 는 더 이상 지원되지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/7943">#7943</a> <a href="https://github.com/rust-lang/cargo/pull/7970">#7970</a></li>
</ul>
<h3 id="수정됨-55"><a class="header" href="#수정됨-55">수정됨</a></h3>
<ul>
<li>전역 명령줄 플래그가 이제 별칭과 함께 작동합니다(예: <code>cargo -v b</code>). <a href="https://github.com/rust-lang/cargo/pull/7837">#7837</a></li>
<li>의존성 구문을 사용하는 <code>required-features</code>(예: <code>renamed_dep/feat_name</code>)가 이제 이름이 변경된 의존성을 올바르게 처리합니다. <a href="https://github.com/rust-lang/cargo/pull/7855">#7855</a></li>
<li>동일한 빌드 중에 빌드 스크립트가 여러 번 실행될 경우, 첫 번째 실행의 출력을 잃지 않고 결과를 별도로 유지하도록 하는 드문 상황을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7857">#7857</a></li>
<li><code>CARGO_TARGET_*_RUNNER=true</code> 환경 변수를 불리언(boolean)으로 잘못 해석하던 문제를 수정했습니다. 또한 관련 환경 변수 오류 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/7891">#7891</a></li>
<li>내부 libgit2 라이브러리를 업데이트하여 Git 지원에 대한 다양한 수정을 포함했습니다. <a href="https://github.com/rust-lang/cargo/pull/7939">#7939</a></li>
<li><code>cargo package</code> / <code>cargo publish</code> 가 더 이상 각 파일의 전체 내용을 메모리에 버퍼링하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/7946">#7946</a></li>
<li>Git 의존성에서 유효하지 않은 <code>Cargo.toml</code> 파일을 더 많이 무시하도록 했습니다. Cargo는 현재 요청된 패키지를 찾기 위해 전체 저장소를 탐색합니다. 일부 유효하지 않은 매니페스트는 이미 건너뛰었으나, 이제는 모든 유효하지 않은 매니페스트를 건너뜜니다. <a href="https://github.com/rust-lang/cargo/pull/7947">#7947</a></li>
</ul>
<h3 id="나이틀리nightly-전용-51"><a class="header" href="#나이틀리nightly-전용-51">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>출력 디렉토리를 설정하기 위해 <code>build.out-dir</code> 설정 변수를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/7810">#7810</a></li>
<li>병렬 rustc의 성능 향상을 지원하기 위해 <code>-Zjobserver-per-rustc</code> 기능을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/7731">#7731</a></li>
<li><code>build-std</code> 및 <code>cc</code> 와 같은 크레이트 간의 파일 이름 충돌 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7860">#7860</a></li>
<li><code>-Ztimings</code> 가 오류가 발생하더라도 보고서를 저장합니다. <a href="https://github.com/rust-lang/cargo/pull/7872">#7872</a></li>
<li>로드할 설정 파일의 경로를 받을 수 있도록 <code>--config</code> 명령줄 플래그를 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/7901">#7901</a></li>
<li>새로운 기능 리졸버를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/7820">#7820</a></li>
<li>Rustdoc 문서가 이제 사이드바에 패키지 버전을 자동으로 포함합니다(<code>-Z crate-versions</code> 플래그 필요). <a href="https://github.com/rust-lang/cargo/pull/7903">#7903</a></li>
</ul>
<h2 id="cargo-142-2020-03-12"><a class="header" href="#cargo-142-2020-03-12">Cargo 1.42 (2020-03-12)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/0bf7aafe...rust-1.42.0">0bf7aafe…rust-1.42.0</a></p>
<h3 id="추가됨-53"><a class="header" href="#추가됨-53">추가됨</a></h3>
<ul>
<li>Git 인증에 대한 문서를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/7658">#7658</a></li>
<li>Bitbucket Pipeline 배지가 이제 crates.io에서 지원됩니다. <a href="https://github.com/rust-lang/cargo/pull/7663">#7663</a></li>
<li><code>cargo vendor</code> 가 이제 각 패키지의 디렉토리 이름에 항상 버전 번호를 포함하도록 강제하는 <code>--versioned-dirs</code> 옵션을 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/7631">#7631</a></li>
<li>proc-macro 패키지의 extern prelude에 <code>proc_macro</code> 크레이트가 이제 자동으로 추가됩니다. 이는 proc-macro에서 <code>extern crate proc_macro;</code> 가 더 이상 필요하지 않음을 의미합니다. <a href="https://github.com/rust-lang/cargo/pull/7700">#7700</a></li>
</ul>
<h3 id="변경됨-53"><a class="header" href="#변경됨-53">변경됨</a></h3>
<ul>
<li><code>cfg()</code> 표현식에서 <code>debug_assertions</code>, <code>test</code>, <code>proc_macro</code> 또는 <code>feature=</code> 가 사용되는 경우 경고를 발생시킵니다. <a href="https://github.com/rust-lang/cargo/pull/7660">#7660</a></li>
<li>Cargo 타겟, 워크스페이스 및 기능에 대한 새로운 장을 추가하는 등 Cargo 문서가 대폭 업데이트되었습니다. <a href="https://github.com/rust-lang/cargo/pull/7733">#7733</a></li>
<li>윈도우: 모든 Windows MSVC 타겟에 대해 <code>.lib</code> DLL 임포트 라이브러리가 이제 DLL 옆으로 복사됩니다. 이전에는 <code>pc-windows-msvc</code> 에 대해서만 지원되었습니다. 이는 <code>uwp-windows-msvc</code> 타겟에 대한 DLL 지원을 추가합니다. <a href="https://github.com/rust-lang/cargo/pull/7758">#7758</a></li>
<li><code>[target]</code> 설정의 <code>ar</code> 필드가 더 이상 읽히지 않습니다. 이 필드는 4년 넘게 무시되어 왔습니다. <a href="https://github.com/rust-lang/cargo/pull/7763">#7763</a></li>
<li>Bash 자동 완성 파일이 간소화되고 최신 변경 사항에 맞춰 업데이트되었습니다. <a href="https://github.com/rust-lang/cargo/pull/7789">#7789</a></li>
<li>자격 증명(credentials)이 모든 Cargo 명령이 아닌 필요할 때만 로드됩니다. <a href="https://github.com/rust-lang/cargo/pull/7774">#7774</a></li>
</ul>
<h3 id="수정됨-56"><a class="header" href="#수정됨-56">수정됨</a></h3>
<ul>
<li>일부 경우에 오탐(false positive)을 발생시키던 <code>--offline</code> 빈 인덱스 확인을 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/7655">#7655</a></li>
<li><code>include</code> 목록에 추가하면 이제 <code>.</code> 으로 시작하는 파일과 디렉토리를 패키지에 포함할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/7680">#7680</a></li>
<li>자격 증명 파일에 이전 항목이 있을 때 <code>cargo login</code> 이 대체 레지스트리 토큰을 제거하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7708">#7708</a></li>
<li>대체 레지스트리와 함께 사용할 때 <code>cargo vendor</code> 가 패닉을 일으키던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7718">#7718</a></li>
<li>핑거프린트 디버그 로그 메시지의 잘못된 설명을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7749">#7749</a></li>
<li><code>[source]</code> 가 여러 번 정의된 경우 이제 오류가 발생합니다. 이전에는 무작위로 소스를 선택하여 비결정적인 동작을 유발할 수 있었습니다. <a href="https://github.com/rust-lang/cargo/pull/7751">#7751</a></li>
<li><code>cargo metadata</code> 의 <code>dep_kinds</code> 가 이제 중복 제거됩니다. <a href="https://github.com/rust-lang/cargo/pull/7756">#7756</a></li>
<li>Git 저장소 내부의 하위 디렉토리에 있는 <code>.gitignore</code> 에 <code>Cargo.lock</code> 이 나열되어 있을 때의 패키징 문제를 수정했습니다. 이전에는 <code>Cargo.lock</code> 이 저장소의 루트에 있다고 가정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7779">#7779</a></li>
<li>부분적인 파일 전송 오류가 발생할 때 이제 자동으로 재시도합니다. <a href="https://github.com/rust-lang/cargo/pull/7788">#7788</a></li>
<li>리눅스: CPU iowait 통계 수치가 감소할 때 발생하던 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7803">#7803</a></li>
<li><code>RUSTFLAGS</code> 를 통해 <code>--sysroot</code> 가 전달될 때 호스트 컴파일러 설정을 감지하기 위해 잘못된 sysroot를 사용하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7798">#7798</a></li>
</ul>
<h3 id="나이틀리nightly-전용-52"><a class="header" href="#나이틀리nightly-전용-52">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><code>build-std</code> 가 이제 sysroot 패키지를 찾기 위해 <code>--sysroot</code> 대신 <code>--extern</code> 을 사용합니다. <a href="https://github.com/rust-lang/cargo/pull/7699">#7699</a></li>
<li>설정 값을 지정하기 위해 <code>--config</code> 명령줄 옵션을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/7649">#7649</a></li>
<li>다른 설정 파일을 포함할 수 있도록 <code>include</code> 설정 값을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/7649">#7649</a></li>
<li>설정 파일의 프로파일이 이제 모든 이름의 프로파일을 지원합니다. 이전에는 dev/release로 제한되었습니다. <a href="https://github.com/rust-lang/cargo/pull/7750">#7750</a></li>
</ul>
<h2 id="cargo-141-2020-01-30"><a class="header" href="#cargo-141-2020-01-30">Cargo 1.41 (2020-01-30)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/5da4b4d4...rust-1.41.0">5da4b4d4…rust-1.41.0</a></p>
<h3 id="추가됨-54"><a class="header" href="#추가됨-54">추가됨</a></h3>
<ul>
<li>🔥 Cargo가 이제 새로운 <code>Cargo.lock</code> 파일 형식을 사용합니다. 이 새로운 형식은 소스 제어 시스템에서 더 쉬운 병합을 지원해야 합니다. 기존 형식을 사용하는 프로젝트는 계속해서 기존 형식을 사용하며, 새로운 <code>Cargo.lock</code> 파일만 새로운 형식을 사용합니다. <a href="https://github.com/rust-lang/cargo/pull/7579">#7579</a></li>
<li>🔥 <code>cargo install</code> 이 이제 실패하는 대신 이미 설치된 패키지를 업그레이드합니다. <a href="https://github.com/rust-lang/cargo/pull/7560">#7560</a></li>
<li>🔥 프로파일 재정의(override) 기능이 추가되었습니다. 이를 통해 개별 의존성이나 빌드 스크립트에 대한 프로파일을 재정의할 수 있습니다. 자세한 내용은 <a href="https://doc.rust-lang.org/nightly/cargo/reference/profiles.html#overrides">문서</a> 를 참조하세요. <a href="https://github.com/rust-lang/cargo/pull/7591">#7591</a></li>
<li>빌드 스크립트에 대한 새로운 문서를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/7565">#7565</a></li>
<li>Cargo의 JSON 출력에 대한 문서를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/7595">#7595</a></li>
<li>설정 및 환경 변수 문서가 대폭 확장되었습니다. <a href="https://github.com/rust-lang/cargo/pull/7650">#7650</a></li>
<li><code>cargo doc --open</code> 을 위한 <code>BROWSER</code> 환경 변수 지원을 다시 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/7576">#7576</a></li>
<li><code>cargo metadata</code> 의 의존성에 대해 <code>kind</code> 와 <code>platform</code> 을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/7132">#7132</a></li>
<li><code>build-script-executed</code> JSON 메시지에 이제 <code>OUT_DIR</code> 값이 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/7622">#7622</a></li>
</ul>
<h3 id="변경됨-54"><a class="header" href="#변경됨-54">변경됨</a></h3>
<ul>
<li><code>cargo doc</code> 이 이제 기본적으로 바이너리의 비공개(private) 항목도 문서화합니다. <a href="https://github.com/rust-lang/cargo/pull/7593">#7593</a></li>
<li>서브 명령어 오타 제안에 이제 별칭(alias)이 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/7486">#7486</a></li>
<li><code>.gitignore</code> 에 “이미 존재하는…” 주석이 추가되는 방식을 조정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7570">#7570</a></li>
<li>토큰 복사/붙여넣기 시 포함된 <code>cargo login</code> 텍스트를 무시합니다. <a href="https://github.com/rust-lang/cargo/pull/7588">#7588</a></li>
<li>윈도우: 파일 시스템에서 지원하지 않는 경우 파일 잠금 오류를 무시합니다. <a href="https://github.com/rust-lang/cargo/pull/7602">#7602</a></li>
<li><code>.gitignore</code> 에서 <code>**/*.rs.bk</code> 를 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/7647">#7647</a></li>
</ul>
<h3 id="수정됨-57"><a class="header" href="#수정됨-57">수정됨</a></h3>
<ul>
<li><code>build</code> 설정 섹션의 일부 키에 대한 미사용 경고를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7575">#7575</a></li>
<li>리눅스: <code>/proc/stat</code> 을 파싱할 때 패닉이 발생하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7580">#7580</a></li>
<li><code>cargo vendor</code> 에서 표준 경로(canonical path)를 표시하지 않도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/7629">#7629</a></li>
</ul>
<h3 id="나이틀리nightly-전용-53"><a class="header" href="#나이틀리nightly-전용-53">나이틀리(Nightly) 전용</a></h3>
<h2 id="cargo-140-2019-12-19"><a class="header" href="#cargo-140-2019-12-19">Cargo 1.40 (2019-12-19)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/1c6ec66d...5da4b4d4">1c6ec66d…5da4b4d4</a></p>
<h3 id="추가됨-55"><a class="header" href="#추가됨-55">추가됨</a></h3>
<ul>
<li>TLS 버전 및 최소/최대 버전을 제어하기 위해 <code>http.ssl-version</code> 설정 옵션을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/7308">#7308</a></li>
<li>🔥 컴파일러 경고가 이제 디스크에 캐시됩니다. 빌드에서 경고가 발생하면, 빌드를 다시 실행할 때 경고가 다시 표시됩니다. <a href="https://github.com/rust-lang/cargo/pull/7450">#7450</a></li>
<li>리졸버 그래프에 표시되는 노드를 주어진 타겟 트리플에 포함된 패키지로만 좁히기 위해 <code>cargo metadata</code> 에 <code>--filter-platform</code> 옵션을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/7376">#7376</a></li>
</ul>
<h3 id="변경됨-55"><a class="header" href="#변경됨-55">변경됨</a></h3>
<ul>
<li>Cargo의 “플랫폼” <code>cfg</code> 파싱 기능이 <code>cargo-platform</code> 이라는 별도의 크레이트로 추출되었습니다. <a href="https://github.com/rust-lang/cargo/pull/7375">#7375</a></li>
<li>시스템 호출 오버헤드를 줄이기 위해 Cargo 캐시에 추출된 의존성들이 더 이상 수정 시간(mtime)을 보존하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/7465">#7465</a></li>
<li>윈도우: EXE 파일 이름에 더 이상 메타데이터 해시가 포함되지 않습니다. 이는 디버거가 파일 이름을 PDB 파일과 연관시키는 데 도움이 됩니다. <a href="https://github.com/rust-lang/cargo/pull/7400">#7400</a></li>
<li>Wasm32: <code>.wasm</code> 파일이 이제 “실행 파일“로 취급되지 않으며, 이에 따라 <code>cargo test</code> 및 <code>cargo run</code> 이 생성된 <code>.js</code> 파일과 함께 제대로 작동합니다. <a href="https://github.com/rust-lang/cargo/pull/7476">#7476</a></li>
<li>crates.io가 이제 SPDX 3.6 라이선스를 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/7481">#7481</a></li>
<li>순환 의존성 오류 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/7470">#7470</a></li>
<li>인수 없는 <code>cargo clean</code> 이 더 이상 패키지 캐시를 잠그지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/7502">#7502</a></li>
<li><code>cargo publish</code> 가 이제 버전 키가 없는 개발 의존성(dev-dependency)의 게시를 허용합니다. Git 또는 경로만 지정된 개발 의존성은 업로드 전 패키지 매니페스트에서 제거됩니다. <a href="https://github.com/rust-lang/cargo/pull/7333">#7333</a></li>
<li>가상 워크스페이스의 루트에서 <code>--features</code> 및 <code>--no-default-features</code> 를 사용하면 이제 무시되는 대신 오류가 발생합니다. <a href="https://github.com/rust-lang/cargo/pull/7507">#7507</a></li>
<li>패키지 아카이브 내의 생성된 파일(<code>Cargo.toml</code> 및 <code>Cargo.lock</code> 등)의 타임스탬프가 이제 에포크(epoch) 대신 현재 시간으로 설정됩니다. <a href="https://github.com/rust-lang/cargo/pull/7523">#7523</a></li>
<li><code>-Z</code> 플래그 파서가 이제 더 엄격해져서 잘못된 구문을 더 많이 거부합니다. <a href="https://github.com/rust-lang/cargo/pull/7531">#7531</a></li>
</ul>
<h3 id="수정됨-58"><a class="header" href="#수정됨-58">수정됨</a></h3>
<ul>
<li>패키지에 <code>include</code> 필드가 있고, <code>Cargo.lock</code> 이 <code>.gitignore</code> 에 있으며, 바이너리 또는 예제 타겟이 있고, 현재 프로젝트에 <code>Cargo.lock</code> 이 존재하는 경우, <code>Cargo.lock</code> 이 더럽다(dirty)며 게시가 실패하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7448">#7448</a></li>
<li><code>[patch]</code> 항목의 특정한 조합에서 발생하던 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7452">#7452</a></li>
<li>윈도우: <code>cargo test</code> 또는 <code>rustc</code> 가 시그널이나 세그먼테이션 오류와 같은 비정상적인 방식으로 충돌할 때의 오류 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/7535">#7535</a></li>
</ul>
<h3 id="나이틀리nightly-전용-54"><a class="header" href="#나이틀리nightly-전용-54">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><code>mtime-on-use</code> 기능을 이제 <code>unstable.mtime_on_use</code> 설정 옵션을 통해 활성화할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/7411">#7411</a></li>
<li>이름이 지정된 프로파일(named profiles) 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/6989">#6989</a></li>
<li>“abort” 패닉 전략으로 테스트를 빌드하고 실행할 수 있도록 <code>-Zpanic-abort-tests</code> 를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/7460">#7460</a></li>
<li><code>build-std</code> 가 <code>--sysroot</code> 를 사용하도록 변경했습니다. <a href="https://github.com/rust-lang/cargo/pull/7421">#7421</a></li>
<li><code>-Ztimings</code> 에 대한 다양한 수정 및 개선 사항이 적용되었습니다. <a href="https://github.com/rust-lang/cargo/pull/7395">#7395</a> <a href="https://github.com/rust-lang/cargo/pull/7398">#7398</a> <a href="https://github.com/rust-lang/cargo/pull/7397">#7397</a> <a href="https://github.com/rust-lang/cargo/pull/7403">#7403</a> <a href="https://github.com/rust-lang/cargo/pull/7428">#7428</a> <a href="https://github.com/rust-lang/cargo/pull/7429">#7429</a></li>
<li>프로파일 재정의 구문이 <code>[profile.dev.package.NAME]</code> 으로 변경되었습니다. <a href="https://github.com/rust-lang/cargo/pull/7504">#7504</a></li>
<li>워크스페이스에서 사용되지 않는 프로파일 재정의에 대한 경고를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7536">#7536</a></li>
</ul>
<h2 id="cargo-139-2019-11-07"><a class="header" href="#cargo-139-2019-11-07">Cargo 1.39 (2019-11-07)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/e853aa97...1c6ec66d">e853aa97…1c6ec66d</a></p>
<h3 id="추가됨-56"><a class="header" href="#추가됨-56">추가됨</a></h3>
<ul>
<li>설정 파일에 이제 <code>.toml</code> 파일 확장자를 사용할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/7295">#7295</a></li>
<li>“all“의 의미에 대한 혼란을 피하기 위해 <code>--workspace</code> 플래그를 <code>--all</code> 의 별칭으로 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/7241">#7241</a></li>
<li><code>cargo metadata</code> 에 <code>publish</code> 필드를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/7354">#7354</a></li>
</ul>
<h3 id="변경됨-56"><a class="header" href="#변경됨-56">변경됨</a></h3>
<ul>
<li><code>rustc</code> 의 출력 파싱에 실패할 경우 더 많은 정보를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/7236">#7236</a></li>
<li>TOML 오류에 이제 열 번호가 표시됩니다. <a href="https://github.com/rust-lang/cargo/pull/7248">#7248</a></li>
<li><code>cargo vendor</code> 가 이제 <code>vendor</code> 디렉토리 내에서 <code>.</code> 으로 시작하는 파일을 삭제하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/7242">#7242</a></li>
<li><code>cargo fetch</code> 가 이제 매니페스트 경고를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/7243">#7243</a></li>
<li><code>cargo publish</code> 가 이제 Git 서브모듈에 커밋되지 않은 변경 사항이 있는지 확인합니다. <a href="https://github.com/rust-lang/cargo/pull/7245">#7245</a></li>
<li>빌드 스크립트에서 <code>cargo:rustc-flags</code> 가 이제 공백 없이 <code>-l</code> 및 <code>-L</code> 플래그를 사용할 수 있도록 허용합니다. <a href="https://github.com/rust-lang/cargo/pull/7257">#7257</a></li>
<li><code>cargo install</code> 이 패키지의 이전 버전을 교체할 때, 새로 설치된 버전에는 더 이상 존재하지 않는 기존에 설치된 바이너리들을 이제 삭제합니다. <a href="https://github.com/rust-lang/cargo/pull/7246">#7246</a></li>
<li>Git 의존성을 게시할 때 이제 <code>version</code> 키를 지정할 수도 있습니다. <code>git</code> 값은 <code>path</code> 의존성의 동작과 마찬가지로 업로드된 크레이트에서 제거됩니다. <a href="https://github.com/rust-lang/cargo/pull/7237">#7237</a></li>
<li>워크스페이스 <code>default-members</code> 의 동작이 변경되었습니다. 이제 <code>default-members</code> 는 워크스페이스 루트에서 Cargo를 실행할 때만 적용됩니다. 이전에는 Cargo가 실행되는 디렉토리에 관계없이 항상 적용되었습니다. <a href="https://github.com/rust-lang/cargo/pull/7270">#7270</a></li>
<li>모든 업스트림 변경 사항을 반영하여 libgit2를 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/7275">#7275</a></li>
<li>홈 디렉토리 위치를 찾기 위해 <code>home</code> 의존성을 업데이트했습니다. <a href="https://github.com/rust-lang/cargo/pull/7277">#7277</a></li>
<li>zsh 자동 완성 기능이 업데이트되었습니다. <a href="https://github.com/rust-lang/cargo/pull/7296">#7296</a></li>
<li>SSL 연결 오류 발생 시 이제 재시도합니다. <a href="https://github.com/rust-lang/cargo/pull/7318">#7318</a></li>
<li>잡서버(jobserver)가 (N-1개 대신) N개의 토큰을 획득한 후 즉시 추가 토큰을 획득하도록 변경되었습니다. 이는 윈도우에서 <code>cc</code> 크레이트가 암시적 토큰을 해제할 수 있도록 지원하기 위해 변경된 사항입니다. <a href="https://github.com/rust-lang/cargo/pull/7344">#7344</a></li>
<li>다음에 빌드할 크레이트를 선택하는 스케줄링 알고리즘이 변경되었습니다. 이제 해당 크레이트를 기다리는 전이적(transitive) 크레이트 수가 가장 많은 크레이트를 선택합니다. 이전에는 최대 위상 깊이(topological depth)를 사용했습니다. <a href="https://github.com/rust-lang/cargo/pull/7390">#7390</a></li>
<li>RUSTFLAGS가 더 이상 메타데이터 및 파일 이름 해시에 포함되지 않으며, 이를 추가했던 1.33의 변경 사항을 되돌렸습니다. 이는 RUSTFLAGS의 모든 변경이 재컴파일을 유발하지만, 심볼 멍글링(symbol munging)에는 영향을 미치지 않음을 의미합니다. <a href="https://github.com/rust-lang/cargo/pull/7459">#7459</a></li>
</ul>
<h3 id="수정됨-59"><a class="header" href="#수정됨-59">수정됨</a></h3>
<ul>
<li>약식 SSH URL(예: <code>git@github.com/user/repo.git</code>)을 사용하는 서브모듈을 포함한 Git 의존성이 이제 정상적으로 작동합니다. <a href="https://github.com/rust-lang/cargo/pull/7238">#7238</a></li>
<li>macOS에서 <code>.dSYM</code> 심볼릭 링크를 생성할 때 깨진 심볼릭 링크를 처리합니다. <a href="https://github.com/rust-lang/cargo/pull/7268">#7268</a></li>
<li><code>[patch]</code> 테이블에서 동일한 크레이트의 여러 버전과 관련된 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7303">#7303</a></li>
<li>이름의 부분 문자열이 지원되지 않는 크레이트 타입(예: “bin”)과 일치하는 사용자 정의 타겟 <code>.json</code> 파일과 관련된 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/issues/7363">#7363</a></li>
<li>proc-macro 크레이트 타입에 대한 문서 생성 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7159">#7159</a></li>
<li>빌드 스레드 내에서 Cargo가 패닉을 일으킬 때 멈추던 현상을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7366">#7366</a></li>
<li><code>build.rs</code> 스크립트가 빌드 간에 서로 다른 <code>rerun-if</code> 지시문을 실행할 때의 재빌드 감지 문제를 수정했습니다. Cargo가 변경 후 잘못된 재빌드를 유발하고 있었습니다. <a href="https://github.com/rust-lang/cargo/pull/7373">#7373</a></li>
<li><code>[patch]</code> 테이블 항목에 대한 표준 URL을 올바르게 처리하도록 하여, 패치가 처음 사용된 이후에 작동하지 않던 문제를 방지했습니다. <a href="https://github.com/rust-lang/cargo/pull/7368">#7368</a></li>
<li>통합 테스트가 자신의 빌드를 시작하기 전에 패키지 바이너리 빌드가 완료될 때까지 기다리던 문제를 수정했습니다. 이제 동시에 빌드될 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/7394">#7394</a></li>
<li>이전 릴리스에서 <code>--features a b</code> 플래그가 해석되는 방식이 실수로 변경되었던 것을 수정하여, 이를 <code>--features a</code> 와 명령에 전달되는 인수 <code>b</code> 로 해석하는 원래 동작으로 복구했습니다. 여러 기능을 전달하려면 <code>--features "a b"</code> 와 같이 기능을 따옴표로 묶거나, 쉼표를 사용하거나, 여러 개의 <code>--features</code> 플래그를 사용하세요. <a href="https://github.com/rust-lang/cargo/pull/7419">#7419</a></li>
</ul>
<h3 id="나이틀리nightly-전용-55"><a class="header" href="#나이틀리nightly-전용-55">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>Cargo에서 직접 표준 라이브러리를 빌드할 수 있는 기본적인 지원이 추가되었습니다. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#build-std">docs</a>) <a href="https://github.com/rust-lang/cargo/pull/7216">#7216</a></li>
<li>개별 컴파일 단계에서 소요된 시간에 대한 HTML 보고서를 생성하는 <code>-Ztimings</code> 기능을 추가했습니다. 이는 또한 콘솔에 완료 단계와 JSON 데이터를 출력할 수 있습니다. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#timings">docs</a>) <a href="https://github.com/rust-lang/cargo/pull/7311">#7311</a></li>
<li>문서 테스트(doctest)를 교차 컴파일하는 기능을 추가했습니다. (<a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#doctest-xcompile">docs</a>) <a href="https://github.com/rust-lang/cargo/pull/6892">#6892</a></li>
</ul>
<h2 id="cargo-138-2019-09-26"><a class="header" href="#cargo-138-2019-09-26">Cargo 1.38 (2019-09-26)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/4c1fa54d...23ef9a4e">4c1fa54d…23ef9a4e</a></p>
<h3 id="추가됨-57"><a class="header" href="#추가됨-57">추가됨</a></h3>
<ul>
<li>🔥 빌드 중 유휴 CPU 병렬성을 더 잘 활용하기 위해 Cargo 빌드 파이프라이닝이 기본적으로 활성화되었습니다. <a href="https://github.com/rust-lang/cargo/pull/7143">#7143</a></li>
<li>Cargo의 <code>--message-format</code> 옵션을 이제 여러 번 지정할 수 있으며 쉼표로 구분된 값 목록을 허용합니다. 이전 값들에 더해, 이제 <code>json</code> 메시지 모드에서 rustc로부터 오는 출력을 구성하는 <code>json-diagnostic-short</code> 및 <code>json-diagnostic-rendered-ansi</code> 도 허용합니다. <a href="https://github.com/rust-lang/cargo/pull/7214">#7214</a></li>
<li>Cirrus CI 배지가 이제 crates.io에서 지원됩니다. <a href="https://github.com/rust-lang/cargo/pull/7119">#7119</a></li>
<li><code>Cargo.lock</code> 의 새로운 형식이 도입되었습니다. 이 새로운 형식은 소스 제어에서의 병합 충돌을 더 자주 방지하고, 전반적으로 변경 사항을 더 안전하게 병합할 수 있도록 설계되었습니다. 현재 이 새로운 형식은 활성화되어 있지 않지만, Cargo는 이 형식이 발견되면 이를 사용합니다. 향후 어느 시점에는 이것이 기본값이 될 예정입니다. <a href="https://github.com/rust-lang/cargo/pull/7070">#7070</a></li>
<li>FreeBSD에 대한 진행률 표시줄 지원이 추가되었습니다. <a href="https://github.com/rust-lang/cargo/pull/7222">#7222</a></li>
</ul>
<h3 id="변경됨-57"><a class="header" href="#변경됨-57">변경됨</a></h3>
<ul>
<li><code>-q</code> 플래그가 이제 Cargo 자체에서 발생하는 오류에 대한 루트 오류 메시지를 억제하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/7116">#7116</a></li>
<li>Cargo 북이 이제 mdbook 0.3으로 게시되어 여러 포맷 수정 및 개선 사항을 제공합니다. <a href="https://github.com/rust-lang/cargo/pull/7140">#7140</a></li>
<li><code>--features</code> 명령줄 플래그를 이제 여러 번 지정할 수 있습니다. 모든 플래그에서 지정된 기능 목록이 하나로 합쳐집니다. <a href="https://github.com/rust-lang/cargo/pull/7084">#7084</a></li>
<li>패키지 include/exclude의 glob-vs-gitignore 경고가 제거되었습니다. 이제 패키지에서 경고 없이 gitignore 스타일의 매칭을 사용할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/7170">#7170</a></li>
<li>Cargo가 <code>cfg</code> 값과 같은 정보를 위해 <code>rustc</code> 에 쿼리할 때 <code>rustc</code> 출력 파싱에 실패하면, 이제 해당 명령과 출력을 함께 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/7185">#7185</a></li>
<li><code>cargo package</code>/<code>cargo publish</code> 가 이제 Git 서브모듈에 대한 심볼릭 링크가 해당 서브모듈을 포함하도록 허용합니다. <a href="https://github.com/rust-lang/cargo/pull/6817">#6817</a></li>
<li>버전 요구 사항이 어떤 버전과도 일치하지 않지만, 사용 가능한 프리릴리스 버전이 있는 경우의 오류 메시지를 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/7191">#7191</a></li>
</ul>
<h3 id="수정됨-60"><a class="header" href="#수정됨-60">수정됨</a></h3>
<ul>
<li><code>git-fetch-with-cli</code> 설정 옵션을 사용하고 <code>GIT_DIR</code> 환경 변수가 설정된 상태에서 Git 저장소를 업데이트할 때 잘못된 디렉토리를 사용하던 문제를 수정했습니다. 이는 Git 콜백에서 Cargo를 실행할 때 발생할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/7082">#7082</a></li>
<li>별도의 디버그 출력을 갖는 타겟에 대해 dep-info 파일이 덮어씌워지던 문제를 수정했습니다. 예를 들어, <code>.dSYM</code> 디렉토리가 있는 <code>-apple-</code> 타겟의 바이너리는 <code>.d</code> 파일을 덮어씌우곤 했습니다. <a href="https://github.com/rust-lang/cargo/pull/7057">#7057</a></li>
<li><code>[patch]</code> 테이블이 “소스당 하나의 메이저 버전” 규칙을 준수하지 않던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7118">#7118</a></li>
<li><code>cargo rustc</code> 명령에서 메타데이터 해시 계산 시 <code>--remap-path-prefix</code> 플래그를 무시하도록 했습니다. 이전에는 이 재매핑 설정이 심볼 이름에 의도치 않게 영향을 미치고 있었습니다. <a href="https://github.com/rust-lang/cargo/pull/7134">#7134</a></li>
<li><code>[patch]</code> 의존성에서의 순환 감지 기능을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7174">#7174</a></li>
<li>Git 설정 <code>core.symlinks</code> 가 true일 때 윈도우에서 <code>cargo new</code> 가 심볼릭 링크를 남기던 문제를 수정했습니다. 또한 업스트림 libgit2의 여러 수정 사항과 업데이트를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/7176">#7176</a></li>
<li>macOS: <code>target</code> 디렉토리를 백업에서 제외하도록 설정하는 플래그 관련 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7192">#7192</a></li>
<li>멀티바이트 문자가 포함된 일부 상황에서 <code>cargo fix</code> 가 패닉을 일으키던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7221">#7221</a></li>
</ul>
<h3 id="나이틀리nightly-전용-56"><a class="header" href="#나이틀리nightly-전용-56">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>Clippy의 기계 적용 가능한 수정 사항을 적용하는 <code>cargo fix --clippy</code> 를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/7069">#7069</a></li>
<li>표준 라이브러리와 같은 바이너리 의존성에 대한 변경 사항 추적을 추가하기 위해 <code>-Z binary-dep-depinfo</code> 플래그를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/7137">#7137</a> <a href="https://github.com/rust-lang/cargo/pull/7219">#7219</a></li>
<li><code>cargo clippy-preview</code> 가 변경 사항이 없더라도 항상 실행되도록 변경되었습니다. <a href="https://github.com/rust-lang/cargo/pull/7157">#7157</a></li>
<li><code>CARGO_BUILD_PIPELINING</code> 사용 시 지수적 폭발이 발생하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7062">#7062</a></li>
<li><code>cargo clippy-preview</code> 에서 clippy에 인수를 전달하는 방식을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7162">#7162</a></li>
</ul>
<h2 id="cargo-137-2019-08-15"><a class="header" href="#cargo-137-2019-08-15">Cargo 1.37 (2019-08-15)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/c4fcfb72...9edd0891">c4fcfb72…9edd0891</a></p>
<h3 id="추가됨-58"><a class="header" href="#추가됨-58">추가됨</a></h3>
<ul>
<li>타겟의 문서가 테스트되는지 여부를 판단하기 위해 <code>cargo metadata</code> 에 <code>doctest</code> 필드를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/6953">#6953</a> <a href="https://github.com/rust-lang/cargo/pull/6965">#6965</a></li>
<li>🔥 <a href="https://doc.rust-lang.org/nightly/cargo/commands/cargo-vendor.html"><code>cargo vendor</code></a> 명령어가 이제 Cargo에 내장되었습니다. 이 명령어는 모든 의존성 소스의 로컬 복사본을 만드는 데 사용될 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/6869">#6869</a></li>
<li>🔥 “락파일 게시(publish lockfile)” 기능이 이제 안정화되었습니다. 이 기능은 패키지에 바이너리 실행 파일 타겟이 포함된 경우, 패키지 게시 시 <code>Cargo.lock</code> 파일을 자동으로 포함합니다. 기본적으로 Cargo는 패키지 설치 시 <code>Cargo.lock</code> 을 무시합니다. 게시된 패키지에 포함된 <code>Cargo.lock</code> 파일을 강제로 사용하려면 <code>cargo install --locked</code> 를 사용하세요. 이는 <code>cargo install</code> 이 일관되게 동일한 결과를 재현하도록 보장하는 데 유용할 수 있습니다. 또한 의존성에 유의적 버전(semver) 호환되지 않는 변경 사항이 실수로 게시된 경우, 작동하는 것으로 알려진 버전으로 되돌릴 수 있는 방법을 제공합니다. <a href="https://github.com/rust-lang/cargo/pull/7026">#7026</a></li>
<li>🔥 <code>default-run</code> 기능이 안정화되었습니다. 이 기능을 사용하면 패키지에 여러 바이너리가 포함된 경우 <code>cargo run</code> 으로 실행할 기본 바이너리 실행 파일을 지정할 수 있습니다. <code>Cargo.toml</code> 의 <code>[package]</code> 테이블에서 <code>default-run</code> 키를 기본으로 사용할 바이너리 이름으로 설정하세요. <a href="https://github.com/rust-lang/cargo/pull/7056">#7056</a></li>
</ul>
<h3 id="변경됨-58"><a class="header" href="#변경됨-58">변경됨</a></h3>
<ul>
<li><code>cargo package</code> 가 이제 빌드 스크립트가 빈 디렉토리를 생성하지 않는지 확인합니다. <a href="https://github.com/rust-lang/cargo/pull/6973">#6973</a></li>
<li><code>cargo doc</code> 이 중복된 출력을 생성하여 파일이 무작위로 덮어씌워지는 경우 이제 경고가 발생합니다. 이는 의존성 이름 변경, 동일 패키지의 여러 버전, 라이브러리 이름 변경 등 다양한 이유로 발생할 수 있습니다. 이는 알려진 버그이며 올바르게 처리하기 위해 추가 작업이 필요합니다. <a href="https://github.com/rust-lang/cargo/pull/6998">#6998</a></li>
<li><code>--features foo/bar</code> 를 사용하여 의존성의 기능을 활성화할 때, <code>foo</code> 가 선택적(optional) 의존성이 아니라면 더 이상 현재 크레이트를 <code>foo</code> 기능으로 컴파일하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/7010">#7010</a></li>
<li>RUSTFLAGS를 통해 <code>--remap-path-prefix</code> 가 전달되더라도 더 이상 파일 이름 메타데이터 해시에 영향을 주지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/6966">#6966</a></li>
<li>Cargo가 Git 저장소 접근에 사용하는 libgit2가 0.28.2로 업데이트되었습니다. 이는 지난 11월 마지막 업데이트 이후 수백 가지의 변경 사항과 수정을 포함합니다. <a href="https://github.com/rust-lang/cargo/pull/7018">#7018</a></li>
<li>Cargo가 이제 rustc에 의해 생성된 dep-info 파일에서 절대 경로를 지원합니다. 이는 재빌드 감지를 위해 libstd와 같은 <a href="https://github.com/rust-lang/rust/pull/61727">바이너리 추적</a> 을 위한 기초 작업입니다. (참고: 이 기능에는 알려진 버그가 포함되어 있습니다.) <a href="https://github.com/rust-lang/cargo/pull/7030">#7030</a></li>
</ul>
<h3 id="수정됨-61"><a class="header" href="#수정됨-61">수정됨</a></h3>
<ul>
<li>zsh 자동 완성이 명령 목록을 가져오는 방식을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6956">#6956</a></li>
<li><code>debug</code> 가 0으로 설정된 경우 빌드 요약에 “+ debuginfo“가 더 이상 출력되지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/6971">#6971</a></li>
<li><code>doc = true</code> 로 설정된 예제에 대해 <code>cargo doc</code> 이 올바르게 문서화하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/7023">#7023</a></li>
<li>CARGO_HOME에서 읽기 전용 잠금을 획득할 수 없더라도 실패하지 않도록 했습니다. 이는 CARGO_HOME이 존재하지 않지만 <code>--locked</code> 가 사용되어 CARGO_HOME이 필요하지 않은 경우에 도움이 됩니다. <a href="https://github.com/rust-lang/cargo/pull/7149">#7149</a></li>
<li>Cargo가 락 파일에서 대기할 때 잡서버(jobserver) 토큰을 해제하던 1.35의 변경 사항을 되돌렸습니다. 이로 인해 일부 상황에서 데드락이 발생했습니다. <a href="https://github.com/rust-lang/cargo/pull/7204">#7204</a></li>
</ul>
<h3 id="나이틀리nightly-전용-57"><a class="header" href="#나이틀리nightly-전용-57">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#cache-messages">컴파일러 메시지 캐싱</a> 기능이 추가되었습니다. <code>-Z cache-messages</code> 플래그는 Cargo가 컴파일러 출력을 캐시하도록 하여 향후 실행 시 이전 경고를 다시 표시할 수 있게 합니다. <a href="https://github.com/rust-lang/cargo/pull/6933">#6933</a></li>
<li><code>-Z mtime-on-use</code> 가 더 이상 중간 산출물을 건드리지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/7050">#7050</a></li>
</ul>
<h2 id="cargo-136-2019-07-04"><a class="header" href="#cargo-136-2019-07-04">Cargo 1.36 (2019-07-04)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/6f3e9c36...c4fcfb72">6f3e9c36…c4fcfb72</a></p>
<h3 id="추가됨-59"><a class="header" href="#추가됨-59">추가됨</a></h3>
<ul>
<li>타겟 자동 감지에 대한 더 자세한 문서를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/6898">#6898</a></li>
<li>🔥 네트워크 연결 없이 Cargo를 사용할 수 있게 해주는 <code>--offline</code> 플래그를 안정화했습니다. <a href="https://github.com/rust-lang/cargo/pull/6934">#6934</a> <a href="https://github.com/rust-lang/cargo/pull/6871">#6871</a></li>
</ul>
<h3 id="변경됨-59"><a class="header" href="#변경됨-59">변경됨</a></h3>
<ul>
<li>매니페스트에 <code>publish = ["crates-io"]</code> 를 추가하여 게시를 crates.io로만 제한할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/6838">#6838</a></li>
<li>macOS: <code>DYLD_FALLBACK_LIBRARY_PATH</code> 가 설정되지 않은 경우에만 기본 경로를 포함합니다. 또한 기본 집합에서 <code>/lib</code> 를 제거했습니다. <a href="https://github.com/rust-lang/cargo/pull/6856">#6856</a></li>
<li>로그인 토큰을 사용할 수 없는 경우 <code>cargo publish</code> 가 이제 즉시 종료됩니다. <a href="https://github.com/rust-lang/cargo/pull/6854">#6854</a></li>
<li>HTTP/2 스트림 오류를 이제 “일시적인(spurious)” 오류로 간주하여 재시도합니다. <a href="https://github.com/rust-lang/cargo/pull/6861">#6861</a></li>
<li>의존성의 기능이 <em>필수</em> 의존성을 가리키도록 설정하는 것이 이제 오류로 처리됩니다. 이전에는 경고였습니다. <a href="https://github.com/rust-lang/cargo/pull/6860">#6860</a></li>
<li><code>registry.index</code> 설정 값이 이제 상대 <code>file:</code> URL을 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/6873">#6873</a></li>
<li>macOS: 디버거가 찾을 수 있도록 메타데이터 해시가 없는 예제 바이너리 옆에 <code>.dSYM</code> 디렉토리가 심볼릭 링크로 생성됩니다. <a href="https://github.com/rust-lang/cargo/pull/6891">#6891</a></li>
<li>새 프로젝트의 기본 <code>Cargo.toml</code> 템플릿에 이제 문서 링크를 제공하는 주석이 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/6881">#6881</a></li>
<li>크레이트 다운로드 요약의 문구를 일부 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/6916">#6916</a> <a href="https://github.com/rust-lang/cargo/pull/6920">#6920</a></li>
<li>✨ <code>log</code> 크레이트를 사용하는 사용자 코드에 Cargo의 디버그 출력이 표시되지 않도록, 환경 변수 <code>RUST_LOG</code> 를 <code>CARGO_LOG</code> 로 변경했습니다. <a href="https://github.com/rust-lang/cargo/pull/6918">#6918</a></li>
<li>패키징 시 <code>package.include</code> 에 나열되지 않더라도 <code>Cargo.toml</code> 이 항상 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/6925">#6925</a></li>
<li>패키지 include/exclude 값이 이제 글로브(glob) 패턴 대신 gitignore 패턴을 사용합니다. <a href="https://github.com/rust-lang/cargo/pull/6924">#6924</a></li>
<li>crates.io 타임아웃 발생 시 더 나은 오류 메시지를 제공합니다. 또한 다른 HTTP 응답 코드에 대한 오류 메시지도 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/6936">#6936</a></li>
</ul>
<h3 id="성능"><a class="header" href="#성능">성능</a></h3>
<ul>
<li>일부 경우에 대한 리졸버 성능이 향상되었습니다. <a href="https://github.com/rust-lang/cargo/pull/6853">#6853</a></li>
<li>결과를 캐싱하여 Cargo가 인덱스 JSON 파일을 읽는 방식을 최적화했습니다. <a href="https://github.com/rust-lang/cargo/pull/6880">#6880</a> <a href="https://github.com/rust-lang/cargo/pull/6912">#6912</a> <a href="https://github.com/rust-lang/cargo/pull/6940">#6940</a></li>
<li>다양한 성능 개선이 이루어졌습니다. <a href="https://github.com/rust-lang/cargo/pull/6867">#6867</a></li>
</ul>
<h3 id="수정됨-62"><a class="header" href="#수정됨-62">수정됨</a></h3>
<ul>
<li>의존성에 대한 온디스크(on-disk) 핑거프린트 정보를 더 세밀하게 추적합니다. 이는 빌드가 중단되었다가 재시작되는 일부 드문 경우에 도움이 될 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/6832">#6832</a></li>
<li><code>cargo run</code> 이 이제 비 UTF-8 인수를 자식 프로세스에 올바르게 전달합니다. <a href="https://github.com/rust-lang/cargo/pull/6849">#6849</a></li>
<li>macOS의 기본 버전인 bash 3.2에서 bash 자동 완성이 작동하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6905">#6905</a></li>
<li>zsh 자동 완성에 대한 다양한 수정 및 개선 사항을 반영했습니다. <a href="https://github.com/rust-lang/cargo/pull/6926">#6926</a> <a href="https://github.com/rust-lang/cargo/pull/6929">#6929</a></li>
<li><code>Cargo.lock</code> 파일이 없는 경우 <code>cargo update</code> 가 <code>-p</code> 인수를 무시하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6904">#6904</a></li>
</ul>
<h3 id="나이틀리nightly-전용-58"><a class="header" href="#나이틀리nightly-전용-58">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>설치된 크레이트의 세부 정보를 추적하고 오래된 경우 업데이트하는 <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#install-upgrade"><code>-Z install-upgrade</code> 기능</a> 을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/6798">#6798</a></li>
<li>공개 의존성과 비공개 의존성을 구분하여 추적할 수 있게 해주는 <a href="https://doc.rust-lang.org/nightly/cargo/reference/unstable.html#public-dependency"><code>public-dependency</code> 기능</a> 을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/6772">#6772</a></li>
<li><code>build.pipelining</code> 설정 옵션(<code>CARGO_BUILD_PIPELINING</code> 환경 변수)을 통한 빌드 파이프라이닝 기능을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/6883">#6883</a></li>
<li><code>publish-lockfile</code> 기능에 몇 가지 중요한 변경 사항이 있습니다. 이제 기본값이 <code>true</code> 로 설정되어 바이너리 크레이트의 경우 <code>Cargo.lock</code> 이 항상 게시됩니다. 게시 중에 <code>Cargo.lock</code> 이 다시 생성됩니다. <code>cargo install</code> 은 이제 기본적으로 <code>Cargo.lock</code> 파일을 무시하며, 락 파일을 사용하려면 <code>--locked</code> 가 필요합니다. 삭제(yank)된 의존성이 감지되면 경고가 표시됩니다. <a href="https://github.com/rust-lang/cargo/pull/6840">#6840</a></li>
</ul>
<h2 id="cargo-135-2019-05-23"><a class="header" href="#cargo-135-2019-05-23">Cargo 1.35 (2019-05-23)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/6789d8a0...6f3e9c36">6789d8a0…6f3e9c36</a></p>
<h3 id="추가됨-60"><a class="header" href="#추가됨-60">추가됨</a></h3>
<ul>
<li>빌드 스크립트에서 cdylib 크레이트에 대한 링커 인수를 지정할 수 있도록 <code>rustc-cdylib-link-arg</code> 키를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/6298">#6298</a></li>
</ul>
<h3 id="변경됨-60"><a class="header" href="#변경됨-60">변경됨</a></h3>
<ul>
<li><code>cargo test foo</code> 와 같이 테스트 필터를 전달할 때, (예제가 <code>test = true</code> 로 설정되지 않은 한) 예제를 빌드하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/6683">#6683</a></li>
<li>테스트가 실제로 조용히 실행되도록 <code>cargo test</code> 의 <code>--quiet</code> 플래그를 libtest 하네스로 전달합니다. <a href="https://github.com/rust-lang/cargo/pull/6358">#6358</a></li>
<li>파일 수정 여부를 확인하는 <code>cargo package</code> 의 검증 단계가 더 엄격해졌습니다. 파일 시스템 수정 시간(mtime)을 확인하는 대신 내용의 해시를 사용합니다. 또한 패키지의 <em>모든</em> 파일을 확인합니다. <a href="https://github.com/rust-lang/cargo/pull/6740">#6740</a></li>
<li>Cargo가 파일 잠금으로 인해 차단될 때마다 잡서버 토큰이 해제됩니다. <a href="https://github.com/rust-lang/cargo/pull/6748">#6748</a></li>
<li>동일한 이름을 가진 여러 테이블 헤더를 허용하던 TOML 파서의 이전 버그에 대해 경고를 발생시킵니다. <a href="https://github.com/rust-lang/cargo/pull/6761">#6761</a></li>
<li><code>CARGO_PKG_*</code> 환경 변수를 메타데이터 해시에서 제거하고 대신 핑거프린트에 추가했습니다. 이는 이 값들이 변경될 때 오래된 산출물이 남지 않음을 의미합니다. 또한 “repository” 값을 핑거프린트에 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/6785">#6785</a></li>
<li><code>cargo metadata</code> 가 더 이상 <code>resolve.nodes.deps</code> 에서 라이브러리가 없는 의존성에 대해 <code>null</code> 필드를 표시하지 않습니다. 해당 의존성은 더 이상 표시되지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/6534">#6534</a></li>
<li><code>cargo new</code> 실행 시 이메일 주소가 빈 문자열로 설정된 경우 <code>authors</code> 필드에 이메일 주소를 포함하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/6802">#6802</a></li>
<li>여러 패키지를 문서화할 때 <code>cargo doc --open</code> 이 이제 정상적으로 작동합니다. <a href="https://github.com/rust-lang/cargo/pull/6803">#6803</a></li>
<li><code>cargo install --path P</code> 가 이제 디렉토리 P에서 <code>.cargo/config</code> 파일을 로드합니다. <a href="https://github.com/rust-lang/cargo/pull/6805">#6805</a></li>
<li>버전 요구 사항에서 유의적 버전 메타데이터(예: <code>1.0.0+1234</code>)를 사용하는 경우, 이제 해당 정보가 무시된다는 경고가 발생합니다. <a href="https://github.com/rust-lang/cargo/pull/6806">#6806</a></li>
<li><code>cargo install</code> 이 이제 일부 플래그가 무시될 수 있는 특정 플래그 조합을 거부합니다. <a href="https://github.com/rust-lang/cargo/pull/6801">#6801</a></li>
<li>일부 경우에 대한 리졸버 성능이 향상되었습니다. <a href="https://github.com/rust-lang/cargo/pull/6776">#6776</a></li>
</ul>
<h3 id="수정됨-63"><a class="header" href="#수정됨-63">수정됨</a></h3>
<ul>
<li>서로 다른 명령(예: <code>cargo build</code> 후 <code>cargo test</code>)을 실행할 때 두 번째 명령이 빌드 스크립트의 오래된 결과를 사용할 수 있던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6720">#6720</a></li>
<li><code>.gitignore</code> 파일이 루트 패키지 디렉토리와 일치할 경우 <code>cargo fix</code> 가 제대로 작동하지 않던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6767">#6767</a></li>
<li>프로파일에 <code>panic=unwind</code> 가 설정된 경우 라이브러리가 실수로 여러 번 컴파일되던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6781">#6781</a></li>
<li><code>build.target</code> 설정 값의 JSON 파일 경로를 표준화(canonicalize)하여 의존성 빌드 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6778">#6778</a></li>
<li>빌드 스크립트 컴파일이 중단된 경우(예: 강제 종료됨) 빌드 스크립트를 재실행하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6782">#6782</a></li>
<li>fossil 저장소를 초기화할 때의 <code>cargo new</code> 관련 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6792">#6792</a></li>
<li><code>git-fetch-with-cli</code> 기능을 사용할 때 강제 푸시(force push)가 발생한 Git 저장소의 업데이트 지원 문제를 수정했습니다. 이제 <code>git-fetch-with-cli</code> 가 실패할 때 더 많은 오류 정보를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/6800">#6800</a></li>
<li>WASM 타겟으로 빌드된 <code>--example</code> 바이너리가 파일 이름에 더 이상 메타데이터 해시를 포함하지 않도록 수정되었으며, <code>compiler-artifact</code> JSON 메시지에 올바르게 출력됩니다. <a href="https://github.com/rust-lang/cargo/pull/6812">#6812</a></li>
</ul>
<h3 id="나이틀리nightly-전용-59"><a class="header" href="#나이틀리nightly-전용-59">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><code>cargo clippy-preview</code> 가 이제 내장 Cargo 명령어가 되었습니다. <a href="https://github.com/rust-lang/cargo/pull/6759">#6759</a></li>
<li><code>build-override</code> 프로파일 설정에 이제 proc-macro와 그 의존성이 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/6811">#6811</a></li>
<li>선택적 의존성 및 타겟별 의존성이 이제 <code>-Z offline</code> 에서 더 잘 작동합니다. <a href="https://github.com/rust-lang/cargo/pull/6814">#6814</a></li>
</ul>
<h2 id="cargo-134-2019-04-11"><a class="header" href="#cargo-134-2019-04-11">Cargo 1.34 (2019-04-11)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/f099fe94...6789d8a0">f099fe94…6789d8a0</a></p>
<h3 id="추가됨-61"><a class="header" href="#추가됨-61">추가됨</a></h3>
<ul>
<li>🔥 <a href="https://doc.rust-lang.org/1.34.0/cargo/reference/registries.html">대체 레지스트리(alternate registries)</a> 지원을 안정화했습니다. <a href="https://github.com/rust-lang/cargo/pull/6654">#6654</a></li>
<li>Cargo와 함께 builds.sr.ht 지속적 통합(CI)을 사용하는 방법에 대한 문서를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/6565">#6565</a></li>
<li><code>Cargo.lock</code> 상단에 이 파일이 <code>@generated</code> 임을 나타내는 주석이 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/6548">#6548</a></li>
<li>Azure DevOps 배지가 이제 지원됩니다. <a href="https://github.com/rust-lang/cargo/pull/6264">#6264</a></li>
<li><code>--exclude</code> 플래그가 알 수 없는 패키지를 지정하는 경우 경고를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/6679">#6679</a></li>
</ul>
<h3 id="변경됨-61"><a class="header" href="#변경됨-61">변경됨</a></h3>
<ul>
<li><code>cargo test --doc --no-run</code> 은 아무 작업도 수행하지 않으므로, 이제 그 취지의 오류를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/6628">#6628</a></li>
<li>Bash 자동 완성에 대한 다양한 업데이트: 누락된 옵션 및 명령 추가, libtest 자동 완성 지원, <code>--target</code> 자동 완성에 rustup 사용, 파일 이름 자동 완성으로의 폴백(fallback) 기능, 명령줄 편집 기능 수정 등을 수행했습니다. <a href="https://github.com/rust-lang/cargo/pull/6644">#6644</a></li>
<li><code>[patch]</code> 섹션이 포함된 크레이트를 게시할 때 더 이상 오류가 발생하지 않습니다. 게시하기 전에 매니페스트에서 <code>[patch]</code> 섹션이 제거됩니다. <a href="https://github.com/rust-lang/cargo/pull/6535">#6535</a></li>
<li><code>build.incremental = true</code> 설정 값이 이제 <code>CARGO_INCREMENTAL=1</code> 과 동일하게 처리됩니다. 이전에는 무시되었습니다. <a href="https://github.com/rust-lang/cargo/pull/6688">#6688</a></li>
<li>레지스트리에서 발생하는 오류가 이제 HTTP 응답 코드에 관계없이 항상 표시됩니다. <a href="https://github.com/rust-lang/cargo/pull/6771">#6771</a></li>
</ul>
<h3 id="수정됨-64"><a class="header" href="#수정됨-64">수정됨</a></h3>
<ul>
<li><code>cargo run --example</code> 에 대한 bash 자동 완성을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6578">#6578</a></li>
<li><em>로컬</em> 레지스트리를 사용하면서 동일한 크레이트를 빌드하는 여러 Cargo 명령을 동시에 실행할 때의 레이스 컨디션을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6591">#6591</a></li>
<li>진행률 표시줄의 깜빡임 및 과도한 업데이트 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6615">#6615</a></li>
<li>잘못된 자격 증명을 반환하는 Git 자격 증명 헬퍼를 사용할 때 멈추던 현상을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6681">#6681</a></li>
<li>로컬 레지스트리에서 삭제(yank)된 크레이트를 해결하는 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6750">#6750</a></li>
</ul>
<h3 id="나이틀리nightly-전용-60"><a class="header" href="#나이틀리nightly-전용-60">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>크레이트가 사용될 때 파일 시스템의 mtime을 업데이트하도록 하는 <code>-Z mtime-on-use</code> 플래그를 추가했습니다. 이는 향후 사용되지 않는 파일을 정리하기 위해 오래된 산출물을 추적할 수 있도록 하기 위함입니다. <a href="https://github.com/rust-lang/cargo/pull/6477">#6477</a> <a href="https://github.com/rust-lang/cargo/pull/6573">#6573</a></li>
<li>호스트와 타겟 모두를 위해 proc-macro를 빌드하는 실험적인 <code>-Z dual-proc-macros</code> 를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/6547">#6547</a></li>
</ul>
<h2 id="cargo-133-2019-02-28"><a class="header" href="#cargo-133-2019-02-28">Cargo 1.33 (2019-02-28)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/8610973a...f099fe94">8610973a…f099fe94</a></p>
<h3 id="추가됨-62"><a class="header" href="#추가됨-62">추가됨</a></h3>
<ul>
<li><code>compiler-artifact</code> JSON 메시지에 이제 빌드된 실행 파일의 경로를 포함하는 <code>"executable"</code> 키가 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/6363">#6363</a></li>
<li>매뉴얼 페이지가 다시 작성되었으며, 이제 웹 문서와 함께 게시됩니다. <a href="https://github.com/rust-lang/cargo/pull/6405">#6405</a></li>
<li><code>cargo login</code> 이 이제 토큰을 저장한 후 확인 메시지를 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/6466">#6466</a></li>
<li><code>[patch]</code> 항목이 어떤 패키지와도 일치하지 않는 경우 이제 경고가 발생합니다. <a href="https://github.com/rust-lang/cargo/pull/6470">#6470</a></li>
<li><code>cargo metadata</code> 에 이제 패키지에 대한 <code>links</code> 키가 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/6480">#6480</a></li>
<li><code>-vv</code> 를 사용한 “매우 상세한” 출력에서 이제 Cargo가 프로세스를 실행할 때 설정하는 환경 변수들이 표시됩니다. <a href="https://github.com/rust-lang/cargo/pull/6492">#6492</a></li>
<li><code>--example</code>, <code>--bin</code>, <code>--bench</code>, <code>--test</code> 옵션을 인수 없이 사용하면 해당 옵션에 대해 사용 가능한 타겟 목록을 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/6505">#6505</a></li>
<li>윈도우: 프로세스가 확장 상태 종료 코드(extended status exit code)와 함께 실패하는 경우, 이제 해당 코드에 대한 읽기 쉬운 이름이 표시됩니다. <a href="https://github.com/rust-lang/cargo/pull/6532">#6532</a></li>
<li>패키지 검증 시 지정된 기능을 사용할 수 있도록 <code>cargo package</code> 및 <code>cargo publish</code> 명령에 <code>--features</code>, <code>--no-default-features</code>, <code>--all-features</code> 플래그를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/6453">#6453</a></li>
</ul>
<h3 id="변경됨-62"><a class="header" href="#변경됨-62">변경됨</a></h3>
<ul>
<li><code>cargo fix</code> 가 수정된 코드를 컴파일하는 데 실패하는 경우, 이제 rustc 오류가 콘솔에 표시됩니다. <a href="https://github.com/rust-lang/cargo/pull/6419">#6419</a></li>
<li>사용되지 않는 <code>cargo login</code> 의 <code>--host</code> 플래그를 숨겼습니다. <a href="https://github.com/rust-lang/cargo/pull/6466">#6466</a></li>
<li>빌드 스크립트 핑거프린트에 이제 rustc 버전이 포함됩니다. <a href="https://github.com/rust-lang/cargo/pull/6473">#6473</a></li>
<li>macOS: <code>DYLD_LIBRARY_PATH</code> 대신 <code>DYLD_FALLBACK_LIBRARY_PATH</code> 를 설정하도록 변경되었습니다. <a href="https://github.com/rust-lang/cargo/pull/6355">#6355</a></li>
<li><code>RUSTFLAGS</code> 가 이제 메타데이터 해시에 포함됩니다. 즉, 플래그를 변경해도 이전에 빌드된 파일을 덮어쓰지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/6503">#6503</a></li>
<li>크레이트 그래프를 업데이트할 때 관련 없는 삭제(yanked)된 크레이트가 잘못 제거되던 문제를 수정했습니다. 이제 가능한 경우 원래 버전을 유지합니다. 이전에는 <code>cargo update -p somecrate</code> 실행 시 관련 없는 패키지들이 다운그레이드되는 원인이 되었습니다. <a href="https://github.com/rust-lang/cargo/issues/5702">#5702</a></li>
<li>TOML 파일이 이제 <a href="https://github.com/toml-lang/toml/blob/master/CHANGELOG.md#050--2018-07-11">0.5 TOML 구문</a> 을 지원합니다.</li>
</ul>
<h3 id="수정됨-65"><a class="header" href="#수정됨-65">수정됨</a></h3>
<ul>
<li><code>cargo fix</code> 가 이제 여러 파일을 수정하는 제안을 무시합니다. <a href="https://github.com/rust-lang/cargo/pull/6402">#6402</a></li>
<li>동일한 소스 파일을 공유하는 타겟들을 처리하기 위해 <code>cargo fix</code> 가 이제 한 번에 하나의 타겟만 수정합니다. <a href="https://github.com/rust-lang/cargo/pull/6434">#6434</a></li>
<li>Cargo 명령 목록을 표시할 때의 bash 자동 완성 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/issues/6461">#6461</a></li>
<li><code>cargo init</code> 실행 시 <code>.gitignore</code> 파일에 중복 항목이 생성되지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6521">#6521</a></li>
<li>빌드가 이제 컴파일 도중에 파일이 수정되었는지 감지를 시도하여, 다시 빌드할 때 새로운 변경 사항을 반영할 수 있게 합니다. 이는 컴파일이 끝날 때가 아니라 <em>시작될 때</em> 를 추적함으로써 수행됩니다. 또한 <a href="https://github.com/rust-lang/cargo/pull/5919">#5919</a> 가 되돌려졌는데, 이는 Cargo가 동일한 파일 시스템 mtime을 재빌드가 필요한 것으로 간주하지 <em>않음</em> 을 의미합니다. <a href="https://github.com/rust-lang/cargo/pull/6484">#6484</a></li>
</ul>
<h3 id="나이틀리nightly-전용-61"><a class="header" href="#나이틀리nightly-전용-61">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><code>[patch]</code> 테이블에서 URL뿐만 아니라 레지스트리 <em>이름</em> 도 사용할 수 있도록 허용합니다. <a href="https://github.com/rust-lang/cargo/pull/6456">#6456</a></li>
<li><code>cargo metadata</code> 의 의존성 정보에 <code>registry</code> 키가 추가되었습니다. <a href="https://github.com/rust-lang/cargo/pull/6500">#6500</a></li>
<li>레지스트리 이름이 이제 패키지 이름과 동일한 스타일(영문자, 숫자, <code>-</code>, <code>_</code>)로 제한됩니다. <a href="https://github.com/rust-lang/cargo/pull/6469">#6469</a></li>
<li><code>cargo login</code> 이 이제 레지스트리 설정의 <code>/me</code> URL을 표시합니다. <a href="https://github.com/rust-lang/cargo/pull/6466">#6466</a></li>
<li><code>cargo login --registry=NAME</code> 이 이제 토큰 대화형 입력을 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/6466">#6466</a></li>
<li>레지스트리가 이제 API 접근을 지원하지 않음을 나타내기 위해 <code>config.json</code> 에서 <code>api</code> 키를 생략할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/6466">#6466</a></li>
<li>metabuild와 함께 <code>--message-format=json</code> 을 사용할 때 발생하던 패닉을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6432">#6432</a></li>
<li>대체 레지스트리를 사용할 때 crates.io로의 게시 여부 감지 로직을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6525">#6525</a></li>
</ul>
<h2 id="cargo-132-2019-01-17"><a class="header" href="#cargo-132-2019-01-17">Cargo 1.32 (2019-01-17)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/339d9f9c...8610973a">339d9f9c…8610973a</a></p>
<h3 id="추가됨-63"><a class="header" href="#추가됨-63">추가됨</a></h3>
<ul>
<li>레지스트리가 이제 성공적으로 게시된 후 경고 메시지를 표시할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/6303">#6303</a></li>
<li>Added a <a href="appendix/glossary.html">glossary</a> to the documentation. <a href="https://github.com/rust-lang/cargo/pull/6321">#6321</a></li>
<li><code>cargo check</code> 에 대한 별칭 <code>c</code> 를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/6218">#6218</a></li>
</ul>
<h3 id="변경됨-63"><a class="header" href="#변경됨-63">변경됨</a></h3>
<ul>
<li>🔥 HTTP/2 멀티플렉싱(multiplexing)이 이제 기본적으로 활성화됩니다. 이를 비활성화하려면 <code>http.multiplexing</code> 설정 값을 사용하세요. <a href="https://github.com/rust-lang/cargo/pull/6271">#6271</a></li>
<li>줄을 지울 때 공백 대신 ANSI 이스케이프 시퀀스를 사용합니다. <a href="https://github.com/rust-lang/cargo/pull/6233">#6233</a></li>
<li>문제를 일으킬 수 있는 Git 의존성 체크아웃 시 Git 템플릿 사용을 비활성화했습니다. <a href="https://github.com/rust-lang/cargo/pull/6252">#6252</a></li>
<li><code>net.git-fetch-with-cli</code> 옵션을 사용할 때 <code>--update-head-ok</code> Git 플래그를 포함하도록 했습니다. 이는 일부 저장소를 가져올 때 발생하는 실패를 방지하는 데 도움이 됩니다. <a href="https://github.com/rust-lang/cargo/pull/6250">#6250</a></li>
<li><code>cargo package</code> 의 검증 단계에서 크레이트를 추출할 때, 일부 드문 파일 시스템에서 실패하던 파일 시스템 mtime 설정을 더 이상 수행하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/6257">#6257</a></li>
<li><code>Cargo.toml</code> 에서 <code>crate-type = ["proc-macro"]</code> 가 이제 <code>proc-macro = true</code> 와 동일하게 처리됩니다. <a href="https://github.com/rust-lang/cargo/pull/6256">#6256</a></li>
<li>가상 워크스페이스에 <code>dependencies</code>, <code>features</code>, <code>target</code> 또는 <code>badges</code> 가 설정된 경우 이제 오류가 발생합니다. 워크스페이스 구성원에서 <code>replace</code> 또는 <code>patch</code> 가 사용되는 경우 경고가 표시됩니다. <a href="https://github.com/rust-lang/cargo/pull/6276">#6276</a></li>
<li>일부 상황에서의 리졸버 성능을 개선했습니다. <a href="https://github.com/rust-lang/cargo/pull/6283">#6283</a> <a href="https://github.com/rust-lang/cargo/pull/6366">#6366</a></li>
<li><code>.rmeta</code> 파일이 더 이상 기본 타겟 디렉토리(<code>target/debug</code>)에 하드 링크되지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/6292">#6292</a></li>
<li>여러 타겟이 동일한 출력 파일 이름으로 빌드되는 경우 경고가 발생합니다. <a href="https://github.com/rust-lang/cargo/pull/6308">#6308</a></li>
<li><code>cargo build</code>(<code>--release</code> 없이)를 사용할 때 벤치마크가 이제 “bench” 대신 “test” 프로파일을 사용하여 빌드됩니다. 이를 통해 벤치마크 디버깅이 쉬워지고 혼란스러운 동작을 방지할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/6309">#6309</a></li>
<li>사용자 별칭(alias)이 이제 내장 별칭(<code>b</code>, <code>r</code>, <code>t</code>, <code>c</code>)을 재정의할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/6259">#6259</a></li>
<li><code>autobins=false</code> 설정 시 이제 추론된 타겟의 자동 감지가 비활성화됩니다. <a href="https://github.com/rust-lang/cargo/pull/6329">#6329</a></li>
<li>프로젝트에서 불안정한 기능을 사용하는 경우, <code>cargo verify-project</code> 가 안정 버전(stable)에서 실패하도록 변경되었습니다. <a href="https://github.com/rust-lang/cargo/pull/6326">#6326</a></li>
<li>이름 내부에 <code>.</code> 이 포함된 플랫폼 타겟이 이제 허용됩니다. <a href="https://github.com/rust-lang/cargo/pull/6255">#6255</a></li>
<li><code>cargo clean --release</code> 가 이제 릴리스 디렉토리만 삭제합니다. <a href="https://github.com/rust-lang/cargo/pull/6349">#6349</a></li>
</ul>
<h3 id="수정됨-66"><a class="header" href="#수정됨-66">수정됨</a></h3>
<ul>
<li><code>cargo new</code> 실행 시 이메일 주소에 불필요한 꺾쇠 괄호(<code>&lt; &gt;</code>)가 추가되는 문제를 방지했습니다. <a href="https://github.com/rust-lang/cargo/pull/6243">#6243</a></li>
<li>CI 환경 변수가 설정된 경우 진행률 표시줄이 비활성화됩니다. <a href="https://github.com/rust-lang/cargo/pull/6281">#6281</a></li>
<li>모든 rustc 출력을 메모리에 보관하지 않도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6289">#6289</a></li>
<li>JSON 파싱에 실패하고 rustc가 0이 아닌 코드로 종료되는 경우, 파싱 실패 메시지를 잃어버리지 않도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/6290">#6290</a></li>
<li>빌드 스크립트가 있는 프로젝트 디렉토리의 이름을 바꿀 때의 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6328">#6328</a></li>
<li>예제에서 <code>crate_type = ["bin"]</code> 을 설정한 경우 <code>cargo run --example NAME</code> 이 올바르게 작동하도록 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6330">#6330</a></li>
<li><code>cargo package</code> 의 Git 검색 로직이 너무 공격적이던 문제를 수정했습니다. 이제 <code>--allow-dirty</code> 는 Git 저장소 확인을 완전히 비활성화합니다. <a href="https://github.com/rust-lang/cargo/pull/6280">#6280</a></li>
<li><code>[patch]</code> 의존성에 대한 빌드 변경 사항 추적 기능을 수정하여, 재빌드가 필요하지 않은 상황에서 <code>cargo build</code> 가 재빌드하던 문제를 해결했습니다. <a href="https://github.com/rust-lang/cargo/pull/6493">#6493</a></li>
</ul>
<h3 id="나이틀리nightly-전용-62"><a class="header" href="#나이틀리nightly-전용-62">나이틀리(Nightly) 전용</a></h3>
<ul>
<li>레지스트리 URL에서 사용자 이름을 사용할 수 있도록 허용합니다. <a href="https://github.com/rust-lang/cargo/pull/6242">#6242</a></li>
<li>사용자 정의 빌드 스크립트 실행과 빌드 스크립트 컴파일을 구분할 수 있도록 build-plan JSON 구조에 <code>"compile_mode"</code> 키를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/6331">#6331</a></li>
<li><code>--out-dir</code> 이 이제 빌드 스크립트를 복사하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/6300">#6300</a></li>
</ul>
<h2 id="cargo-131-2018-12-06"><a class="header" href="#cargo-131-2018-12-06">Cargo 1.31 (2018-12-06)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/36d96825...339d9f9c">36d96825…339d9f9c</a></p>
<h3 id="추가됨-64"><a class="header" href="#추가됨-64">추가됨</a></h3>
<ul>
<li>🔥 2018 에디션 지원을 안정화했습니다. <a href="https://github.com/rust-lang/cargo/pull/5984">#5984</a> <a href="https://github.com/rust-lang/cargo/pull/5989">#5989</a></li>
<li>🔥 <code>Cargo.toml</code> 에서 <a href="https://doc.rust-lang.org/1.31.0/cargo/reference/specifying-dependencies.html#renaming-dependencies-in-cargotoml">의존성 이름을 변경</a> 할 수 있는 기능을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/6319">#6319</a></li>
<li>🔥 HTTP/2 파이프라이닝 및 멀티플렉싱 지원을 추가했습니다. <code>http.multiplexing</code> 설정 값을 통해 활성화할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/6005">#6005</a></li>
<li>HTTP 연결 디버깅을 위해 <code>http.debug</code> 설정 값을 추가했습니다. 디버그 정보를 표시하려면 <code>CARGO_HTTP_DEBUG=true RUST_LOG=cargo::ops::registry cargo build</code> 를 사용하세요. <a href="https://github.com/rust-lang/cargo/pull/6166">#6166</a></li>
<li>빌드 시 <code>Cargo.toml</code> 의 저장소(repository) 값으로 <code>CARGO_PKG_REPOSITORY</code> 환경 변수가 설정됩니다. <a href="https://github.com/rust-lang/cargo/pull/6096">#6096</a></li>
</ul>
<h3 id="변경됨-64"><a class="header" href="#변경됨-64">변경됨</a></h3>
<ul>
<li><code>cargo test --doc</code> 이 이제 다른 플래그를 무시하는 대신 거부합니다. <a href="https://github.com/rust-lang/cargo/pull/6037">#6037</a></li>
<li><code>cargo install</code> 이 <code>~/.cargo/config</code> 를 무시하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6026">#6026</a></li>
<li><code>cargo version --verbose</code> 가 이제 <code>cargo -vV</code> 와 동일하게 작동합니다. <a href="https://github.com/rust-lang/cargo/pull/6076">#6076</a></li>
<li><code>Cargo.lock</code> 상단의 주석이 이제 보존됩니다. <a href="https://github.com/rust-lang/cargo/pull/6181">#6181</a></li>
<li>“매우 상세한” 모드(<code>cargo build -vv</code>)로 빌드할 때, 빌드 스크립트 출력 앞에 패키지 이름과 버전(예: <code>[foo 0.0.1]</code>)이 붙습니다. <a href="https://github.com/rust-lang/cargo/pull/6164">#6164</a></li>
<li><code>cargo fix --broken-code</code> 가 수정 사항 적용 후 컴파일에 실패할 경우, 파일을 되돌리지 않고 실패한 상태 그대로 둡니다. <a href="https://github.com/rust-lang/cargo/pull/6316">#6316</a></li>
</ul>
<h3 id="수정됨-67"><a class="header" href="#수정됨-67">수정됨</a></h3>
<ul>
<li>윈도우: <code>cargo run</code> 실행 시 프로세스에 Ctrl-C를 전달합니다. <a href="https://github.com/rust-lang/cargo/pull/6004">#6004</a></li>
<li>macOS: bash 자동 완성을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6038">#6038</a></li>
<li>bash 자동 완성에서 <code>+toolchain</code> 완성 시 임의의 툴체인 이름을 지원합니다. <a href="https://github.com/rust-lang/cargo/pull/6038">#6038</a></li>
<li>의존성 해결 실패 시 백트래킹 과정에서의 리졸버 에지 케이스를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/5988">#5988</a></li>
<li><code>cargo test --all-targets</code> 가 라이브러리 테스트를 세 번 실행하던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6039">#6039</a></li>
<li>이름이 변경된 의존성을 crates.io에 게시하는 기능을 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/5993">#5993</a></li>
<li>여러 바이너리가 포함된 Git 저장소에서의 <code>cargo install</code> 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6060">#6060</a></li>
<li>rustc에서 보낸 깊게 중첩된 JSON이 누락되던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6081">#6081</a></li>
<li>윈도우: msys 터미널에서 너비가 60자로 고정되던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6122">#6122</a></li>
<li>대시(<code>-</code>)가 포함된 이름으로 변경된 의존성 관련 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6140">#6140</a></li>
<li>dylib가 <code>target/debug</code> 와 <code>target/debug/deps</code> 양쪽에 존재할 때 잘못된 dylib에 링크되던 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6167">#6167</a></li>
<li><code>panic=abort</code> 사용 시 불필요하게 재컴파일되던 일부 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/6170">#6170</a></li>
</ul>
<h3 id="나이틀리nightly-전용-63"><a class="header" href="#나이틀리nightly-전용-63">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><code>cargo install</code> 에 <code>--registry</code> 플래그를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/6128">#6128</a></li>
<li><code>--registry</code> 플래그가 전달되지 않았을 때 사용할 기본 레지스트리를 지정하는 <code>registry.default</code> 설정 값을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/6135">#6135</a></li>
<li><code>cargo new</code> 및 <code>cargo init</code> 에 <code>--registry</code> 플래그를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/6135">#6135</a></li>
</ul>
<h2 id="cargo-130-2018-10-25"><a class="header" href="#cargo-130-2018-10-25">Cargo 1.30 (2018-10-25)</a></h2>
<p><a href="https://github.com/rust-lang/cargo/compare/524a578d...36d96825">524a578d…36d96825</a></p>
<h3 id="추가됨-65"><a class="header" href="#추가됨-65">추가됨</a></h3>
<ul>
<li>🔥 빌드 중에 진행 상황을 보여주는 애니메이션 진행률 표시줄을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/5995/">#5995</a></li>
<li><code>cargo metadata</code> 에 해결된 의존성에 대한 더 많은 정보를 포함하고 이름이 변경된 의존성을 올바르게 처리하는 <code>resolve.nodes.deps</code> 키를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/5871">#5871</a></li>
<li>패키지를 생성할 때, Git 저장소에서 파일의 변경 여부(dirty)를 확인하는 데 실패할 경우 <code>-v</code> 와 함께 더 자세한 정보를 제공합니다. 또한 윈도우에서의 확인 문제를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/5858">#5858</a></li>
<li><code>--bin</code>, <code>--test</code>, <code>--example</code>, <code>--bench</code>, <code>--lib</code> 과 같은 필터를 특정 패키지를 선택하지 않고도 워크스페이스에서 사용할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/5873">#5873</a></li>
<li>특정 패키지를 선택하지 않고도 워크스페이스에서 <code>cargo run</code> 을 사용할 수 있습니다. <a href="https://github.com/rust-lang/cargo/pull/5877">#5877</a></li>
<li><code>cargo doc --message-format=json</code> 이 이제 rustdoc의 JSON 메시지를 출력합니다. <a href="https://github.com/rust-lang/cargo/pull/5878">#5878</a></li>
<li>한 줄 메시지를 보여주는 <code>--message-format=short</code> 를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/5879">#5879</a></li>
<li>현재 Git 해시를 캡처하는 <code>.cargo_vcs_info.json</code> 파일을 <code>.crate</code> 패키지에 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/5886">#5886</a></li>
<li>내장된 libgit2 라이브러리 대신 <code>git</code> 실행 파일을 사용하여 저장소를 가져오는 <code>net.git-fetch-with-cli</code> 설정 옵션을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/5914">#5914</a></li>
<li><code>cargo metadata</code> 에 <code>required-features</code> 를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/5902">#5902</a></li>
<li>패키지 내에서 <code>cargo uninstall</code> 을 실행하면 이제 해당 패키지를 제거합니다. <a href="https://github.com/rust-lang/cargo/pull/5927">#5927</a></li>
<li>Git에 스테이징된 파일이 있더라도 실행할 수 있도록 <code>cargo fix</code> 에 <code>--allow-staged</code> 플래그를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/5943">#5943</a></li>
<li><code>net.low-speed-limit</code> 설정 값을 추가하고, HTTP 작업에 대해 <code>net.timeout</code> 을 준수하도록 했습니다. <a href="https://github.com/rust-lang/cargo/pull/5957">#5957</a></li>
<li><code>cargo new</code> 에 <code>--edition</code> 플래그를 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/5984">#5984</a></li>
<li>베타 기간 동안 2018 에디션 지원을 일시적으로 안정화했습니다. <a href="https://github.com/rust-lang/cargo/pull/5984">#5984</a> <a href="https://github.com/rust-lang/cargo/pull/5989">#5989</a></li>
<li>설정 표현식을 사용하는 타겟에 대해 실행/테스트/벤치마크 러너를 지정할 수 있는 <code>target.'cfg(…)'.runner</code> 설정 값 지원을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/5959">#5959</a></li>
</ul>
<h3 id="변경됨-65"><a class="header" href="#변경됨-65">변경됨</a></h3>
<ul>
<li>윈도우: 메인 프로세스가 종료될 때 <code>cargo run</code> 이 자식 프로세스를 강제 종료하지 않습니다. <a href="https://github.com/rust-lang/cargo/pull/5887">#5887</a></li>
<li><code>cargo doc --open</code> 으로 웹 브라우저를 열 때 <code>opener</code> 크레이트를 사용하도록 전환했습니다. 이는 모든 플랫폼에서 시스템 선호 브라우저를 더 안정적으로 선택할 것입니다. <a href="https://github.com/rust-lang/cargo/pull/5888">#5888</a></li>
<li>파일 mtime이 동일한 경우에도 이제 타겟을 재빌드합니다. 이전에는 파일이 마지막 빌드보다 엄격하게 <em>최신</em> 인 경우에만 재빌드되었습니다. <a href="https://github.com/rust-lang/cargo/pull/5919">#5919</a></li>
<li><code>cargo install</code> 실행 시 <code>build.target</code> 설정 값을 무시합니다. <a href="https://github.com/rust-lang/cargo/pull/5874">#5874</a></li>
<li><code>cargo fix</code> 실행 시 <code>RUSTC_WRAPPER</code> 를 무시합니다. <a href="https://github.com/rust-lang/cargo/pull/5983">#5983</a></li>
<li>비어 있는 <code>RUSTC_WRAPPER</code> 를 무시합니다. <a href="https://github.com/rust-lang/cargo/pull/5985">#5985</a></li>
</ul>
<h3 id="수정됨-68"><a class="header" href="#수정됨-68">수정됨</a></h3>
<ul>
<li><code>Cargo.toml</code> 에 edition 필드가 있는 패키지를 생성할 때의 오류를 수정했습니다. <a href="https://github.com/rust-lang/cargo/pull/5908">#5908</a></li>
<li>워크스페이스 내의 경로 의존성에 대해 더 일관되게 상대 경로를 사용합니다. <a href="https://github.com/rust-lang/cargo/pull/5935">#5935</a></li>
<li><code>cargo fix</code> 가 이전에 실행되었더라도 이제 항상 실행됩니다. <a href="https://github.com/rust-lang/cargo/pull/5944">#5944</a></li>
<li>윈도우: 터미널 너비를 더 안정적으로 감지하도록 시도합니다. msys 기반 터미널은 너비가 60자로 고정됩니다. <a href="https://github.com/rust-lang/cargo/pull/6010">#6010</a></li>
<li><code>cargo doc --document-private-items</code> 사용 시 여러 타겟 플래그를 허용합니다. <a href="https://github.com/rust-lang/cargo/pull/6022">6022</a></li>
</ul>
<h3 id="나이틀리nightly-전용-64"><a class="header" href="#나이틀리nightly-전용-64">나이틀리(Nightly) 전용</a></h3>
<ul>
<li><a href="https://doc.rust-lang.org/1.30.0/cargo/reference/unstable.html#metabuild">메타빌드(metabuild)</a> 기능을 추가했습니다. <a href="https://github.com/rust-lang/cargo/pull/5628">#5628</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="용어집"><a class="header" href="#용어집">용어집</a></h1>
<h2 id="산출물-artifact"><a class="header" href="#산출물-artifact">산출물 (Artifact)</a></h2>
<p><em>산출물(artifact)</em> 은 컴파일 프로세스의 결과로 생성된 파일 또는 파일 집합입니다. 여기에는 링크 가능한 라이브러리, 실행 가능한 바이너리 및 생성된 문서가 포함됩니다.</p>
<h2 id="cargo-1"><a class="header" href="#cargo-1">Cargo</a></h2>
<p><em>Cargo</em> 는 Rust <a href="appendix/glossary.html#package-manager"><em>패키지 관리자</em></a> 이며, 이 책의 주요 주제입니다.</p>
<h2 id="cargolock"><a class="header" href="#cargolock">Cargo.lock</a></h2>
<p><a href="appendix/glossary.html#lock-file"><em>락 파일(lock file)</em></a> 을 참조하세요.</p>
<h2 id="cargotoml"><a class="header" href="#cargotoml">Cargo.toml</a></h2>
<p><a href="appendix/glossary.html#manifest"><em>매니페스트(manifest)</em></a> 를 참조하세요.</p>
<h2 id="크레이트-crate"><a class="header" href="#크레이트-crate">크레이트 (Crate)</a></h2>
<p>러스트 <em>크레이트(crate)</em> 는 라이브러리 또는 실행 프로그램이며, 각각 <em>라이브러리 크레이트</em> 또는 <em>바이너리 크레이트</em> 라고 합니다.</p>
<p>Cargo <a href="appendix/glossary.html#package">패키지</a> 에 대해 정의된 모든 <a href="appendix/glossary.html#target">타겟</a> 은 <em>크레이트</em> 입니다.</p>
<p>느슨하게 말해서, <em>크레이트</em> 라는 용어는 타겟의 소스 코드나 타겟이 생성하는 컴파일된 산출물을 가리킬 수 있습니다. 또한 <a href="appendix/glossary.html#registry">레지스트리</a> 에서 가져온 압축된 패키지를 가리킬 수도 있습니다.</p>
<p>주어진 크레이트의 소스 코드는 다시 <a href="appendix/glossary.html#module"><em>모듈(modules)</em></a> 로 세분화될 수 있습니다.</p>
<h2 id="에디션-edition-1"><a class="header" href="#에디션-edition-1">에디션 (Edition)</a></h2>
<p><em>러스트 에디션(Rust edition)</em> 은 러스트 언어의 발전적 이정표입니다. <a href="appendix/../reference/manifest.html#the-edition-field">패키지의 에디션</a> 은 <code>Cargo.toml</code> <a href="appendix/glossary.html#manifest">매니페스트</a> 에 지정되며, 개별 타겟은 자신이 사용하는 에디션을 지정할 수 있습니다. 자세한 내용은 <a href="appendix/../../edition-guide/index.html">에디션 가이드</a> 를 참조하세요.</p>
<h2 id="기능-feature"><a class="header" href="#기능-feature">기능 (Feature)</a></h2>
<p><em>기능(feature)</em> 의 의미는 문맥에 따라 다릅니다:</p>
<ul>
<li>
<p><a href="appendix/../reference/features.html"><em>기능(feature)</em></a> 은 조건부 컴파일을 가능하게 하는 이름이 지정된 플래그입니다. 기능은 선택적 의존성을 가리키거나, 소스 코드 내에서 확인할 수 있는 <code>Cargo.toml</code> <a href="appendix/glossary.html#manifest">매니페스트</a> 에 정의된 임의의 이름을 가리킬 수 있습니다.</p>
</li>
<li>
<p>Cargo에는 Cargo 자체의 실험적인 동작을 활성화하는 데 사용할 수 있는 <a href="appendix/../reference/unstable.html"><em>불안정한 기능 플래그(unstable feature flags)</em></a> 가 있습니다.</p>
</li>
<li>
<p>러스트 컴파일러와 Rustdoc은 자체적인 불안정한 기능 플래그를 가지고 있습니다 (<a href="https://doc.rust-lang.org/nightly/unstable-book/index.html">The Unstable Book</a> 및 <a href="https://doc.rust-lang.org/nightly/rustdoc/unstable-features.html">The Rustdoc Book</a> 참조).</p>
</li>
<li>
<p>CPU 타겟에는 CPU의 기능을 지정하는 <a href="appendix/../../reference/attributes/codegen.html#the-target_feature-attribute"><em>타겟 기능(target features)</em></a> 이 있습니다.</p>
</li>
</ul>
<h2 id="인덱스-index"><a class="header" href="#인덱스-index">인덱스 (Index)</a></h2>
<p><em>인덱스(index)</em> 는 <a href="appendix/glossary.html#registry">레지스트리</a> 에 있는 <a href="appendix/glossary.html#crate"><em>크레이트</em></a> 의 검색 가능한 목록입니다.</p>
<h2 id="락-파일-lock-file-1"><a class="header" href="#락-파일-lock-file-1">락 파일 (Lock file)</a></h2>
<p><code>Cargo.lock</code> <em>락 파일(lock file)</em> 은 <a href="appendix/glossary.html#workspace">_워크스페이스 _</a> 또는 <a href="appendix/glossary.html#package">_ 패키지_</a> 에서 사용되는 모든 의존성의 정확한 버전을 기록하는 파일입니다. 이 파일은 Cargo에 의해 자동으로 생성됩니다. <a href="appendix/../guide/cargo-toml-vs-cargo-lock.html">Cargo.toml vs Cargo.lock</a> 을 참조하세요.</p>
<h2 id="매니페스트-manifest"><a class="header" href="#매니페스트-manifest">매니페스트 (Manifest)</a></h2>
<p><a href="appendix/../reference/manifest.html"><em>매니페스트(manifest)</em></a> 는 <code>Cargo.toml</code> 이라는 파일에 작성된 <a href="appendix/glossary.html#package">패키지</a> 또는 <a href="appendix/glossary.html#workspace">워크스페이스</a> 에 대한 설명입니다.</p>
<p><a href="appendix/../reference/workspaces.html"><em>가상 매니페스트(virtual manifest)</em></a> 는 워크스페이스만을 설명하고 패키지를 포함하지 않는 <code>Cargo.toml</code> 파일입니다.</p>
<h2 id="구성원-member"><a class="header" href="#구성원-member">구성원 (Member)</a></h2>
<p><em>구성원(member)</em> 은 <a href="appendix/glossary.html#workspace">_워크스페이스 _</a> 에 속한 <a href="appendix/glossary.html#package">_ 패키지_</a> 입니다.</p>
<h2 id="모듈-module"><a class="header" href="#모듈-module">모듈 (Module)</a></h2>
<p>러스트의 모듈 시스템은 코드를 <em>모듈(modules)</em> 이라고 불리는 논리적 단위로 구성하는 데 사용되며, 코드 내에서 격리된 네임스페이스를 제공합니다.</p>
<p>주어진 <a href="appendix/glossary.html#crate">크레이트</a> 의 소스 코드는 하나 이상의 별도 모듈로 세분화될 수 있습니다. 이는 일반적으로 코드를 관련 기능 영역별로 구성하거나, 소스 내 심볼(구조체, 함수 등)의 가시성 범위(공개/비공개)를 제어하기 위해 수행됩니다.</p>
<p><a href="appendix/glossary.html#manifest"><code>Cargo.toml</code></a> 파일은 주로 정의하는 <a href="appendix/glossary.html#package">패키지</a>, 해당 크레이트, 그리고 해당 크레이트가 의존하는 크레이트의 패키지와 관련이 있습니다. 그럼에도 불구하고 러스트로 작업할 때 “모듈“이라는 용어를 자주 접하게 되므로, 주어진 크레이트와의 관계를 이해해야 합니다.</p>
<h2 id="패키지-package"><a class="header" href="#패키지-package">패키지 (Package)</a></h2>
<p><em>패키지(package)</em> 는 소스 파일 모음과 패키지를 설명하는 <code>Cargo.toml</code> <a href="appendix/glossary.html#manifest"><em>매니페스트</em></a> 파일의 집합입니다. 패키지에는 패키지 간의 의존성을 지정하는 데 사용되는 이름과 버전이 있습니다.</p>
<p>패키지에는 각각이 <a href="appendix/glossary.html#crate">_크레이트 _</a> 인 여러 <a href="appendix/glossary.html#target">_ 타겟_</a> 이 포함되어 있습니다. <code>Cargo.toml</code> 파일은 패키지 내 크레이트의 유형(바이너리 또는 라이브러리)과 함께, 이 책 전반에서 설명하는 대로 각 크레이트가 어떻게 빌드되는지, 직접적인 의존성이 무엇인지 등 각 크레이트에 대한 메타데이터를 설명합니다.</p>
<p><em>패키지 루트(package root)</em> 는 패키지의 <code>Cargo.toml</code> 매니페스트가 위치한 디렉토리입니다. (<a href="appendix/glossary.html#workspace"><em>워크스페이스 루트</em></a> 와 비교해 보세요.)</p>
<p><a href="appendix/../reference/pkgid-spec.html"><em>패키지 ID 명세(package ID specification)</em></a> 또는 <em>SPEC</em> 은 특정 소스의 특정 패키지 버전을 고유하게 참조하는 데 사용되는 문자열입니다.</p>
<p>중소규모의 러스트 프로젝트는 하나의 패키지만 필요로 하는 경우가 많지만, 그 안에 여러 개의 크레이트를 포함하는 것은 흔한 일입니다.</p>
<p>규모가 더 큰 프로젝트는 여러 패키지를 포함할 수 있으며, 이 경우 Cargo <a href="appendix/glossary.html#workspace"><em>워크스페이스(workspaces)</em></a> 를 사용하여 패키지 간의 공통 의존성 및 기타 관련 메타데이터를 관리할 수 있습니다.</p>
<h2 id="패키지-관리자-package-manager"><a class="header" href="#패키지-관리자-package-manager">패키지 관리자 (Package manager)</a></h2>
<p>넓은 의미에서 <em>패키지 관리자(package manager)</em> 는 소프트웨어 생태계에서 산출물의 획득, 설치 및 업그레이드 프로세스를 자동화하는 프로그램(또는 관련 프로그램 모음)입니다. 프로그래밍 언어 생태계 내에서 패키지 관리자는 개발자 중심의 도구로서, 주요 기능은 중앙 저장소에서 라이브러리 산출물과 그 의존성을 다운로드하는 것입니다. 이 기능은 종종 (언어별 컴파일러를 호출하여) 소프트웨어 빌드를 수행하는 기능과 결합됩니다.</p>
<p><a href="appendix/glossary.html#cargo"><em>Cargo</em></a> 는 러스트 생태계의 패키지 관리자입니다. Cargo는 러스트 <a href="appendix/glossary.html#package">패키지(#package)</a> 의 의존성(<a href="appendix/glossary.html#crate">_ 크레이트(#crate)_</a> 라고 불리는 <a href="appendix/glossary.html#artifact">_ 산출물(#artifact)_</a>)을 다운로드하고, 패키지를 컴파일하고, 배포 가능한 패키지를 만들며, (선택적으로) 이를 러스트 커뮤니티의 <a href="appendix/glossary.html#registry">_ 패키지 레지스트리(#registry)_</a> 인 <a href="https://crates.io/">crates.io</a> 에 업로드합니다.</p>
<h2 id="패키지-레지스트리-package-registry"><a class="header" href="#패키지-레지스트리-package-registry">패키지 레지스트리 (Package registry)</a></h2>
<p><a href="appendix/glossary.html#registry"><em>레지스트리(registry)</em></a> 를 참조하세요.</p>
<h2 id="프로젝트-project"><a class="header" href="#프로젝트-project">프로젝트 (Project)</a></h2>
<p><a href="appendix/glossary.html#package">패키지(#package)</a> 의 또 다른 이름입니다.</p>
<h2 id="레지스트리-registry"><a class="header" href="#레지스트리-registry">레지스트리 (Registry)</a></h2>
<p><em>레지스트리(registry)</em> 는 설치하거나 <a href="appendix/glossary.html#package">_패키지(#package)</a>_ 의 의존성으로 사용할 수 있는 다운로드 가능한 <a href="appendix/glossary.html#crate"><em>크레이트(#crate)</em></a> 모음을 포함하는 서비스입니다. 러스트 생태계의 기본 레지스트리는 <a href="https://crates.io">crates.io</a> 입니다. 레지스트리는 모든 크레이트 목록을 포함하는 <a href="appendix/glossary.html#index">_ 인덱스(#index)_</a> 를 가지고 있으며, Cargo에게 필요한 크레이트를 다운로드하는 방법을 알려줍니다.</p>
<h2 id="소스-source"><a class="header" href="#소스-source">소스 (Source)</a></h2>
<p><em>소스(source)</em> 는 <a href="appendix/glossary.html#package">_패키지(#package)</a>_ 의 의존성으로 포함될 수 있는 <a href="appendix/glossary.html#crate"><em>크레이트(#crate)</em></a> 를 제공하는 제공자입니다. 소스에는 여러 종류가 있습니다:</p>
<ul>
<li><strong>레지스트리 소스 (Registry source)</strong> — <a href="appendix/glossary.html#registry">레지스트리(#registry)</a> 를 참조하세요.</li>
<li><strong>로컬 레지스트리 소스 (Local registry source)</strong> — 파일 시스템에 압축 파일로 저장된 크레이트 집합입니다. <a href="appendix/../reference/source-replacement.html#local-registry-sources">로컬 레지스트리 소스</a> 를 참조하세요.</li>
<li><strong>디렉토리 소스 (Directory source)</strong> — 파일 시스템에 압축되지 않은 파일로 저장된 크레이트 집합입니다. <a href="appendix/../reference/source-replacement.html#directory-sources">디렉토리 소스</a> 를 참조하세요.</li>
<li><strong>경로 소스 (Path source)</strong> — 파일 시스템에 위치한 개별 패키지(<a href="appendix/../reference/specifying-dependencies.html#specifying-path-dependencies">경로 의존성</a> 등) 또는 여러 패키지 집합(<a href="appendix/../reference/overriding-dependencies.html#paths-overrides">경로 재정의</a> 등)입니다.</li>
<li><strong>Git 소스 (Git source)</strong> — Git 저장소에 위치한 패키지(<a href="appendix/../reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories">Git 의존성</a> 또는 <a href="appendix/../reference/source-replacement.html">Git 소스</a> 등)입니다.</li>
</ul>
<p>자체적인 자세한 내용은 <a href="appendix/../reference/source-replacement.html">소스 교체(Source Replacement)</a> 를 참조하세요.</p>
<h2 id="사양spec"><a class="header" href="#사양spec">사양(Spec)</a></h2>
<p><a href="appendix/glossary.html#package">패키지 ID 명세(#package)</a> 를 참조하세요.</p>
<h2 id="타겟"><a class="header" href="#타겟">타겟</a></h2>
<p><em>타겟(target)</em> 이라는 용어의 의미는 문맥에 따라 다릅니다:</p>
<ul>
<li>
<p><strong>Cargo 타겟 (Cargo Target)</strong> — Cargo <a href="appendix/glossary.html#package">패키지(#package)</a> 는 생성될 <a href="appendix/glossary.html#artifact">산출물(#artifact)</a> 에 해당하는 <em>타겟</em> 들로 구성됩니다. 패키지는 라이브러리, 바이너리, 예제, 테스트 및 벤치마크 타겟을 가질 수 있습니다. <a href="appendix/../reference/cargo-targets.html#configuring-a-target">타겟 목록</a> 은 <code>Cargo.toml</code> <a href="appendix/glossary.html#manifest">매니페스트(#manifest)</a> 에서 구성되며, 종종 소스 파일의 <a href="appendix/../guide/project-layout.html">디렉토리 레이아웃</a> 에 따라 자동으로 추론됩니다.</p>
</li>
<li>
<p><strong>Target Directory</strong> — Cargo places built artifacts in the <em>target</em> directory. By default this is a directory named <code>target</code> at the <a href="appendix/glossary.html#workspace"><em>workspace</em></a> root, or the package root if not using a workspace. The directory may be changed with the <code>--target-dir</code> command-line option, the <code>CARGO_TARGET_DIR</code> <a href="appendix/../reference/environment-variables.html">environment variable</a>, or the <code>build.target-dir</code> <a href="appendix/../reference/config.html">config option</a>. For more information see the <a href="appendix/../reference/build-cache.html">build cache</a> documentation.</p>
</li>
<li>
<p><strong>타겟 아키텍처 (Target Architecture)</strong> — 빌드된 산출물이 실행될 OS 및 머신 아키텍처를 일반적으로 <em>타겟</em> 이라고 합니다.</p>
</li>
<li>
<p><strong>타겟 트리플 (Target Triple)</strong> — 트리플은 타겟 아키텍처를 지정하기 위한 특정 형식입니다. 트리플은 생성된 산출물의 아키텍처인 <em>타겟 트리플</em> 과 컴파일러가 실행 중인 아키텍처인 <em>호스트 트리플</em> 로 불릴 수 있습니다. 타겟 트리플은 <code>--target</code> 명령줄 옵션이나 <code>build.target</code> <a href="appendix/../reference/config.html">설정 옵션</a> 으로 지정할 수 있습니다. 트리플의 일반적인 형식은 <code>&lt;arch&gt;&lt;sub&gt;-&lt;vendor&gt;-&lt;sys&gt;-&lt;abi&gt;</code> 이며 각 부분의 의미는 다음과 같습니다:</p>
<ul>
<li><code>arch</code> = 기본 CPU 아키텍처 (예: <code>x86_64</code>, <code>i686</code>, <code>arm</code>, <code>thumb</code>, <code>mips</code> 등)</li>
<li><code>sub</code> = CPU 하위 아키텍처 (예: <code>arm</code> 의 경우 <code>v7</code>, <code>v7s</code>, <code>v5te</code> 등)</li>
<li><code>vendor</code> = 벤더 (예: <code>unknown</code>, <code>apple</code>, <code>pc</code>, <code>nvidia</code> 등)</li>
<li><code>sys</code> = 시스템 이름 (예: <code>linux</code>, <code>windows</code>, <code>darwin</code> 등). <code>none</code> 은 일반적으로 OS가 없는 베어메탈(bare-metal)에 사용됩니다.</li>
<li><code>abi</code> = ABI (예: <code>gnu</code>, <code>android</code>, <code>eabi</code> 등)
일부 매개변수는 생략될 수 있습니다. 지원되는 타겟 목록을 보려면 <code>rustc --print target-list</code> 를 실행하세요.</li>
</ul>
</li>
</ul>
<h2 id="테스트-타겟-test-targets"><a class="header" href="#테스트-타겟-test-targets">테스트 타겟 (Test Targets)</a></h2>
<p>Cargo <em>테스트 타겟(test targets)</em> 은 코드의 올바른 작동과 정확성을 검증하는 데 도움이 되는 바이너리를 생성합니다. 테스트 산출물에는 두 가지 유형이 있습니다:</p>
<ul>
<li><strong>단위 테스트 (Unit test)</strong> — <em>단위 테스트</em> 는 라이브러리 또는 바이너리 타겟에서 직접 컴파일된 실행 바이너리입니다. 라이브러리 또는 바이너리 코드의 전체 내용을 포함하며, 개별 코드 단위를 검증하기 위해 <code>#[test]</code> 속성이 붙은 함수를 실행합니다.</li>
<li><strong>통합 테스트 타겟 (Integration test target)</strong> — <a href="appendix/../reference/cargo-targets.html#integration-tests">_통합 테스트 타겟 _</a> 은 소스가 <code>tests</code> 디렉토리에 있거나 <code>Cargo.toml</code> <a href="appendix/glossary.html#manifest">_ 매니페스트 _</a> 의 <a href="appendix/../reference/cargo-targets.html#configuring-a-target"><code>[[test]]</code> 테이블</a>에 지정된 별개의 <a href="appendix/glossary.html#crate">_ 크레이트_</a> 인 <em>테스트 타겟</em> 에서 컴파일된 실행 바이너리입니다. 이는 라이브러리의 공개 API만 테스트하거나, 바이너리를 실행하여 동작을 검증하기 위한 것입니다.</li>
</ul>
<h2 id="워크스페이스-workspace"><a class="header" href="#워크스페이스-workspace">워크스페이스 (Workspace)</a></h2>
<p><a href="appendix/../reference/workspaces.html"><em>워크스페이스(workspace)</em></a> 는 공통된 의존성 해결(공유된 <code>Cargo.lock</code> <a href="appendix/glossary.html#lock-file">_ 락 파일 _</a> 사용), 출력 디렉토리, 그리고 프로파일과 같은 다양한 설정을 공유하는 하나 이상의 <a href="appendix/glossary.html#package">_ 패키지_</a> 모음입니다.</p>
<p><a href="appendix/../reference/workspaces.html"><em>가상 워크스페이스(virtual workspace)</em></a> 는 루트 <code>Cargo.toml</code> <a href="appendix/glossary.html#manifest">_ 매니페스트 _</a> 가 패키지를 정의하지 않고 워크스페이스 <a href="appendix/glossary.html#member">_ 구성원_</a> 만 나열하는 워크스페이스입니다.</p>
<p><em>워크스페이스 루트(workspace root)</em> 는 워크스페이스의 <code>Cargo.toml</code> 매니페스트가 위치한 디렉토리입니다. (<a href="appendix/glossary.html#package"><em>패키지 루트</em></a> 와 비교해 보세요.)</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git-인증"><a class="header" href="#git-인증">Git 인증</a></h1>
<p>Cargo는 Git 의존성과 레지스트리를 사용할 때 몇 가지 형태의 인증을 지원합니다. 이 부록에는 Cargo와 함께 작동하는 방식으로 Git 인증을 설정하는 데 필요한 정보가 포함되어 있습니다.</p>
<p>다른 인증 방법이 필요한 경우, 내장 지원 대신 <code>git</code> 실행 파일을 사용하여 원격 저장소를 가져오도록 <a href="appendix/../reference/config.html#netgit-fetch-with-cli"><code>net.git-fetch-with-cli</code></a> 설정 값을 지정할 수 있습니다. 이는 <code>CARGO_NET_GIT_FETCH_WITH_CLI=true</code> 환경 변수로 활성화할 수 있습니다.</p>
<blockquote>
<p><strong>Note:</strong> Cargo does not require authentication for public git dependencies so if you see an authentication failure in that context, ensure that the URL is correct.</p>
</blockquote>
<h2 id="https-인증"><a class="header" href="#https-인증">HTTPS 인증</a></h2>
<p>HTTPS 인증에는 <a href="https://git-scm.com/book/en/v2/Git-Tools-Credential-Storage"><code>credential.helper</code></a> 메커니즘이 필요합니다. 여러 가지 자격 증명 헬퍼가 있으며, 글로벌 Git 설정 파일에서 사용할 헬퍼를 지정합니다.</p>
<pre><code class="language-ini"># ~/.gitconfig

[credential]
helper = store
</code></pre>
<p>Cargo는 비밀번호를 묻지 않으므로, 대부분의 헬퍼의 경우 Cargo를 실행하기 전에 헬퍼에게 초기 사용자 이름/비밀번호를 제공해야 합니다. 한 가지 방법은 비공개 Git 저장소에 대해 <code>git clone</code> 을 실행하고 사용자 이름/비밀번호를 입력하는 것입니다.</p>
<blockquote>
<p><strong>팁:</strong><br> macOS 사용자는 osxkeychain 헬퍼 사용을 고려해 보세요.<br> Windows 사용자는 <a href="https://github.com/microsoft/Git-Credential-Manager-Core/">GCM</a> 헬퍼 사용을 고려해 보세요.</p>
</blockquote>
<blockquote>
<p><strong>참고:</strong> Windows 사용자는 <code>sh</code> 쉘이 <code>PATH</code> 에 포함되어 있는지 확인해야 합니다. 이는 일반적으로 Git for Windows 설치 시 함께 제공됩니다.</p>
</blockquote>
<h2 id="ssh-인증"><a class="header" href="#ssh-인증">SSH 인증</a></h2>
<p>SSH 인증을 위해서는 SSH 키를 획득하기 위해 <code>ssh-agent</code> 가 실행 중이어야 합니다. 적절한 환경 변수(대부분의 Unix 계열 시스템에서는 <code>SSH_AUTH_SOCK</code>)가 설정되어 있는지, 그리고 올바른 키가 추가되었는지(<code>ssh-add</code> 사용) 확인하세요.</p>
<p>Windows는 Pageant(<a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/">PuTTY</a> 의 일부) 또는 <code>ssh-agent</code> 를 사용할 수 있습니다. <code>ssh-agent</code> 를 사용하려면 Cargo는 MinGW 또는 Cygwin에서 사용하는 시뮬레이션된 Unix 도메인 소켓을 지원하지 않으므로 Windows의 일부로 배포되는 OpenSSH를 사용해야 합니다. Windows 설치에 대한 자세한 내용은 <a href="https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_install_firstuse">Microsoft 설치 문서</a> 에서 확인할 수 있으며, <a href="https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_keymanagement">키 관리</a> 페이지에는 <code>ssh-agent</code> 를 시작하고 키를 추가하는 방법에 대한 지침이 있습니다.</p>
<blockquote>
<p><strong>참고:</strong> Cargo는 <code>git@example.com:user/repo.git</code> 과 같은 git의 단축 SSH URL을 지원하지 않습니다. <code>ssh://git@example.com/user/repo.git</code> 과 같은 전체 SSH URL을 사용하세요.</p>
</blockquote>
<blockquote>
<p><strong>참고:</strong> SSH 설정 파일(OpenSSH의 <code>~/.ssh/config</code> 등)은 Cargo의 내장 SSH 라이브러리에서 사용되지 않습니다. 더 복잡한 요구 사항이 있는 경우 <a href="appendix/../reference/config.html#netgit-fetch-with-cli"><code>net.git-fetch-with-cli</code></a> 를 사용해야 합니다.</p>
</blockquote>
<h3 id="ssh-알려진-호스트-known-hosts"><a class="header" href="#ssh-알려진-호스트-known-hosts">SSH 알려진 호스트 (Known Hosts)</a></h3>
<p>SSH 호스트에 연결할 때 Cargo는 호스트 키 목록인 “known hosts“를 사용하여 호스트의 신원을 확인해야 합니다. Cargo는 표준 위치(홈 디렉토리의 <code>.ssh/known_hosts</code>, Unix 계열 플랫폼의 경우 <code>/etc/ssh/ssh_known_hosts</code>, Windows의 경우 <code>%PROGRAMDATA%\ssh\ssh_known_hosts</code>)에 있는 OpenSSH 스타일의 <code>known_hosts</code> 파일에서 이러한 알려진 호스트를 찾을 수 있습니다. 이 파일에 대한 자세한 내용은 <a href="https://man.openbsd.org/sshd#SSH_KNOWN_HOSTS_FILE_FORMAT">sshd 맨 페이지</a> 에서 확인할 수 있습니다. 또는 <a href="appendix/../reference/config.html#netsshknown-hosts"><code>net.ssh.known-hosts</code></a> 를 사용하여 Cargo 설정 파일에서 키를 구성할 수도 있습니다.</p>
<p>known hosts가 구성되기 전에 SSH 호스트에 연결하면 Cargo는 호스트 키를 추가하는 방법을 알려주는 오류 메시지를 표시합니다. 여기에는 시각적으로 확인하기 더 쉬운 호스트 키의 작은 해시인 “지문(fingerprint)“도 포함됩니다. 서버 관리자는 공개 키에 대해 <code>ssh-keygen</code> 을 실행하여(예: <code>ssh-keygen -l -f /etc/ssh/ssh_host_ecdsa_key.pub</code>) 지문을 얻을 수 있습니다. 잘 알려진 사이트는 웹에 지문을 게시할 수 있습니다. 예를 들어 GitHub는 <a href="https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints">https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints</a>에 게시합니다.</p>
<p>Cargo에는 <a href="https://github.com">github.com</a> 에 대한 호스트 키가 내장되어 있습니다. 만약 키가 변경되면 설정이나 known_hosts 파일에 새 키를 추가할 수 있습니다.</p>
<blockquote>
<p><strong>참고:</strong> Cargo는 <code>known_hosts</code> 파일의 <code>@cert-authority</code> 또는 <code>@revoked</code> 마커를 지원하지 않습니다. 이 기능을 사용하려면 <a href="appendix/../reference/config.html#netgit-fetch-with-cli"><code>net.git-fetch-with-cli</code></a> 를 사용하세요. 이는 Cargo의 SSH 클라이언트가 예상대로 작동하지 않는 경우에도 좋은 팁입니다.</p>
</blockquote>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/language-picker.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
